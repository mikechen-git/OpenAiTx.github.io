<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Cysharp/MemoryPack nl</title>
    <meta name="title" content="MemoryPack - Cysharp/MemoryPack nl | MemoryPack Zero encoding extreme performance binary serializer voor C# en Unity. In vergelijking met System.Text.Json, protobuf-net, MessagePack for C#, Orleans...">
    <meta name="description" content="Cysharp/MemoryPack - GitHub repository nl documentation and information | MemoryPack Zero encoding extreme performance binary serializer voor C# en Unity. In vergelijking met System.Text.Json, protobuf-net, MessagePack for C#, Orleans...">
    <meta name="keywords" content="Cysharp, MemoryPack, GitHub, repository, nl documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/Cysharp/MemoryPack/README-nl.html">
    <meta property="og:title" content="MemoryPack - Cysharp/MemoryPack nl | MemoryPack Zero encoding extreme performance binary serializer voor C# en Unity. In vergelijking met System.Text.Json, protobuf-net, MessagePack for C#, Orleans...">
    <meta property="og:description" content="Cysharp/MemoryPack - GitHub repository nl documentation and information | MemoryPack Zero encoding extreme performance binary serializer voor C# en Unity. In vergelijking met System.Text.Json, protobuf-net, MessagePack for C#, Orleans...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/Cysharp/MemoryPack" id="githubRepoLink" target="_blank">Cysharp/MemoryPack</a>
<h1 style="display: none;">MemoryPack Zero encoding extreme performance binary serializer voor C# en Unity. In vergelijking met System.Text.Json, protobuf-net, MessagePack for C#, Orleans...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>MemoryPack</h1>
<p><a href="https://www.nuget.org/packages/MemoryPack"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet" /></a>
<a href="https://github.com/Cysharp/MemoryPack/actions"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions" /></a>
<a href="https://github.com/Cysharp/MemoryPack/releases"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases" /></a></p>
<p>Zero encoding extreme performance binary serializer voor C# en Unity.</p>
<p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image" /></p>
<blockquote>
<p>In vergelijking met <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/">Orleans.Serialization</a>. Gemeten op .NET 7 / Ryzen 9 5950X machine. Deze serializers hebben een <code>IBufferWriter&lt;byte&gt;</code> methode, geserialiseerd met <code>ArrayBufferWriter&lt;byte&gt;</code> en hergebruikt om buffer kopiëren te vermijden.</p>
</blockquote>
<p>Voor standaard objecten is MemoryPack x10 sneller en x2 ~ x5 sneller dan andere binaire serializers. Voor struct arrays is MemoryPack zelfs nog krachtiger, met snelheden tot x50 ~ x200 hoger dan andere serializers.</p>
<p>MemoryPack is mijn 4e serializer. Hiervoor heb ik bekende serializers gemaakt, ~~<a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>. De reden voor de snelheid van MemoryPack is het C#-specifieke, voor C# geoptimaliseerde binaire formaat en een goed afgestemde implementatie gebaseerd op mijn eerdere ervaring. Het is ook een compleet nieuw ontwerp dat gebruik maakt van .NET 7 en C# 11 en de Incremental Source Generator (.NET Standard 2.1 (.NET 5, 6) en er is ook Unity-ondersteuning).</p>
<p>Andere serializers voeren veel coderingsbewerkingen uit zoals VarInt-codering, tags, string, enz. Het MemoryPack-formaat gebruikt een zero-encoding ontwerp dat zoveel mogelijk C#-geheugen kopieert. Zero-encoding lijkt op FlatBuffers, maar heeft geen speciaal type nodig, het serialisatiedoel van MemoryPack is POCO.</p>
<p>Naast prestaties heeft MemoryPack de volgende functies.</p>
<ul>
<li>Ondersteunt moderne I/O-API's (<code>IBufferWriter&lt;byte&gt;</code>, <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>)</li>
<li>Native AOT-vriendelijke Source Generator gebaseerde codegeneratie, geen Dynamic CodeGen (IL.Emit)</li>
<li>Reflectievrije niet-generieke API's</li>
<li>Deserialiseren in een bestaand instantie</li>
<li>Polymorfe (Union) serialisatie</li>
<li>Beperkt versie-tolerant (snel/standaard) en volledige versie-tolerante ondersteuning</li>
<li>Serialisatie van circulaire referenties</li>
<li>PipeWriter/Reader gebaseerde streaming serialisatie</li>
<li>TypeScript codegeneratie en ASP.NET Core Formatter</li>
<li>Unity (2021.3) IL2CPP-ondersteuning via .NET Source Generator</li>
</ul>
<h2>Installatie</h2>
<p>Deze bibliotheek wordt verspreid via NuGet. Voor de beste prestaties wordt <code>.NET 7</code> aanbevolen. De minimale vereiste is <code>.NET Standard 2.1</code>.</p>
<blockquote>
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/MemoryPack">MemoryPack</a></p>
</blockquote>
<p>Daarnaast vereist een code-editor Roslyn 4.3.1 ondersteuning, bijvoorbeeld Visual Studio 2022 versie 17.3, .NET SDK 6.0.401. Zie voor details het <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support">Roslyn Version Support</a> document.</p>
<p>Voor Unity zijn de vereisten en het installatieproces volledig anders. Zie de <a href="#unity">Unity</a> sectie voor details.</p>
<h2>Snelle start</h2>
<p>Definieer een struct of klasse om te serialiseren en annoteer deze met het <code>[MemoryPackable]</code> attribuut en het <code>partial</code> sleutelwoord.</p>
<pre><code class="language-csharp">using MemoryPack;

[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}
</code></pre>
<p>Serialisatiecode wordt gegenereerd door de C# source generator functionaliteit, die de <code>IMemoryPackable&lt;T&gt;</code> interface implementeert. In Visual Studio kun je de gegenereerde code bekijken door de sneltoets <code>Ctrl+K, R</code> te gebruiken op de klassenaam en <code>*.MemoryPackFormatter.g.cs</code> te selecteren.</p>
<p>Roep <code>MemoryPackSerializer.Serialize&lt;T&gt;/Deserialize&lt;T&gt;</code> aan om een objectinstantie te serialiseren/deserialiseren.</p>
<pre><code class="language-csharp">var v = new Person { Age = 40, Name = &quot;John&quot; };

var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p>De <code>Serialize</code>-methode ondersteunt een returntype van <code>byte[]</code> evenals serialisatie naar <code>IBufferWriter&lt;byte&gt;</code> of <code>Stream</code>. De <code>Deserialize</code>-methode ondersteunt <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code> en <code>Stream</code>. Er zijn ook niet-generieke versies.</p>
<h2>Standaard ondersteunde types</h2>
<p>Deze types kunnen standaard worden geserialiseerd:</p>
<ul>
<li>.NET-primitieven (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, etc.)</li>
<li>Unmanaged types (Elke <code>enum</code>, elke door de gebruiker gedefinieerde <code>struct</code> zonder referentietypes)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code> <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory&lt;&gt;</code>, <code>ReadOnlyMemory&lt;&gt;</code>, <code>ArraySegment&lt;&gt;</code>, <code>ReadOnlySequence&lt;&gt;</code></li>
<li><code>Nullable&lt;&gt;</code>, <code>Lazy&lt;&gt;</code>, <code>KeyValuePair&lt;,&gt;</code>, <code>Tuple&lt;,...&gt;</code>, <code>ValueTuple&lt;,...&gt;</code></li>
<li><code>List&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>SortedSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code></li>
<li><code>Dictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>,  <code>ReadOnlyDictionary&lt;,&gt;</code></li>
<li><code>Collection&lt;&gt;</code>, <code>ReadOnlyCollection&lt;&gt;</code>, <code>ObservableCollection&lt;&gt;</code>, <code>ReadOnlyObservableCollection&lt;&gt;</code></li>
<li><code>IEnumerable&lt;&gt;</code>, <code>ICollection&lt;&gt;</code>, <code>IList&lt;&gt;</code>, <code>IReadOnlyCollection&lt;&gt;</code>, <code>IReadOnlyList&lt;&gt;</code>, <code>ISet&lt;&gt;</code></li>
<li><code>IDictionary&lt;,&gt;</code>, <code>IReadOnlyDictionary&lt;,&gt;</code>, <code>ILookup&lt;,&gt;</code>, <code>IGrouping&lt;,&gt;</code>,</li>
<li><code>ConcurrentBag&lt;&gt;</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>, <code>BlockingCollection&lt;&gt;</code></li>
<li>Immutable collecties (<code>ImmutableList&lt;&gt;</code>, etc.) en interfaces (<code>IImmutableList&lt;&gt;</code>, etc.)</li>
</ul>
<h2>Definieer <code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code></h2>
<p><code>[MemoryPackable]</code> kan worden geannoteerd op elke <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> en <code>interface</code>. Als een type een <code>struct</code> of <code>record struct</code> is die geen referentietypes bevat (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>), wordt extra annotatie (ignore, include, constructor, callbacks) niet gebruikt; deze worden direct uit het geheugen geserialiseerd/gedeserialiseerd.</p>
<p>Anders serialiseert <code>[MemoryPackable]</code> standaard de publieke instantie-eigenschappen of velden. Je kunt <code>[MemoryPackIgnore]</code> gebruiken om een serialisatiedoel te verwijderen, <code>[MemoryPackInclude]</code> promoot een privé-lid tot serialisatiedoel.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // deze types worden standaard geserialiseerd
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }

    // deze types worden standaard niet geserialiseerd
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;

    // gebruik [MemoryPackIgnore] om een publiek lid uit te sluiten van serialisatie
    [MemoryPackIgnore]
    public int PublicProperty2 =&gt; PublicProperty + PublicField;

    // gebruik [MemoryPackInclude] om een privé-lid te promoten tot serialisatiedoel
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}
</code></pre>
<p>De codegenerator van <code>MemoryPack</code> voegt informatie toe over welke leden worden geserialiseerd aan de <code>&lt;remarks /&gt;</code> sectie. Dit kan worden bekeken door met Intellisense over het type te zweven.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image" /></p>
<p>Alle leden moeten memorypack-serialiseerbaar zijn, zo niet dan zal de codegenerator een foutmelding geven.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image" /></p>
<p>MemoryPack heeft 35 diagnosticaregels (<code>MEMPACK001</code> tot <code>MEMPACK035</code>) om comfortabel te definiëren.</p>
<p>Als een doeltijdstype extern MemoryPack-serialisatie heeft en geregistreerd is, gebruik dan <code>[MemoryPackAllowSerialize]</code> om diagnostics te onderdrukken.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}
</code></pre>
<p>De volgorde van leden is <strong>belangrijk</strong>. MemoryPack serialiseert niet de ledennaam of andere informatie, maar serialiseert velden in de volgorde waarin ze zijn gedeclareerd. Als een type is overgeërfd, gebeurt serialisatie in de volgorde ouder → kind. De volgorde van leden mag niet veranderen voor de deserialisatie. Zie voor schema-evolutie de <a href="#version-tolerant">Version tolerant</a> sectie.</p>
<p>De standaardvolgorde is sequentieel, maar je kunt een expliciete layout kiezen met <code>[MemoryPackable(SerializeLayout.Explicit)]</code> en <code>[MemoryPackOrder()]</code>.</p>
<pre><code class="language-csharp">// serialiseer Prop0 -&gt; Prop1
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}
</code></pre>
<h3>Constructorselectie</h3>
<p>MemoryPack ondersteunt zowel geparametriseerde als parameterloze constructors. De selectie van de constructor volgt deze regels (geldt voor klassen en structs):</p>
<ul>
<li>Als er een <code>[MemoryPackConstructor]</code> is, wordt deze gebruikt.</li>
<li>Als er geen expliciete constructor is (inclusief privé), wordt een parameterloze gebruikt.</li>
<li>Als er één parameterloze/geparametriseerde constructor is (inclusief privé), wordt deze gebruikt.</li>
<li>Als er meerdere constructors zijn, dan moet het <code>[MemoryPackConstructor]</code> attribuut worden toegepast op de gewenste constructor (de generator kiest niet automatisch), anders geeft de generator een foutmelding.</li>
<li>Bij gebruik van een geparametriseerde constructor moeten alle parameternamen overeenkomen met de corresponderende ledennamen (hoofdletterongevoelig).</li>
</ul>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;

    // Je kunt een geparametriseerde constructor gebruiken - parameternamen moeten overeenkomen met de corresponderende ledennaam (hoofdletterongevoelig)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}

// ondersteunt ook record primary constructor
[MemoryPackable]
public partial record Person2(int Age, string Name);

public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }

    public Person3()
    {
    }
</code></pre>
<pre><code class="language-csharp">// Als er meerdere constructors zijn, dan moet [MemoryPackConstructor] gebruikt worden
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}
</code></pre>
<h3>Serialisatie-callbacks</h3>
<p>Bij serialiseren/deserialiseren kan MemoryPack een before/after event aanroepen met behulp van de attributen <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. Deze kunnen zowel statische als instantie (niet-statische) methoden annoteren, en zowel publieke als private methoden.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class MethodCallSample
{
    // aanroepvolgorde van de methoden is statisch -&gt; instantie
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }

    // private methode is ook toegestaan
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }

    // serializing -&gt; /* serialize */ -&gt; serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }

    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }

    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }

    // Let op: instantie-methode met MemoryPackOnDeserializing wordt niet aangeroepen als instantie niet via `ref` is meegegeven
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }

    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }

    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}
</code></pre>
<p>Callbacks staan parameterloze methoden en <code>ref reader/writer, ref T value</code> methoden toe. Bijvoorbeeld, ref callbacks kunnen een custom header schrijven/uitlezen vóór het serialisatieproces.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }

    [MemoryPackOnSerializing]
    static void WriteId&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter&lt;byte&gt; // .NET Standard 2.1, gebruik where TBufferWriter : class, IBufferWriter&lt;byte&gt;
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // schrijf GUID in de header.
    }

    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // lees custom header vóór deserialisatie
        var guid = reader.ReadUnmanaged&lt;Guid&gt;();
        Console.WriteLine(guid);
    }
}
</code></pre>
<p>Als je een waarde toekent aan <code>ref value</code>, kun je de waarde wijzigen die wordt gebruikt voor serialisatie/deserialisatie. Bijvoorbeeld, instantieren vanuit een ServiceProvider.</p>
<pre><code class="language-csharp">// voor je deze formatter gebruikt, stel ServiceProvider in
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);

[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;

    public int MyProperty { get; private set; }

    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService&lt;InstantiateFromServiceProvider&gt;();
    }
}
</code></pre>
<h2>Definieer een custom collectie</h2>
<p>Standaard probeert een met <code>[MemoryPackObject]</code> geannoteerd type zijn members te serialiseren. Echter, als een type een collectie is (<code>ICollection&lt;&gt;</code>, <code>ISet&lt;&gt;</code>, <code>IDictionary&lt;,&gt;</code>), gebruik dan <code>GenerateType.Collection</code> om het correct te serialiseren.</p>
<pre><code class="language-csharp">[MemoryPackable(GenerateType.Collection)]
public partial class MyList&lt;T&gt; : List&lt;T&gt;
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary&lt;TValue&gt; : Dictionary&lt;string, TValue&gt;
{

}
</code></pre>
<h2>Statische constructor</h2>
<p>Een MemoryPackable class kan geen statische constructor definiëren omdat de gegenereerde partial class deze gebruikt. In plaats daarvan kun je een <code>static partial void StaticConstructor()</code> definiëren om hetzelfde te bereiken.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}
</code></pre>
<h2>Polymorfisme (Union)</h2>
<p>MemoryPack ondersteunt het serialiseren van interface- en abstracte klasse-objecten voor polymorfe serialisatie. In MemoryPack wordt deze functie Union genoemd. Alleen interfaces en abstracte klassen mogen worden geannoteerd met <code>[MemoryPackUnion]</code> attributen. Unieke union-tags zijn vereist.</p>
<pre><code class="language-csharp">// Annoteer [MemoryPackable] en afgeleide types met [MemoryPackUnion]
// Union ondersteunt ook abstracte klassen
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}

[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}

[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---

IUnionSample data = new FooClass() { XYZ = 999 };

// Serialize als interface type.
var bin = MemoryPackSerializer.Serialize(data);

// Deserialize als interface type.
var reData = MemoryPackSerializer.Deserialize&lt;IUnionSample&gt;(bin);

switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}
</code></pre>
<p><code>tag</code> staat waarden toe van <code>0</code> ~ <code>65535</code>, het is vooral efficiënt voor minder dan <code>250</code>.</p>
<pre><code>Als een interface en afgeleide typen zich in verschillende assemblies bevinden, kun je in plaats daarvan `MemoryPackUnionFormatterAttribute` gebruiken. Formatters worden zo gegenereerd dat ze automatisch worden geregistreerd via `ModuleInitializer` in C# 9.0 en hoger.

&gt; Let op: `ModuleInitializer` wordt niet ondersteund in Unity, dus de formatter moet handmatig worden geregistreerd. Om je union formatter te registreren, roep je `{naam van je union formatter}Initializer.RegisterFormatter()` handmatig aan in Startup. Bijvoorbeeld `UnionSampleFormatterInitializer.RegisterFormatter()`.

```csharp
// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}

// AssemblyB definieer de definitie buiten het doeldtype
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}
</code></pre>
<p>Union kan in code worden samengesteld via <code>DynamicUnionFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp">// (ushort, Type)[]
var formatter = new DynamicUnionFormatter&lt;IFooBarBaz&gt;(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);

MemoryPackFormatterProvider.Register(formatter);
</code></pre>
<h2>Serialize API</h2>
<p><code>Serialize</code> heeft drie overloads.</p>
<pre><code class="language-csharp">// Niet-generieke API is ook beschikbaar, bij deze versies is het eerste argument Type en de waarde object?
byte[] Serialize&lt;T&gt;(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize&lt;T, TBufferWriter&gt;(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync&lt;T&gt;(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
</code></pre>
<p>Voor prestaties wordt de aanbevolen API met <code>BufferWriter</code> gebruikt. Dit serialiseert direct in de buffer. Het kan worden toegepast op <code>PipeWriter</code> in <code>System.IO.Pipelines</code>, <code>BodyWriter</code> in ASP .NET Core, enzovoort.</p>
<p>Als een <code>byte[]</code> vereist is (bijv. <code>RedisValue</code> in <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>), is de teruggegeven <code>byte[]</code> API eenvoudig en bijna net zo snel.</p>
<p>Let op dat <code>SerializeAsync</code> voor <code>Stream</code> alleen asynchroon is voor Flush; het serialiseert alles in één keer in de interne poolbuffer van MemoryPack en schrijft vervolgens met <code>WriteAsync</code>. Daarom is de <code>BufferWriter</code> overload, die buffer en flush scheidt en beheert, beter.</p>
<p>Als je volledig streaming wilt schrijven, zie de sectie <a href="#streaming-serialization">Streaming Serialization</a>.</p>
<h3>MemoryPackSerializerOptions</h3>
<p><code>MemoryPackSerializerOptions</code> configureert of strings als UTF16 of UTF8 worden geserialiseerd. Dit kan worden geconfigureerd door <code>MemoryPackSerializerOptions.Utf8</code> door te geven voor UTF8-codering, <code>MemoryPackSerializerOptions.Utf16</code> voor UTF16-codering, of <code>MemoryPackSerializerOptions.Default</code> wat standaard op UTF8 staat. Null doorgeven of de standaardparameter gebruiken resulteert in UTF8-codering.</p>
<p>Aangezien de interne stringrepresentatie van C# UTF16 is, presteert UTF16 beter. Echter, de payload is meestal groter; in UTF8 is een ASCII-string één byte, terwijl deze in UTF16 twee bytes is. Omdat het verschil in grootte van deze payload zo groot is, wordt standaard UTF8 gebruikt.</p>
<p>Als de data niet-ASCII is (bijv. Japans, wat meer dan 3 bytes kan zijn, en UTF8 is dan groter), of als je het apart moet comprimeren, kan UTF16 betere resultaten geven.</p>
<p>Hoewel tijdens serialisatie kan worden gekozen voor UTF8 of UTF16, is het niet nodig om dit tijdens deserialisatie te specificeren. Het wordt automatisch gedetecteerd en normaal gedeserialiseerd.</p>
<p>Daarnaast kun je <code>IServiceProvider? ServiceProvider { get; init; }</code> uit de opties krijgen/instellen. Dit is handig om een DI-object (zoals <code>ILogger&lt;T&gt;</code>) te verkrijgen tijdens het serialisatieproces (<code>MemoryPackReader/MemoryPackWriter</code> heeft een .Options property).</p>
<h2>Deserialize API</h2>
<p><code>Deserialize</code> heeft overloads voor <code>ReadOnlySpan&lt;byte&gt;</code> en <code>ReadOnlySequence&lt;byte&gt;</code>, <code>Stream</code> en <code>ref</code> ondersteuning.</p>
<pre><code class="language-csharp">T? Deserialize&lt;T&gt;(ReadOnlySpan&lt;byte&gt; buffer)
int Deserialize&lt;T&gt;(ReadOnlySpan&lt;byte&gt; buffer, ref T? value)
T? Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; buffer)
int Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; buffer, ref T? value)
async ValueTask&lt;T?&gt; DeserializeAsync&lt;T&gt;(Stream stream)
</code></pre>
<p>De <code>ref</code> overload overschrijft een bestaande instantie, zie voor details de <a href="#overwrite">Overwrite</a> sectie.</p>
<p><code>DeserializeAsync(Stream)</code> is geen volledige streaming read-operatie; eerst wordt tot het einde van de stream gelezen in de interne pool van MemoryPack, daarna wordt gedeserialiseerd.</p>
<p>Als je een volledige streaming read-operatie wilt uitvoeren, zie de sectie <a href="#streaming-serialization">Streaming Serialization</a>.</p>
<h2>Overwrite</h2>
<p>Om allocaties te verminderen ondersteunt MemoryPack deserialisatie naar een bestaande instantie, waarbij deze wordt overschreven. Dit kan met de overload <code>Deserialize(ref T? value)</code>.</p>
<pre><code class="language-csharp">var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);

// overschrijf data naar bestaande instantie.
MemoryPackSerializer.Deserialize(bin, ref person);
</code></pre>
<p>MemoryPack zal proberen zoveel mogelijk te overschrijven, maar als aan de volgende voorwaarden niet wordt voldaan, wordt er een nieuwe instantie aangemaakt (zoals bij normale deserialisatie).</p>
<ul>
<li>ref waarde (inclusief leden in het objectgrafiek) is null, stel een nieuwe instantie in</li>
<li>alleen parameterloze constructor toegestaan, als een constructor met parameters wordt gebruikt, wordt een nieuwe instantie gemaakt</li>
<li>als waarde <code>T[]</code> is, alleen hergebruiken als de lengte gelijk is, anders een nieuwe instantie maken</li>
<li>als waarde een collectie is die een <code>.Clear()</code> methode heeft (<code>List&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentBag&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>) wordt Clear() aangeroepen en wordt deze hergebruikt, anders wordt een nieuwe instantie aangemaakt</li>
</ul>
<h2>Version tolerant</h2>
<p>Standaard (<code>GenerateType.Object</code>) ondersteunt MemoryPack beperkte schema-evolutie.</p>
<ul>
<li>unmanaged struct kan niet meer worden gewijzigd</li>
<li>leden kunnen worden toegevoegd, maar niet verwijderd</li>
<li>lidnaam kan worden gewijzigd</li>
<li>ledenvolgorde kan niet worden gewijzigd</li>
<li>lidtype kan niet worden gewijzigd</li>
</ul>
<pre><code class="language-csharp">[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}

// Toevoegen is OK.
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}

// Verwijderen is NG.
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}

// Volgorde wijzigen is NG.
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}
</code></pre>
<p>In het gebruiksgeval, oude data opslaan (naar bestand, naar redis, etc...) en lezen naar nieuw schema is altijd oké. In het RPC-scenario bestaat het schema zowel aan de client- als aan de serverzijde; de client moet vóór de server worden bijgewerkt. Een bijgewerkte client kan zonder problemen verbinding maken met de oude server, maar een oude client kan niet verbinden met een nieuwe server.</p>
<p>Standaard, wanneer oude data wordt gelezen naar een nieuw schema, worden leden die niet aan de datazijde staan geïnitialiseerd met het <code>default</code> literal.
Als je dit wilt vermijden en de initiële waarden van velden/properties wilt gebruiken, kun je <code>[SuppressDefaultInitialization]</code> gebruiken.</p>
<pre><code class="language-cs">[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }

    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // &lt; als oude data ontbreekt, wordt `111` gezet.
    
    public int Prop3 { get; set; } = 222; // &lt; als oude data ontbreekt, wordt `default` gezet.
}
</code></pre>
<p><code>[SuppressDefaultInitialization]</code> heeft de volgende beperking:</p>
<ul>
<li>Kan niet worden gebruikt met readonly, init-only en required modifier.</li>
</ul>
<p>De volgende <a href="#serialization-info">Serialization info</a> sectie laat zien hoe je kunt controleren op schemawijzigingen, bijvoorbeeld met CI, om ongelukken te voorkomen.</p>
<p>Bij gebruik van <code>GenerateType.VersionTolerant</code> wordt volledige versie-tolerantie ondersteund.</p>
<ul>
<li>unmanaged struct kan niet meer worden gewijzigd</li>
<li>alle leden moeten expliciet <code>[MemoryPackOrder]</code> krijgen (behalve als <code>SerializeLayout.Sequential</code> is geannoteerd)</li>
<li>leden kunnen worden toegevoegd, verwijderd, maar volgorde niet hergebruiken (wel ontbrekende volgorde gebruiken)</li>
<li>lidnaam kan worden gewijzigd</li>
<li>ledenvolgorde kan niet worden gewijzigd</li>
<li>lidtype kan niet worden gewijzigd</li>
</ul>
<pre><code class="language-csharp">// Ok om te serialiseren/deserialiseren beide 
// VersionTolerantObject1 -&gt; VersionTolerantObject2 en 
// VersionTolerantObject2 -&gt; VersionTolerantObject1

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;

    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;

    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{
```csharp
[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;

// verwijderd
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;

[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;

// toegevoegd
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}
</code></pre>
<pre><code class="language-csharp">// Indien SerializeLayout.Sequential expliciet is ingesteld, wordt automatische ordening toegestaan.
// Maar het is niet mogelijk om leden te verwijderen voor versie-tolerantie.
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}
</code></pre>
<p><code>GenerateType.VersionTolerant</code> is langzamer dan <code>GenerateType.Object</code> bij het serialiseren. Ook zal de payload-grootte iets groter zijn.</p>
<h2>Serialisatie-informatie</h2>
<p>Je kunt via IntelliSense in het type zien welke leden worden geserialiseerd. Er is een optie om deze informatie tijdens het compileren naar een bestand te schrijven. Stel <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> als volgt in.</p>
<pre><code class="language-xml">&lt;!-- output memorypack serialisatie-info naar een map --&gt;
&lt;ItemGroup&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_SerializationInfoOutputDirectory&quot; /&gt;
&lt;/ItemGroup&gt;
&lt;PropertyGroup&gt;
    &lt;MemoryPackGenerator_SerializationInfoOutputDirectory&gt;$(MSBuildProjectDirectory)\MemoryPackLogs&lt;/MemoryPackGenerator_SerializationInfoOutputDirectory&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>De volgende informatie wordt naar het bestand geschreven.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image" /></p>
<p>Als het type unmanaged is, wordt <code>unmanaged</code> vóór de typenaam weergegeven.</p>
<pre><code class="language-txt">unmanaged FooStruct
---
int x
int y
</code></pre>
<p>Door de verschillen in dit bestand te controleren, kunnen gevaarlijke schemawijzigingen worden voorkomen. Bijvoorbeeld, je kunt CI gebruiken om de volgende regels te detecteren</p>
<ul>
<li>wijziging van unmanaged type</li>
<li>wijziging van ledenvolgorde</li>
<li>verwijderen van leden</li>
</ul>
<h2>Circulaire Referentie</h2>
<p>MemoryPack ondersteunt ook circulaire referenties. Dit maakt het mogelijk om boomstructuren als zodanig te serialiseren.</p>
<pre><code class="language-csharp">// om circulaire referentie mogelijk te maken, gebruik GenerateType.CircularReference
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}
</code></pre>
<p>Bijvoorbeeld, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references">System.Text.Json preserve-references</a> code wordt dan als volgt.</p>
<pre><code class="language-csharp">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = &quot;Tyler Stein&quot;
};

Employee adrian = new()
{
    Name = &quot;Adrian King&quot;
};

tyler.DirectReports = new List&lt;Employee&gt; { adrian };
adrian.Manager = tyler;

var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize&lt;Employee&gt;(bin);

Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true

[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List&lt;Employee&gt;? DirectReports { get; set; }
}
</code></pre>
<p><code>GenerateType.CircularReference</code> heeft dezelfde eigenschappen als versie-tolerant. Echter, als extra beperking zijn alleen parameterloze constructors toegestaan. Ook wordt object-referentie-tracking alleen gedaan voor objecten gemarkeerd met <code>GenerateType.CircularReference</code>. Als je een ander object wilt volgen, wikkel het dan in.</p>
<h2>CustomFormatter</h2>
<p>Als je <code>MemoryPackCustomFormatterAttribute&lt;T&gt;</code> of <code>MemoryPackCustomFormatterAttribute&lt;TFormatter, T&gt;</code> implementeert (presteert beter, maar complexer), kun je een custom formatter configureren voor een lid van een MemoryPackObject.</p>
<pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute&lt;T&gt; : Attribute
{
    public abstract IMemoryPackFormatter&lt;T&gt; GetFormatter();
}
</code></pre>
<p>MemoryPack biedt de volgende formatter-attributen: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute&lt;TValue&gt;</code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter&lt;T&gt;</code>, <code>MemoryPoolFormatter&lt;T&gt;</code>, <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // serialiseer dit lid als UTF16 String, het is sneller dan UTF8 maar in ASCII is de grootte groter (maar voor niet-ASCII soms kleiner).
    [Utf16StringFormatter]
    public string? Text { get; set; }

    // Bij deserialisatie wordt Dictionary geïnitialiseerd met StringComparer.OrdinalIgnoreCase.
    [OrdinalIgnoreCaseStringDictionaryFormatter&lt;int&gt;]
    public Dictionary&lt;string, int&gt;? Ids { get; set; }
    
    // Tijdens deserialisatie worden alle strings geïnterneerd (zie: String.Intern). Als vergelijkbare waarden vaak voorkomen, bespaart dit geheugen.
    [InternStringFormatter]
    public string? Flag { get; set; }
}
</code></pre>
<p>Om een gelijkheidscomparer voor een set/dictionary te configureren, hebben alle ingebouwde formatters een comparer-constructor overload. Je kunt eenvoudig aangepaste gelijkheidscomparer-formatters maken.</p>
<pre><code class="language-csharp">public sealed class OrdinalIgnoreCaseStringDictionaryFormatter&lt;TValue&gt; : MemoryPackCustomFormatterAttribute&lt;Dictionary&lt;string, TValue?&gt;&gt;
{
    static readonly DictionaryFormatter&lt;string, TValue?&gt; formatter = new DictionaryFormatter&lt;string, TValue?&gt;(StringComparer.OrdinalIgnoreCase);

    public override IMemoryPackFormatter&lt;Dictionary&lt;string, TValue?&gt;&gt; GetFormatter()
    {
        return formatter;
    }
}
</code></pre>
<p><code>BitPackFormatter</code> comprimeert alleen <code>bool[]</code> types. <code>bool[]</code> wordt normaal geserialiseerd als 1 byte per boolean waarde, maar <code>BitPackFormatter</code> serialiseert <code>bool[]</code> zoals een <code>BitArray</code> waarbij elke bool als 1 bit wordt opgeslagen. Door <code>BitPackFormatter</code> te gebruiken, worden 8 booleans 1 byte, terwijl dat normaal 8 bytes zou zijn, wat resulteert in een 8x kleinere grootte.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BitPackFormatter]
    public bool[]? Data { get; set; }
}
</code></pre>
<p><code>BrotliFormatter</code> is voor <code>byte[]</code>, bijvoorbeeld kun je met Brotli een grote payload comprimeren.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}
</code></pre>
<p><code>BrotliStringFormatter</code> is voor <code>string</code>, serialiseer gecomprimeerde string (UTF16) met Brotli.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}
</code></pre>
<p><code>BrotliFormatter&lt;T&gt;</code> is voor elk type, seriële data gecomprimeerd door Brotli. Als een type <code>byte[]</code> of <code>string</code> is, kun je voor de prestaties beter <code>BrotliFormatter</code> of <code>BrotliStringFormatter</code> gebruiken.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BrotliFormatter&lt;ChildType&gt;]
    public ChildType? Child { get; set; }
}
</code></pre>
<h2>Deserialiseren met array pooling</h2>
<p>Om een grote array (elke <code>T</code>) te deserialiseren, biedt MemoryPack meerdere efficiënte pooling-methoden. De meest effectieve manier is om de <a href="#overwrite">#Overwrite</a> functie te gebruiken. In het bijzonder wordt <code>List&lt;T&gt;</code> altijd hergebruikt.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List&lt;byte&gt; Payload { get; set; }
}

// ----

// List&lt;byte&gt; wordt hergebruikt, geen allocatie bij deserialiseren.
MemoryPackSerializer.Deserialize&lt;ListBytesSample&gt;(bin, ref reuseObject);

// voor efficiënte bewerking kun je Span&lt;T&gt; krijgen via CollectionsMarshal
var span = CollectionsMarshal.AsSpan(value.Payload);
</code></pre>
<p>Een handige manier is deserialiseren naar een ArrayPool op het moment van deserialisatie. MemoryPack biedt <code>MemoryPoolFormatter&lt;T&gt;</code> en <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }

    [MemoryPoolFormatter&lt;byte&gt;]
    public Memory&lt;byte&gt; Payload { get; private set; }

    public PoolModelSample(int id, Memory&lt;byte&gt; payload)
    {
        Id = id;
        Payload = payload;
    }

    // Je moet zelf de return code schrijven, hier een snippet.

    bool usePool;

    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }

    public void Dispose()
    {
        if (!usePool) return;

        Return(Payload); Payload = default;
    }

    static void Return&lt;T&gt;(Memory&lt;T&gt; memory) =&gt; Return((ReadOnlyMemory&lt;T&gt;)memory);

    static void Return&lt;T&gt;(ReadOnlyMemory&lt;T&gt; memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) &amp;&amp; segment.Array is { Length: &gt; 0 })
        {
            ArrayPool&lt;T&gt;.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;());
        }
    }
}

// ---

using(var value = MemoryPackSerializer.Deserialize&lt;PoolModelSample&gt;(bin))
{
    // doe iets...
}   // teruggeven aan ArrayPool
</code></pre>
<h2>Prestaties</h2>
<p>Zie mijn blogpost <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p>
<h2>Payloadgrootte en compressie</h2>
<p>De payloadgrootte hangt af van de doelwaarde; in tegenstelling tot JSON zijn er geen sleutels en het is een binair formaat, dus de payloadgrootte zal waarschijnlijk kleiner zijn dan bij JSON.</p>
<p>Voor formaten met varint-codering, zoals MessagePack en Protobuf, is MemoryPack vaak groter als er veel ints worden gebruikt (in MemoryPack zijn ints altijd 4 bytes vanwege fixed size encoding, terwijl MessagePack 1~5 bytes gebruikt).</p>
<p>float en double zijn 4 bytes en 8 bytes in MemoryPack, maar 5 bytes en 9 bytes in MessagePack. Dus MemoryPack is kleiner, bijvoorbeeld voor Vector3 (float, float, float) arrays.</p>
<p>String is standaard UTF8, wat vergelijkbaar is met andere serializers, maar als de UTF16-optie wordt gekozen, heeft het een ander karakter.</p>
<p>In elk geval, als de payloadgrootte groot is, moet compressie worden overwogen. LZ4, ZStandard en Brotli worden aanbevolen.</p>
<h3>Compressie</h3>
<p>MemoryPack biedt een efficiënte helper voor <a href="https://github.com/google/brotli">Brotli</a> compressie via <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder">BrotliEncoder</a> en <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder">BrotliDecoder</a>. MemoryPack's <code>BrotliCompressor</code> en <code>BrotliDecompressor</code> bieden compressie/decompressie geoptimaliseerd voor het interne gedrag van MemoryPack.</p>
<pre><code class="language-csharp">using MemoryPack.Compression;

// Compressie (vereist using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);

// Verkrijg gecomprimeerde byte[]
var compressedBytes = compressor.ToArray();

// Of schrijf naar een andere IBufferWriter&lt;byte&gt; (bijvoorbeeld PipeWriter)
compressor.CopyTo(response.BodyWriter);
</code></pre>
<pre><code class="language-csharp">using MemoryPack.Compression;

// Decompressie (vereist using)
using var decompressor = new BrotliDecompressor();

// Verkrijg gedecomprimeerde ReadOnlySequence&lt;byte&gt; van ReadOnlySpan&lt;byte&gt; of ReadOnlySequence&lt;byte&gt;
var decompressedBuffer = decompressor.Decompress(buffer);

var value = MemoryPackSerializer.Deserialize&lt;T&gt;(decompressedBuffer);
</code></pre>
<p>Zowel <code>BrotliCompressor</code> als <code>BrotliDecompressor</code> zijn structs, ze alloceren geen geheugen op de heap. Beide slaan gecomprimeerde of gedecomprimeerde data op in een interne geheugenpool voor Serialize/Deserialize. Daarom is het noodzakelijk om het geheugengebruik vrij te geven; vergeet niet om <code>using</code> te gebruiken.</p>
<p>Het compressieniveau is erg belangrijk. De standaardwaarde is ingesteld op quality-1 (CompressionLevel.Fastest), wat anders is dan de .NET-standaard (CompressionLevel.Optimal, quality-4).</p>
<p>Fastest (quality-1) is qua snelheid vergelijkbaar met <a href="https://github.com/lz4/lz4">LZ4</a>, maar 4 is veel langzamer. Dit is cruciaal bevonden in het serializer-gebruiksscenario. Wees voorzichtig bij het gebruik van de standaard <code>BrotliStream</code> (quality-4 is de standaard). In elk geval zullen compressie-/decompressiesnelheden en -groottes zeer verschillende resultaten opleveren voor verschillende data. Bereid de data voor die jouw applicatie moet verwerken en test het zelf.</p>
<p>Let op: er is een meervoudige snelheidsstraf tussen MemoryPack's ongecomprimeerde en Brotli's extra compressie.</p>
<p>Brotli wordt ook ondersteund in een custom formatter. Met <code>BrotliFormatter</code> kun je een specifiek lid comprimeren.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}
</code></pre>
<h2>Externe types serialiseren</h2>
<p>Als je externe types wilt serialiseren, kun je een custom formatter maken en deze registreren bij de provider, zie <a href="#formatterprovider-api">Formatter/Provider API</a> voor details. Het maken van een custom formatter is echter moeilijk. Daarom raden we aan een wrappertype te maken. Bijvoorbeeld, als je een extern type wilt serialiseren genaamd <code>AnimationCurve</code>.</p>
<pre><code class="language-csharp">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;

    [MemoryPackInclude]
    WrapMode preWrapMode =&gt; AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode =&gt; AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys =&gt; AnimationCurve.keys;

    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }

    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}
</code></pre>
<p>Het te wrappen type is public, maar uitgesloten van serialisatie (<code>MemoryPackIgnore</code>). De properties die je wilt serialiseren zijn private, maar inbegrepen (<code>MemoryPackInclude</code>). Twee patronen van constructors moeten ook voorbereid zijn. De constructor die door de serializer wordt gebruikt, moet private zijn.</p>
<p>Zoals het nu is, moet het elke keer worden gewrapt, wat onhandig is. En een struct wrapper kan geen null representeren. Laten we dus een custom formatter maken.</p>
<pre><code class="language-csharp">public class AnimationCurveFormatter : MemoryPackFormatter&lt;AnimationCurve&gt;
{
    // Unity ondersteunt geen scoped en TBufferWriter, dus wijzig de signature naar `Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)`
    public override void Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref AnimationCurve? value)
    {
        if (value == null)
```csharp
{
    writer.WriteNullObjectHeader();
    return;
}

writer.WritePackable(new SerializableAnimationCurve(value));
}

public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // skip null block
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable&lt;SerializableAnimationCurve&gt;();
    value = wrapped.AnimationCurve;
}
}
</code></pre>
<p>Registreer tenslotte de formatter in startup.</p>
<pre><code class="language-csharp">MemoryPackFormatterProvider.Register&lt;AnimationCurve&gt;(new AnimationCurveFormatter());
</code></pre>
<blockquote>
<p>Opmerking: Unity's AnimationCurve is standaard serialiseerbaar, dus deze aangepaste formatter is niet nodig voor AnimationCurve</p>
</blockquote>
<h2>Pakketten</h2>
<p>MemoryPack heeft de volgende pakketten.</p>
<ul>
<li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li>
</ul>
<p><code>MemoryPack</code> is de hoofd bibliotheek en biedt volledige ondersteuning voor hoge prestaties bij serialisatie en deserialisatie van binaire objecten. Het is afhankelijk van <code>MemoryPack.Core</code> voor de kernbibliotheken en van <code>MemoryPack.Generator</code> voor codegeneratie. <code>MemoryPack.Streaming</code> voegt aanvullende extensies toe voor <a href="#streaming-serialization">Streaming Serialization</a>.  <code>MemoryPack.AspNetCoreMvcFormatter</code> voegt input/output formatters toe voor ASP.NET Core. <code>MemoryPack.UnityShims</code> voegt Unity shim types en formatters toe voor gedeeld gebruik van types tussen .NET en Unity.</p>
<h2>TypeScript en ASP.NET Core Formatter</h2>
<p>MemoryPack ondersteunt TypeScript codegeneratie. Het genereert klassen- en serialisatiecode vanuit C#, met andere woorden, je kunt types delen met de browser zonder gebruik te maken van OpenAPI, proto, etc.</p>
<p>Codegeneratie is geïntegreerd met Source Generator, de volgende optie (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) stelt de uitvoermap in voor TypeScript-code. Runtime code wordt gelijktijdig gegenereerd, dus er zijn geen aanvullende afhankelijkheden vereist.</p>
<pre><code class="language-xml">&lt;!-- output memorypack TypeScript-code naar map --&gt;
&lt;ItemGroup&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptOutputDirectory&quot; /&gt;
&lt;/ItemGroup&gt;
&lt;PropertyGroup&gt;
    &lt;MemoryPackGenerator_TypeScriptOutputDirectory&gt;$(MSBuildProjectDirectory)\wwwroot\js\memorypack&lt;/MemoryPackGenerator_TypeScriptOutputDirectory&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>Een C# MemoryPackable type moet geannoteerd zijn met <code>[GenerateTypeScript]</code>.</p>
<pre><code class="language-csharp">[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}

public enum Gender
{
    Male, Female, Other
}
</code></pre>
<p>Runtime code en TypeScript type worden gegenereerd in de doelmap.</p>
<p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image" /></p>
<p>De gegenereerde code ziet er als volgt uit, met eenvoudige velden en statische methoden voor serialize/serializeArray en deserialize/deserializeArray.</p>
<pre><code class="language-typescript">import { MemoryPackWriter } from &quot;./MemoryPackWriter.js&quot;;
import { MemoryPackReader } from &quot;./MemoryPackReader.js&quot;;
import { Gender } from &quot;./Gender.js&quot;; 

export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;

    constructor() {
        // snip...
    }

    static serialize(value: Person | null): Uint8Array {
        // snip...
    }

    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }

    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }

    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }

    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }

    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}
</code></pre>
<p>Je kunt dit type als volgt gebruiken.</p>
<pre><code class="language-typescript">let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = &quot;foo&quot;;
person.lastName = &quot;bar&quot;;
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = [&quot;foo@bar.com&quot;, &quot;zoo@bar.net&quot;];

// serialiseer naar Uint8Array
let bin = Person.serialize(person);

let blob = new Blob([bin.buffer], { type: &quot;application/x-memorypack&quot; })

let response = await fetch(&quot;http://localhost:5260/api&quot;,
    { method: &quot;POST&quot;, body: blob, headers: { &quot;Content-Type&quot;: &quot;application/x-memorypack&quot; } });

let buffer = await response.arrayBuffer();

// deserialiseer van ArrayBuffer 
let person2 = Person.deserialize(buffer);
</code></pre>
<p>Het pakket <code>MemoryPack.AspNetCoreMvcFormatter</code> voegt <code>MemoryPack</code> input en output formatters toe aan ASP.NET Core MVC. Je kunt <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> toevoegen aan ASP.NET Core MVC met de volgende code.</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // Als checkContentType: true, dan kan meerdere formaten outputten (JSON/MemoryPack, etc...). standaard is false.
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});
</code></pre>
<p>Als je aanroept vanuit HttpClient, kun je <code>application/x-memorypack</code> instellen als content-header.</p>
<pre><code class="language-csharp">var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue(&quot;application/x-memorypack&quot;);
</code></pre>
<h3>TypeScript Type Mapping</h3>
<p>Er zijn enkele beperkingen op de typen die gegenereerd kunnen worden. Onder de primitieve types worden <code>char</code> en <code>decimal</code> niet ondersteund. Ook kan een OpenGenerics type niet gebruikt worden.</p>
<p>|  C#  |  TypeScript  | Beschrijving |
| ---- | ---- | ---- |
| <code>bool</code> |  <code>boolean</code>  |
| <code>byte</code> |  <code>number</code>  |
| <code>sbyte</code> |  <code>number</code>  |
| <code>int</code> |  <code>number</code> |
| <code>uint</code> |  <code>number</code> |
| <code>short</code> |  <code>number</code> |
| <code>ushort</code> |  <code>number</code> |
| <code>long</code> |  <code>bigint</code> |</p>
<pre><code>| `ulong` |  `bigint` |
| `float` |  `number` |
| `double` |  `number` |
| `string` |  `string \| null`  | 
| `Guid` |  `string`  | In TypeScript wordt dit als string weergegeven, maar bij serialiseren/deserialiseren als 16-byte binaire data
| `DateTime` | `Date` | DateTimeKind wordt genegeerd
| `enum` | `const enum` | `long` en `ulong` als onderliggende types worden niet ondersteund
| `T?` | `T \| null` |
| `T[]` | `T[] \| null` |
| `byte[]` | `Uint8Array \| null` |
| `: ICollection&lt;T&gt;` | `T[] \| null` | Ondersteunt alle `ICollection&lt;T&gt;` geïmplementeerde types zoals `List&lt;T&gt;`
| `: ISet&lt;T&gt;` | `Set&lt;T&gt; \| null` | Ondersteunt alle `ISet&lt;T&gt;` geïmplementeerde types zoals `HashSet&lt;T&gt;`
| `: IDictionary&lt;K,V&gt;` | `Map&lt;K, V&gt; \| null` | Ondersteunt alle `IDictionary&lt;K,V&gt;` geïmplementeerde types zoals `Dictionary&lt;K,V&gt;`.
| `[MemoryPackable]` | `class` | Ondersteunt alleen klassen
| `[MemoryPackUnion]` | `abstract class` |

`[GenerateTypeScript]` kan alleen op klassen worden toegepast en wordt momenteel niet ondersteund voor structs.

### Extensie van importbestand en lidnaamnotatie configureren

Standaard genereert MemoryPack de bestandsextensie als `.js`, bijvoorbeeld `import { MemoryPackWriter } from &quot;./MemoryPackWriter.js&quot;;`. Wil je een andere extensie of geen extensie, gebruik dan `MemoryPackGenerator_TypeScriptImportExtension` om dit te configureren.
Ook worden de lidnamen automatisch omgezet naar camelCase. Wil je de originele naam gebruiken, zet `MemoryPackGenerator_TypeScriptConvertPropertyName` op `false`.

```xml
&lt;ItemGroup&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptOutputDirectory&quot; /&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptImportExtension&quot; /&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptConvertPropertyName&quot; /&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptEnableNullableTypes&quot; /&gt;
&lt;/ItemGroup&gt;
&lt;PropertyGroup&gt;
    &lt;MemoryPackGenerator_TypeScriptOutputDirectory&gt;$(MSBuildProjectDirectory)\wwwroot\js\memorypack&lt;/MemoryPackGenerator_TypeScriptOutputDirectory&gt;
    &lt;!-- mag leeg zijn --&gt;
    &lt;MemoryPackGenerator_TypeScriptImportExtension&gt;&lt;/MemoryPackGenerator_TypeScriptImportExtension&gt;
    &lt;!-- standaard is true --&gt;
    &lt;MemoryPackGenerator_TypeScriptConvertPropertyName&gt;false&lt;/MemoryPackGenerator_TypeScriptConvertPropertyName&gt;
    &lt;!-- standaard is false --&gt;
    &lt;MemoryPackGenerator_TypeScriptEnableNullableTypes&gt;true&lt;/MemoryPackGenerator_TypeScriptEnableNullableTypes&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> zorgt ervoor dat C# nullable annotaties worden weerspiegeld in de TypeScript-code. De standaardwaarde is false, waardoor alles nullable wordt.</p>
<h2>Streaming Serialisatie</h2>
<p><code>MemoryPack.Streaming</code> biedt <code>MemoryPackStreamingSerializer</code>, die extra ondersteuning toevoegt voor het serialiseren en deserialiseren van collecties met streams.</p>
<pre><code class="language-csharp">public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync&lt;T&gt;(PipeWriter pipeWriter, int count, IEnumerable&lt;T&gt; source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync&lt;T&gt;(Stream stream, int count, IEnumerable&lt;T&gt; source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable&lt;T?&gt; DeserializeAsync&lt;T&gt;(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable&lt;T?&gt; DeserializeAsync&lt;T&gt;(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}
</code></pre>
<h2>Formatter/Provider API</h2>
<p>Als je een formatter handmatig wilt implementeren, erf dan van <code>MemoryPackFormatter&lt;T&gt;</code> en overschrijf de methoden <code>Serialize</code> en <code>Deserialize</code>.</p>
<pre><code class="language-csharp">public class SkeltonFormatter : MemoryPackFormatter&lt;Skelton&gt;
{
    public override void Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        // gebruik writer-methoden.
    }

    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        // gebruik reader-methoden.
    }
}
</code></pre>
<p>De gemaakte formatter wordt geregistreerd met <code>MemoryPackFormatterProvider</code>.</p>
<pre><code class="language-csharp">MemoryPackFormatterProvider.Register(new SkeltonFormatter());
</code></pre>
<p>Let op: <code>unmanaged struct</code> (bevat geen referentietypen) kan geen custom formatter gebruiken, deze wordt altijd geserialiseerd volgens de native geheugenlayout.</p>
<h2>MemoryPackWriter/ReaderOptionalState</h2>
<p>Initialiseren van <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> vereist OptionalState. Dit is een wrapper om <code>MemoryPackSerializerOptions</code>, en kan worden gemaakt via <code>MemoryPackWriterOptionalStatePool</code>.</p>
<pre><code class="language-csharp">// bij dispose, wordt OptionalState teruggegeven aan de pool.
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter&lt;T&gt;(ref t, state);
}

// voor Reader
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}
</code></pre>
<h2>Afhankelijkheid van target framework</h2>
<p>MemoryPack biedt <code>netstandard2.1</code> en <code>net7.0</code>, maar deze zijn niet compatibel met elkaar. Als je bijvoorbeeld MemoryPackable types onder een <code>netstandard2.1</code> project gebruikt vanuit een <code>net7.0</code> project, krijg je een runtime-exceptie zoals:</p>
<blockquote>
<p>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</p>
</blockquote>
<p>Omdat net7.0 gebruikmaakt van statische abstracte leden (<code>Virtual static method</code>), die niet worden ondersteund door netstandard2.1, is dit het verwachte gedrag.</p>
<p>Een .NET 7-project mag de netstandard 2.1 dll niet gebruiken. Met andere woorden: als de applicatie een .NET 7-project is, moeten alle afhankelijkheden die MemoryPack gebruiken .NET 7 ondersteunen. Dus als een bibliotheekontwikkelaar afhankelijk is van MemoryPack, moet je een dual target framework configureren.</p>
<pre><code class="language-xml">&lt;TargetFrameworks&gt;netstandard2.1;net7.0&lt;/TargetFrameworks&gt;
</code></pre>
<h2>RPC</h2>
<p><a href="https://github.com/Cysharp/MagicOnion">Cysharp/MagicOnion</a> is een code-first grpc-dotnet framework dat MessagePack gebruikt in plaats van protobuf. MagicOnion ondersteunt nu MemoryPack als serialisatielaag via het <code>MagicOnion.Serialization.MemoryPack</code>-pakket (preview). Zie details: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support">MagicOnion#MemoryPack support</a></p>
<h2>Unity</h2>
<p>Minimaal ondersteunde Unity-versie is <code>2022.3.12f1</code>.</p>
<p>Het <code>MemoryPack</code>-kernpakket is beschikbaar via nuget. Het is ook beschikbaar in Unity. Wil je ondersteuning voor Unity ingebouwde types, dan bieden we aanvullend de MemoryPack.Unity-extensie.</p>
<ol>
<li>Installeer <code>MemoryPack</code> vanuit NuGet met <a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a></li>
</ol>
<ul>
<li><p>Open het venster via NuGet -&gt; Beheer NuGet Packages, zoek &quot;MemoryPack&quot; en druk op Installeren.
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot" /></p>
</li>
<li><p>Krijg je een foutmelding over versieconflicten, schakel dan versievalidatie uit in Player Settings (Edit -&gt; Projectinstellingen -&gt; Player -&gt; Scroll naar beneden en vouw &quot;Other Settings&quot; uit, schakel vervolgens &quot;Assembly Version Validation&quot; uit onder het kopje &quot;Configuration&quot;).</p>
</li>
</ul>
<ol start="2">
<li>Installeer het <code>MemoryPack.Unity</code>-pakket door te verwijzen naar de git-URL</li>
</ol>
<ul>
<li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code>
<img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot" />
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot" /></li>
</ul>
<p>MemoryPack gebruikt het <em>.</em>.* release tag-systeem, dus je kunt een versie opgeven als #1.0.0. Bijvoorbeeld: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p>
<p>Net als bij de .NET-versie wordt de code gegenereerd door een code generator (<code>MemoryPack.Generator.dll</code>). Implementatie zonder reflectie biedt ook de beste prestaties in IL2CPP.</p>
<p>Voor meer informatie over Unity en Source Generator, zie de <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Unity documentatie</a>.</p>
<p>Source Generator wordt ook officieel gebruikt door Unity door <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">com.unity.properties</a> en <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html">com.unity.entities</a>. Met andere woorden, het is de standaard voor codegeneratie in de volgende generatie Unity.</p>
<p>Je kunt alle unmanaged types (zoals <code>Vector3</code>, <code>Rect</code>, etc...) en enkele klassen (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>) serialiseren. Wil je andere Unity-specifieke types serialiseren, zie het gedeelte <a href="#serialize-external-types">Externe types serialiseren</a>.</p>
<p>Qua prestaties in Unity is MemoryPack x3~x10 sneller dan JsonUtility.</p>
<p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image" /></p>
<p>Als gedeelde code Unity-types bevat (<code>Vector2</code>, etc...), biedt MemoryPack het <code>MemoryPack.UnityShims</code>-pakket via NuGet.</p>
<p>Het <code>MemoryPack.UnityShims</code>-pakket biedt shims voor Unity's standaard structs (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) en enkele klassen (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>).</p>
<blockquote>
<p>[!WAARSCHUWING]
Momenteel gelden de volgende beperkingen voor gebruik in Unity</p>
</blockquote>
<ol>
<li>De Unity-versie ondersteunt geen CustomFormatter.</li>
<li>Als je .NET7 of nieuwer gebruikt, is het MemoryPack binaire formaat niet volledig compatibel met Unity.
<ul>
<li>Dit probleem doet zich voor bij waarde types waarvoor <code>[StructLayout(LayoutKind.Auto)]</code> expliciet is opgegeven. (De standaard voor struct is <code>LayoutKind.Sequencial</code>.) Voor zulke types kunnen binaries die in .NET zijn geserialiseerd, niet worden gedeserialiseerd in Unity. Evenzo kan een binary die in Unity is geserialiseerd, niet worden geserialiseerd aan de .NET-kant.</li>
<li>De getroffen types omvatten doorgaans de volgende types:
<ul>
<li><code>DateTimeOffset</code></li>
<li><code>ValueTuple</code></li>
</ul>
</li>
<li>Momenteel is de eenvoudige oplossing om deze types niet te gebruiken.</li>
</ul>
</li>
</ol>
<h2>Native AOT</h2>
<p>Helaas veroorzaakt .NET 7 Native AOT een crash (<code>Generic virtual method pointer lookup failure</code>) bij gebruik van MemoryPack, vanwege een runtime bug.
Dit wordt opgelost in .NET 8. Door <code>Microsoft.DotNet.ILCompiler</code> preview te gebruiken, wordt het probleem in .NET 7 opgelost. Zie <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611">opmerking bij issue</a> voor instructies om dit in te stellen.</p>
<h2>Binaire wireformaatspecificatie</h2>
<p>Het type <code>T</code> dat wordt gedefinieerd in <code>Serialize&lt;T&gt;</code> en <code>Deserialize&lt;T&gt;</code> wordt het C#-schema genoemd. Het MemoryPack-formaat is geen zelfbeschrijvend formaat. Voor deserialisatie is het bijbehorende C#-schema vereist. Deze types bestaan als interne representaties van binaries, maar types kunnen niet worden bepaald zonder een C#-schema.</p>
<p>Endianness moet <code>Little Endian</code> zijn. De C#-implementatie houdt echter geen rekening met endianness en kan dus niet worden gebruikt op big-endian machines. Moderne computers zijn echter vrijwel altijd little-endian.</p>
<p>Er zijn acht types formaten.</p>
<ul>
<li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>Circulaire Referentie Object</li>
<li>Tuple</li>
<li>Collectie</li>
<li>String</li>
<li>Unie</li>
</ul>
<h3>Unmanaged struct</h3>
<p>Unmanaged struct is een C# struct die geen referentietypen bevat, vergelijkbare beperking als <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>. Serialiseren van struct layout zoals het is, inclusief padding.</p>
<h3>Object</h3>
<p><code>(byte memberCount, [values...])</code></p>
<p>Object heeft 1 byte unsigned byte als aantal leden in de header. Aantal leden kan van <code>0</code> tot <code>249</code>, <code>255</code> geeft aan dat het object <code>null</code> is. Waarden slaan memorypack-waarde op voor het aantal leden.</p>
<h3>Version Tolerant Object</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], [values...])</code></p>
<p>Version Tolerant Object is vergelijkbaar met Object maar heeft de bytelengte van de waarden in de header. varint volgt deze specificatie, eerste sbyte is waarde of typeCode en de volgende X bytes zijn de waarde. 0 tot 127 = unsigned byte waarde, -1 tot -120 = signed byte waarde, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p>
<h3>Circulaire Referentie Object</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])</code><br />
<code>(250, varint referenceId)</code></p>
<p>Circulaire Referentie Object is vergelijkbaar met Version Tolerant Object maar als memberCount 250 is, is de volgende varint(unsigned-int32) de referenceId. Zo niet, dan wordt na byte-length-of-values, varint referenceId geschreven.</p>
<h3>Tuple</h3>
<p><code>(values...)</code></p>
<p>Tuple is een collectie met vaste grootte van niet-nullable waarden. In .NET worden <code>KeyValuePair&lt;TKey, TValue&gt;</code> en <code>ValueTuple&lt;T,...&gt;</code> geserialiseerd als Tuple.</p>
<h3>Collectie</h3>
<p><code>(int length, [values...])</code></p>
<p>Collectie heeft een 4-byte signed integer als datatelling in de header, <code>-1</code> betekent <code>null</code>. Waarden slaan memorypack-waarde op voor het aantal van de lengte.</p>
<h3>String</h3>
<p><code>(int utf16-length, utf16-value)</code><br />
<code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)</code></p>
<p>String heeft twee vormen, UTF16 en UTF8. Als de eerste 4-byte signed integer <code>-1</code> is, betekent dit null. <code>0</code> betekent leeg. UTF16 is hetzelfde als collectie (serialiseren als <code>ReadOnlySpan&lt;char&gt;</code>, utf16-value's byte-telling is utf16-length * 2). Als het eerste signed integer &lt;= <code>-2</code>, wordt de waarde gecodeerd in UTF8. utf8-byte-count is gecodeerd in complement, <code>~utf8-byte-count</code> om het aantal bytes te bepalen. De volgende signed integer is utf16-length, dit kan <code>-1</code> zijn wat onbekende lengte betekent. utf8-bytes slaan bytes op voor het aantal utf8-byte-count.</p>
<h3>Unie</h3>
<p><code>(byte tag, value)</code><br />
<code>(250, ushort tag, value)</code></p>
<p>Eerste unsigned byte is tag voor gediscrimineerde waarde type of vlag, <code>0</code> tot <code>249</code> betekent tag, <code>250</code> betekent dat de volgende unsigned short de tag is, <code>255</code> betekent dat de unie <code>null</code> is.</p>
<h2>Licentie</h2>
<p>Deze bibliotheek is gelicentieerd onder de MIT-licentie.</p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-09</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>