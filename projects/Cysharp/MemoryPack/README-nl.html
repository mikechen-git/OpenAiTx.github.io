<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Open AI Tx</title>

    <!-- Primary Meta Tags -->
    <meta name="title" content="Open AI Tx - Markdown Viewer">
    <meta name="description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta name="keywords" content="Open AI Tx, Markdown, GitHub Style, Documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/view.html">
    <meta property="og:title" content="Open AI Tx - Markdown Viewer">
    <meta property="og:description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">

    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="icon.jpg">
    <link rel="apple-touch-icon" href="icon.jpg">

    <!-- Marked.js for Markdown rendering -->
    <script type="text/javascript" async="" src="https://www.statcounter.com/counter/recorder.js"></script><script src="js/marked.min.js"></script>
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="css/github.min.css">
    <script src="js/highlight.min.js"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="view.css">
    <style>
        /* Layout */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .main-container {
            margin: 0 auto;
            width: 100%;
            max-width: 980px;
            padding: 0 20px;
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0 15px;
            }
        }

        /* Image size restrictions */
        .markdown-body img {
            max-width: 100%;
            height: auto;
        }

        /* Existing styles */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f6f8fa;
            border-bottom: 1px solid #e1e4e8;
            position: relative;
        }

        .back-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #0366d6;
            text-decoration: none;
            display: flex;
            align-items: center;
            font-size: 14px;
            padding: 5px 10px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #fff;
        }

        .back-button:hover {
            background-color: #f6f8fa;
            border-color: #0366d6;
        }

        .back-button::before {
            content: "←";
            margin-right: 5px;
            font-size: 16px;
        }

        .header .links {
            margin-top: 10px;
            font-size: 16px;
        }

        .header .links a {
            color: #0366d6;
            text-decoration: none;
            margin-left: 5px;
        }

        .header .links a:hover {
            text-decoration: underline;
        }
        
        /* Language badges styles */
        .language-badges {
            margin-top: 15px;
            text-align: center;
        }
        .language-badges a {
            display: inline-block;
            margin: 2px;
            text-decoration: none;
        }
        .language-badges img {
            height: 20px;
            border-radius: 3px;
        }
        .language-badges a:hover img {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div class="header">
        <a href="javascript:history.back()" class="back-button">Back</a>
        <div class="links">
            GitHub Repository: <a href="https://github.com/Cysharp/MemoryPack" id="githubRepoLink" target="_blank">Cysharp/MemoryPack</a>
        </div>
        <div class="language-badges" id="languageBadges"><a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=en"><img src="https://img.shields.io/badge/EN-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-CN"><img src="https://img.shields.io/badge/简中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-TW"><img src="https://img.shields.io/badge/繁中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ja"><img src="https://img.shields.io/badge/日本語-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ko"><img src="https://img.shields.io/badge/한국어-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=th"><img src="https://img.shields.io/badge/ไทย-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=fr"><img src="https://img.shields.io/badge/Français-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=de"><img src="https://img.shields.io/badge/Deutsch-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=es"><img src="https://img.shields.io/badge/Español-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=it"><img src="https://img.shields.io/badge/Italiano-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ru"><img src="https://img.shields.io/badge/Русский-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pt"><img src="https://img.shields.io/badge/Português-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=nl"><img src="https://img.shields.io/badge/Nederlands-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pl"><img src="https://img.shields.io/badge/Polski-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ar"><img src="https://img.shields.io/badge/العربية-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=tr"><img src="https://img.shields.io/badge/Türkçe-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=vi"><img src="https://img.shields.io/badge/Tiếng Việt-white" alt="version"></a></div>
    </div>

    <div class="main-container">
        <div class="markdown-body" id="content"><h1>MemoryPack</h1>
<p><a href="https://www.nuget.org/packages/MemoryPack"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a><br><a href="https://github.com/Cysharp/MemoryPack/actions"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a><br><a href="https://github.com/Cysharp/MemoryPack/releases"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p>
<p>Zero encoding extreme performance binary serializer voor C# en Unity.</p>
<p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p>
<blockquote>
<p>In vergelijking met <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/">Orleans.Serialization</a>. Gemeten op .NET 7 / Ryzen 9 5950X machine. Deze serializers hebben een <code>IBufferWriter&lt;byte&gt;</code> methode, geserialiseerd met <code>ArrayBufferWriter&lt;byte&gt;</code> en hergebruikt om buffer kopiëren te vermijden.</p>
</blockquote>
<p>Voor standaard objecten is MemoryPack x10 sneller en x2 ~ x5 sneller dan andere binaire serializers. Voor struct arrays is MemoryPack zelfs nog krachtiger, met snelheden tot x50 ~ x200 hoger dan andere serializers.</p>
<p>MemoryPack is mijn 4e serializer. Hiervoor heb ik bekende serializers gemaakt, <del><a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a></del>, <del><a href="https://github.com/neuecc/Utf8Json">Utf8Json</a></del>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>. De reden voor de snelheid van MemoryPack is het C#-specifieke, voor C# geoptimaliseerde binaire formaat en een goed afgestemde implementatie gebaseerd op mijn eerdere ervaring. Het is ook een compleet nieuw ontwerp dat gebruik maakt van .NET 7 en C# 11 en de Incremental Source Generator (.NET Standard 2.1 (.NET 5, 6) en er is ook Unity-ondersteuning).</p>
<p>Andere serializers voeren veel coderingsbewerkingen uit zoals VarInt-codering, tags, string, enz. Het MemoryPack-formaat gebruikt een zero-encoding ontwerp dat zoveel mogelijk C#-geheugen kopieert. Zero-encoding lijkt op FlatBuffers, maar heeft geen speciaal type nodig, het serialisatiedoel van MemoryPack is POCO.</p>
<p>Naast prestaties heeft MemoryPack de volgende functies.</p>
<ul>
<li>Ondersteunt moderne I/O-API's (<code>IBufferWriter&lt;byte&gt;</code>, <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>)</li>
<li>Native AOT-vriendelijke Source Generator gebaseerde codegeneratie, geen Dynamic CodeGen (IL.Emit)</li>
<li>Reflectievrije niet-generieke API's</li>
<li>Deserialiseren in een bestaand instantie</li>
<li>Polymorfe (Union) serialisatie</li>
<li>Beperkt versie-tolerant (snel/standaard) en volledige versie-tolerante ondersteuning</li>
<li>Serialisatie van circulaire referenties</li>
<li>PipeWriter/Reader gebaseerde streaming serialisatie</li>
<li>TypeScript codegeneratie en ASP.NET Core Formatter</li>
<li>Unity (2021.3) IL2CPP-ondersteuning via .NET Source Generator</li>
</ul>
<h2>Installatie</h2>
<p>Deze bibliotheek wordt verspreid via NuGet. Voor de beste prestaties wordt <code>.NET 7</code> aanbevolen. De minimale vereiste is <code>.NET Standard 2.1</code>.</p>
<blockquote>
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/MemoryPack">MemoryPack</a></p>
</blockquote>
<p>Daarnaast vereist een code-editor Roslyn 4.3.1 ondersteuning, bijvoorbeeld Visual Studio 2022 versie 17.3, .NET SDK 6.0.401. Zie voor details het <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support">Roslyn Version Support</a> document.</p>
<p>Voor Unity zijn de vereisten en het installatieproces volledig anders. Zie de <a href="#unity">Unity</a> sectie voor details.</p>
<h2>Snelle start</h2>
<p>Definieer een struct of klasse om te serialiseren en annoteer deze met het <code>[MemoryPackable]</code> attribuut en het <code>partial</code> sleutelwoord.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack;

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Serialisatiecode wordt gegenereerd door de C# source generator functionaliteit, die de <code>IMemoryPackable&lt;T&gt;</code> interface implementeert. In Visual Studio kun je de gegenereerde code bekijken door de sneltoets <code>Ctrl+K, R</code> te gebruiken op de klassenaam en <code>*.MemoryPackFormatter.g.cs</code> te selecteren.</p>
<p>Roep <code>MemoryPackSerializer.Serialize&lt;T&gt;/Deserialize&lt;T&gt;</code> aan om een objectinstantie te serialiseren/deserialiseren.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Person { Age = <span class="hljs-number">40</span>, Name = <span class="hljs-string">"John"</span> };

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(v);
<span class="hljs-keyword">var</span> val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p>De <code>Serialize</code>-methode ondersteunt een returntype van <code>byte[]</code> evenals serialisatie naar <code>IBufferWriter&lt;byte&gt;</code> of <code>Stream</code>. De <code>Deserialize</code>-methode ondersteunt <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code> en <code>Stream</code>. Er zijn ook niet-generieke versies.</p>
<h2>Standaard ondersteunde types</h2>
<p>Deze types kunnen standaard worden geserialiseerd:</p>
<ul>
<li>.NET-primitieven (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, etc.)</li>
<li>Unmanaged types (Elke <code>enum</code>, elke door de gebruiker gedefinieerde <code>struct</code> zonder referentietypes)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code> <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory&lt;&gt;</code>, <code>ReadOnlyMemory&lt;&gt;</code>, <code>ArraySegment&lt;&gt;</code>, <code>ReadOnlySequence&lt;&gt;</code></li>
<li><code>Nullable&lt;&gt;</code>, <code>Lazy&lt;&gt;</code>, <code>KeyValuePair&lt;,&gt;</code>, <code>Tuple&lt;,...&gt;</code>, <code>ValueTuple&lt;,...&gt;</code></li>
<li><code>List&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>SortedSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code></li>
<li><code>Dictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>,  <code>ReadOnlyDictionary&lt;,&gt;</code> </li>
<li><code>Collection&lt;&gt;</code>, <code>ReadOnlyCollection&lt;&gt;</code>, <code>ObservableCollection&lt;&gt;</code>, <code>ReadOnlyObservableCollection&lt;&gt;</code></li>
<li><code>IEnumerable&lt;&gt;</code>, <code>ICollection&lt;&gt;</code>, <code>IList&lt;&gt;</code>, <code>IReadOnlyCollection&lt;&gt;</code>, <code>IReadOnlyList&lt;&gt;</code>, <code>ISet&lt;&gt;</code></li>
<li><code>IDictionary&lt;,&gt;</code>, <code>IReadOnlyDictionary&lt;,&gt;</code>, <code>ILookup&lt;,&gt;</code>, <code>IGrouping&lt;,&gt;</code>,</li>
<li><code>ConcurrentBag&lt;&gt;</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>, <code>BlockingCollection&lt;&gt;</code></li>
<li>Immutable collecties (<code>ImmutableList&lt;&gt;</code>, etc.) en interfaces (<code>IImmutableList&lt;&gt;</code>, etc.)</li>
</ul>
<h2>Definieer <code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code></h2>
<p><code>[MemoryPackable]</code> kan worden geannoteerd op elke <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> en <code>interface</code>. Als een type een <code>struct</code> of <code>record struct</code> is die geen referentietypes bevat (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>), wordt extra annotatie (ignore, include, constructor, callbacks) niet gebruikt; deze worden direct uit het geheugen geserialiseerd/gedeserialiseerd.</p>
<p>Anders serialiseert <code>[MemoryPackable]</code> standaard de publieke instantie-eigenschappen of velden. Je kunt <code>[MemoryPackIgnore]</code> gebruiken om een serialisatiedoel te verwijderen, <code>[MemoryPackInclude]</code> promoot een privé-lid tot serialisatiedoel.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// deze types worden standaard geserialiseerd</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicField;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> PublicReadOnlyField;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PrivateSetPublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ReadOnlyPublicProperty { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> RequiredInitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }

    <span class="hljs-comment">// deze types worden standaard niet geserialiseerd</span>
    <span class="hljs-built_in">int</span> privateProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-built_in">int</span> privateField;
    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> privateReadOnlyField;

    <span class="hljs-comment">// gebruik [MemoryPackIgnore] om een publiek lid uit te sluiten van serialisatie</span>
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty2 =&gt; PublicProperty + PublicField;

    <span class="hljs-comment">// gebruik [MemoryPackInclude] om een privé-lid te promoten tot serialisatiedoel</span>
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateField2;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>De codegenerator van <code>MemoryPack</code> voegt informatie toe over welke leden worden geserialiseerd aan de <code>&lt;remarks /&gt;</code> sectie. Dit kan worden bekeken door met Intellisense over het type te zweven.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p>
<p>Alle leden moeten memorypack-serialiseerbaar zijn, zo niet dan zal de codegenerator een foutmelding geven.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p>
<p>MemoryPack heeft 35 diagnosticaregels (<code>MEMPACK001</code> tot <code>MEMPACK035</code>) om comfortabel te definiëren.</p>
<p>Als een doeltijdstype extern MemoryPack-serialisatie heeft en geregistreerd is, gebruik dan <code>[MemoryPackAllowSerialize]</code> om diagnostics te onderdrukken.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample2</span>
{
    [<span class="hljs-meta">MemoryPackAllowSerialize</span>]
    <span class="hljs-keyword">public</span> NotSerializableType? NotSerializableProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>De volgorde van leden is <strong>belangrijk</strong>. MemoryPack serialiseert niet de ledennaam of andere informatie, maar serialiseert velden in de volgorde waarin ze zijn gedeclareerd. Als een type is overgeërfd, gebeurt serialisatie in de volgorde ouder → kind. De volgorde van leden mag niet veranderen voor de deserialisatie. Zie voor schema-evolutie de <a href="#version-tolerant">Version tolerant</a> sectie.</p>
<p>De standaardvolgorde is sequentieel, maar je kunt een expliciete layout kiezen met <code>[MemoryPackable(SerializeLayout.Explicit)]</code> en <code>[MemoryPackOrder()]</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// serialiseer Prop0 -&gt; Prop1</span>
[<span class="hljs-meta">MemoryPackable(SerializeLayout.Explicit)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleExplicitOrder</span>
{
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h3>Constructorselectie</h3>
<p>MemoryPack ondersteunt zowel geparametriseerde als parameterloze constructors. De selectie van de constructor volgt deze regels (geldt voor klassen en structs):</p>
<ul>
<li>Als er een <code>[MemoryPackConstructor]</code> is, wordt deze gebruikt.</li>
<li>Als er geen expliciete constructor is (inclusief privé), wordt een parameterloze gebruikt.</li>
<li>Als er één parameterloze/geparametriseerde constructor is (inclusief privé), wordt deze gebruikt.</li>
<li>Als er meerdere constructors zijn, dan moet het <code>[MemoryPackConstructor]</code> attribuut worden toegepast op de gewenste constructor (de generator kiest niet automatisch), anders geeft de generator een foutmelding.</li>
<li>Bij gebruik van een geparametriseerde constructor moeten alle parameternamen overeenkomen met de corresponderende ledennamen (hoofdletterongevoelig).</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Name;

    <span class="hljs-comment">// Je kunt een geparametriseerde constructor gebruiken - parameternamen moeten overeenkomen met de corresponderende ledennaam (hoofdletterongevoelig)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Age = age;
        <span class="hljs-keyword">this</span>.Name = name;
    }
}

<span class="hljs-comment">// ondersteunt ook record primary constructor</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Person2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Age, <span class="hljs-built_in">string</span> Name</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>()</span>
    {
    }
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Als er meerdere constructors zijn, dan moet [MemoryPackConstructor] gebruikt worden</span>
[<span class="hljs-meta">MemoryPackConstructor</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
{
    <span class="hljs-keyword">this</span>.Age = age;
    <span class="hljs-keyword">this</span>.Name = name;
}
</code></pre>
<h3>Serialisatie-callbacks</h3>
<p>Bij serialiseren/deserialiseren kan MemoryPack een before/after event aanroepen met behulp van de attributen <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. Deze kunnen zowel statische als instantie (niet-statische) methoden annoteren, en zowel publieke als private methoden.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MethodCallSample</span>
{
    <span class="hljs-comment">// aanroepvolgorde van de methoden is statisch -&gt; instantie</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing1));
    }

    <span class="hljs-comment">// private methode is ook toegestaan</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing2));
    }

    <span class="hljs-comment">// serializing -&gt; /* serialize */ -&gt; serialized</span>
    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized1));
    }

    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing1));
    }

    <span class="hljs-comment">// Let op: instantie-methode met MemoryPackOnDeserializing wordt niet aangeroepen als instantie niet via `ref` is meegegeven</span>
    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized1));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized2));
    }
}
</code></pre>
<p>Callbacks staan parameterloze methoden en <code>ref reader/writer, ref T value</code> methoden toe. Bijvoorbeeld, ref callbacks kunnen een custom header schrijven/uitlezen vóór het serialisatieproces.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EmitIdData</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteId</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)
        <span class="hljs-keyword">where</span> TBufferWriter : IBufferWriter&lt;<span class="hljs-built_in">byte</span>&gt; <span class="hljs-comment">// .NET Standard 2.1, gebruik where TBufferWriter : class, IBufferWriter&lt;byte&gt;</span></span>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); <span class="hljs-comment">// schrijf GUID in de header.</span>
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadId</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-comment">// lees custom header vóór deserialisatie</span>
        <span class="hljs-keyword">var</span> guid = reader.ReadUnmanaged&lt;Guid&gt;();
        Console.WriteLine(guid);
    }
}
</code></pre>
<p>Als je een waarde toekent aan <code>ref value</code>, kun je de waarde wijzigen die wordt gebruikt voor serialisatie/deserialisatie. Bijvoorbeeld, instantieren vanuit een ServiceProvider.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// voor je deze formatter gebruikt, stel ServiceProvider in</span>
<span class="hljs-comment">// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };</span>
<span class="hljs-comment">// MemoryPackSerializer.Deserialize(value, options);</span>

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InstantiateFromServiceProvider</span>
{
    <span class="hljs-keyword">static</span> IServiceProvider serviceProvider = <span class="hljs-literal">default</span>!;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> InstantiateFromServiceProvider <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">value</span> = reader.Options.ServiceProvider!.GetRequiredService&lt;InstantiateFromServiceProvider&gt;();
    }
}
</code></pre>
<h2>Definieer een custom collectie</h2>
<p>Standaard probeert een met <code>[MemoryPackObject]</code> geannoteerd type zijn members te serialiseren. Echter, als een type een collectie is (<code>ICollection&lt;&gt;</code>, <code>ISet&lt;&gt;</code>, <code>IDictionary&lt;,&gt;</code>), gebruik dan <code>GenerateType.Collection</code> om het correct te serialiseren.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt;
{
}

[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyStringDictionary</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>&gt;
{

}
</code></pre>
<h2>Statische constructor</h2>
<p>Een MemoryPackable class kan geen statische constructor definiëren omdat de gegenereerde partial class deze gebruikt. In plaats daarvan kun je een <code>static partial void StaticConstructor()</code> definiëren om hetzelfde te bereiken.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CctorSample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StaticConstructor</span>()</span>
    {
    }
}
</code></pre>
<h2>Polymorfisme (Union)</h2>
<p>MemoryPack ondersteunt het serialiseren van interface- en abstracte klasse-objecten voor polymorfe serialisatie. In MemoryPack wordt deze functie Union genoemd. Alleen interfaces en abstracte klassen mogen worden geannoteerd met <code>[MemoryPackUnion]</code> attributen. Unieke union-tags zijn vereist.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Annoteer [MemoryPackable] en afgeleide types met [MemoryPackUnion]</span>
<span class="hljs-comment">// Union ondersteunt ook abstracte klassen</span>
[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> XYZ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BarClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? OPQ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
<span class="hljs-comment">// ---</span>

IUnionSample data = <span class="hljs-keyword">new</span> FooClass() { XYZ = <span class="hljs-number">999</span> };

<span class="hljs-comment">// Serialize als interface type.</span>
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(data);

<span class="hljs-comment">// Deserialize als interface type.</span>
<span class="hljs-keyword">var</span> reData = MemoryPackSerializer.Deserialize&lt;IUnionSample&gt;(bin);

<span class="hljs-keyword">switch</span> (reData)
{
    <span class="hljs-keyword">case</span> FooClass x:
        Console.WriteLine(x.XYZ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BarClass x:
        Console.WriteLine(x.OPQ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-literal">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p><code>tag</code> staat waarden toe van <code>0</code> ~ <code>65535</code>, het is vooral efficiënt voor minder dan <code>250</code>.</p>
<pre><code class="hljs language-kotlin">Als een <span class="hljs-keyword">interface</span> <span class="hljs-title class_">en</span> <span class="hljs-title">afgeleide</span> <span class="hljs-title">typen</span> <span class="hljs-title">zich</span> <span class="hljs-title">in</span> <span class="hljs-title">verschillende</span> <span class="hljs-title">assemblies</span> <span class="hljs-title">bevinden</span>, <span class="hljs-type">kun</span> <span class="hljs-title">je</span> <span class="hljs-title">in</span> <span class="hljs-title">plaats</span> <span class="hljs-title">daarvan</span> `<span class="hljs-title">MemoryPackUnionFormatterAttribute</span>` <span class="hljs-title">gebruiken</span>. <span class="hljs-title">Formatters</span> <span class="hljs-title">worden</span> <span class="hljs-title">zo</span> <span class="hljs-title">gegenereerd</span> <span class="hljs-title">dat</span> <span class="hljs-title">ze</span> <span class="hljs-title">automatisch</span> <span class="hljs-title">worden</span> <span class="hljs-title">geregistreerd</span> <span class="hljs-title">via</span> `<span class="hljs-title">ModuleInitializer</span>` <span class="hljs-title">in</span> <span class="hljs-title">C</span># 9.0 <span class="hljs-title">en</span> <span class="hljs-title">hoger</span>.

&gt; Let op: `ModuleInitializer` wordt niet ondersteund <span class="hljs-keyword">in</span> Unity, dus de formatter moet handmatig worden geregistreerd. Om je union formatter te registreren, roep je `{naam van je union formatter}Initializer.RegisterFormatter()` handmatig aan <span class="hljs-keyword">in</span> Startup. Bijvoorbeeld `UnionSampleFormatterInitializer.RegisterFormatter()`.

```csharp
<span class="hljs-comment">// AssemblyA</span>
[MemoryPackable(GenerateType.NoGenerate)]
<span class="hljs-keyword">public</span> partial <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUnionSample</span>
{
}

<span class="hljs-comment">// AssemblyB definieer de definitie buiten het doeldtype</span>
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(<span class="hljs-number">0</span>, typeof(FooClass))]
[MemoryPackUnion(<span class="hljs-number">1</span>, typeof(BarClass))]
<span class="hljs-keyword">public</span> partial <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionSampleFormatter</span>
{
}
</code></pre>
<p>Union kan in code worden samengesteld via <code>DynamicUnionFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// (ushort, Type)[]</span>
<span class="hljs-keyword">var</span> formatter = <span class="hljs-keyword">new</span> DynamicUnionFormatter&lt;IFooBarBaz&gt;(
    (<span class="hljs-number">0</span>, <span class="hljs-keyword">typeof</span>(Foo)),
    (<span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(Bar)),
    (<span class="hljs-number">2</span>, <span class="hljs-keyword">typeof</span>(Baz))
);

MemoryPackFormatterProvider.Register(formatter);
</code></pre>
<h2>Serialize API</h2>
<p><code>Serialize</code> heeft drie overloads.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Niet-generieke API is ook beschikbaar, bij deze versies is het eerste argument Type en de waarde object?</span>
<span class="hljs-function"><span class="hljs-built_in">byte</span>[] <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> TBufferWriter bufferWriter, <span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
</span></code></pre>
<p>Voor prestaties wordt de aanbevolen API met <code>BufferWriter</code> gebruikt. Dit serialiseert direct in de buffer. Het kan worden toegepast op <code>PipeWriter</code> in <code>System.IO.Pipelines</code>, <code>BodyWriter</code> in ASP .NET Core, enzovoort.</p>
<p>Als een <code>byte[]</code> vereist is (bijv. <code>RedisValue</code> in <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>), is de teruggegeven <code>byte[]</code> API eenvoudig en bijna net zo snel.</p>
<p>Let op dat <code>SerializeAsync</code> voor <code>Stream</code> alleen asynchroon is voor Flush; het serialiseert alles in één keer in de interne poolbuffer van MemoryPack en schrijft vervolgens met <code>WriteAsync</code>. Daarom is de <code>BufferWriter</code> overload, die buffer en flush scheidt en beheert, beter.</p>
<p>Als je volledig streaming wilt schrijven, zie de sectie <a href="#streaming-serialization">Streaming Serialization</a>.</p>
<h3>MemoryPackSerializerOptions</h3>
<p><code>MemoryPackSerializerOptions</code> configureert of strings als UTF16 of UTF8 worden geserialiseerd. Dit kan worden geconfigureerd door <code>MemoryPackSerializerOptions.Utf8</code> door te geven voor UTF8-codering, <code>MemoryPackSerializerOptions.Utf16</code> voor UTF16-codering, of <code>MemoryPackSerializerOptions.Default</code> wat standaard op UTF8 staat. Null doorgeven of de standaardparameter gebruiken resulteert in UTF8-codering.</p>
<p>Aangezien de interne stringrepresentatie van C# UTF16 is, presteert UTF16 beter. Echter, de payload is meestal groter; in UTF8 is een ASCII-string één byte, terwijl deze in UTF16 twee bytes is. Omdat het verschil in grootte van deze payload zo groot is, wordt standaard UTF8 gebruikt.</p>
<p>Als de data niet-ASCII is (bijv. Japans, wat meer dan 3 bytes kan zijn, en UTF8 is dan groter), of als je het apart moet comprimeren, kan UTF16 betere resultaten geven.</p>
<p>Hoewel tijdens serialisatie kan worden gekozen voor UTF8 of UTF16, is het niet nodig om dit tijdens deserialisatie te specificeren. Het wordt automatisch gedetecteerd en normaal gedeserialiseerd.</p>
<p>Daarnaast kun je <code>IServiceProvider? ServiceProvider { get; init; }</code> uit de opties krijgen/instellen. Dit is handig om een DI-object (zoals <code>ILogger&lt;T&gt;</code>) te verkrijgen tijdens het serialisatieproces (<code>MemoryPackReader/MemoryPackWriter</code> heeft een .Options property).</p>
<h2>Deserialize API</h2>
<p><code>Deserialize</code> heeft overloads voor <code>ReadOnlySpan&lt;byte&gt;</code> en <code>ReadOnlySequence&lt;byte&gt;</code>, <code>Stream</code> en <code>ref</code> ondersteuning.</p>
<pre><code class="language-csharp hljs">T? Deserialize&lt;T&gt;(ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer)
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
T? <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer</span>)
<span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
<span class="hljs-keyword">async</span> <span class="hljs-title">ValueTask</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream</span>)
</span></code></pre>
<p>De <code>ref</code> overload overschrijft een bestaande instantie, zie voor details de <a href="#overwrite">Overwrite</a> sectie.</p>
<p><code>DeserializeAsync(Stream)</code> is geen volledige streaming read-operatie; eerst wordt tot het einde van de stream gelezen in de interne pool van MemoryPack, daarna wordt gedeserialiseerd.</p>
<p>Als je een volledige streaming read-operatie wilt uitvoeren, zie de sectie <a href="#streaming-serialization">Streaming Serialization</a>.</p>
<h2>Overwrite</h2>
<p>Om allocaties te verminderen ondersteunt MemoryPack deserialisatie naar een bestaande instantie, waarbij deze wordt overschreven. Dit kan met de overload <code>Deserialize(ref T? value)</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(person);

<span class="hljs-comment">// overschrijf data naar bestaande instantie.</span>
MemoryPackSerializer.Deserialize(bin, <span class="hljs-keyword">ref</span> person);
</code></pre>
<p>MemoryPack zal proberen zoveel mogelijk te overschrijven, maar als aan de volgende voorwaarden niet wordt voldaan, wordt er een nieuwe instantie aangemaakt (zoals bij normale deserialisatie).</p>
<ul>
<li>ref waarde (inclusief leden in het objectgrafiek) is null, stel een nieuwe instantie in</li>
<li>alleen parameterloze constructor toegestaan, als een constructor met parameters wordt gebruikt, wordt een nieuwe instantie gemaakt</li>
<li>als waarde <code>T[]</code> is, alleen hergebruiken als de lengte gelijk is, anders een nieuwe instantie maken</li>
<li>als waarde een collectie is die een <code>.Clear()</code> methode heeft (<code>List&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentBag&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>) wordt Clear() aangeroepen en wordt deze hergebruikt, anders wordt een nieuwe instantie aangemaakt</li>
</ul>
<h2>Version tolerant</h2>
<p>Standaard (<code>GenerateType.Object</code>) ondersteunt MemoryPack beperkte schema-evolutie.</p>
<ul>
<li>unmanaged struct kan niet meer worden gewijzigd</li>
<li>leden kunnen worden toegevoegd, maar niet verwijderd</li>
<li>lidnaam kan worden gewijzigd</li>
<li>ledenvolgorde kan niet worden gewijzigd</li>
<li>lidtype kan niet worden gewijzigd</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Toevoegen is OK.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? AddedProp { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Verwijderen is NG.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-comment">// public int Prop1 { get; set; }</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Volgorde wijzigen is NG.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>In het gebruiksgeval, oude data opslaan (naar bestand, naar redis, etc...) en lezen naar nieuw schema is altijd oké. In het RPC-scenario bestaat het schema zowel aan de client- als aan de serverzijde; de client moet vóór de server worden bijgewerkt. Een bijgewerkte client kan zonder problemen verbinding maken met de oude server, maar een oude client kan niet verbinden met een nieuwe server.</p>
<p>Standaard, wanneer oude data wordt gelezen naar een nieuw schema, worden leden die niet aan de datazijde staan geïnitialiseerd met het <code>default</code> literal.<br>Als je dit wilt vermijden en de initiële waarden van velden/properties wilt gebruiken, kun je <code>[SuppressDefaultInitialization]</code> gebruiken.</p>
<pre><code class="language-cs hljs language-csharp">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DefaultValue</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">SuppressDefaultInitialization</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">111</span>; <span class="hljs-comment">// &lt; als oude data ontbreekt, wordt `111` gezet.</span>
    
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">222</span>; <span class="hljs-comment">// &lt; als oude data ontbreekt, wordt `default` gezet.</span>
}
</code></pre>
<p> <code>[SuppressDefaultInitialization]</code> heeft de volgende beperking:</p>
<ul>
<li>Kan niet worden gebruikt met readonly, init-only en required modifier.</li>
</ul>
<p>De volgende <a href="#serialization-info">Serialization info</a> sectie laat zien hoe je kunt controleren op schemawijzigingen, bijvoorbeeld met CI, om ongelukken te voorkomen.</p>
<p>Bij gebruik van <code>GenerateType.VersionTolerant</code> wordt volledige versie-tolerantie ondersteund.</p>
<ul>
<li>unmanaged struct kan niet meer worden gewijzigd</li>
<li>alle leden moeten expliciet <code>[MemoryPackOrder]</code> krijgen (behalve als <code>SerializeLayout.Sequential</code> is geannoteerd)</li>
<li>leden kunnen worden toegevoegd, verwijderd, maar volgorde niet hergebruiken (wel ontbrekende volgorde gebruiken)</li>
<li>lidnaam kan worden gewijzigd</li>
<li>ledenvolgorde kan niet worden gewijzigd</li>
<li>lidtype kan niet worden gewijzigd</li>
</ul>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Ok om te serialiseren/deserialiseren beide </span>
<span class="hljs-comment">// VersionTolerantObject1 -&gt; VersionTolerantObject2 en </span>
<span class="hljs-comment">// VersionTolerantObject2 -&gt; VersionTolerantObject1</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject1</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject2</span>
{
```csharp
[<span class="hljs-meta">MemoryPackOrder(0)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// verwijderd</span>
<span class="hljs-comment">//[MemoryPackOrder(1)]</span>
<span class="hljs-comment">//public long MyProperty1 { get; set; } = default;</span>

[<span class="hljs-meta">MemoryPackOrder(2)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// toegevoegd</span>
[<span class="hljs-meta">MemoryPackOrder(3)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Indien SerializeLayout.Sequential expliciet is ingesteld, wordt automatische ordening toegestaan.</span>
<span class="hljs-comment">// Maar het is niet mogelijk om leden te verwijderen voor versie-tolerantie.</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<p><code>GenerateType.VersionTolerant</code> is langzamer dan <code>GenerateType.Object</code> bij het serialiseren. Ook zal de payload-grootte iets groter zijn.</p>
<h2>Serialisatie-informatie</h2>
<p>Je kunt via IntelliSense in het type zien welke leden worden geserialiseerd. Er is een optie om deze informatie tijdens het compileren naar een bestand te schrijven. Stel <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> als volgt in.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- output memorypack serialisatie-info naar een map --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_SerializationInfoOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\MemoryPackLogs<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>De volgende informatie wordt naar het bestand geschreven.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p>
<p>Als het type unmanaged is, wordt <code>unmanaged</code> vóór de typenaam weergegeven.</p>
<pre><code class="language-txt hljs language-plaintext">unmanaged FooStruct
---
int x
int y
</code></pre>
<p>Door de verschillen in dit bestand te controleren, kunnen gevaarlijke schemawijzigingen worden voorkomen. Bijvoorbeeld, je kunt CI gebruiken om de volgende regels te detecteren</p>
<ul>
<li>wijziging van unmanaged type</li>
<li>wijziging van ledenvolgorde</li>
<li>verwijderen van leden</li>
</ul>
<h2>Circulaire Referentie</h2>
<p>MemoryPack ondersteunt ook circulaire referenties. Dit maakt het mogelijk om boomstructuren als zodanig te serialiseren.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// om circulaire referentie mogelijk te maken, gebruik GenerateType.CircularReference</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> Node? Parent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Node[]? Children { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p> Bijvoorbeeld, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references">System.Text.Json preserve-references</a> code wordt dan als volgt.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0</span>
Employee tyler = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Tyler Stein"</span>
};

Employee adrian = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Adrian King"</span>
};

tyler.DirectReports = <span class="hljs-keyword">new</span> List&lt;Employee&gt; { adrian };
adrian.Manager = tyler;

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize&lt;Employee&gt;(bin);

Console.WriteLine(tylerDeserialized?.DirectReports?[<span class="hljs-number">0</span>].Manager == tylerDeserialized); <span class="hljs-comment">// true</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Employee? Manager { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> List&lt;Employee&gt;? DirectReports { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>GenerateType.CircularReference</code> heeft dezelfde eigenschappen als versie-tolerant. Echter, als extra beperking zijn alleen parameterloze constructors toegestaan. Ook wordt object-referentie-tracking alleen gedaan voor objecten gemarkeerd met <code>GenerateType.CircularReference</code>. Als je een ander object wilt volgen, wikkel het dan in.</p>
<h2>CustomFormatter</h2>
<p>Als je <code>MemoryPackCustomFormatterAttribute&lt;T&gt;</code> of <code>MemoryPackCustomFormatterAttribute&lt;TFormatter, T&gt;</code> implementeert (presteert beter, maar complexer), kun je een custom formatter configureren voor een lid van een MemoryPackObject.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Attribute</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> IMemoryPackFormatter&lt;T&gt; <span class="hljs-title">GetFormatter</span>()</span>;
}
</code></pre>
<p>MemoryPack biedt de volgende formatter-attributen: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute&lt;TValue&gt;</code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter&lt;T&gt;</code>, <code>MemoryPoolFormatter&lt;T&gt;</code>, <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// serialiseer dit lid als UTF16 String, het is sneller dan UTF8 maar in ASCII is de grootte groter (maar voor niet-ASCII soms kleiner).</span>
    [<span class="hljs-meta">Utf16StringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Text { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment">// Bij deserialisatie wordt Dictionary geïnitialiseerd met StringComparer.OrdinalIgnoreCase.</span>
    [<span class="hljs-meta">OrdinalIgnoreCaseStringDictionaryFormatter&lt;int&gt;</span>]
    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;? Ids { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    
    <span class="hljs-comment">// Tijdens deserialisatie worden alle strings geïnterneerd (zie: String.Intern). Als vergelijkbare waarden vaak voorkomen, bespaart dit geheugen.</span>
    [<span class="hljs-meta">InternStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Flag { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Om een gelijkheidscomparer voor een set/dictionary te configureren, hebben alle ingebouwde formatters een comparer-constructor overload. Je kunt eenvoudig aangepaste gelijkheidscomparer-formatters maken.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OrdinalIgnoreCaseStringDictionaryFormatter</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>?&gt;&gt;
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt; formatter = <span class="hljs-keyword">new</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt;(StringComparer.OrdinalIgnoreCase);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> IMemoryPackFormatter&lt;Dictionary&lt;<span class="hljs-built_in">string</span>, TValue?&gt;&gt; GetFormatter()
    {
        <span class="hljs-keyword">return</span> formatter;
    }
}
</code></pre>
<p><code>BitPackFormatter</code> comprimeert alleen <code>bool[]</code> types. <code>bool[]</code> wordt normaal geserialiseerd als 1 byte per boolean waarde, maar <code>BitPackFormatter</code> serialiseert <code>bool[]</code> zoals een <code>BitArray</code> waarbij elke bool als 1 bit wordt opgeslagen. Door <code>BitPackFormatter</code> te gebruiken, worden 8 booleans 1 byte, terwijl dat normaal 8 bytes zou zijn, wat resulteert in een 8x kleinere grootte.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BitPackFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[]? Data { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter</code> is voor <code>byte[]</code>, bijvoorbeeld kun je met Brotli een grote payload comprimeren.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliStringFormatter</code> is voor <code>string</code>, serialiseer gecomprimeerde string (UTF16) met Brotli.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? LargeText { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter&lt;T&gt;</code> is voor elk type, seriële data gecomprimeerd door Brotli. Als een type <code>byte[]</code> of <code>string</code> is, kun je voor de prestaties beter <code>BrotliFormatter</code> of <code>BrotliStringFormatter</code> gebruiken.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter&lt;ChildType&gt;</span>]
    <span class="hljs-keyword">public</span> ChildType? Child { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>Deserialiseren met array pooling</h2>
<p>Om een grote array (elke <code>T</code>) te deserialiseren, biedt MemoryPack meerdere efficiënte pooling-methoden. De meest effectieve manier is om de <a href="#overwrite">#Overwrite</a> functie te gebruiken. In het bijzonder wordt <code>List&lt;T&gt;</code> altijd hergebruikt.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ListBytesSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">byte</span>&gt; Payload</span> { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// ----</span>

<span class="hljs-comment">// List&lt;byte&gt; wordt hergebruikt, geen allocatie bij deserialiseren.</span>
MemoryPackSerializer.Deserialize&lt;ListBytesSample&gt;(bin, <span class="hljs-keyword">ref</span> reuseObject);

<span class="hljs-comment">// voor efficiënte bewerking kun je Span&lt;T&gt; krijgen via CollectionsMarshal</span>
<span class="hljs-keyword">var</span> span = CollectionsMarshal.AsSpan(<span class="hljs-keyword">value</span>.Payload);
</code></pre>
<p>Een handige manier is deserialiseren naar een ArrayPool op het moment van deserialisatie. MemoryPack biedt <code>MemoryPoolFormatter&lt;T&gt;</code> en <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PoolModelSample</span> : <span class="hljs-title">IDisposable</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; }

    [<span class="hljs-meta">MemoryPoolFormatter&lt;byte&gt;</span>]
    <span class="hljs-keyword">public</span> Memory&lt;<span class="hljs-built_in">byte</span>&gt; Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PoolModelSample</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, Memory&lt;<span class="hljs-built_in">byte</span>&gt; payload</span>)</span>
    {
        Id = id;
        Payload = payload;
    }

    <span class="hljs-comment">// Je moet zelf de return code schrijven, hier een snippet.</span>

    <span class="hljs-built_in">bool</span> usePool;

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized</span>()</span>
    {
        usePool = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span>
    {
        <span class="hljs-keyword">if</span> (!usePool) <span class="hljs-keyword">return</span>;

        Return(Payload); Payload = <span class="hljs-literal">default</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Memory&lt;T&gt; memory</span>)</span> =&gt; Return((ReadOnlyMemory&lt;T&gt;)memory);

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlyMemory&lt;T&gt; memory</span>)</span>
    {
        <span class="hljs-keyword">if</span> (MemoryMarshal.TryGetArray(memory, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> segment) &amp;&amp; segment.Array <span class="hljs-keyword">is</span> { Length: &gt; <span class="hljs-number">0</span> })
        {
            ArrayPool&lt;T&gt;.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;());
        }
    }
}

<span class="hljs-comment">// ---</span>

<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;PoolModelSample&gt;(bin))
{
    <span class="hljs-comment">// doe iets...</span>
}   <span class="hljs-comment">// teruggeven aan ArrayPool</span>
</code></pre>
<h2>Prestaties</h2>
<p>Zie mijn blogpost <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p>
<h2>Payloadgrootte en compressie</h2>
<p>De payloadgrootte hangt af van de doelwaarde; in tegenstelling tot JSON zijn er geen sleutels en het is een binair formaat, dus de payloadgrootte zal waarschijnlijk kleiner zijn dan bij JSON.</p>
<p>Voor formaten met varint-codering, zoals MessagePack en Protobuf, is MemoryPack vaak groter als er veel ints worden gebruikt (in MemoryPack zijn ints altijd 4 bytes vanwege fixed size encoding, terwijl MessagePack 1~5 bytes gebruikt).</p>
<p>float en double zijn 4 bytes en 8 bytes in MemoryPack, maar 5 bytes en 9 bytes in MessagePack. Dus MemoryPack is kleiner, bijvoorbeeld voor Vector3 (float, float, float) arrays.</p>
<p>String is standaard UTF8, wat vergelijkbaar is met andere serializers, maar als de UTF16-optie wordt gekozen, heeft het een ander karakter.</p>
<p>In elk geval, als de payloadgrootte groot is, moet compressie worden overwogen. LZ4, ZStandard en Brotli worden aanbevolen.</p>
<h3>Compressie</h3>
<p>MemoryPack biedt een efficiënte helper voor <a href="https://github.com/google/brotli">Brotli</a> compressie via <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder">BrotliEncoder</a> en <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder">BrotliDecoder</a>. MemoryPack's <code>BrotliCompressor</code> en <code>BrotliDecompressor</code> bieden compressie/decompressie geoptimaliseerd voor het interne gedrag van MemoryPack.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// Compressie (vereist using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> compressor = <span class="hljs-keyword">new</span> BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, <span class="hljs-keyword">value</span>);

<span class="hljs-comment">// Verkrijg gecomprimeerde byte[]</span>
<span class="hljs-keyword">var</span> compressedBytes = compressor.ToArray();

<span class="hljs-comment">// Of schrijf naar een andere IBufferWriter&lt;byte&gt; (bijvoorbeeld PipeWriter)</span>
compressor.CopyTo(response.BodyWriter);
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// Decompressie (vereist using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> decompressor = <span class="hljs-keyword">new</span> BrotliDecompressor();

<span class="hljs-comment">// Verkrijg gedecomprimeerde ReadOnlySequence&lt;byte&gt; van ReadOnlySpan&lt;byte&gt; of ReadOnlySequence&lt;byte&gt;</span>
<span class="hljs-keyword">var</span> decompressedBuffer = decompressor.Decompress(buffer);

<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;T&gt;(decompressedBuffer);
</code></pre>
<p>Zowel <code>BrotliCompressor</code> als <code>BrotliDecompressor</code> zijn structs, ze alloceren geen geheugen op de heap. Beide slaan gecomprimeerde of gedecomprimeerde data op in een interne geheugenpool voor Serialize/Deserialize. Daarom is het noodzakelijk om het geheugengebruik vrij te geven; vergeet niet om <code>using</code> te gebruiken.</p>
<p>Het compressieniveau is erg belangrijk. De standaardwaarde is ingesteld op quality-1 (CompressionLevel.Fastest), wat anders is dan de .NET-standaard (CompressionLevel.Optimal, quality-4).</p>
<p>Fastest (quality-1) is qua snelheid vergelijkbaar met <a href="https://github.com/lz4/lz4">LZ4</a>, maar 4 is veel langzamer. Dit is cruciaal bevonden in het serializer-gebruiksscenario. Wees voorzichtig bij het gebruik van de standaard <code>BrotliStream</code> (quality-4 is de standaard). In elk geval zullen compressie-/decompressiesnelheden en -groottes zeer verschillende resultaten opleveren voor verschillende data. Bereid de data voor die jouw applicatie moet verwerken en test het zelf.</p>
<p>Let op: er is een meervoudige snelheidsstraf tussen MemoryPack's ongecomprimeerde en Brotli's extra compressie.</p>
<p>Brotli wordt ook ondersteund in een custom formatter. Met <code>BrotliFormatter</code> kun je een specifiek lid comprimeren.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>Externe types serialiseren</h2>
<p>Als je externe types wilt serialiseren, kun je een custom formatter maken en deze registreren bij de provider, zie <a href="#formatterprovider-api">Formatter/Provider API</a> voor details. Het maken van een custom formatter is echter moeilijk. Daarom raden we aan een wrappertype te maken. Bijvoorbeeld, als je een extern type wilt serialiseren genaamd <code>AnimationCurve</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">struct</span> SerializableAnimationCurve
{
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimationCurve AnimationCurve;

    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode preWrapMode =&gt; AnimationCurve.preWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode postWrapMode =&gt; AnimationCurve.postWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    Keyframe[] keys =&gt; AnimationCurve.keys;

    [<span class="hljs-meta">MemoryPackConstructor</span>]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        <span class="hljs-keyword">var</span> curve = <span class="hljs-keyword">new</span> AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        <span class="hljs-keyword">this</span>.AnimationCurve = curve;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SerializableAnimationCurve</span>(<span class="hljs-params">AnimationCurve animationCurve</span>)</span>
    {
        <span class="hljs-keyword">this</span>.AnimationCurve = animationCurve;
    }
}
</code></pre>
<p>Het te wrappen type is public, maar uitgesloten van serialisatie (<code>MemoryPackIgnore</code>). De properties die je wilt serialiseren zijn private, maar inbegrepen (<code>MemoryPackInclude</code>). Twee patronen van constructors moeten ook voorbereid zijn. De constructor die door de serializer wordt gebruikt, moet private zijn.</p>
<p>Zoals het nu is, moet het elke keer worden gewrapt, wat onhandig is. En een struct wrapper kan geen null representeren. Laten we dus een custom formatter maken.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimationCurveFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">AnimationCurve</span>&gt;
{
    <span class="hljs-comment">// Unity ondersteunt geen scoped en TBufferWriter, dus wijzig de signature naar `Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)`</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
```csharp
{
    writer.WriteNullObjectHeader();
    <span class="hljs-keyword">return</span>;
}

writer.WritePackable(<span class="hljs-keyword">new</span> SerializableAnimationCurve(<span class="hljs-keyword">value</span>));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (reader.PeekIsNull())
    {
        reader.Advance(<span class="hljs-number">1</span>); <span class="hljs-comment">// skip null block</span>
        <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">var</span> wrapped = reader.ReadPackable&lt;SerializableAnimationCurve&gt;();
    <span class="hljs-keyword">value</span> = wrapped.AnimationCurve;
}
}
</code></pre>
<p>Registreer tenslotte de formatter in startup.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register&lt;AnimationCurve&gt;(<span class="hljs-keyword">new</span> AnimationCurveFormatter());
</code></pre>
<blockquote>
<p>Opmerking: Unity's AnimationCurve is standaard serialiseerbaar, dus deze aangepaste formatter is niet nodig voor AnimationCurve</p>
</blockquote>
<h2>Pakketten</h2>
<p>MemoryPack heeft de volgende pakketten.</p>
<ul>
<li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li>
</ul>
<p><code>MemoryPack</code> is de hoofd bibliotheek en biedt volledige ondersteuning voor hoge prestaties bij serialisatie en deserialisatie van binaire objecten. Het is afhankelijk van <code>MemoryPack.Core</code> voor de kernbibliotheken en van <code>MemoryPack.Generator</code> voor codegeneratie. <code>MemoryPack.Streaming</code> voegt aanvullende extensies toe voor <a href="#streaming-serialization">Streaming Serialization</a>.  <code>MemoryPack.AspNetCoreMvcFormatter</code> voegt input/output formatters toe voor ASP.NET Core. <code>MemoryPack.UnityShims</code> voegt Unity shim types en formatters toe voor gedeeld gebruik van types tussen .NET en Unity.</p>
<h2>TypeScript en ASP.NET Core Formatter</h2>
<p>MemoryPack ondersteunt TypeScript codegeneratie. Het genereert klassen- en serialisatiecode vanuit C#, met andere woorden, je kunt types delen met de browser zonder gebruik te maken van OpenAPI, proto, etc.</p>
<p>Codegeneratie is geïntegreerd met Source Generator, de volgende optie (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) stelt de uitvoermap in voor TypeScript-code. Runtime code wordt gelijktijdig gegenereerd, dus er zijn geen aanvullende afhankelijkheden vereist.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- output memorypack TypeScript-code naar map --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>Een C# MemoryPackable type moet geannoteerd zijn met <code>[GenerateTypeScript]</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">GenerateTypeScript</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> required Guid Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> FirstName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> LastName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required DateTime DateOfBirth { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required Gender Gender { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span>[] Emails { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Gender
{
    Male, Female, Other
}
</code></pre>
<p>Runtime code en TypeScript type worden gegenereerd in de doelmap.</p>
<p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p>
<p>De gegenereerde code ziet er als volgt uit, met eenvoudige velden en statische methoden voor serialize/serializeArray en deserialize/deserializeArray.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackWriter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackWriter.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackReader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackReader.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Gender</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./Gender.js"</span>; 

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">dateOfBirth</span>: <span class="hljs-title class_">Date</span>;
    <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>;
    <span class="hljs-attr">emails</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArray</span>(<span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArrayCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArray</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArrayCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }
}
</code></pre>
<p>Je kunt dit type als volgt gebruiken.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
person.<span class="hljs-property">id</span> = crypto.<span class="hljs-title function_">randomUUID</span>();
person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;
person.<span class="hljs-property">firstName</span> = <span class="hljs-string">"foo"</span>;
person.<span class="hljs-property">lastName</span> = <span class="hljs-string">"bar"</span>;
person.<span class="hljs-property">dateOfBirth</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1999</span>, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
person.<span class="hljs-property">gender</span> = <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Other</span>;
person.<span class="hljs-property">emails</span> = [<span class="hljs-string">"foo@bar.com"</span>, <span class="hljs-string">"zoo@bar.net"</span>];

<span class="hljs-comment">// serialiseer naar Uint8Array</span>
<span class="hljs-keyword">let</span> bin = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">serialize</span>(person);

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([bin.<span class="hljs-property">buffer</span>], { <span class="hljs-attr">type</span>: <span class="hljs-string">"application/x-memorypack"</span> })

<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"http://localhost:5260/api"</span>,
    { <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>, <span class="hljs-attr">body</span>: blob, <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/x-memorypack"</span> } });

<span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();

<span class="hljs-comment">// deserialiseer van ArrayBuffer </span>
<span class="hljs-keyword">let</span> person2 = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">deserialize</span>(buffer);
</code></pre>
<p>Het pakket <code>MemoryPack.AspNetCoreMvcFormatter</code> voegt <code>MemoryPack</code> input en output formatters toe aan ASP.NET Core MVC. Je kunt <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> toevoegen aan ASP.NET Core MVC met de volgende code.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackInputFormatter());
    <span class="hljs-comment">// Als checkContentType: true, dan kan meerdere formaten outputten (JSON/MemoryPack, etc...). standaard is false.</span>
    options.OutputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackOutputFormatter(checkContentType: <span class="hljs-literal">false</span>));
});
</code></pre>
<p>Als je aanroept vanuit HttpClient, kun je <code>application/x-memorypack</code> instellen als content-header.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> content = <span class="hljs-keyword">new</span> ByteArrayContent(bin)
content.Headers.ContentType = <span class="hljs-keyword">new</span> MediaTypeHeaderValue(<span class="hljs-string">"application/x-memorypack"</span>);
</code></pre>
<h3>TypeScript Type Mapping</h3>
<p>Er zijn enkele beperkingen op de typen die gegenereerd kunnen worden. Onder de primitieve types worden <code>char</code> en <code>decimal</code> niet ondersteund. Ook kan een OpenGenerics type niet gebruikt worden.</p>
<table>
<thead>
<tr>
<th>C#</th>
<th>TypeScript</th>
<th>Beschrijving</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>sbyte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>bigint</code></td>
<td></td>
</tr>
</tbody></table>
<pre><code class="hljs language-xml">| `ulong` |  `bigint` |
| `float` |  `number` |
| `double` |  `number` |
| `string` |  `string \| null`  | 
| `Guid` |  `string`  | In TypeScript wordt dit als string weergegeven, maar bij serialiseren/deserialiseren als 16-byte binaire data
| `DateTime` | `Date` | DateTimeKind wordt genegeerd
| `enum` | `const enum` | `long` en `ulong` als onderliggende types worden niet ondersteund
| `T?` | `T \| null` |
| `T[]` | `T[] \| null` |
| `byte[]` | `Uint8Array \| null` |
| `: ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `T[] \| null` | Ondersteunt alle `ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` geïmplementeerde types zoals `List<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`
| `: ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `Set<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> \| null` | Ondersteunt alle `ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` geïmplementeerde types zoals `HashSet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`
| `: IDictionary&lt;K,V&gt;` | `Map&lt;K, V&gt; \| null` | Ondersteunt alle `IDictionary&lt;K,V&gt;` geïmplementeerde types zoals `Dictionary&lt;K,V&gt;`.
| `[MemoryPackable]` | `class` | Ondersteunt alleen klassen
| `[MemoryPackUnion]` | `abstract class` |

`[GenerateTypeScript]` kan alleen op klassen worden toegepast en wordt momenteel niet ondersteund voor structs.

### Extensie van importbestand en lidnaamnotatie configureren

Standaard genereert MemoryPack de bestandsextensie als `.js`, bijvoorbeeld `import { MemoryPackWriter } from "./MemoryPackWriter.js";`. Wil je een andere extensie of geen extensie, gebruik dan `MemoryPackGenerator_TypeScriptImportExtension` om dit te configureren.
Ook worden de lidnamen automatisch omgezet naar camelCase. Wil je de originele naam gebruiken, zet `MemoryPackGenerator_TypeScriptConvertPropertyName` op `false`.

```xml
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptImportExtension"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptConvertPropertyName"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptEnableNullableTypes"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- mag leeg zijn --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- standaard is true --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- standaard is false --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> zorgt ervoor dat C# nullable annotaties worden weerspiegeld in de TypeScript-code. De standaardwaarde is false, waardoor alles nullable wordt.</p>
<h2>Streaming Serialisatie</h2>
<p><code>MemoryPack.Streaming</code> biedt <code>MemoryPackStreamingSerializer</code>, die extra ondersteuning toevoegt voor het serialiseren en deserialiseren van collecties met streams.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackStreamingSerializer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeWriter pipeWriter, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeReader pipeReader, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, [EnumeratorCancellation] CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
}
</span></code></pre>
<h2>Formatter/Provider API</h2>
<p>Als je een formatter handmatig wilt implementeren, erf dan van <code>MemoryPackFormatter&lt;T&gt;</code> en overschrijf de methoden <code>Serialize</code> en <code>Deserialize</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SkeltonFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">Skelton</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
        {
            writer.WriteNullObjectHeader();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// gebruik writer-methoden.</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (!reader.TryReadObjectHeader(<span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> count))
        {
            <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// gebruik reader-methoden.</span>
    }
}
</code></pre>
<p>De gemaakte formatter wordt geregistreerd met <code>MemoryPackFormatterProvider</code>.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register(<span class="hljs-keyword">new</span> SkeltonFormatter());
</code></pre>
<p>Let op: <code>unmanaged struct</code> (bevat geen referentietypen) kan geen custom formatter gebruiken, deze wordt altijd geserialiseerd volgens de native geheugenlayout.</p>
<h2>MemoryPackWriter/ReaderOptionalState</h2>
<p>Initialiseren van <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> vereist OptionalState. Dit is een wrapper om <code>MemoryPackSerializerOptions</code>, en kan worden gemaakt via <code>MemoryPackWriterOptionalStatePool</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// bij dispose, wordt OptionalState teruggegeven aan de pool.</span>
<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> writer = <span class="hljs-keyword">new</span> MemoryPackWriter&lt;T&gt;(<span class="hljs-keyword">ref</span> t, state);
}

<span class="hljs-comment">// voor Reader</span>
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> MemoryPackReader(buffer, state);
}
</code></pre>
<h2>Afhankelijkheid van target framework</h2>
<p>MemoryPack biedt <code>netstandard2.1</code> en <code>net7.0</code>, maar deze zijn niet compatibel met elkaar. Als je bijvoorbeeld MemoryPackable types onder een <code>netstandard2.1</code> project gebruikt vanuit een <code>net7.0</code> project, krijg je een runtime-exceptie zoals:</p>
<blockquote>
<p>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</p>
</blockquote>
<p>Omdat net7.0 gebruikmaakt van statische abstracte leden (<code>Virtual static method</code>), die niet worden ondersteund door netstandard2.1, is dit het verwachte gedrag.</p>
<p>Een .NET 7-project mag de netstandard 2.1 dll niet gebruiken. Met andere woorden: als de applicatie een .NET 7-project is, moeten alle afhankelijkheden die MemoryPack gebruiken .NET 7 ondersteunen. Dus als een bibliotheekontwikkelaar afhankelijk is van MemoryPack, moet je een dual target framework configureren.</p>
<pre><code class="language-xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">TargetFrameworks</span>&gt;</span>netstandard2.1;net7.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFrameworks</span>&gt;</span>
</code></pre>
<h2>RPC</h2>
<p><a href="https://github.com/Cysharp/MagicOnion">Cysharp/MagicOnion</a> is een code-first grpc-dotnet framework dat MessagePack gebruikt in plaats van protobuf. MagicOnion ondersteunt nu MemoryPack als serialisatielaag via het <code>MagicOnion.Serialization.MemoryPack</code>-pakket (preview). Zie details: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support">MagicOnion#MemoryPack support</a></p>
<h2>Unity</h2>
<p>Minimaal ondersteunde Unity-versie is <code>2022.3.12f1</code>.</p>
<p>Het <code>MemoryPack</code>-kernpakket is beschikbaar via nuget. Het is ook beschikbaar in Unity. Wil je ondersteuning voor Unity ingebouwde types, dan bieden we aanvullend de MemoryPack.Unity-extensie.</p>
<ol>
<li>Installeer <code>MemoryPack</code> vanuit NuGet met <a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a></li>
</ol>
<ul>
<li><p>Open het venster via NuGet -&gt; Beheer NuGet Packages, zoek "MemoryPack" en druk op Installeren.<br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p>
</li>
<li><p>Krijg je een foutmelding over versieconflicten, schakel dan versievalidatie uit in Player Settings (Edit -&gt; Projectinstellingen -&gt; Player -&gt; Scroll naar beneden en vouw "Other Settings" uit, schakel vervolgens "Assembly Version Validation" uit onder het kopje "Configuration").</p>
</li>
</ul>
<ol start="2">
<li>Installeer het <code>MemoryPack.Unity</code>-pakket door te verwijzen naar de git-URL</li>
</ol>
<ul>
<li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code><br><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot"><br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></li>
</ul>
<p>MemoryPack gebruikt het <em>.</em>.* release tag-systeem, dus je kunt een versie opgeven als #1.0.0. Bijvoorbeeld: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p>
<p>Net als bij de .NET-versie wordt de code gegenereerd door een code generator (<code>MemoryPack.Generator.dll</code>). Implementatie zonder reflectie biedt ook de beste prestaties in IL2CPP.</p>
<p>Voor meer informatie over Unity en Source Generator, zie de <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Unity documentatie</a>.</p>
<p>Source Generator wordt ook officieel gebruikt door Unity door <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">com.unity.properties</a> en <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html">com.unity.entities</a>. Met andere woorden, het is de standaard voor codegeneratie in de volgende generatie Unity.</p>
<p>Je kunt alle unmanaged types (zoals <code>Vector3</code>, <code>Rect</code>, etc...) en enkele klassen (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>) serialiseren. Wil je andere Unity-specifieke types serialiseren, zie het gedeelte <a href="#serialize-external-types">Externe types serialiseren</a>.</p>
<p>Qua prestaties in Unity is MemoryPack x3~x10 sneller dan JsonUtility.</p>
<p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p>
<p>Als gedeelde code Unity-types bevat (<code>Vector2</code>, etc...), biedt MemoryPack het <code>MemoryPack.UnityShims</code>-pakket via NuGet.</p>
<p>Het <code>MemoryPack.UnityShims</code>-pakket biedt shims voor Unity's standaard structs (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) en enkele klassen (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>).</p>
<blockquote>
<p>[!WAARSCHUWING]<br>Momenteel gelden de volgende beperkingen voor gebruik in Unity</p>
</blockquote>
<ol>
<li>De Unity-versie ondersteunt geen CustomFormatter.</li>
<li>Als je .NET7 of nieuwer gebruikt, is het MemoryPack binaire formaat niet volledig compatibel met Unity.<ul>
<li>Dit probleem doet zich voor bij waarde types waarvoor <code>[StructLayout(LayoutKind.Auto)]</code> expliciet is opgegeven. (De standaard voor struct is <code>LayoutKind.Sequencial</code>.) Voor zulke types kunnen binaries die in .NET zijn geserialiseerd, niet worden gedeserialiseerd in Unity. Evenzo kan een binary die in Unity is geserialiseerd, niet worden geserialiseerd aan de .NET-kant.</li>
<li>De getroffen types omvatten doorgaans de volgende types:<ul>
<li><code>DateTimeOffset</code></li>
<li><code>ValueTuple</code></li>
</ul>
</li>
<li>Momenteel is de eenvoudige oplossing om deze types niet te gebruiken.</li>
</ul>
</li>
</ol>
<h2>Native AOT</h2>
<p>Helaas veroorzaakt .NET 7 Native AOT een crash (<code>Generic virtual method pointer lookup failure</code>) bij gebruik van MemoryPack, vanwege een runtime bug.<br>Dit wordt opgelost in .NET 8. Door <code>Microsoft.DotNet.ILCompiler</code> preview te gebruiken, wordt het probleem in .NET 7 opgelost. Zie <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611">opmerking bij issue</a> voor instructies om dit in te stellen.</p>
<h2>Binaire wireformaatspecificatie</h2>
<p>Het type <code>T</code> dat wordt gedefinieerd in <code>Serialize&lt;T&gt;</code> en <code>Deserialize&lt;T&gt;</code> wordt het C#-schema genoemd. Het MemoryPack-formaat is geen zelfbeschrijvend formaat. Voor deserialisatie is het bijbehorende C#-schema vereist. Deze types bestaan als interne representaties van binaries, maar types kunnen niet worden bepaald zonder een C#-schema.</p>
<p>Endianness moet <code>Little Endian</code> zijn. De C#-implementatie houdt echter geen rekening met endianness en kan dus niet worden gebruikt op big-endian machines. Moderne computers zijn echter vrijwel altijd little-endian.</p>
<p>Er zijn acht types formaten.</p>
<ul>
<li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>Circulaire Referentie Object</li>
<li>Tuple</li>
<li>Collectie</li>
<li>String</li>
<li>Unie</li>
</ul>
<h3>Unmanaged struct</h3>
<p>Unmanaged struct is een C# struct die geen referentietypen bevat, vergelijkbare beperking als <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>. Serialiseren van struct layout zoals het is, inclusief padding.</p>
<h3>Object</h3>
<p><code>(byte memberCount, [values...])</code></p>
<p>Object heeft 1 byte unsigned byte als aantal leden in de header. Aantal leden kan van <code>0</code> tot <code>249</code>, <code>255</code> geeft aan dat het object <code>null</code> is. Waarden slaan memorypack-waarde op voor het aantal leden.</p>
<h3>Version Tolerant Object</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], [values...])</code></p>
<p>Version Tolerant Object is vergelijkbaar met Object maar heeft de bytelengte van de waarden in de header. varint volgt deze specificatie, eerste sbyte is waarde of typeCode en de volgende X bytes zijn de waarde. 0 tot 127 = unsigned byte waarde, -1 tot -120 = signed byte waarde, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p>
<h3>Circulaire Referentie Object</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])</code><br><code>(250, varint referenceId)</code></p>
<p>Circulaire Referentie Object is vergelijkbaar met Version Tolerant Object maar als memberCount 250 is, is de volgende varint(unsigned-int32) de referenceId. Zo niet, dan wordt na byte-length-of-values, varint referenceId geschreven.</p>
<h3>Tuple</h3>
<p><code>(values...)</code></p>
<p>Tuple is een collectie met vaste grootte van niet-nullable waarden. In .NET worden <code>KeyValuePair&lt;TKey, TValue&gt;</code> en <code>ValueTuple&lt;T,...&gt;</code> geserialiseerd als Tuple.</p>
<h3>Collectie</h3>
<p><code>(int length, [values...])</code></p>
<p>Collectie heeft een 4-byte signed integer als datatelling in de header, <code>-1</code> betekent <code>null</code>. Waarden slaan memorypack-waarde op voor het aantal van de lengte.</p>
<h3>String</h3>
<p><code>(int utf16-length, utf16-value)</code><br><code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)</code></p>
<p>String heeft twee vormen, UTF16 en UTF8. Als de eerste 4-byte signed integer <code>-1</code> is, betekent dit null. <code>0</code> betekent leeg. UTF16 is hetzelfde als collectie (serialiseren als <code>ReadOnlySpan&lt;char&gt;</code>, utf16-value's byte-telling is utf16-length * 2). Als het eerste signed integer &lt;= <code>-2</code>, wordt de waarde gecodeerd in UTF8. utf8-byte-count is gecodeerd in complement, <code>~utf8-byte-count</code> om het aantal bytes te bepalen. De volgende signed integer is utf16-length, dit kan <code>-1</code> zijn wat onbekende lengte betekent. utf8-bytes slaan bytes op voor het aantal utf8-byte-count.</p>
<h3>Unie</h3>
<p><code>(byte tag, value)</code><br><code>(250, ushort tag, value)</code></p>
<p>Eerste unsigned byte is tag voor gediscrimineerde waarde type of vlag, <code>0</code> tot <code>249</code> betekent tag, <code>250</code> betekent dat de volgende unsigned short de tag is, <code>255</code> betekent dat de unie <code>null</code> is.</p>
<h2>Licentie</h2>
<p>Deze bibliotheek is gelicentieerd onder de MIT-licentie.</p>
<hr>
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-09</p>
<hr>
</div>
    </div>

    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async=""></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
    <script src="view.js"></script>


</body></html>