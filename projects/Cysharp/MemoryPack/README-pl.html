<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Open AI Tx</title>

    <!-- Primary Meta Tags -->
    <meta name="title" content="Open AI Tx - Markdown Viewer">
    <meta name="description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta name="keywords" content="Open AI Tx, Markdown, GitHub Style, Documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/view.html">
    <meta property="og:title" content="Open AI Tx - Markdown Viewer">
    <meta property="og:description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">

    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="icon.jpg">
    <link rel="apple-touch-icon" href="icon.jpg">

    <!-- Marked.js for Markdown rendering -->
    <script type="text/javascript" async="" src="https://www.statcounter.com/counter/recorder.js"></script><script src="js/marked.min.js"></script>
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="css/github.min.css">
    <script src="js/highlight.min.js"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="view.css">
    <style>
        /* Layout */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .main-container {
            margin: 0 auto;
            width: 100%;
            max-width: 980px;
            padding: 0 20px;
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0 15px;
            }
        }

        /* Image size restrictions */
        .markdown-body img {
            max-width: 100%;
            height: auto;
        }

        /* Existing styles */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f6f8fa;
            border-bottom: 1px solid #e1e4e8;
            position: relative;
        }

        .back-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #0366d6;
            text-decoration: none;
            display: flex;
            align-items: center;
            font-size: 14px;
            padding: 5px 10px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #fff;
        }

        .back-button:hover {
            background-color: #f6f8fa;
            border-color: #0366d6;
        }

        .back-button::before {
            content: "←";
            margin-right: 5px;
            font-size: 16px;
        }

        .header .links {
            margin-top: 10px;
            font-size: 16px;
        }

        .header .links a {
            color: #0366d6;
            text-decoration: none;
            margin-left: 5px;
        }

        .header .links a:hover {
            text-decoration: underline;
        }
        
        /* Language badges styles */
        .language-badges {
            margin-top: 15px;
            text-align: center;
        }
        .language-badges a {
            display: inline-block;
            margin: 2px;
            text-decoration: none;
        }
        .language-badges img {
            height: 20px;
            border-radius: 3px;
        }
        .language-badges a:hover img {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div class="header">
        <a href="javascript:history.back()" class="back-button">Back</a>
        <div class="links">
            GitHub Repository: <a href="https://github.com/Cysharp/MemoryPack" id="githubRepoLink" target="_blank">Cysharp/MemoryPack</a>
        </div>
        <div class="language-badges" id="languageBadges"><a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=en"><img src="https://img.shields.io/badge/EN-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-CN"><img src="https://img.shields.io/badge/简中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-TW"><img src="https://img.shields.io/badge/繁中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ja"><img src="https://img.shields.io/badge/日本語-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ko"><img src="https://img.shields.io/badge/한국어-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=th"><img src="https://img.shields.io/badge/ไทย-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=fr"><img src="https://img.shields.io/badge/Français-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=de"><img src="https://img.shields.io/badge/Deutsch-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=es"><img src="https://img.shields.io/badge/Español-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=it"><img src="https://img.shields.io/badge/Italiano-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ru"><img src="https://img.shields.io/badge/Русский-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pt"><img src="https://img.shields.io/badge/Português-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=nl"><img src="https://img.shields.io/badge/Nederlands-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pl"><img src="https://img.shields.io/badge/Polski-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ar"><img src="https://img.shields.io/badge/العربية-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=tr"><img src="https://img.shields.io/badge/Türkçe-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=vi"><img src="https://img.shields.io/badge/Tiếng Việt-white" alt="version"></a></div>
    </div>

    <div class="main-container">
        <div class="markdown-body" id="content"><h1>MemoryPack</h1>
<p><a href="https://www.nuget.org/packages/MemoryPack"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a><br><a href="https://github.com/Cysharp/MemoryPack/actions"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a><br><a href="https://github.com/Cysharp/MemoryPack/releases"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p>
<p>Ekstremalnie wydajny, binarny serializer C# i Unity bez kodowania (zero encoding).</p>
<p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p>
<blockquote>
<p>Porównanie z <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/">Orleans.Serialization</a>. Pomiar wykonany na .NET 7 / Ryzen 9 5950X. Serializatory te posiadają metodę <code>IBufferWriter&lt;byte&gt;</code>, serializacja z użyciem <code>ArrayBufferWriter&lt;byte&gt;</code> i ponowne użycie bufora w celu uniknięcia kopiowania podczas pomiaru.</p>
</blockquote>
<p>Dla standardowych obiektów, MemoryPack jest x10 szybszy oraz x2 ~ x5 szybszy niż inne binarne serializatory. Dla tablic struktur, MemoryPack jest jeszcze potężniejszy, osiągając prędkość nawet x50 ~ x200 większą niż inne serializatory.</p>
<p>MemoryPack jest moim czwartym serializatorem, wcześniej stworzyłem znane serializatory, <del><a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a></del>, <del><a href="https://github.com/neuecc/Utf8Json">Utf8Json</a></del>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>. Powodem szybkości MemoryPack jest jego specyficzny dla C#, zoptymalizowany pod C# format binarny oraz doskonale dostrojona implementacja oparta na moim wcześniejszym doświadczeniu. Jest to także zupełnie nowy projekt wykorzystujący .NET 7, C# 11 oraz Incremental Source Generator (.NET Standard 2.1 (.NET 5, 6) oraz wsparcie dla Unity).</p>
<p>Inne serializatory wykonują wiele operacji kodowania takich jak kodowanie VarInt, tagi, stringi itd. Format MemoryPack stosuje podejście zero-encoding, kopiując jak najwięcej pamięci C#. Zero-encoding jest podobny do FlatBuffers, jednak nie wymaga specjalnych typów, a celem serializacji MemoryPack są POCO.</p>
<p>Poza wydajnością, MemoryPack oferuje także:</p>
<ul>
<li>Wsparcie dla nowoczesnych API I/O (<code>IBufferWriter&lt;byte&gt;</code>, <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>)</li>
<li>Natywna, przyjazna AOT generacja kodu oparta na Source Generator, bez Dynamic CodeGen (IL.Emit)</li>
<li>API bez refleksji i niegenericzne</li>
<li>Deserializacja do istniejącej instancji</li>
<li>Serializacja polimorficzna (Union)</li>
<li>Ograniczona tolerancja wersji (szybka/domyslna) oraz pełna tolerancja wersji</li>
<li>Serializacja cyklicznych referencji</li>
<li>Serializacja strumieniowa oparta na PipeWriter/Reader</li>
<li>Generowanie kodu TypeScript i formatter dla ASP.NET Core</li>
<li>Wsparcie dla Unity (2021.3) IL2CPP przez .NET Source Generator</li>
</ul>
<h2>Instalacja</h2>
<p>Biblioteka jest dystrybuowana przez NuGet. Dla najlepszej wydajności zaleca się użycie <code>.NET 7</code>. Minimalnym wymaganiem jest <code>.NET Standard 2.1</code>.</p>
<blockquote>
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/MemoryPack">MemoryPack</a></p>
</blockquote>
<p>Wymagany jest także edytor kodu ze wsparciem dla Roslyn 4.3.1, np. Visual Studio 2022 w wersji 17.3, .NET SDK 6.0.401. Szczegóły w dokumencie <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support">Roslyn Version Support</a>.</p>
<p>W przypadku Unity wymagania i proces instalacji są zupełnie inne. Szczegóły w sekcji <a href="#unity">Unity</a>.</p>
<h2>Szybki start</h2>
<p>Zdefiniuj strukturę lub klasę do serializacji i oznacz ją atrybutem <code>[MemoryPackable]</code> oraz słowem kluczowym <code>partial</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack;

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Kod do serializacji generowany jest przez C# source generator, który implementuje interfejs <code>IMemoryPackable&lt;T&gt;</code>. W Visual Studio możesz sprawdzić wygenerowany kod skrótem <code>Ctrl+K, R</code> na nazwie klasy i wybrać <code>*.MemoryPackFormatter.g.cs</code>.</p>
<p>Wywołaj <code>MemoryPackSerializer.Serialize&lt;T&gt;/Deserialize&lt;T&gt;</code>, aby zserializować/deserializować instancję obiektu.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Person { Age = <span class="hljs-number">40</span>, Name = <span class="hljs-string">"John"</span> };

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(v);
<span class="hljs-keyword">var</span> val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p>Metoda <code>Serialize</code> obsługuje zwracanie typu <code>byte[]</code>, a także potrafi serializować do <code>IBufferWriter&lt;byte&gt;</code> lub <code>Stream</code>. Metoda <code>Deserialize</code> obsługuje <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code> oraz <code>Stream</code>. Istnieją również wersje niegeneryczne tych metod.</p>
<h2>Wspierane typy wbudowane</h2>
<p>Domyślnie mogą być serializowane następujące typy:</p>
<ul>
<li>Typy prymitywne .NET (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, itd.)</li>
<li>Typy niezarządzane (dowolne <code>enum</code>, dowolny własny <code>struct</code> nie zawierający typów referencyjnych)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code>, <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory&lt;&gt;</code>, <code>ReadOnlyMemory&lt;&gt;</code>, <code>ArraySegment&lt;&gt;</code>, <code>ReadOnlySequence&lt;&gt;</code></li>
<li><code>Nullable&lt;&gt;</code>, <code>Lazy&lt;&gt;</code>, <code>KeyValuePair&lt;,&gt;</code>, <code>Tuple&lt;,...&gt;</code>, <code>ValueTuple&lt;,...&gt;</code></li>
<li><code>List&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>SortedSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code></li>
<li><code>Dictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>,  <code>ReadOnlyDictionary&lt;,&gt;</code></li>
<li><code>Collection&lt;&gt;</code>, <code>ReadOnlyCollection&lt;&gt;</code>, <code>ObservableCollection&lt;&gt;</code>, <code>ReadOnlyObservableCollection&lt;&gt;</code></li>
<li><code>IEnumerable&lt;&gt;</code>, <code>ICollection&lt;&gt;</code>, <code>IList&lt;&gt;</code>, <code>IReadOnlyCollection&lt;&gt;</code>, <code>IReadOnlyList&lt;&gt;</code>, <code>ISet&lt;&gt;</code></li>
<li><code>IDictionary&lt;,&gt;</code>, <code>IReadOnlyDictionary&lt;,&gt;</code>, <code>ILookup&lt;,&gt;</code>, <code>IGrouping&lt;,&gt;</code>,</li>
<li><code>ConcurrentBag&lt;&gt;</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>, <code>BlockingCollection&lt;&gt;</code></li>
<li>Kolekcje niemutowalne (<code>ImmutableList&lt;&gt;</code>, itd.) oraz interfejsy (<code>IImmutableList&lt;&gt;</code>, itd.)</li>
</ul>
<h2>Definiowanie <code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code></h2>
<p><code>[MemoryPackable]</code> można oznaczyć dowolną <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> oraz <code>interface</code>. Jeśli typ to <code>struct</code> lub <code>record struct</code>, który nie zawiera typów referencyjnych (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>), żadne dodatkowe adnotacje (ignore, include, constructor, callbacks) nie są wykorzystywane – serializacja/deserializacja odbywa się bezpośrednio z pamięci.</p>
<p>W przeciwnym przypadku, domyślnie <code>[MemoryPackable]</code> serializuje publiczne właściwości instancyjne lub pola. Możesz użyć <code>[MemoryPackIgnore]</code>, aby wykluczyć członek z serializacji, a <code>[MemoryPackInclude]</code> promuje prywatny człon na cel serializacji.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// te typy są domyślnie serializowane</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicField;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> PublicReadOnlyField;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PrivateSetPublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ReadOnlyPublicProperty { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> RequiredInitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }

    <span class="hljs-comment">// te typy nie są serializowane domyślnie</span>
    <span class="hljs-built_in">int</span> privateProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-built_in">int</span> privateField;
    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> privateReadOnlyField;

    <span class="hljs-comment">// użyj [MemoryPackIgnore], aby wykluczyć publiczny człon z serializacji</span>
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty2 =&gt; PublicProperty + PublicField;

    <span class="hljs-comment">// użyj [MemoryPackInclude], aby promować prywatny człon do serializacji</span>
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateField2;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Generator kodu <code>MemoryPack</code> dodaje informację o tym, które człony są serializowane do sekcji <code>&lt;remarks /&gt;</code>. Można to podejrzeć najeżdżając na typ w Intellisense.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p>
<p>Wszystkie człony muszą być serializowalne przez MemoryPack, w przeciwnym razie generator kodu zgłosi błąd.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p>
<p>MemoryPack posiada 35 reguł diagnostycznych (<code>MEMPACK001</code> do <code>MEMPACK035</code>), aby ułatwić definiowanie typów.</p>
<p>Jeśli typ docelowy jest definiowany zewnętrznie dla serializacji MemoryPack i jest zarejestrowany, użyj <code>[MemoryPackAllowSerialize]</code>, aby wyciszyć diagnostykę.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample2</span>
{
    [<span class="hljs-meta">MemoryPackAllowSerialize</span>]
    <span class="hljs-keyword">public</span> NotSerializableType? NotSerializableProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Kolejność członów jest <strong>ważna</strong> – MemoryPack nie serializuje nazw członów ani dodatkowych informacji, zamiast tego serializuje pola w kolejności ich zadeklarowania. Jeśli typ jest dziedziczony, serializacja następuje w kolejności rodzic → dziecko. Kolejność członów nie może się zmienić podczas deserializacji. W celu ewolucji schematu, zobacz sekcję <a href="#version-tolerant">Version tolerant</a>.</p>
<p>Domyślna kolejność to sekwencyjna, ale możesz wybrać układ jawny z <code>[MemoryPackable(SerializeLayout.Explicit)]</code> i <code>[MemoryPackOrder()]</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// serializuje Prop0 -&gt; Prop1</span>
[<span class="hljs-meta">MemoryPackable(SerializeLayout.Explicit)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleExplicitOrder</span>
{
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h3>Wybór konstruktora</h3>
<p>MemoryPack obsługuje zarówno konstruktory z parametrami, jak i bezparametrowe. Wybór konstruktora odbywa się według następujących zasad (dotyczy klas i struktur):</p>
<ul>
<li>Jeśli jest <code>[MemoryPackConstructor]</code>, użyj go.</li>
<li>Jeśli nie ma jawnego konstruktora (w tym prywatnego), użyj bezparametrowego.</li>
<li>Jeśli istnieje tylko jeden konstruktor bezparametrowy/parametryzowany (w tym prywatny), użyj go.</li>
<li>Jeśli jest wiele konstruktorów, należy oznaczyć żądany konstruktor atrybutem <code>[MemoryPackConstructor]</code> (generator nie wybierze automatycznie), w przeciwnym razie generator zgłosi błąd.</li>
<li>Jeśli używasz konstruktora z parametrami, wszystkie nazwy parametrów muszą odpowiadać nazwom członów (bez rozróżniania wielkości liter).</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Name;

    <span class="hljs-comment">// Możesz użyć konstruktora z parametrami - nazwy parametrów muszą odpowiadać nazwom członów (bez rozróżniania wielkości liter)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Age = age;
        <span class="hljs-keyword">this</span>.Name = name;
    }
}

<span class="hljs-comment">// obsługuje także rekordowy konstruktor główny</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Person2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Age, <span class="hljs-built_in">string</span> Name</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>()</span>
    {
    }
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Jeśli istnieje wiele konstruktorów, należy użyć [MemoryPackConstructor]</span>
[<span class="hljs-meta">MemoryPackConstructor</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
{
    <span class="hljs-keyword">this</span>.Age = age;
    <span class="hljs-keyword">this</span>.Name = name;
}
</code></pre>
<h3>Callbacki serializacji</h3>
<p>Podczas serializacji/deserializacji, MemoryPack może wywołać zdarzenie przed/po użyciu atrybutów <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. Można je oznaczać zarówno dla metod statycznych, jak i instancyjnych (niestatycznych), a także dla metod publicznych i prywatnych.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MethodCallSample</span>
{
    <span class="hljs-comment">// kolejność wywołań metod to static -&gt; instance</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing1));
    }

    <span class="hljs-comment">// dopuszczalna jest również metoda prywatna</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing2));
    }

    <span class="hljs-comment">// serializing -&gt; /* serialize */ -&gt; serialized</span>
    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized1));
    }

    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing1));
    }

    <span class="hljs-comment">// Uwaga: metoda instancyjna z MemoryPackOnDeserializing nie zostanie wywołana, jeśli instancja nie zostanie przekazana przez `ref`</span>
    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized1));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized2));
    }
}
</code></pre>
<p>Callbacki pozwalają na metody bezparametrowe oraz metody <code>ref reader/writer, ref T value</code>. Przykładowo, callbacki ref mogą zapisywać/odczytywać niestandardowy nagłówek przed procesem serializacji.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EmitIdData</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteId</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)
        <span class="hljs-keyword">where</span> TBufferWriter : IBufferWriter&lt;<span class="hljs-built_in">byte</span>&gt; <span class="hljs-comment">// .NET Standard 2.1, użyj where TBufferWriter : class, IBufferWriter&lt;byte&gt;</span></span>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); <span class="hljs-comment">// zapisuje GUID w nagłówku.</span>
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadId</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-comment">// odczytuje niestandardowy nagłówek przed deserializacją</span>
        <span class="hljs-keyword">var</span> guid = reader.ReadUnmanaged&lt;Guid&gt;();
        Console.WriteLine(guid);
    }
}
</code></pre>
<p>Jeśli ustawisz wartość w <code>ref value</code>, możesz zmienić wartość używaną podczas serializacji/deserializacji. Przykładowo, można zainicjalizować instancję z ServiceProvider.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// przed użyciem tego formatera ustaw ServiceProvider</span>
<span class="hljs-comment">// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };</span>
<span class="hljs-comment">// MemoryPackSerializer.Deserialize(value, options);</span>

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InstantiateFromServiceProvider</span>
{
    <span class="hljs-keyword">static</span> IServiceProvider serviceProvider = <span class="hljs-literal">default</span>!;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> InstantiateFromServiceProvider <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">value</span> = reader.Options.ServiceProvider!.GetRequiredService&lt;InstantiateFromServiceProvider&gt;();
    }
}
</code></pre>
<h2>Definiowanie własnej kolekcji</h2>
<p>Domyślnie typ oznaczony <code>[MemoryPackObject]</code> próbuje serializować swoje człony. Jednak jeśli typ jest kolekcją (<code>ICollection&lt;&gt;</code>, <code>ISet&lt;&gt;</code>, <code>IDictionary&lt;,&gt;</code>), należy użyć <code>GenerateType.Collection</code>, aby poprawnie go serializować.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt;
{
}

[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyStringDictionary</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>&gt;
{

}
</code></pre>
<h2>Konstruktor statyczny</h2>
<p>Klasa MemoryPackable nie może definiować statycznego konstruktora, ponieważ generowana klasa partial go używa. Zamiast tego możesz zdefiniować <code>static partial void StaticConstructor()</code>, aby osiągnąć ten sam efekt.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CctorSample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StaticConstructor</span>()</span>
    {
    }
}
</code></pre>
<h2>Polimorfizm (Union)</h2>
<p>MemoryPack obsługuje serializację obiektów interfejsów i klas abstrakcyjnych w celu serializacji polimorficznej. W MemoryPack ta funkcja nazywa się Union. Tylko interfejsy i klasy abstrakcyjne mogą być oznaczane atrybutami <code>[MemoryPackUnion]</code>. Wymagane są unikalne tagi union.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Oznacz [MemoryPackable] oraz typy dziedziczące przez [MemoryPackUnion]</span>
<span class="hljs-comment">// Union obsługuje również klasy abstrakcyjne</span>
[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> XYZ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BarClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? OPQ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
<span class="hljs-comment">// ---</span>

IUnionSample data = <span class="hljs-keyword">new</span> FooClass() { XYZ = <span class="hljs-number">999</span> };

<span class="hljs-comment">// Serializacja jako typ interfejsu.</span>
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(data);

<span class="hljs-comment">// Deserializacja jako typ interfejsu.</span>
<span class="hljs-keyword">var</span> reData = MemoryPackSerializer.Deserialize&lt;IUnionSample&gt;(bin);

<span class="hljs-keyword">switch</span> (reData)
{
    <span class="hljs-keyword">case</span> FooClass x:
        Console.WriteLine(x.XYZ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BarClass x:
        Console.WriteLine(x.OPQ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-literal">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p><code>tag</code> pozwala na wartości od <code>0</code> do <code>65535</code>, szczególnie efektywne są wartości mniejsze niż <code>250</code>.</p>
<pre><code class="hljs language-csharp">Jeśli interfejs i typy pochodne znajdują się w różnych zestawach, możesz zamiast tego użyć `MemoryPackUnionFormatterAttribute`. Formattery są generowane w taki sposób, że są automatycznie rejestrowane za pomocą `ModuleInitializer` w C<span class="hljs-meta"># 9.0 i nowszych.</span>

&gt; Uwaga: `ModuleInitializer` nie jest obsługiwany w Unity, więc formatter musi zostać zarejestrowany ręcznie. Aby zarejestrować własny union formatter, wywołaj ręcznie `{nazwa twojego union formattera}Initializer.RegisterFormatter()` podczas uruchamiania aplikacji. Na przykład `UnionSampleFormatterInitializer.RegisterFormatter()`.

```csharp
<span class="hljs-comment">// AssemblyA</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.NoGenerate)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

<span class="hljs-comment">// AssemblyB definicja poza typem docelowym</span>
[<span class="hljs-meta">MemoryPackUnionFormatter(typeof(IUnionSample))</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnionSampleFormatter</span>
{
}
</code></pre>
<p>Unie można zbudować w kodzie za pomocą <code>DynamicUnionFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// (ushort, Type)[]</span>
<span class="hljs-keyword">var</span> formatter = <span class="hljs-keyword">new</span> DynamicUnionFormatter&lt;IFooBarBaz&gt;(
    (<span class="hljs-number">0</span>, <span class="hljs-keyword">typeof</span>(Foo)),
    (<span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(Bar)),
    (<span class="hljs-number">2</span>, <span class="hljs-keyword">typeof</span>(Baz))
);

MemoryPackFormatterProvider.Register(formatter);
</code></pre>
<h2>Serialize API</h2>
<p><code>Serialize</code> ma trzy przeciążenia.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Dostępne jest również niegeneryczne API, w tej wersji pierwszym argumentem jest Type, a value to object?</span>
<span class="hljs-function"><span class="hljs-built_in">byte</span>[] <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> TBufferWriter bufferWriter, <span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
</span></code></pre>
<p>Ze względów wydajności zalecane jest API wykorzystujące <code>BufferWriter</code>. Serializuje ono bezpośrednio do bufora. Może być stosowane do <code>PipeWriter</code> z <code>System.IO.Pipelines</code>, <code>BodyWriter</code> w ASP .NET Core, itd.</p>
<p>Jeśli wymagane jest <code>byte[]</code> (np. <code>RedisValue</code> w <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>), API zwracające <code>byte[]</code> jest proste i niemal tak szybkie.</p>
<p>Należy pamiętać, że <code>SerializeAsync</code> dla <code>Stream</code> jest asynchroniczne tylko podczas Flush; całość jest serializowana jednorazowo do wewnętrznego bufora MemoryPack, a następnie zapisywana za pomocą <code>WriteAsync</code>. Dlatego przeciążenie z <code>BufferWriter</code>, które oddziela i kontroluje bufor oraz flush, jest lepsze.</p>
<p>Jeśli chcesz wykonać pełne, strumieniowe zapisanie, zobacz sekcję <a href="#streaming-serialization">Streaming Serialization</a>.</p>
<h3>MemoryPackSerializerOptions</h3>
<p><code>MemoryPackSerializerOptions</code> konfiguruje, czy ciągi znaków są serializowane jako UTF16, czy UTF8. Można to skonfigurować, przekazując <code>MemoryPackSerializerOptions.Utf8</code> dla kodowania UTF8, <code>MemoryPackSerializerOptions.Utf16</code> dla UTF16 lub <code>MemoryPackSerializerOptions.Default</code>, które domyślnie ustawia UTF8. Przekazanie null lub użycie parametru domyślnego skutkuje kodowaniem UTF8.</p>
<p>Ponieważ wewnętrzna reprezentacja stringów w C# to UTF16, UTF16 jest bardziej wydajne. Jednak rozmiar danych może być większy; w UTF8 ciąg ASCII to jeden bajt, podczas gdy w UTF16 to dwa bajty. Ponieważ różnica w rozmiarze danych może być znaczna, domyślnie ustawione jest UTF8.</p>
<p>Jeśli dane są nie-ASCII (np. japoński, który może zajmować więcej niż 3 bajty i UTF8 jest większe), lub jeśli musisz kompresować je osobno, lepsze wyniki może dać UTF16.</p>
<p>Podczas serializacji można wybrać UTF8 lub UTF16, nie trzeba tego jednak określać przy deserializacji. Zostanie to wykryte automatycznie i zdeserializowane prawidłowo.</p>
<p>Dodatkowo możesz pobrać/ustawić <code>IServiceProvider? ServiceProvider { get; init; }</code> z opcji. Przydatne do pobierania obiektu DI (np. <code>ILogger&lt;T&gt;</code>) w trakcie procesu serializacji (<code>MemoryPackReader/MemoryPackWriter</code> posiadają właściwość .Options).</p>
<h2>Deserialize API</h2>
<p><code>Deserialize</code> posiada przeciążenia dla <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>, <code>Stream</code> oraz wsparcie dla <code>ref</code>.</p>
<pre><code class="language-csharp hljs">T? Deserialize&lt;T&gt;(ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer)
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
T? <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer</span>)
<span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
<span class="hljs-keyword">async</span> <span class="hljs-title">ValueTask</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream</span>)
</span></code></pre>
<p>Przeciążenie <code>ref</code> nadpisuje istniejącą instancję; szczegóły w sekcji <a href="#overwrite">Overwrite</a>.</p>
<p><code>DeserializeAsync(Stream)</code> nie jest pełną operacją odczytu strumieniowego – najpierw czyta do wewnętrznego bufora MemoryPack aż do końca strumienia, a następnie deserializuje.</p>
<p>Jeśli chcesz wykonać pełny odczyt strumieniowy, zobacz sekcję <a href="#streaming-serialization">Streaming Serialization</a>.</p>
<h2>Overwrite</h2>
<p>Aby ograniczyć alokacje, MemoryPack umożliwia deserializację do istniejącej instancji, nadpisując ją. Można to wykorzystać przez przeciążenie <code>Deserialize(ref T? value)</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(person);

<span class="hljs-comment">// nadpisz dane do istniejącej instancji.</span>
MemoryPackSerializer.Deserialize(bin, <span class="hljs-keyword">ref</span> person);
</code></pre>
<p>MemoryPack spróbuje nadpisać tyle, ile możliwe, ale jeśli poniższe warunki nie są spełnione, zostanie utworzona nowa instancja (jak przy normalnej deserializacji).</p>
<ul>
<li>ref value (w tym członkowie grafu obiektów) to null, ustaw nową instancję</li>
<li>dozwolony jest tylko konstruktor bezparametrowy, jeśli używany jest konstruktor z parametrami, tworzona jest nowa instancja</li>
<li>jeśli wartość to <code>T[]</code>, ponowne użycie tylko przy tej samej długości, w przeciwnym razie nowa instancja</li>
<li>jeśli wartość to kolekcja, która ma metodę <code>.Clear()</code> (<code>List&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentBag&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>), wywołaj Clear() i użyj ponownie, w przeciwnym razie utwórz nową instancję</li>
</ul>
<h2>Odporność na wersje</h2>
<p>Domyślnie (<code>GenerateType.Object</code>) MemoryPack obsługuje ograniczoną ewolucję schematu.</p>
<ul>
<li>struktury niezarządzane nie mogą być już zmieniane</li>
<li>można dodawać członków, ale nie można ich usuwać</li>
<li>można zmieniać nazwę członka</li>
<li>nie można zmieniać kolejności członków</li>
<li>nie można zmieniać typu członka</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Dodanie jest OK.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? AddedProp { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Usunięcie jest NG.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-comment">// public int Prop1 { get; set; }</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Zmiana kolejności jest NG.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>W zastosowaniach, przechowywanie starych danych (do pliku, do redis, itd.) i odczyt do nowego schematu jest zawsze poprawny. W scenariuszu RPC, schemat istnieje po stronie klienta i serwera, klient musi zostać zaktualizowany przed serwerem. Zaktualizowany klient nie ma problemu z połączeniem ze starym serwerem, ale stary klient nie może połączyć się z nowym serwerem.</p>
<p>Domyślnie, gdy stare dane są odczytywane do nowego schematu, wszyscy członkowie nieobecni po stronie danych są inicjowani z literalem <code>default</code>.<br>Jeśli chcesz tego uniknąć i użyć wartości początkowych pól/właściwości, możesz użyć <code>[SuppressDefaultInitialization]</code>.</p>
<pre><code class="language-cs hljs language-csharp">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DefaultValue</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">SuppressDefaultInitialization</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">111</span>; <span class="hljs-comment">// &lt; jeśli stare dane są nieobecne, ustaw `111`.</span>
    
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">222</span>; <span class="hljs-comment">// &lt; jeśli stare dane są nieobecne, ustaw `default`.</span>
}
</code></pre>
<p> <code>[SuppressDefaultInitialization]</code> ma następujące ograniczenia:</p>
<ul>
<li>Nie może być używane z readonly, init-only i modyfikatorem required.</li>
</ul>
<p>Następna sekcja <a href="#serialization-info">Serialization info</a> pokazuje, jak sprawdzać zmiany schematu, np. przez CI, aby zapobiegać błędom.</p>
<p>Przy użyciu <code>GenerateType.VersionTolerant</code> obsługiwana jest pełna odporność na wersje.</p>
<ul>
<li>struktura niezarządzana nie może być już zmieniana</li>
<li>wszyscy członkowie muszą mieć jawnie dodany <code>[MemoryPackOrder]</code> (z wyjątkiem adnotacji <code>SerializeLayout.Sequential</code>)</li>
<li>członków można dodawać, można usuwać, ale nie można ponownie używać numerów porządkowych (można używać brakujących numerów)</li>
<li>można zmieniać nazwę członka</li>
<li>nie można zmieniać kolejności członków</li>
<li>nie można zmieniać typu członka</li>
</ul>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Możliwa serializacja/deserializacja w obu kierunkach </span>
<span class="hljs-comment">// VersionTolerantObject1 -&gt; VersionTolerantObject2 oraz </span>
<span class="hljs-comment">// VersionTolerantObject2 -&gt; VersionTolerantObject1</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject1</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject2</span>
{
```csharp
[<span class="hljs-meta">MemoryPackOrder(0)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// usunięto</span>
<span class="hljs-comment">//[MemoryPackOrder(1)]</span>
<span class="hljs-comment">//public long MyProperty1 { get; set; } = default;</span>

[<span class="hljs-meta">MemoryPackOrder(2)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// dodano</span>
[<span class="hljs-meta">MemoryPackOrder(3)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Jeśli jawnie ustawisz SerializeLayout.Sequential, pozwala to na automatyczne nadawanie kolejności.</span>
<span class="hljs-comment">// Jednak nie można usuwać żadnego członka dla wersji tolerancyjnej.</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<p><code>GenerateType.VersionTolerant</code> jest wolniejszy niż <code>GenerateType.Object</code> podczas serializacji. Dodatkowo, rozmiar danych wyjściowych będzie nieco większy.</p>
<h2>Informacje o serializacji</h2>
<p>Możesz sprawdzić w IntelliSense, które członkowie danego typu są serializowane. Istnieje opcja zapisania tych informacji do pliku podczas kompilacji. Ustaw <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> w następujący sposób.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- zapisz informacje o serializacji memorypack do katalogu --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_SerializationInfoOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\MemoryPackLogs<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>Następujące informacje są zapisywane do pliku.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p>
<p>Jeśli typ jest niezarządzany, przed nazwą typu pojawi się <code>unmanaged</code>.</p>
<pre><code class="language-txt hljs language-plaintext">unmanaged FooStruct
---
int x
int y
</code></pre>
<p>Porównując różnice w tym pliku, można zapobiec niebezpiecznym zmianom schematu. Na przykład, możesz użyć CI do wykrywania następujących reguł:</p>
<ul>
<li>modyfikacja typu niezarządzanego</li>
<li>zmiana kolejności członków</li>
<li>usunięcie członka</li>
</ul>
<h2>Cykliczne referencje</h2>
<p>MemoryPack obsługuje również cykliczne referencje. Pozwala to na serializację obiektów drzewiastych bez zmian.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// aby włączyć cykliczne referencje, użyj GenerateType.CircularReference</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> Node? Parent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Node[]? Children { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p> Na przykład, kod <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references">System.Text.Json preserve-references</a> będzie wyglądał tak:</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0</span>
Employee tyler = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Tyler Stein"</span>
};

Employee adrian = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Adrian King"</span>
};

tyler.DirectReports = <span class="hljs-keyword">new</span> List&lt;Employee&gt; { adrian };
adrian.Manager = tyler;

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize&lt;Employee&gt;(bin);

Console.WriteLine(tylerDeserialized?.DirectReports?[<span class="hljs-number">0</span>].Manager == tylerDeserialized); <span class="hljs-comment">// true</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Employee? Manager { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> List&lt;Employee&gt;? DirectReports { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>GenerateType.CircularReference</code> ma te same cechy co wersja tolerancyjna. Jednak jako dodatkowe ograniczenie, dozwolone są tylko konstruktory bezparametrowe. Dodatkowo, śledzenie referencji obiektów wykonywane jest tylko dla obiektów oznaczonych <code>GenerateType.CircularReference</code>. Jeśli chcesz śledzić inny obiekt, opakuj go.</p>
<h2>CustomFormatter</h2>
<p>Jeśli zaimplementujesz <code>MemoryPackCustomFormatterAttribute&lt;T&gt;</code> lub <code>MemoryPackCustomFormatterAttribute&lt;TFormatter, T&gt;</code> (bardziej wydajne, ale bardziej złożone), możesz skonfigurować użycie własnego formatera dla członka MemoryPackObject.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Attribute</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> IMemoryPackFormatter&lt;T&gt; <span class="hljs-title">GetFormatter</span>()</span>;
}
</code></pre>
<p>MemoryPack udostępnia następujące atrybuty formatowania: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute&lt;TValue&gt;</code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter&lt;T&gt;</code>, <code>MemoryPoolFormatter&lt;T&gt;</code>, <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// serializuje ten członek jako UTF16 String, jest to szybsze niż UTF8, ale dla ASCII rozmiar jest większy (dla znaków nie-ASCII, czasem mniejszy).</span>
    [<span class="hljs-meta">Utf16StringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Text { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment">// Podczas deserializacji Dictionary jest inicjalizowany z StringComparer.OrdinalIgnoreCase.</span>
    [<span class="hljs-meta">OrdinalIgnoreCaseStringDictionaryFormatter&lt;int&gt;</span>]
    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;? Ids { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    
    <span class="hljs-comment">// Podczas deserializacji wszystkie stringi są internowane (patrz: String.Intern). Jeśli podobne wartości powtarzają się, oszczędza to pamięć.</span>
    [<span class="hljs-meta">InternStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Flag { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Aby skonfigurować comparer równości dla set/dictionary, wszystkie wbudowane formatery mają przeciążenie konstruktora z comparerem. Możesz łatwo utworzyć własne formatery z porównywaniem równości.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OrdinalIgnoreCaseStringDictionaryFormatter</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>?&gt;&gt;
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt; formatter = <span class="hljs-keyword">new</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt;(StringComparer.OrdinalIgnoreCase);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> IMemoryPackFormatter&lt;Dictionary&lt;<span class="hljs-built_in">string</span>, TValue?&gt;&gt; GetFormatter()
    {
        <span class="hljs-keyword">return</span> formatter;
    }
}
</code></pre>
<p><code>BitPackFormatter</code> kompresuje tylko typy <code>bool[]</code>. <code>bool[]</code> jest normalnie serializowane jako 1 bajt na wartość, jednak <code>BitPackFormatter</code> serializuje <code>bool[]</code> jak <code>BitArray</code>, zapisując każdą wartość jako 1 bit. Używając <code>BitPackFormatter</code>, 8 wartości bool staje się 1 bajtem zamiast 8, co daje 8-krotne zmniejszenie rozmiaru.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BitPackFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[]? Data { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter</code> jest przeznaczony dla <code>byte[]</code>, na przykład możesz skompresować duży payload za pomocą Brotli.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliStringFormatter</code> jest przeznaczony dla <code>string</code>, serializuje skompresowany string (UTF16) przy użyciu Brotli.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? LargeText { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter&lt;T&gt;</code> jest przeznaczony dla dowolnego typu, dane zserializowane są kompresowane przez Brotli. Jeśli typem jest <code>byte[]</code> lub <code>string</code>, dla wydajności powinieneś użyć <code>BrotliFormatter</code> lub <code>BrotliStringFormatter</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter&lt;ChildType&gt;</span>]
    <span class="hljs-keyword">public</span> ChildType? Child { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>Deserializacja z wykorzystaniem puli tablic</h2>
<p>Aby deserializować dużą tablicę (dowolnego typu <code>T</code>), MemoryPack oferuje wiele wydajnych metod z wykorzystaniem puli. Najbardziej efektywną metodą jest użycie funkcji <a href="#overwrite">#Overwrite</a>. W szczególności <code>List&lt;T&gt;</code> jest zawsze ponownie wykorzystywana.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ListBytesSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">byte</span>&gt; Payload</span> { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// ----</span>

<span class="hljs-comment">// List&lt;byte&gt; jest ponownie wykorzystywana, brak alokacji przy deserializacji.</span>
MemoryPackSerializer.Deserialize&lt;ListBytesSample&gt;(bin, <span class="hljs-keyword">ref</span> reuseObject);

<span class="hljs-comment">// dla wydajnej operacji można uzyskać Span&lt;T&gt; przez CollectionsMarshal</span>
<span class="hljs-keyword">var</span> span = CollectionsMarshal.AsSpan(<span class="hljs-keyword">value</span>.Payload);
</code></pre>
<p>Wygodnym sposobem jest deserializacja do ArrayPool w czasie deserializacji. MemoryPack udostępnia <code>MemoryPoolFormatter&lt;T&gt;</code> i <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PoolModelSample</span> : <span class="hljs-title">IDisposable</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; }

    [<span class="hljs-meta">MemoryPoolFormatter&lt;byte&gt;</span>]
    <span class="hljs-keyword">public</span> Memory&lt;<span class="hljs-built_in">byte</span>&gt; Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PoolModelSample</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, Memory&lt;<span class="hljs-built_in">byte</span>&gt; payload</span>)</span>
    {
        Id = id;
        Payload = payload;
    }

    <span class="hljs-comment">// Kod zwracający zasoby należy napisać samodzielnie, poniżej fragment.</span>

    <span class="hljs-built_in">bool</span> usePool;

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized</span>()</span>
    {
        usePool = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span>
    {
        <span class="hljs-keyword">if</span> (!usePool) <span class="hljs-keyword">return</span>;

        Return(Payload); Payload = <span class="hljs-literal">default</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Memory&lt;T&gt; memory</span>)</span> =&gt; Return((ReadOnlyMemory&lt;T&gt;)memory);

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlyMemory&lt;T&gt; memory</span>)</span>
    {
        <span class="hljs-keyword">if</span> (MemoryMarshal.TryGetArray(memory, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> segment) &amp;&amp; segment.Array <span class="hljs-keyword">is</span> { Length: &gt; <span class="hljs-number">0</span> })
        {
            ArrayPool&lt;T&gt;.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;());
        }
    }
}

<span class="hljs-comment">// ---</span>

<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;PoolModelSample&gt;(bin))
{
    <span class="hljs-comment">// wykonaj dowolne operacje...</span>
}   <span class="hljs-comment">// zwraca do ArrayPool</span>
</code></pre>
<h2>Wydajność</h2>
<p>Zobacz mój wpis na blogu <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p>
<h2>Rozmiar payload i kompresja</h2>
<p>Rozmiar payload zależy od wartości docelowej; w przeciwieństwie do JSON nie ma kluczy i jest to format binarny, więc rozmiar payload będzie prawdopodobnie mniejszy niż w JSON.</p>
<p>Dla formatów z kodowaniem varint, takich jak MessagePack i Protobuf, MemoryPack ma tendencję do generowania większych plików, jeśli często używane są liczby typu int (w MemoryPack inty zawsze mają 4 bajty ze względu na kodowanie o stałym rozmiarze, podczas gdy w MessagePack mają 1~5 bajtów).</p>
<p>float i double mają w MemoryPack odpowiednio 4 i 8 bajtów, ale w MessagePack 5 i 9 bajtów. Zatem w przypadku np. tablic Vector3 (float, float, float) MemoryPack będzie mniejszy.</p>
<p>String jest domyślnie kodowany jako UTF8, co jest podobne do innych serializerów, ale jeśli wybrana zostanie opcja UTF16, będzie miał inny charakter.</p>
<p>W każdym przypadku, jeśli payload jest duży, należy rozważyć kompresję. Zalecane są LZ4, ZStandard oraz Brotli.</p>
<h3>Kompresja</h3>
<p>MemoryPack udostępnia wydajny helper dla kompresji <a href="https://github.com/google/brotli">Brotli</a> przez <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder">BrotliEncoder</a> oraz <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder">BrotliDecoder</a>. <code>BrotliCompressor</code> oraz <code>BrotliDecompressor</code> z MemoryPack oferują kompresję/dekompresję zoptymalizowaną pod kątem wewnętrznego działania MemoryPack.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// Kompresja (wymaga using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> compressor = <span class="hljs-keyword">new</span> BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, <span class="hljs-keyword">value</span>);

<span class="hljs-comment">// Uzyskaj skompresowany byte[]</span>
<span class="hljs-keyword">var</span> compressedBytes = compressor.ToArray();

<span class="hljs-comment">// Lub zapisz do innego IBufferWriter&lt;byte&gt; (np. PipeWriter)</span>
compressor.CopyTo(response.BodyWriter);
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// Dekompresja (wymaga using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> decompressor = <span class="hljs-keyword">new</span> BrotliDecompressor();

<span class="hljs-comment">// Uzyskaj zdekompresowany ReadOnlySequence&lt;byte&gt; z ReadOnlySpan&lt;byte&gt; lub ReadOnlySequence&lt;byte&gt;</span>
<span class="hljs-keyword">var</span> decompressedBuffer = decompressor.Decompress(buffer);

<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;T&gt;(decompressedBuffer);
</code></pre>
<p>Zarówno <code>BrotliCompressor</code>, jak i <code>BrotliDecompressor</code> to struktury, nie alokują pamięci na stercie. Oba przechowują skompresowane lub zdekompresowane dane w wewnętrznej puli pamięci dla Serialize/Deserialize. Dlatego konieczne jest zwolnienie puli pamięci – nie zapomnij o użyciu <code>using</code>.</p>
<p>Poziom kompresji jest bardzo istotny. Domyślnie ustawiony jest na quality-1 (CompressionLevel.Fastest), co różni się od domyślnego poziomu w .NET (CompressionLevel.Optimal, quality-4).</p>
<p>Fastest (quality-1) będzie zbliżony szybkością do <a href="https://github.com/lz4/lz4">LZ4</a>, ale jakość 4 jest znacznie wolniejsza. Uznano to za kluczowe w przypadku zastosowań serializera. Zachowaj ostrożność przy używaniu standardowego <code>BrotliStream</code> (domyślnie quality-4). W każdym przypadku prędkości i rozmiary kompresji/dekompresji będą się bardzo różnić w zależności od danych. Przygotuj dane, które będą obsługiwane w Twojej aplikacji i przetestuj to samodzielnie.</p>
<p>Zwróć uwagę, że pomiędzy niekompresowanym MemoryPack a kompresją Brotli występuje kilkukrotny spadek wydajności.</p>
<p>Brotli jest również obsługiwany w niestandardowym formaterze. <code>BrotliFormatter</code> może kompresować konkretny człon.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>Serializacja typów zewnętrznych</h2>
<p>Jeśli chcesz serializować typy zewnętrzne, możesz stworzyć niestandardowy formatter i zarejestrować go w providerze, szczegóły znajdziesz w <a href="#formatterprovider-api">Formatter/Provider API</a>. Jednak stworzenie własnego formattera jest trudne. Dlatego zalecamy stworzenie typu wrappera. Przykładowo, jeśli chcesz serializować typ zewnętrzny o nazwie <code>AnimationCurve</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">struct</span> SerializableAnimationCurve
{
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimationCurve AnimationCurve;

    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode preWrapMode =&gt; AnimationCurve.preWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode postWrapMode =&gt; AnimationCurve.postWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    Keyframe[] keys =&gt; AnimationCurve.keys;

    [<span class="hljs-meta">MemoryPackConstructor</span>]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        <span class="hljs-keyword">var</span> curve = <span class="hljs-keyword">new</span> AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        <span class="hljs-keyword">this</span>.AnimationCurve = curve;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SerializableAnimationCurve</span>(<span class="hljs-params">AnimationCurve animationCurve</span>)</span>
    {
        <span class="hljs-keyword">this</span>.AnimationCurve = animationCurve;
    }
}
</code></pre>
<p>Typ do opakowania jest publiczny, ale wykluczony z serializacji (<code>MemoryPackIgnore</code>). Właściwości, które chcesz serializować, są prywatne, ale dołączone (<code>MemoryPackInclude</code>). Należy również przygotować dwa wzorce konstruktorów. Konstruktor używany przez serializer powinien być prywatny.</p>
<p>W obecnej postaci należy go opakowywać za każdym razem, co jest niewygodne. Dodatkowo wrapper w formie struktury nie może reprezentować null. Stwórzmy więc niestandardowy formatter.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimationCurveFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">AnimationCurve</span>&gt;
{
    <span class="hljs-comment">// Unity nie obsługuje scoped i TBufferWriter, więc zmień sygnaturę na `Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)`</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
```csharp
{
    writer.WriteNullObjectHeader();
    <span class="hljs-keyword">return</span>;
}

writer.WritePackable(<span class="hljs-keyword">new</span> SerializableAnimationCurve(<span class="hljs-keyword">value</span>));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (reader.PeekIsNull())
    {
        reader.Advance(<span class="hljs-number">1</span>); <span class="hljs-comment">// pomiń blok null</span>
        <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">var</span> wrapped = reader.ReadPackable&lt;SerializableAnimationCurve&gt;();
    <span class="hljs-keyword">value</span> = wrapped.AnimationCurve;
}
}
</code></pre>
<p>Na końcu zarejestruj formatter przy uruchamianiu aplikacji.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register&lt;AnimationCurve&gt;(<span class="hljs-keyword">new</span> AnimationCurveFormatter());
</code></pre>
<blockquote>
<p>Uwaga: AnimationCurve w Unity jest domyślnie serializowalny, więc nie wymaga niestandardowego formatera dla AnimationCurve</p>
</blockquote>
<h2>Pakiety</h2>
<p>MemoryPack udostępnia następujące pakiety.</p>
<ul>
<li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li>
</ul>
<p><code>MemoryPack</code> to główna biblioteka zapewniająca pełne wsparcie dla wysokowydajnej serializacji i deserializacji binarnych obiektów. Zależy od <code>MemoryPack.Core</code> (biblioteki bazowe) oraz <code>MemoryPack.Generator</code> (generowanie kodu). <code>MemoryPack.Streaming</code> dodaje rozszerzenia do <a href="#streaming-serialization">Serializacji strumieniowej</a>. <code>MemoryPack.AspNetCoreMvcFormatter</code> dodaje formatery wejścia/wyjścia dla ASP.NET Core. <code>MemoryPack.UnityShims</code> dodaje typy shim i formatery dla współdzielenia typów pomiędzy .NET a Unity.</p>
<h2>TypeScript oraz ASP.NET Core Formatter</h2>
<p>MemoryPack obsługuje generowanie kodu TypeScript. Generuje klasy oraz kod serializacji z C#, innymi słowy możesz współdzielić typy z przeglądarką bez użycia OpenAPI, proto itp.</p>
<p>Generowanie kodu jest zintegrowane z Source Generator. Poniższa opcja (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) ustawia katalog wyjściowy dla kodu TypeScript. Kod runtime jest generowany równocześnie, więc nie są wymagane żadne dodatkowe zależności.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- wyprowadź kod TypeScript memorypack do katalogu --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>Typ C# MemoryPackable musi być oznaczony atrybutem <code>[GenerateTypeScript]</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">GenerateTypeScript</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> required Guid Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> FirstName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> LastName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required DateTime DateOfBirth { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required Gender Gender { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span>[] Emails { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Gender
{
    Male, Female, Other
}
</code></pre>
<p>Kod runtime oraz typy TypeScript zostaną wygenerowane w docelowym katalogu.</p>
<p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p>
<p>Wygenerowany kod wygląda następująco, z prostymi polami oraz statycznymi metodami serialize/serializeArray oraz deserialize/deserializeArray.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackWriter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackWriter.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackReader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackReader.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Gender</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./Gender.js"</span>; 

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">dateOfBirth</span>: <span class="hljs-title class_">Date</span>;
    <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>;
    <span class="hljs-attr">emails</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArray</span>(<span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArrayCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArray</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArrayCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }
}
</code></pre>
<p>Możesz używać tego typu w następujący sposób.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
person.<span class="hljs-property">id</span> = crypto.<span class="hljs-title function_">randomUUID</span>();
person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;
person.<span class="hljs-property">firstName</span> = <span class="hljs-string">"foo"</span>;
person.<span class="hljs-property">lastName</span> = <span class="hljs-string">"bar"</span>;
person.<span class="hljs-property">dateOfBirth</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1999</span>, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
person.<span class="hljs-property">gender</span> = <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Other</span>;
person.<span class="hljs-property">emails</span> = [<span class="hljs-string">"foo@bar.com"</span>, <span class="hljs-string">"zoo@bar.net"</span>];

<span class="hljs-comment">// serializacja do Uint8Array</span>
<span class="hljs-keyword">let</span> bin = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">serialize</span>(person);

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([bin.<span class="hljs-property">buffer</span>], { <span class="hljs-attr">type</span>: <span class="hljs-string">"application/x-memorypack"</span> })

<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"http://localhost:5260/api"</span>,
    { <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>, <span class="hljs-attr">body</span>: blob, <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/x-memorypack"</span> } });

<span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();

<span class="hljs-comment">// deserializacja z ArrayBuffer </span>
<span class="hljs-keyword">let</span> person2 = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">deserialize</span>(buffer);
</code></pre>
<p>Pakiet <code>MemoryPack.AspNetCoreMvcFormatter</code> dodaje formatery wejścia/wyjścia <code>MemoryPack</code> dla ASP.NET Core MVC. Możesz dodać <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> do ASP.NET Core MVC następującym kodem.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackInputFormatter());
    <span class="hljs-comment">// Jeśli checkContentType: true, wtedy możliwy jest output w wielu formatach (JSON/MemoryPack, itd...). Domyślnie false.</span>
    options.OutputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackOutputFormatter(checkContentType: <span class="hljs-literal">false</span>));
});
</code></pre>
<p>Jeśli wywołujesz z HttpClient, możesz ustawić <code>application/x-memorypack</code> w nagłówku content-type.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> content = <span class="hljs-keyword">new</span> ByteArrayContent(bin)
content.Headers.ContentType = <span class="hljs-keyword">new</span> MediaTypeHeaderValue(<span class="hljs-string">"application/x-memorypack"</span>);
</code></pre>
<h3>Mapowanie typów TypeScript</h3>
<p>Istnieje kilka ograniczeń dotyczących typów, które mogą być generowane. Spośród typów prostych, <code>char</code> i <code>decimal</code> nie są obsługiwane. Nie można również używać typów OpenGenerics.</p>
<table>
<thead>
<tr>
<th>C#</th>
<th>TypeScript</th>
<th>Opis</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>sbyte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>bigint</code></td>
<td></td>
</tr>
</tbody></table>
<pre><code class="hljs language-xml">| `ulong` |  `bigint` |
| `float` |  `number` |
| `double` |  `number` |
| `string` |  `string \| null`  | 
| `Guid` |  `string`  | W TypeScript reprezentowany jako string, ale serializowany/deserializowany jako 16-bajtowa binaria
| `DateTime` | `Date` | DateTimeKind zostanie zignorowany
| `enum` | `const enum` | Typ bazowy `long` i `ulong` nie jest obsługiwany
| `T?` | `T \| null` |
| `T[]` | `T[] \| null` |
| `byte[]` | `Uint8Array \| null` |
| `: ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `T[] \| null` | Obsługuje wszystkie typy implementujące `ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`, np. `List<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`
| `: ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `Set<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> \| null` | Obsługuje wszystkie typy implementujące `ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`, np. `HashSet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`
| `: IDictionary&lt;K,V&gt;` | `Map&lt;K, V&gt; \| null` | Obsługuje wszystkie typy implementujące `IDictionary&lt;K,V&gt;`, np. `Dictionary&lt;K,V&gt;`.
| `[MemoryPackable]` | `class` | Obsługuje tylko klasy
| `[MemoryPackUnion]` | `abstract class` |

`[GenerateTypeScript]` może być stosowany tylko do klas i obecnie nie jest obsługiwany dla struktur.

### Konfiguracja rozszerzenia pliku importu i konwencji nazewnictwa członków

Domyślnie MemoryPack generuje rozszerzenie pliku jako `.js`, np. `import { MemoryPackWriter } from "./MemoryPackWriter.js";`. Jeśli chcesz użyć innego rozszerzenia lub pustego, użyj `MemoryPackGenerator_TypeScriptImportExtension`, aby to skonfigurować.
Nazwy członków są automatycznie konwertowane do camelCase. Jeśli chcesz używać oryginalnych nazw, ustaw `MemoryPackGenerator_TypeScriptConvertPropertyName` na `false`.

```xml
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptImportExtension"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptConvertPropertyName"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptEnableNullableTypes"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- pozwala na pustą wartość --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- domyślnie true --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- domyślnie false --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> pozwala na odzwierciedlenie adnotacji nullable C# w kodzie TypeScript. Domyślnie jest wyłączone (false), więc wszystko jest nullable.</p>
<h2>Serializacja strumieniowa</h2>
<p><code>MemoryPack.Streaming</code> udostępnia <code>MemoryPackStreamingSerializer</code>, który zapewnia dodatkowe wsparcie dla serializacji i deserializacji kolekcji przez strumienie.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackStreamingSerializer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeWriter pipeWriter, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeReader pipeReader, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, [EnumeratorCancellation] CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
}
</span></code></pre>
<h2>Formatter/Provider API</h2>
<p>Jeśli chcesz zaimplementować własny formatter, dziedzicz po <code>MemoryPackFormatter&lt;T&gt;</code> i nadpisz metody <code>Serialize</code> oraz <code>Deserialize</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SkeltonFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">Skelton</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
        {
            writer.WriteNullObjectHeader();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// użyj metod writer'a.</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (!reader.TryReadObjectHeader(<span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> count))
        {
            <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// użyj metod reader'a.</span>
    }
}
</code></pre>
<p>Utworzony formatter rejestruje się przy pomocy <code>MemoryPackFormatterProvider</code>.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register(<span class="hljs-keyword">new</span> SkeltonFormatter());
</code></pre>
<p>Uwaga: <code>unmanaged struct</code> (niezawierający typów referencyjnych) nie może korzystać z własnego formattera, zawsze serializuje natywny układ pamięci.</p>
<h2>MemoryPackWriter/ReaderOptionalState</h2>
<p>Inicjalizacja <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> wymaga OptionalState. To wrapper na <code>MemoryPackSerializerOptions</code>, który można utworzyć za pomocą <code>MemoryPackWriterOptionalStatePool</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// po zwolnieniu, OptionalState wraca do puli.</span>
<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> writer = <span class="hljs-keyword">new</span> MemoryPackWriter&lt;T&gt;(<span class="hljs-keyword">ref</span> t, state);
}

<span class="hljs-comment">// dla Reader</span>
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> MemoryPackReader(buffer, state);
}
</code></pre>
<h2>Zależność od frameworka docelowego</h2>
<p>MemoryPack udostępnia <code>netstandard2.1</code> oraz <code>net7.0</code>, ale oba nie są kompatybilne. Na przykład, gdy typy MemoryPackable są w projekcie <code>netstandard2.1</code> i używasz ich w projekcie <code>net7.0</code>, pojawi się błąd w czasie wykonywania, taki jak</p>
<blockquote>
<p>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</p>
</blockquote>
<p>Ponieważ net7.0 używa statycznych członków abstrakcyjnych (<code>Virtual static method</code>), które nie są obsługiwane w netstandard2.1, to zachowanie jest zgodne ze specyfikacją.</p>
<p>Projekt .NET 7 nie powinien używać dll netstandard 2.1. Innymi słowy, jeśli aplikacja to projekt .NET 7, wszystkie zależności używające MemoryPack muszą obsługiwać .NET 7. Jeśli więc deweloper biblioteki zależy od MemoryPack, należy skonfigurować podwójny target framework.</p>
<pre><code class="language-xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">TargetFrameworks</span>&gt;</span>netstandard2.1;net7.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFrameworks</span>&gt;</span>
</code></pre>
<h2>RPC</h2>
<p><a href="https://github.com/Cysharp/MagicOnion">Cysharp/MagicOnion</a> to framework grpc-dotnet code-first wykorzystujący MessagePack zamiast protobuf. MagicOnion obsługuje teraz MemoryPack jako warstwę serializacji przez pakiet <code>MagicOnion.Serialization.MemoryPack</code> (preview). Szczegóły: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support">MagicOnion#MemoryPack support</a></p>
<h2>Unity</h2>
<p>Minimalna wspierana wersja Unity to <code>2022.3.12f1</code>.</p>
<p>Podstawowa paczka <code>MemoryPack</code> jest dostępna przez nuget. Jest również dostępna w Unity. Jeśli chcesz uzyskać wsparcie dla wbudowanych typów Unity, dodatkowo udostępniamy rozszerzenie MemoryPack.Unity.</p>
<ol>
<li>Zainstaluj <code>MemoryPack</code> z NuGet przy użyciu <a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a></li>
</ol>
<ul>
<li><p>Otwórz okno z NuGet -&gt; Manage NuGet Packages, wyszukaj "MemoryPack" i naciśnij Install.<br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p>
</li>
<li><p>Jeśli pojawi się błąd konfliktu wersji, wyłącz walidację wersji w Player Settings (Edit -&gt; Project Settings -&gt; Player -&gt; Przewiń w dół i rozwiń "Other Settings", a następnie odznacz "Assembly Version Validation" w sekcji "Configuration").</p>
</li>
</ul>
<ol start="2">
<li>Zainstaluj pakiet <code>MemoryPack.Unity</code> dodając referencję do git URL</li>
</ol>
<ul>
<li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code><br><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot"><br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></li>
</ul>
<p>MemoryPack używa tagów wydania <em>.</em>.*, więc możesz określić wersję np. #1.0.0. Przykład: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p>
<p>Podobnie jak w wersji .NET, kod generowany jest przez generator kodu (<code>MemoryPack.Generator.dll</code>). Implementacja bez refleksji zapewnia również najlepszą wydajność w IL2CPP.</p>
<p>Więcej informacji o Unity i generatorze źródeł znajdziesz w <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">dokumentacji Unity</a>.</p>
<p>Generator źródeł jest oficjalnie używany przez Unity w <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">com.unity.properties</a> oraz <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html">com.unity.entities</a>. Innymi słowy, jest to standard generowania kodu w nowej generacji Unity.</p>
<p>Możesz serializować wszystkie typy unmanaged (takie jak <code>Vector3</code>, <code>Rect</code> itd.) oraz niektóre klasy (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>). Jeśli chcesz serializować inne typy specyficzne dla Unity, zobacz sekcję <a href="#serialize-external-types">Serializacja typów zewnętrznych</a>.</p>
<p>Pod względem wydajności w Unity, MemoryPack jest x3~x10 szybszy od JsonUtility.</p>
<p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p>
<p>Jeśli kod współdzielony używa typów Unity (<code>Vector2</code> itd.), MemoryPack udostępnia pakiet <code>MemoryPack.UnityShims</code> w NuGet.</p>
<p>Paczka <code>MemoryPack.UnityShims</code> zapewnia shim'y dla standardowych struktur Unity (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) oraz niektórych klas (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>).</p>
<blockquote>
<p>[!WARNING]<br>Aktualnie w Unity obowiązują następujące ograniczenia:</p>
</blockquote>
<ol>
<li>Wersja Unity nie obsługuje CustomFormatter.</li>
<li>Jeśli używasz .NET7 lub nowszego, binarny format MemoryPack nie jest w pełni kompatybilny z Unity.<ul>
<li>Problem dotyczy typów wartościowych, dla których jawnie określono <code>[StructLayout(LayoutKind.Auto)]</code>. (Domyślnie dla struktur to <code>LayoutKind.Sequential</code>.) Dla takich typów, binaria serializowane w .NET nie mogą być deserializowane w Unity. Podobnie, binaria serializowane w Unity nie mogą być serializowane po stronie .NET.</li>
<li>Dotyczy to zwykle następujących typów:<ul>
<li><code>DateTimeOffset</code></li>
<li><code>ValueTuple</code></li>
</ul>
</li>
<li>Aktualnie prostym rozwiązaniem jest nieużywanie tych typów.</li>
</ul>
</li>
</ol>
<h2>Native AOT</h2>
<p>Niestety, .NET 7 Native AOT powoduje awarię (<code>Generic virtual method pointer lookup failure</code>) podczas używania MemoryPack z powodu błędu środowiska uruchomieniowego.<br>Ma to zostać naprawione w .NET 8. Użycie wersji preview <code>Microsoft.DotNet.ILCompiler</code> rozwiąże problem w .NET 7. Zobacz <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611">komentarz w issue</a> jak to skonfigurować.</p>
<h2>Specyfikacja binarnego formatu wire</h2>
<p>Typ <code>T</code> zdefiniowany w <code>Serialize&lt;T&gt;</code> i <code>Deserialize&lt;T&gt;</code> nazywany jest schematem C#. Format MemoryPack nie jest formatem samoopisującym. Do deserializacji wymagany jest odpowiadający schemat C#. Te typy istnieją jako wewnętrzna reprezentacja binariów, ale typów nie można określić bez schematu C#.</p>
<p>Endian musi być <code>Little Endian</code>. Jednak referencyjna implementacja C# nie zwraca uwagi na endianness, więc nie można jej używać na maszynach big-endian. Jednak współczesne komputery są zazwyczaj little-endian.</p>
<p>Istnieje osiem typów formatów.</p>
<ul>
<li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>Obiekt z Cyklicznym Odwołaniem</li>
<li>Krotka (Tuple)</li>
<li>Kolekcja</li>
<li>Ciąg znaków (String)</li>
<li>Unia (Union)</li>
</ul>
<h3>Niezarządzana struktura</h3>
<p>Niezarządzana struktura to struktura C# nie zawierająca typów referencyjnych, podobne ograniczenie jak <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>. Serializowany jest układ struktury taki, jaki jest, włącznie z paddingiem.</p>
<h3>Obiekt</h3>
<p><code>(byte memberCount, [values...])</code></p>
<p>Obiekt posiada 1-bajtowy, nieznakowany bajt jako liczbę członków w nagłówku. Liczba członków pozwala na wartości od <code>0</code> do <code>249</code>, <code>255</code> oznacza, że obiekt jest <code>null</code>. Wartości przechowują wartości memorypack dla liczby członków.</p>
<h3>Obiekt odporny na wersje</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], [values...])</code></p>
<p>Obiekt odporny na wersje jest podobny do Obiektu, ale posiada długość bajtową wartości w nagłówku. Varint przestrzega tej specyfikacji: pierwszy sbyte to wartość lub typeCode, a kolejne X bajtów to wartość. 0 do 127 = nieznakowany bajt, -1 do -120 = znakowany bajt, -121 = bajt, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p>
<h3>Obiekt z Cyklicznym Odwołaniem</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])</code><br><code>(250, varint referenceId)</code></p>
<p>Obiekt z Cyklicznym Odwołaniem jest podobny do Obiektu odpornego na wersje, ale jeśli memberCount to 250, następny varint(unsigned-int32) to referenceId. W przeciwnym razie, po byte-length-of-values, zapisywany jest varint referenceId.</p>
<h3>Krotka (Tuple)</h3>
<p><code>(values...)</code></p>
<p>Krotka to kolekcja wartości o stałym rozmiarze, nieprzyjmująca wartości null. W .NET, <code>KeyValuePair&lt;TKey, TValue&gt;</code> oraz <code>ValueTuple&lt;T,...&gt;</code> są serializowane jako Krotka.</p>
<h3>Kolekcja</h3>
<p><code>(int length, [values...])</code></p>
<p>Kolekcja posiada 4-bajtową liczbę całkowitą ze znakiem jako liczbę danych w nagłówku, <code>-1</code> oznacza <code>null</code>. Wartości przechowują wartości memorypack dla liczby length.</p>
<h3>Ciąg znaków (String)</h3>
<p><code>(int utf16-length, utf16-value)</code><br><code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)</code></p>
<p>Ciąg znaków ma dwie formy: UTF16 i UTF8. Jeśli pierwsza 4-bajtowa liczba całkowita ze znakiem to <code>-1</code>, oznacza null. <code>0</code> oznacza pusty ciąg znaków. UTF16 jest taki sam jak kolekcja (serializowany jako <code>ReadOnlySpan&lt;char&gt;</code>, liczba bajtów utf16-value to utf16-length * 2). Jeśli pierwsza liczba całkowita ze znakiem &lt;= <code>-2</code>, wartość jest zakodowana przez UTF8. utf8-byte-count jest kodowany jako dopełnienie, <code>~utf8-byte-count</code> aby uzyskać liczbę bajtów. Następna liczba całkowita ze znakiem to utf16-length, dopuszcza się <code>-1</code>, co oznacza nieznaną długość. utf8-bytes przechowuje bajty o liczbie utf8-byte-count.</p>
<h3>Unia (Union)</h3>
<p><code>(byte tag, value)</code><br><code>(250, ushort tag, value)</code></p>
<p>Pierwszy nieznakowany bajt to tag dla wyróżnionego typu wartości lub flagi, <code>0</code> do <code>249</code> oznacza tag, <code>250</code> oznacza, że następny nieznakowany short to tag, <code>255</code> oznacza, że unia jest <code>null</code>.</p>
<h2>Licencja</h2>
<p>Ta biblioteka jest licencjonowana na podstawie licencji MIT.</p>
<hr>
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-09</p>
<hr>
</div>
    </div>

    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async=""></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
    <script src="view.js"></script>


</body></html>