<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Open AI Tx</title>

    <!-- Primary Meta Tags -->
    <meta name="title" content="Open AI Tx - Markdown Viewer">
    <meta name="description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta name="keywords" content="Open AI Tx, Markdown, GitHub Style, Documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/view.html">
    <meta property="og:title" content="Open AI Tx - Markdown Viewer">
    <meta property="og:description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">

    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="icon.jpg">
    <link rel="apple-touch-icon" href="icon.jpg">

    <!-- Marked.js for Markdown rendering -->
    <script type="text/javascript" async="" src="https://www.statcounter.com/counter/recorder.js"></script><script src="js/marked.min.js"></script>
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="css/github.min.css">
    <script src="js/highlight.min.js"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="view.css">
    <style>
        /* Layout */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .main-container {
            margin: 0 auto;
            width: 100%;
            max-width: 980px;
            padding: 0 20px;
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0 15px;
            }
        }

        /* Image size restrictions */
        .markdown-body img {
            max-width: 100%;
            height: auto;
        }

        /* Existing styles */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f6f8fa;
            border-bottom: 1px solid #e1e4e8;
            position: relative;
        }

        .back-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #0366d6;
            text-decoration: none;
            display: flex;
            align-items: center;
            font-size: 14px;
            padding: 5px 10px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #fff;
        }

        .back-button:hover {
            background-color: #f6f8fa;
            border-color: #0366d6;
        }

        .back-button::before {
            content: "←";
            margin-right: 5px;
            font-size: 16px;
        }

        .header .links {
            margin-top: 10px;
            font-size: 16px;
        }

        .header .links a {
            color: #0366d6;
            text-decoration: none;
            margin-left: 5px;
        }

        .header .links a:hover {
            text-decoration: underline;
        }
        
        /* Language badges styles */
        .language-badges {
            margin-top: 15px;
            text-align: center;
        }
        .language-badges a {
            display: inline-block;
            margin: 2px;
            text-decoration: none;
        }
        .language-badges img {
            height: 20px;
            border-radius: 3px;
        }
        .language-badges a:hover img {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div class="header">
        <a href="javascript:history.back()" class="back-button">Back</a>
        <div class="links">
            GitHub Repository: <a href="https://github.com/Cysharp/MemoryPack" id="githubRepoLink" target="_blank">Cysharp/MemoryPack</a>
        </div>
        <div class="language-badges" id="languageBadges"><a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=en"><img src="https://img.shields.io/badge/EN-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-CN"><img src="https://img.shields.io/badge/简中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-TW"><img src="https://img.shields.io/badge/繁中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ja"><img src="https://img.shields.io/badge/日本語-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ko"><img src="https://img.shields.io/badge/한국어-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=th"><img src="https://img.shields.io/badge/ไทย-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=fr"><img src="https://img.shields.io/badge/Français-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=de"><img src="https://img.shields.io/badge/Deutsch-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=es"><img src="https://img.shields.io/badge/Español-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=it"><img src="https://img.shields.io/badge/Italiano-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ru"><img src="https://img.shields.io/badge/Русский-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pt"><img src="https://img.shields.io/badge/Português-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=nl"><img src="https://img.shields.io/badge/Nederlands-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pl"><img src="https://img.shields.io/badge/Polski-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ar"><img src="https://img.shields.io/badge/العربية-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=tr"><img src="https://img.shields.io/badge/Türkçe-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=vi"><img src="https://img.shields.io/badge/Tiếng Việt-white" alt="version"></a></div>
    </div>

    <div class="main-container">
        <div class="markdown-body" id="content"><h1>MemoryPack</h1>
<p><a href="https://www.nuget.org/packages/MemoryPack"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a><br><a href="https://github.com/Cysharp/MemoryPack/actions"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a><br><a href="https://github.com/Cysharp/MemoryPack/releases"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p>
<p>C# और Unity के लिए शून्य एन्कोडिंग, अत्यधिक प्रदर्शन वाला बाइनरी सीरियलाइज़र।</p>
<p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p>
<blockquote>
<p>तुलना की गई है <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/">Orleans.Serialization</a> के साथ। .NET 7 / Ryzen 9 5950X मशीन द्वारा मापा गया। इन सीरियलाइज़रों में <code>IBufferWriter&lt;byte&gt;</code> विधि है, जिसे <code>ArrayBufferWriter&lt;byte&gt;</code> के उपयोग से सीरियलाइज़ किया गया है और बफर कॉपी को मापने से बचने के लिए पुन: उपयोग किया गया है।</p>
</blockquote>
<p>सामान्य ऑब्जेक्ट्स के लिए, MemoryPack x10 गुना तेज़ और अन्य बाइनरी सीरियलाइज़रों की तुलना में x2 ~ x5 गुना तेज़ है। स्ट्रक्चर एरे के लिए, MemoryPack और भी अधिक शक्तिशाली है, जिसकी गति अन्य सीरियलाइज़रों से x50 ~ x200 गुना अधिक है।</p>
<p>MemoryPack मेरा चौथा सीरियलाइज़र है, इससे पहले मैंने प्रसिद्ध सीरियलाइज़र बनाए हैं, <del><a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a></del>, <del><a href="https://github.com/neuecc/Utf8Json">Utf8Json</a></del>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>। MemoryPack की गति का कारण इसकी C#-विशिष्ट, C#-अनुकूलित बाइनरी फ़ॉर्मेट और मेरे पिछले अनुभव पर आधारित एक अच्छी तरह से ट्यून की गई इम्प्लीमेंटेशन है। यह पूरी तरह से नया डिज़ाइन है, जिसमें .NET 7 और C# 11 तथा Incremental Source Generator ( .NET Standard 2.1 (.NET 5, 6) और Unity के लिए भी सपोर्ट है) का उपयोग किया गया है।</p>
<p>अन्य सीरियलाइज़र कई एन्कोडिंग ऑपरेशन्स करते हैं जैसे VarInt एन्कोडिंग, टैग, स्ट्रिंग आदि। MemoryPack फॉर्मेट शून्य-एन्कोडिंग डिज़ाइन का उपयोग करता है जो संभवतः जितना अधिक C# मेमोरी हो सके, उसे कॉपी करता है। शून्य-एन्कोडिंग FlatBuffers के समान है, लेकिन इसके लिए विशेष प्रकार की आवश्यकता नहीं है, MemoryPack का सीरियलाइज़ेशन लक्ष्य POCO है।</p>
<p>प्रदर्शन के अलावा, MemoryPack में ये विशेषताएँ हैं:</p>
<ul>
<li>आधुनिक I/O APIs का समर्थन (<code>IBufferWriter&lt;byte&gt;</code>, <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>)</li>
<li>Native AOT फ्रेंडली Source Generator आधारित कोड जनरेशन, कोई डायनामिक CodeGen (IL.Emit) नहीं</li>
<li>Reflectionless non-generics APIs</li>
<li>मौजूदा इंस्टेंस में डीसिरियलाइज़ करें</li>
<li>पॉलिमॉर्फिज्म (Union) सीरियलाइज़ेशन</li>
<li>सीमित वर्शन-टोलरेंट (फास्ट/डिफ़ॉल्ट) और पूर्ण वर्शन-टोलरेंट सपोर्ट</li>
<li>Circular reference सीरियलाइज़ेशन</li>
<li>PipeWriter/Reader आधारित स्ट्रीमिंग सीरियलाइज़ेशन</li>
<li>TypeScript कोड जनरेशन और ASP.NET Core Formatter</li>
<li>Unity (2021.3) IL2CPP सपोर्ट .NET Source Generator के माध्यम से</li>
</ul>
<h2>इंस्टॉलेशन</h2>
<p>यह लाइब्रेरी NuGet के माध्यम से वितरित की जाती है। सर्वोत्तम प्रदर्शन के लिए, <code>.NET 7</code> का उपयोग करने की सिफारिश की जाती है। न्यूनतम आवश्यकता <code>.NET Standard 2.1</code> है।</p>
<blockquote>
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/MemoryPack">MemoryPack</a></p>
</blockquote>
<p>साथ ही कोड एडिटर में Roslyn 4.3.1 सपोर्ट होना आवश्यक है, जैसे Visual Studio 2022 version 17.3, .NET SDK 6.0.401। विवरण के लिए, <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support">Roslyn Version Support</a> दस्तावेज़ देखें।</p>
<p>Unity के लिए, आवश्यकताएँ और इंस्टॉलेशन प्रक्रिया पूरी तरह से अलग है। विवरण के लिए <a href="#unity">Unity</a> अनुभाग देखें।</p>
<h2>त्वरित प्रारंभ</h2>
<p>सीरियलाइज़ करने के लिए एक struct या class को परिभाषित करें और उसे <code>[MemoryPackable]</code> एट्रिब्यूट तथा <code>partial</code> कीवर्ड से सजाएँ।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack;

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>सीरियलाइज़ेशन कोड C# सोर्स जनरेटर फीचर द्वारा जनरेट किया जाता है, जो <code>IMemoryPackable&lt;T&gt;</code> इंटरफ़ेस को इम्प्लीमेंट करता है। Visual Studio में आप जेनरेटेड कोड को क्लास नाम पर <code>Ctrl+K, R</code> शॉर्टकट का उपयोग करके और <code>*.MemoryPackFormatter.g.cs</code> चुनकर देख सकते हैं।</p>
<p>किसी ऑब्जेक्ट इंस्टेंस को सीरियलाइज़/डीसीरियलाइज़ करने के लिए <code>MemoryPackSerializer.Serialize&lt;T&gt;/Deserialize&lt;T&gt;</code> कॉल करें।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Person { Age = <span class="hljs-number">40</span>, Name = <span class="hljs-string">"John"</span> };

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(v);
<span class="hljs-keyword">var</span> val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p><code>Serialize</code> मेथड <code>byte[]</code> रिटर्न टाइप को सपोर्ट करती है, साथ ही यह <code>IBufferWriter&lt;byte&gt;</code> या <code>Stream</code> में भी सीरियलाइज़ कर सकती है। <code>Deserialize</code> मेथड <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code> और <code>Stream</code> को सपोर्ट करती है। और नॉन-जनरिक वर्शन भी उपलब्ध हैं।</p>
<h2>बिल्ट-इन सपोर्टेड टाइप्स</h2>
<p>ये टाइप्स डिफ़ॉल्ट रूप से सीरियलाइज़ किए जा सकते हैं:</p>
<ul>
<li>.NET प्रिमिटिव्स (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, आदि)</li>
<li>Unmanaged टाइप्स (कोई भी <code>enum</code>, कोई भी यूज़र-डिफाइन्ड <code>struct</code> जिसमें रेफरेंस टाइप्स न हों)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code>, <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory&lt;&gt;</code>, <code>ReadOnlyMemory&lt;&gt;</code>, <code>ArraySegment&lt;&gt;</code>, <code>ReadOnlySequence&lt;&gt;</code></li>
<li><code>Nullable&lt;&gt;</code>, <code>Lazy&lt;&gt;</code>, <code>KeyValuePair&lt;,&gt;</code>, <code>Tuple&lt;,...&gt;</code>, <code>ValueTuple&lt;,...&gt;</code></li>
<li><code>List&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>SortedSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code></li>
<li><code>Dictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>,  <code>ReadOnlyDictionary&lt;,&gt;</code> </li>
<li><code>Collection&lt;&gt;</code>, <code>ReadOnlyCollection&lt;&gt;</code>, <code>ObservableCollection&lt;&gt;</code>, <code>ReadOnlyObservableCollection&lt;&gt;</code></li>
<li><code>IEnumerable&lt;&gt;</code>, <code>ICollection&lt;&gt;</code>, <code>IList&lt;&gt;</code>, <code>IReadOnlyCollection&lt;&gt;</code>, <code>IReadOnlyList&lt;&gt;</code>, <code>ISet&lt;&gt;</code></li>
<li><code>IDictionary&lt;,&gt;</code>, <code>IReadOnlyDictionary&lt;,&gt;</code>, <code>ILookup&lt;,&gt;</code>, <code>IGrouping&lt;,&gt;</code>,</li>
<li><code>ConcurrentBag&lt;&gt;</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>, <code>BlockingCollection&lt;&gt;</code></li>
<li>Immutable collections (<code>ImmutableList&lt;&gt;</code>, आदि) और इंटरफेसेस (<code>IImmutableList&lt;&gt;</code>, आदि)</li>
</ul>
<h2><code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code> को परिभाषित करें</h2>
<p><code>[MemoryPackable]</code> को किसी भी <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> और <code>interface</code> पर लगाया जा सकता है। यदि कोई टाइप <code>struct</code> या <code>record struct</code> है जिसमें कोई रेफरेंस टाइप नहीं है (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>), तो कोई अतिरिक्त एट्रिब्यूट (ignore, include, constructor, callbacks) उपयोग नहीं होते, इसे सीधे मेमोरी से सीरियलाइज़/डीसीरियलाइज़ किया जाता है।</p>
<p>अन्यथा, डिफ़ॉल्ट रूप से, <code>[MemoryPackable]</code> पब्लिक इंस्टेंस प्रॉपर्टीज़ या फील्ड्स को सीरियलाइज़ करता है। आप <code>[MemoryPackIgnore]</code> का उपयोग करके किसी सीरियलाइज़ेशन टार्गेट को हटा सकते हैं, <code>[MemoryPackInclude]</code> किसी प्राइवेट सदस्य को सीरियलाइज़ेशन टार्गेट में प्रमोट करता है।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// ये टाइप्स डिफ़ॉल्ट रूप से सीरियलाइज़ होते हैं</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicField;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> PublicReadOnlyField;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PrivateSetPublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ReadOnlyPublicProperty { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> RequiredInitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }

    <span class="hljs-comment">// ये टाइप्स डिफ़ॉल्ट रूप से सीरियलाइज़ नहीं होते हैं</span>
    <span class="hljs-built_in">int</span> privateProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-built_in">int</span> privateField;
    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> privateReadOnlyField;

    <span class="hljs-comment">// किसी पब्लिक सदस्य को टार्गेट से हटाने के लिए [MemoryPackIgnore] का उपयोग करें</span>
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty2 =&gt; PublicProperty + PublicField;

    <span class="hljs-comment">// किसी प्राइवेट सदस्य को सीरियलाइज़ेशन टार्गेट में प्रमोट करने के लिए [MemoryPackInclude] का उपयोग करें</span>
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateField2;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>MemoryPack</code> का कोड जनरेटर <code>&lt;remarks /&gt;</code> सेक्शन में यह जानकारी जोड़ता है कि कौन से सदस्य सीरियलाइज़ किए गए हैं। इसे टाइप पर Intellisense के साथ होवर करके देखा जा सकता है।</p>
<p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p>
<p>सभी सदस्यों का मेमोरीपैक-सीरियलाइज़ेबल होना आवश्यक है, यदि नहीं, तो कोड जनरेटर त्रुटि देगा।</p>
<p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p>
<p>MemoryPack में 35 डायग्नोस्टिक्स नियम हैं (<code>MEMPACK001</code> से <code>MEMPACK035</code>) ताकि डिफ़ाइन करना सरल हो।</p>
<p>यदि टार्गेट टाइप का MemoryPack सीरियलाइज़ेशन बाहरी रूप से डिफाइन किया गया है और रजिस्टर्ड है, तो डायग्नोस्टिक्स को साइलेंट करने के लिए <code>[MemoryPackAllowSerialize]</code> का उपयोग करें।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample2</span>
{
    [<span class="hljs-meta">MemoryPackAllowSerialize</span>]
    <span class="hljs-keyword">public</span> NotSerializableType? NotSerializableProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>सदस्यों का क्रम <strong>महत्वपूर्ण</strong> है, MemoryPack सदस्य-नाम या अन्य जानकारी को सीरियलाइज़ नहीं करता, बल्कि फील्ड्स को उनके डिक्लेरेशन क्रम में सीरियलाइज़ करता है। यदि टाइप इनहेरिटेड है, तो सीरियलाइज़ेशन माता-पिता → बच्चे के क्रम में किया जाता है। डीसिरियलाइज़ेशन के लिए सदस्यों का क्रम बदला नहीं जा सकता। स्कीमा इवोल्यूशन के लिए, <a href="#version-tolerant">Version tolerant</a> अनुभाग देखें।</p>
<p>डिफ़ॉल्ट क्रम अनुक्रमिक है, लेकिन आप <code>[MemoryPackable(SerializeLayout.Explicit)]</code> और <code>[MemoryPackOrder()]</code> के साथ स्पष्ट लेआउट चुन सकते हैं।</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Prop0 -&gt; Prop1 को सीरियलाइज़ करें</span>
[<span class="hljs-meta">MemoryPackable(SerializeLayout.Explicit)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleExplicitOrder</span>
{
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h3>कन्स्ट्रक्टर चयन</h3>
<p>MemoryPack पैरामीटराइज्ड और पैरामीटरलेस दोनों कन्स्ट्रक्टर्स को सपोर्ट करता है। कन्स्ट्रक्टर का चयन ये नियम अपनाता है (क्लास और स्ट्रक्चर दोनों पर लागू):</p>
<ul>
<li>यदि <code>[MemoryPackConstructor]</code> है, तो उसी का उपयोग करें।</li>
<li>यदि कोई स्पष्ट कन्स्ट्रक्टर (प्राइवेट सहित) नहीं है, तो पैरामीटरलेस का उपयोग करें।</li>
<li>यदि एक ही पैरामीटरलेस/पैरामीटराइज्ड कन्स्ट्रक्टर (प्राइवेट सहित) है, तो उसी का उपयोग करें।</li>
<li>यदि एक से अधिक कन्स्ट्रक्टर हैं, तो वांछित कन्स्ट्रक्टर पर <code>[MemoryPackConstructor]</code> एट्रिब्यूट लगाया जाना चाहिए (जनरेटर अपने आप कोई नहीं चुनेगा), अन्यथा जनरेटर त्रुटि देगा।</li>
<li>यदि पैरामीटराइज्ड कन्स्ट्रक्टर का उपयोग करते हैं, तो सभी पैरामीटर नाम संबंधित सदस्य नामों से मेल खाने चाहिए (केस-इन्सेंसिटिव)।</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Name;

    <span class="hljs-comment">// आप पैरामीटराइज्ड कन्स्ट्रक्टर का उपयोग कर सकते हैं - पैरामीटर नाम संबंधित सदस्यों के नाम से मेल खाने चाहिए (केस-इन्सेंसिटिव)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Age = age;
        <span class="hljs-keyword">this</span>.Name = name;
    }
}

<span class="hljs-comment">// रिकॉर्ड प्राइमरी कन्स्ट्रक्टर भी सपोर्टेड है</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Person2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Age, <span class="hljs-built_in">string</span> Name</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>()</span>
    {
    }
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// यदि एक से अधिक कंस्ट्रक्टर हैं, तो [MemoryPackConstructor] का उपयोग किया जाना चाहिए</span>
[<span class="hljs-meta">MemoryPackConstructor</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
{
    <span class="hljs-keyword">this</span>.Age = age;
    <span class="hljs-keyword">this</span>.Name = name;
}
</code></pre>
<h3>सीरियलाइज़ेशन कॉलबैक</h3>
<p>सीरियलाइज़/डिसीरियलाइज़ करते समय, MemoryPack <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code> एट्रिब्यूट्स का उपयोग कर के पहले/बाद में इवेंट को इनवोक कर सकता है। यह दोनों static और instance (non-static) मेथड्स, और public तथा private मेथड्स पर एनोनेट किया जा सकता है।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MethodCallSample</span>
{
    <span class="hljs-comment">// मेथड कॉल ऑर्डर है static -&gt; instance</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing1));
    }

    <span class="hljs-comment">// प्राइवेट मेथड भी अनुमति है</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing2));
    }

    <span class="hljs-comment">// serializing -&gt; /* serialize */ -&gt; serialized</span>
    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized1));
    }

    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing1));
    }

    <span class="hljs-comment">// नोट: instance मेथड जिसमें MemoryPackOnDeserializing है, वह तब नहीं कॉल होता अगर instance `ref` से पास न हो</span>
    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized1));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized2));
    }
}
</code></pre>
<p>कॉलबैक बिना पैरामीटर वाले मेथड और <code>ref reader/writer, ref T value</code> मेथड की अनुमति देता है। उदाहरण के लिए, ref कॉलबैक सीरियलाइज़ेशन प्रोसेस से पहले कस्टम हेडर लिख/पढ़ सकते हैं।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EmitIdData</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteId</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)
        <span class="hljs-keyword">where</span> TBufferWriter : IBufferWriter&lt;<span class="hljs-built_in">byte</span>&gt; <span class="hljs-comment">// .NET Standard 2.1, उपयोग करें where TBufferWriter : class, IBufferWriter&lt;byte&gt;</span></span>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); <span class="hljs-comment">// हेडर में GUID लिखें।</span>
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadId</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-comment">// डिसीरियलाइज़ से पहले कस्टम हेडर पढ़ें</span>
        <span class="hljs-keyword">var</span> guid = reader.ReadUnmanaged&lt;Guid&gt;();
        Console.WriteLine(guid);
    }
}
</code></pre>
<p>यदि <code>ref value</code> में कोई मान सेट किया जाए, तो आप सीरियलाइज़ेशन/डिसीरियलाइज़ेशन के लिए उपयोग किए गए मान को बदल सकते हैं। उदाहरण के लिए, ServiceProvider से इंस्टेंसिएट करें।</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// इस फॉर्मेटर का उपयोग करने से पहले, ServiceProvider सेट करें</span>
<span class="hljs-comment">// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };</span>
<span class="hljs-comment">// MemoryPackSerializer.Deserialize(value, options);</span>

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InstantiateFromServiceProvider</span>
{
    <span class="hljs-keyword">static</span> IServiceProvider serviceProvider = <span class="hljs-literal">default</span>!;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> InstantiateFromServiceProvider <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">value</span> = reader.Options.ServiceProvider!.GetRequiredService&lt;InstantiateFromServiceProvider&gt;();
    }
}
</code></pre>
<h2>कस्टम कलेक्शन परिभाषित करें</h2>
<p>डिफ़ॉल्ट रूप से, एनोनेटेड <code>[MemoryPackObject]</code> टाइप अपने सदस्यों को सीरियलाइज़ करने की कोशिश करता है। हालांकि, यदि कोई टाइप कलेक्शन (<code>ICollection&lt;&gt;</code>, <code>ISet&lt;&gt;</code>, <code>IDictionary&lt;,&gt;</code>) है, तो इसे सही तरीके से सीरियलाइज़ करने के लिए <code>GenerateType.Collection</code> का उपयोग करें।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt;
{
}

[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyStringDictionary</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>&gt;
{

}
</code></pre>
<h2>Static constructor</h2>
<p>MemoryPackable क्लास static constructor को परिभाषित नहीं कर सकती क्योंकि जेनेरेटेड partial class इसका उपयोग करती है। इसके बजाय, आप वही कार्य करने के लिए <code>static partial void StaticConstructor()</code> परिभाषित कर सकते हैं।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CctorSample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StaticConstructor</span>()</span>
    {
    }
}
</code></pre>
<h2>Polymorphism (Union)</h2>
<p>MemoryPack इंटरफेस और एब्सट्रैक्ट क्लास ऑब्जेक्ट्स को सीरियलाइज़ करने के लिए पोलीमॉर्फिज्म सीरियलाइज़ेशन का समर्थन करता है। MemoryPack में इस फीचर को Union कहा जाता है। केवल इंटरफेस और एब्सट्रैक्ट क्लासेज को <code>[MemoryPackUnion]</code> एट्रिब्यूट्स के साथ एनोनेट करने की अनुमति है। यूनिक यूनियन टैग्स आवश्यक हैं।</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// [MemoryPackable] और इनहेरिटेंस टाइप्स को [MemoryPackUnion] से एनोनेट करें</span>
<span class="hljs-comment">// Union एब्सट्रैक्ट क्लास को भी सपोर्ट करता है</span>
[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> XYZ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BarClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? OPQ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
<span class="hljs-comment">// ---</span>

IUnionSample data = <span class="hljs-keyword">new</span> FooClass() { XYZ = <span class="hljs-number">999</span> };

<span class="hljs-comment">// इंटरफेस टाइप के रूप में सीरियलाइज़ करें।</span>
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(data);

<span class="hljs-comment">// इंटरफेस टाइप के रूप में डिसीरियलाइज़ करें।</span>
<span class="hljs-keyword">var</span> reData = MemoryPackSerializer.Deserialize&lt;IUnionSample&gt;(bin);

<span class="hljs-keyword">switch</span> (reData)
{
    <span class="hljs-keyword">case</span> FooClass x:
        Console.WriteLine(x.XYZ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BarClass x:
        Console.WriteLine(x.OPQ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-literal">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p><code>tag</code> की अनुमति <code>0</code> ~ <code>65535</code> तक है, यह विशेष रूप से <code>250</code> से कम के लिए कुशल है।</p>
<pre><code class="hljs language-csharp">यदि कोई इंटरफ़ेस और डेराइव्ड टाइप्स अलग-अलग असेंबली में हैं, तो आप इसके बजाय `MemoryPackUnionFormatterAttribute` का उपयोग कर सकते हैं। फॉर्मेटर्स इस प्रकार जनरेट किए जाते हैं कि वे स्वचालित रूप से C<span class="hljs-meta"># 9.0 और उसके ऊपर में `ModuleInitializer` के माध्यम से रजिस्टर हो जाते हैं।</span>

&gt; ध्यान दें कि `ModuleInitializer` यूनिटी में समर्थित नहीं है, इसलिए फॉर्मेटर को मैन्युअली रजिस्टर करना होगा। अपने यूनियन फॉर्मेटर को रजिस्टर करने के लिए स्टार्टअप में `{name of your union formatter}Initializer.RegisterFormatter()` मैन्युअली कॉल करें। उदाहरण के लिए `UnionSampleFormatterInitializer.RegisterFormatter()`।

```csharp
<span class="hljs-comment">// AssemblyA</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.NoGenerate)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

<span class="hljs-comment">// AssemblyB में टारगेट टाइप के बाहर डिफिनिशन डिफाइन करें</span>
[<span class="hljs-meta">MemoryPackUnionFormatter(typeof(IUnionSample))</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnionSampleFormatter</span>
{
}
</code></pre>
<p>यूनियन को कोड में <code>DynamicUnionFormatter&lt;T&gt;</code> के माध्यम से असेंबल किया जा सकता है।</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// (ushort, Type)[]</span>
<span class="hljs-keyword">var</span> formatter = <span class="hljs-keyword">new</span> DynamicUnionFormatter&lt;IFooBarBaz&gt;(
    (<span class="hljs-number">0</span>, <span class="hljs-keyword">typeof</span>(Foo)),
    (<span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(Bar)),
    (<span class="hljs-number">2</span>, <span class="hljs-keyword">typeof</span>(Baz))
);

MemoryPackFormatterProvider.Register(formatter);
</code></pre>
<h2>Serialize API</h2>
<p><code>Serialize</code> के तीन ओवरलोड्स हैं।</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// नॉन-जेनरिक API भी उपलब्ध है, इन वर्शन में पहला आर्ग्युमेंट टाइप होता है और वैल्यू ऑब्जेक्ट?</span>
<span class="hljs-function"><span class="hljs-built_in">byte</span>[] <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> TBufferWriter bufferWriter, <span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
</span></code></pre>
<p>परफॉर्मेंस के लिए, अनुशंसित API <code>BufferWriter</code> का उपयोग करता है। यह सीधे बफर में सीरियलाइज़ करता है। इसे <code>System.IO.Pipelines</code> के <code>PipeWriter</code>, ASP .NET Core के <code>BodyWriter</code> आदि पर लागू किया जा सकता है।</p>
<p>यदि <code>byte[]</code> आवश्यक है (जैसे <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a> में <code>RedisValue</code>), तो रिटर्निंग <code>byte[]</code> API सरल और लगभग उतना ही तेज़ है।</p>
<p>ध्यान दें कि <code>Stream</code> के लिए <code>SerializeAsync</code> केवल Flush के लिए असिंक्रोनस है; यह सब कुछ एक बार MemoryPack के इंटरनल पूल बफर में सीरियलाइज़ करता है और फिर <code>WriteAsync</code> का उपयोग करता है। इसलिए, <code>BufferWriter</code> ओवरलोड, जो बफर और फ्लश को अलग और नियंत्रित करता है, बेहतर है।</p>
<p>यदि आप पूरी तरह से स्ट्रीमिंग राइट करना चाहते हैं, तो <a href="#streaming-serialization">Streaming Serialization</a> सेक्शन देखें।</p>
<h3>MemoryPackSerializerOptions</h3>
<p><code>MemoryPackSerializerOptions</code> यह कॉन्फ़िगर करता है कि स्ट्रिंग्स को UTF16 या UTF8 के रूप में सीरियलाइज़ किया जाए। इसे UTF8 एन्कोडिंग के लिए <code>MemoryPackSerializerOptions.Utf8</code>, UTF16 के लिए <code>MemoryPackSerializerOptions.Utf16</code> या डिफ़ॉल्ट के लिए <code>MemoryPackSerializerOptions.Default</code> (जो डिफ़ॉल्ट रूप से UTF8 है) पास करके सेट किया जा सकता है। null पास करने या डिफ़ॉल्ट पैरामीटर का उपयोग करने पर UTF8 एन्कोडिंग होती है।</p>
<p>चूंकि C# की इंटरनल स्ट्रिंग रिप्रेजेंटेशन UTF16 है, इसलिए UTF16 परफॉर्मेंस में बेहतर है। हालांकि, पेलोड आमतौर पर बड़ा होता है; UTF8 में एक ASCII स्ट्रिंग एक बाइट है, जबकि UTF16 में दो बाइट होती है। इस पेलोड के साइज में बड़ा अंतर होने के कारण, डिफ़ॉल्ट रूप से UTF8 सेट किया गया है।</p>
<p>यदि डेटा नॉन-ASCII है (जैसे जापानी, जो 3 से अधिक बाइट हो सकता है, और UTF8 में बड़ा होता है), या यदि आपको इसे अलग से कंप्रेस करना है, तो UTF16 बेहतर परिणाम दे सकता है।</p>
<p>सीरियलाइज़ेशन के दौरान आप UTF8 या UTF16 चुन सकते हैं, लेकिन डीसिरियलाइज़ेशन के दौरान इसे स्पेसिफाई करना आवश्यक नहीं है। यह स्वचालित रूप से डिटेक्ट और सामान्य रूप से डीसिरियलाइज़ हो जाएगा।</p>
<p>इसके अलावा, आप ऑप्शंस से <code>IServiceProvider? ServiceProvider { get; init; }</code> प्राप्त/सेट कर सकते हैं। यह सीरियलाइज़ेशन प्रोसेस से DI ऑब्जेक्ट (जैसे <code>ILogger&lt;T&gt;</code>) प्राप्त करने में उपयोगी है (<code>MemoryPackReader/MemoryPackWriter</code> में .Options प्रॉपर्टी है)।</p>
<h2>Deserialize API</h2>
<p><code>Deserialize</code> में <code>ReadOnlySpan&lt;byte&gt;</code> और <code>ReadOnlySequence&lt;byte&gt;</code>, <code>Stream</code> ओवरलोड और <code>ref</code> सपोर्ट है।</p>
<pre><code class="language-csharp hljs">T? Deserialize&lt;T&gt;(ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer)
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
T? <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer</span>)
<span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
<span class="hljs-keyword">async</span> <span class="hljs-title">ValueTask</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream</span>)
</span></code></pre>
<p><code>ref</code> ओवरलोड मौजूदा इंस्टेंस को ओवरराइट करता है, विवरण के लिए <a href="#overwrite">Overwrite</a> सेक्शन देखें।</p>
<p><code>DeserializeAsync(Stream)</code> पूरी तरह से स्ट्रीमिंग रीड ऑपरेशन नहीं है, पहले यह MemoryPack के इंटरनल पूल में एंड-ऑफ-स्ट्रीम तक पढ़ता है, फिर डीसिरियलाइज़ करता है।</p>
<p>यदि आप पूरी तरह से स्ट्रीमिंग रीड ऑपरेशन करना चाहते हैं, तो <a href="#streaming-serialization">Streaming Serialization</a> सेक्शन देखें।</p>
<h2>Overwrite</h2>
<p>अलोकेशन्स को कम करने के लिए, MemoryPack मौजूदा इंस्टेंस में डीसिरियलाइज़ करके उसे ओवरराइट करने को सपोर्ट करता है। इसे <code>Deserialize(ref T? value)</code> ओवरलोड के साथ उपयोग किया जा सकता है।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(person);

<span class="hljs-comment">// मौजूदा इंस्टेंस में डेटा ओवरराइट करें।</span>
MemoryPackSerializer.Deserialize(bin, <span class="hljs-keyword">ref</span> person);
</code></pre>
<p>MemoryPack जितना संभव हो उतना ओवरराइट करने का प्रयास करेगा, लेकिन यदि निम्नलिखित कंडीशंस मेल नहीं खातीं, तो यह नया इंस्टेंस बनाएगा (सामान्य डीसिरियलाइज़ेशन की तरह)।</p>
<ul>
<li>ref value (ऑब्जेक्ट ग्राफ में मेंबर्स सहित) null है, नया इंस्टेंस सेट करें</li>
<li>केवल पैरामीटरलेस कंस्ट्रक्टर की अनुमति है, यदि पैरामीटराइज्ड कंस्ट्रक्टर का उपयोग किया गया है, तो नया इंस्टेंस बनाएं</li>
<li>यदि value <code>T[]</code> है, तो केवल तभी री-यूज़ करें जब लेंथ समान हो, अन्यथा नया इंस्टेंस बनाएं</li>
<li>यदि value ऐसी कलेक्शन है जिसमें <code>.Clear()</code> मेथड है (<code>List&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentBag&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>) तो Clear() कॉल करें और री-यूज़ करें, अन्यथा नया इंस्टेंस बनाएं</li>
</ul>
<h2>Version tolerant</h2>
<p>डिफ़ॉल्ट में (<code>GenerateType.Object</code>), MemoryPack सीमित स्कीमा इवोल्यूशन को सपोर्ट करता है।</p>
<ul>
<li>unmanaged struct अब बदला नहीं जा सकता</li>
<li>मेंबर्स जोड़े जा सकते हैं, लेकिन हटाए नहीं जा सकते</li>
<li>मेंबर नाम बदला जा सकता है</li>
<li>मेंबर ऑर्डर बदला नहीं जा सकता</li>
<li>मेंबर टाइप बदला नहीं जा सकता</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Add करना ठीक है।</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? AddedProp { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Remove करना NG (नॉट गुड) है।</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-comment">// public int Prop1 { get; set; }</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// ऑर्डर बदलना NG (नॉट गुड) है।</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>उपयोग में, पुराना डेटा (फाइल में, रेडिस में आदि) स्टोर करें और नए स्कीमा में पढ़ना हमेशा ठीक है। RPC परिदृश्य में, स्कीमा क्लाइंट और सर्वर दोनों साइड पर मौजूद होता है, क्लाइंट को सर्वर से पहले अपडेट करना चाहिए। अपडेटेड क्लाइंट को पुराने सर्वर से कनेक्ट करने में कोई समस्या नहीं है, लेकिन पुराना क्लाइंट नए सर्वर से कनेक्ट नहीं कर सकता।</p>
<p>डिफ़ॉल्ट रूप से, जब पुराना डेटा नए स्कीमा में पढ़ा जाता है, तो डेटा साइड पर मौजूद न होने वाले सभी मेंबर्स को <code>default</code> लिटरल से इनिशियलाइज़ किया जाता है।<br>यदि आप इससे बचना चाहते हैं और फील्ड/प्रॉपर्टीज के इनिशियल वैल्यू का उपयोग करना चाहते हैं, तो आप <code>[SuppressDefaultInitialization]</code> का उपयोग कर सकते हैं।</p>
<pre><code class="language-cs hljs language-csharp">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DefaultValue</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">SuppressDefaultInitialization</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">111</span>; <span class="hljs-comment">// &lt; अगर पुराना डेटा मिसिंग है तो `111` सेट करें।</span>
    
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">222</span>; <span class="hljs-comment">// &lt; अगर पुराना डेटा मिसिंग है तो `default` सेट करें।</span>
}
</code></pre>
<p><code>[SuppressDefaultInitialization]</code> की निम्नलिखित सीमाएँ हैं:</p>
<ul>
<li>इसे readonly, init-only, और required मोडिफायर के साथ उपयोग नहीं किया जा सकता।</li>
</ul>
<p>अगला <a href="#serialization-info">Serialization info</a> सेक्शन दिखाता है कि स्कीमा बदलावों की जांच कैसे करें, जैसे CI के द्वारा, दुर्घटनाओं को रोकने के लिए।</p>
<p>जब <code>GenerateType.VersionTolerant</code> का उपयोग करते हैं, तो यह पूर्ण वर्शन-टॉलरेंट को सपोर्ट करता है।</p>
<ul>
<li>unmanaged struct अब बदला नहीं जा सकता</li>
<li>सभी मेंबर्स को स्पष्ट रूप से <code>[MemoryPackOrder]</code> जोड़ना आवश्यक है (सिवाय <code>SerializeLayout.Sequential</code> के)</li>
<li>मेंबर्स जोड़े जा सकते हैं, हटाए जा सकते हैं लेकिन ऑर्डर को री-यूज़ नहीं किया जा सकता (मिसिंग ऑर्डर का उपयोग कर सकते हैं)</li>
<li>मेंबर नाम बदला जा सकता है</li>
<li>मेंबर ऑर्डर बदला नहीं जा सकता</li>
<li>मेंबर टाइप बदला नहीं जा सकता</li>
</ul>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// दोनों को serialize/deserialize करना ठीक है </span>
<span class="hljs-comment">// VersionTolerantObject1 -&gt; VersionTolerantObject2 और </span>
<span class="hljs-comment">// VersionTolerantObject2 -&gt; VersionTolerantObject1</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject1</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject2</span>
{
```csharp
[<span class="hljs-meta">MemoryPackOrder(0)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// हटाया गया</span>
<span class="hljs-comment">//[MemoryPackOrder(1)]</span>
<span class="hljs-comment">//public long MyProperty1 { get; set; } = default;</span>

[<span class="hljs-meta">MemoryPackOrder(2)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// जोड़ा गया</span>
[<span class="hljs-meta">MemoryPackOrder(3)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// यदि SerializeLayout.Sequential को स्पष्ट रूप से सेट किया गया है, तो स्वतः क्रम की अनुमति देता है।</span>
<span class="hljs-comment">// लेकिन यह वर्शन-टॉलरेंट के लिए कोई सदस्य हटाने की अनुमति नहीं देता।</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<p><code>GenerateType.VersionTolerant</code> को serialize करने में <code>GenerateType.Object</code> की तुलना में धीमा है। साथ ही, पेलोड का आकार थोड़ा बड़ा होगा।</p>
<h2>Serialization जानकारी</h2>
<p>आप यह देख सकते हैं कि किस प्रकार के कौन से सदस्य serialize हो रहे हैं, इसके लिए IntelliSense में चेक करें। एक विकल्प है कि इस जानकारी को compile समय पर एक फ़ाइल में लिखा जाए। <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> को निम्न प्रकार से सेट करें।</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- memorypack serialization info को directory में आउटपुट करें --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_SerializationInfoOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\MemoryPackLogs<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>निम्न जानकारी फ़ाइल में लिखी जाती है।</p>
<p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p>
<p>यदि प्रकार unmanaged है, तो type नाम से पहले <code>unmanaged</code> दिखाया जाता है।</p>
<pre><code class="language-txt hljs language-plaintext">unmanaged FooStruct
---
int x
int y
</code></pre>
<p>इस फ़ाइल में अंतर की जाँच करके, खतरनाक schema बदलाव को रोका जा सकता है। उदाहरण के लिए, आप निम्न नियमों का पता लगाने के लिए CI का उपयोग कर सकते हैं</p>
<ul>
<li>unmanaged type को बदलना</li>
<li>सदस्य के क्रम में परिवर्तन</li>
<li>सदस्य को हटाना</li>
</ul>
<h2>Circular Reference</h2>
<p>MemoryPack सर्कुलर रेफरेंस को भी सपोर्ट करता है। इससे ट्री ऑब्जेक्ट्स को जैसा है वैसा serialize किया जा सकता है।</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// सर्कुलर-रेफरेंस सक्षम करने के लिए, GenerateType.CircularReference का उपयोग करें</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> Node? Parent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Node[]? Children { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p> उदाहरण के लिए, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references">System.Text.Json preserve-references</a> कोड यहां जैसा होगा।</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0</span>
Employee tyler = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Tyler Stein"</span>
};

Employee adrian = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Adrian King"</span>
};

tyler.DirectReports = <span class="hljs-keyword">new</span> List&lt;Employee&gt; { adrian };
adrian.Manager = tyler;

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize&lt;Employee&gt;(bin);

Console.WriteLine(tylerDeserialized?.DirectReports?[<span class="hljs-number">0</span>].Manager == tylerDeserialized); <span class="hljs-comment">// true</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Employee? Manager { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> List&lt;Employee&gt;? DirectReports { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>GenerateType.CircularReference</code> में version-tolerant के समान विशेषताएँ हैं। हालांकि, एक अतिरिक्त बाध्यता के रूप में, केवल parameterless constructors की अनुमति है। साथ ही, object reference tracking केवल उन्हीं objects के लिए किया जाता है जिन्हें <code>GenerateType.CircularReference</code> के साथ चिह्नित किया गया है। यदि आप किसी अन्य object को ट्रैक करना चाहते हैं, तो उसे wrap करें।</p>
<h2>CustomFormatter</h2>
<p>यदि आप <code>MemoryPackCustomFormatterAttribute&lt;T&gt;</code> या <code>MemoryPackCustomFormatterAttribute&lt;TFormatter, T&gt;</code> (अधिक performant, लेकिन जटिल) को implement करते हैं, तो आप MemoryPackObject के सदस्य के लिए custom formatter का उपयोग configure कर सकते हैं।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Attribute</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> IMemoryPackFormatter&lt;T&gt; <span class="hljs-title">GetFormatter</span>()</span>;
}
</code></pre>
<p>MemoryPack निम्नलिखित formatting attributes प्रदान करता है: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute&lt;TValue&gt;</code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter&lt;T&gt;</code>, <code>MemoryPoolFormatter&lt;T&gt;</code>, <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// इस सदस्य को UTF16 String के रूप में serialize करें, यह UTF8 की तुलना में बेहतर performance देता है लेकिन ASCII में, आकार बड़ा होता है (लेकिन non ASCII में कभी-कभी छोटा भी हो सकता है)।</span>
    [<span class="hljs-meta">Utf16StringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Text { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment">// deserialize में, Dictionary को StringComparer.OrdinalIgnoreCase के साथ initialize किया जाता है।</span>
    [<span class="hljs-meta">OrdinalIgnoreCaseStringDictionaryFormatter&lt;int&gt;</span>]
    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;? Ids { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    
    <span class="hljs-comment">// deserialize समय, सभी string को intern किया जाता है (देखें: String.Intern)। यदि समान मान बार-बार आते हैं, तो यह memory बचाता है।</span>
    [<span class="hljs-meta">InternStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Flag { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Set/dictionary के equality comparer को configure करने के लिए, सभी built-in formatter में एक comparer constructor overload होता है। आप आसानी से custom equality-comparer formatter बना सकते हैं।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OrdinalIgnoreCaseStringDictionaryFormatter</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>?&gt;&gt;
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt; formatter = <span class="hljs-keyword">new</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt;(StringComparer.OrdinalIgnoreCase);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> IMemoryPackFormatter&lt;Dictionary&lt;<span class="hljs-built_in">string</span>, TValue?&gt;&gt; GetFormatter()
    {
        <span class="hljs-keyword">return</span> formatter;
    }
}
</code></pre>
<p><code>BitPackFormatter</code> केवल <code>bool[]</code> प्रकार को compress करता है। <code>bool[]</code> आमतौर पर प्रत्येक boolean मान के लिए 1 बाइट के रूप में serialize होता है, लेकिन <code>BitPackFormatter</code> <code>bool[]</code> को एक <code>BitArray</code> की तरह serialize करता है, जिसमें प्रत्येक bool को 1 बिट के रूप में संग्रहित किया जाता है। <code>BitPackFormatter</code> का उपयोग करने पर, 8 bools = 1 बाइट, जबकि सामान्यतः 8 बाइट होते, जिससे आकार 8 गुना कम हो जाता है।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BitPackFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[]? Data { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter</code> <code>byte[]</code> के लिए है, उदाहरण के लिए आप Brotli द्वारा बड़े payload को compress कर सकते हैं।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliStringFormatter</code> <code>string</code> के लिए है, Brotli द्वारा compressed string (UTF16) को serialize करता है।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? LargeText { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter&lt;T&gt;</code> किसी भी प्रकार के लिए है, ब्रोटली द्वारा संपीड़ित सीरियलाइज़्ड डेटा के लिए। यदि प्रकार <code>byte[]</code> या <code>string</code> है, तो प्रदर्शन के लिए आपको <code>BrotliFormatter</code> या <code>BrotliStringFormatter</code> का उपयोग करना चाहिए।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter&lt;ChildType&gt;</span>]
    <span class="hljs-keyword">public</span> ChildType? Child { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>एरे पूलिंग को डिसीरियलाइज़ करना</h2>
<p>किसी बड़े एरे (किसी भी <code>T</code>) को डिसीरियलाइज़ करने के लिए, MemoryPack कई कुशल पूलिंग विधियाँ प्रदान करता है। सबसे प्रभावी तरीका है <a href="#overwrite">#Overwrite</a> फ़ंक्शन का उपयोग करना। विशेष रूप से <code>List&lt;T&gt;</code> हमेशा पुन: उपयोग होती है।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ListBytesSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">byte</span>&gt; Payload</span> { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// ----</span>

<span class="hljs-comment">// List&lt;byte&gt; पुन: उपयोग होती है, डिसीरियलाइज़ में कोई आवंटन नहीं।</span>
MemoryPackSerializer.Deserialize&lt;ListBytesSample&gt;(bin, <span class="hljs-keyword">ref</span> reuseObject);

<span class="hljs-comment">// कुशल संचालन के लिए, आप CollectionsMarshal द्वारा Span&lt;T&gt; प्राप्त कर सकते हैं</span>
<span class="hljs-keyword">var</span> span = CollectionsMarshal.AsSpan(<span class="hljs-keyword">value</span>.Payload);
</code></pre>
<p>एक सुविधाजनक तरीका है डिसीरियलाइज़ के समय ArrayPool में डिसीरियलाइज़ करना। MemoryPack <code>MemoryPoolFormatter&lt;T&gt;</code> और <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code> प्रदान करता है।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PoolModelSample</span> : <span class="hljs-title">IDisposable</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; }

    [<span class="hljs-meta">MemoryPoolFormatter&lt;byte&gt;</span>]
    <span class="hljs-keyword">public</span> Memory&lt;<span class="hljs-built_in">byte</span>&gt; Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PoolModelSample</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, Memory&lt;<span class="hljs-built_in">byte</span>&gt; payload</span>)</span>
    {
        Id = id;
        Payload = payload;
    }

    <span class="hljs-comment">// आपको return कोड स्वयं लिखना होगा, यहाँ स्निपेट है।</span>

    <span class="hljs-built_in">bool</span> usePool;

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized</span>()</span>
    {
        usePool = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span>
    {
        <span class="hljs-keyword">if</span> (!usePool) <span class="hljs-keyword">return</span>;

        Return(Payload); Payload = <span class="hljs-literal">default</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Memory&lt;T&gt; memory</span>)</span> =&gt; Return((ReadOnlyMemory&lt;T&gt;)memory);

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlyMemory&lt;T&gt; memory</span>)</span>
    {
        <span class="hljs-keyword">if</span> (MemoryMarshal.TryGetArray(memory, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> segment) &amp;&amp; segment.Array <span class="hljs-keyword">is</span> { Length: &gt; <span class="hljs-number">0</span> })
        {
            ArrayPool&lt;T&gt;.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;());
        }
    }
}

<span class="hljs-comment">// ---</span>

<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;PoolModelSample&gt;(bin))
{
    <span class="hljs-comment">// कुछ भी करें...</span>
}   <span class="hljs-comment">// ArrayPool में वापस करें</span>
</code></pre>
<h2>प्रदर्शन</h2>
<p>मेरा ब्लॉग पोस्ट देखें <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p>
<h2>पेलोड आकार और संपीड़न</h2>
<p>पेलोड आकार लक्ष्य मान पर निर्भर करता है; JSON के विपरीत, इसमें कोई कुंजी नहीं होती और यह एक बाइनरी फॉर्मेट है, इसलिए पेलोड आकार JSON से छोटा होने की संभावना है।</p>
<p>उनके लिए जिनमें varint एन्कोडिंग है, जैसे MessagePack और Protobuf, यदि बहुत अधिक int का उपयोग किया गया हो तो MemoryPack बड़ा हो सकता है (MemoryPack में, int हमेशा 4 बाइट होते हैं फिक्स्ड साइज एन्कोडिंग के कारण, जबकि MessagePack में 1~5 बाइट होते हैं)।</p>
<p>float और double MemoryPack में 4 बाइट और 8 बाइट हैं, लेकिन MessagePack में 5 बाइट और 9 बाइट हैं। तो उदाहरण के लिए, Vector3 (float, float, float) एरे के लिए MemoryPack छोटा होता है।</p>
<p>String डिफ़ॉल्ट रूप से UTF8 है, जो अन्य सीरियलाइज़र्स के समान है, लेकिन यदि UTF16 विकल्प चुना जाता है, तो यह अलग प्रकार का होगा।</p>
<p>किसी भी स्थिति में, यदि पेलोड आकार बड़ा है, तो संपीड़न पर विचार किया जाना चाहिए। LZ4, ZStandard और Brotli अनुशंसित हैं।</p>
<h3>संपीड़न</h3>
<p>MemoryPack <a href="https://github.com/google/brotli">Brotli</a> संपीड़न के लिए <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder">BrotliEncoder</a> और <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder">BrotliDecoder</a> के माध्यम से एक कुशल हेल्पर प्रदान करता है। MemoryPack के <code>BrotliCompressor</code> और <code>BrotliDecompressor</code> MemoryPack के आंतरिक व्यवहार के लिए अनुकूलित संपीड़न/डिसम्प्रेशन प्रदान करते हैं।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// Compression(आवश्यक using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> compressor = <span class="hljs-keyword">new</span> BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, <span class="hljs-keyword">value</span>);

<span class="hljs-comment">// संपीड़ित byte[] प्राप्त करें</span>
<span class="hljs-keyword">var</span> compressedBytes = compressor.ToArray();

<span class="hljs-comment">// या अन्य IBufferWriter&lt;byte&gt; में लिखें (जैसे PipeWriter)</span>
compressor.CopyTo(response.BodyWriter);
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// Decompression(आवश्यक using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> decompressor = <span class="hljs-keyword">new</span> BrotliDecompressor();

<span class="hljs-comment">// ReadOnlySpan&lt;byte&gt; या ReadOnlySequence&lt;byte&gt; से डिसम्प्रेस्ड ReadOnlySequence&lt;byte&gt; प्राप्त करें</span>
<span class="hljs-keyword">var</span> decompressedBuffer = decompressor.Decompress(buffer);

<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;T&gt;(decompressedBuffer);
</code></pre>
<p>दोनों <code>BrotliCompressor</code> और <code>BrotliDecompressor</code> struct हैं, यह heap पर मेमोरी आवंटित नहीं करते। दोनों Serialize/Deserialize के लिए डेटा को एक आंतरिक मेमोरी पूल में संग्रहित करते हैं। इसलिए, मेमोरी पूलिंग को रिलीज़ करना आवश्यक है, <code>using</code> का उपयोग करना न भूलें।</p>
<p>संपीड़न स्तर बहुत महत्वपूर्ण है। डिफ़ॉल्ट रूप से quality-1 (CompressionLevel.Fastest) सेट किया गया है, जो .NET डिफ़ॉल्ट (CompressionLevel.Optimal, quality-4) से अलग है।</p>
<p>Fastest (quality-1) की गति <a href="https://github.com/lz4/lz4">LZ4</a> के करीब होगी, लेकिन 4 बहुत धीमा है। यह सीरियलाइज़र उपयोग परिदृश्य में महत्वपूर्ण पाया गया। मानक <code>BrotliStream</code> का उपयोग करते समय सावधान रहें (डिफ़ॉल्ट quality-4 है)। किसी भी स्थिति में, संपीड़न/डिसम्प्रेशन की गति और आकार अलग-अलग डेटा के लिए बहुत भिन्न होंगे। कृपया अपने एप्लिकेशन द्वारा उपयोग किए जाने वाले डेटा के साथ स्वयं परीक्षण करें।</p>
<p>ध्यान दें कि MemoryPack के असंपीड़ित और Brotli के संपीड़न के बीच कई गुना गति दंड है।</p>
<p>Brotli कस्टम फ़ॉर्मेटर में भी समर्थित है। <code>BrotliFormatter</code> किसी विशिष्ट सदस्य को संपीड़ित कर सकता है।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>बाहरी प्रकारों को सीरियलाइज़ करें</h2>
<p>यदि आप बाहरी प्रकारों को सीरियलाइज़ करना चाहते हैं, तो आप एक कस्टम फ़ॉर्मेटर बना सकते हैं और उसे प्रोवाइडर में रजिस्टर कर सकते हैं, विवरण के लिए देखें <a href="#formatterprovider-api">Formatter/Provider API</a>। हालांकि, एक कस्टम फ़ॉर्मेटर बनाना कठिन है। इसलिए, हम एक रैपर टाइप बनाने की सलाह देते हैं। उदाहरण के लिए, यदि आप <code>AnimationCurve</code> नामक बाहरी प्रकार को सीरियलाइज़ करना चाहते हैं।</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">struct</span> SerializableAnimationCurve
{
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimationCurve AnimationCurve;

    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode preWrapMode =&gt; AnimationCurve.preWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode postWrapMode =&gt; AnimationCurve.postWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    Keyframe[] keys =&gt; AnimationCurve.keys;

    [<span class="hljs-meta">MemoryPackConstructor</span>]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        <span class="hljs-keyword">var</span> curve = <span class="hljs-keyword">new</span> AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        <span class="hljs-keyword">this</span>.AnimationCurve = curve;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SerializableAnimationCurve</span>(<span class="hljs-params">AnimationCurve animationCurve</span>)</span>
    {
        <span class="hljs-keyword">this</span>.AnimationCurve = animationCurve;
    }
}
</code></pre>
<p>रैप करने के लिए प्रकार सार्वजनिक है, लेकिन सीरियलाइज़ेशन से बाहर रखा गया है (<code>MemoryPackIgnore</code>)। जिन गुणों को आप सीरियलाइज़ करना चाहते हैं वे निजी हैं, लेकिन शामिल किए गए हैं (<code>MemoryPackInclude</code>)। दो प्रकार के कन्स्ट्रक्टर भी तैयार किए जाने चाहिए। सीरियलाइज़र द्वारा उपयोग किया जाने वाला कन्स्ट्रक्टर निजी होना चाहिए।</p>
<p>जैसा है, इसे हर बार रैप करना होगा, जो असुविधाजनक है। और साथ ही struct wrapper null को निरूपित नहीं कर सकता। तो आइए एक कस्टम फ़ॉर्मेटर बनाते हैं।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimationCurveFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">AnimationCurve</span>&gt;
{
    <span class="hljs-comment">// Unity scoped और TBufferWriter को सपोर्ट नहीं करता, इसलिए signature बदलें `Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)`</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
```csharp
{
    writer.WriteNullObjectHeader();
    <span class="hljs-keyword">return</span>;
}

writer.WritePackable(<span class="hljs-keyword">new</span> SerializableAnimationCurve(<span class="hljs-keyword">value</span>));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (reader.PeekIsNull())
    {
        reader.Advance(<span class="hljs-number">1</span>); <span class="hljs-comment">// null ब्लॉक को छोड़ें</span>
        <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">var</span> wrapped = reader.ReadPackable&lt;SerializableAnimationCurve&gt;();
    <span class="hljs-keyword">value</span> = wrapped.AnimationCurve;
}
</code></pre>
<p>अंत में, स्टार्टअप में फॉर्मेटर को रजिस्टर करें।</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register&lt;AnimationCurve&gt;(<span class="hljs-keyword">new</span> AnimationCurveFormatter());
</code></pre>
<blockquote>
<p>नोट: Unity की AnimationCurve डिफ़ॉल्ट रूप से सीरियलाइज़ेबल है इसलिए AnimationCurve के लिए इस कस्टम फॉर्मेटर की आवश्यकता नहीं है।</p>
</blockquote>
<h2>Packages</h2>
<p>MemoryPack के ये पैकेज हैं।</p>
<ul>
<li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li>
</ul>
<p><code>MemoryPack</code> मुख्य लाइब्रेरी है, यह बाइनरी ऑब्जेक्ट्स के हाई परफॉर्मेंस सीरियलाइज़ेशन और डीसीरियलाइज़ेशन के लिए पूरी सपोर्ट प्रदान करता है। यह <code>MemoryPack.Core</code> पर बेस लाइब्रेरीज़ के लिए और <code>MemoryPack.Generator</code> पर कोड जेनरेशन के लिए निर्भर करता है। <code>MemoryPack.Streaming</code> <a href="#streaming-serialization">Streaming Serialization</a> के लिए अतिरिक्त एक्सटेंशन जोड़ता है।  <code>MemoryPack.AspNetCoreMvcFormatter</code> ASP.NET Core के लिए इनपुट/आउटपुट फॉर्मेटर्स जोड़ता है। <code>MemoryPack.UnityShims</code> .NET और Unity के बीच साझा किए जाने वाले टाइप्स के लिए Unity शिम टाइप्स और फॉर्मेटर्स जोड़ता है।</p>
<h2>TypeScript और ASP.NET Core Formatter</h2>
<p>MemoryPack TypeScript कोड जेनरेशन सपोर्ट करता है। यह C# से क्लास और सीरियलाइज़ेशन कोड जेनरेट करता है, दूसरे शब्दों में, आप OpenAPI, proto, आदि का उपयोग किए बिना ब्राउज़र के साथ टाइप्स साझा कर सकते हैं।</p>
<p>कोड जेनरेशन Source Generator के साथ इंटीग्रेटेड है, निम्नलिखित विकल्प (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) TypeScript कोड के लिए आउटपुट डायरेक्टरी सेट करते हैं। रनटाइम कोड भी एक ही समय पर आउटपुट होता है, इसलिए कोई अतिरिक्त डिपेंडेंसी आवश्यक नहीं है।</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- मेमोरीपैक TypeScript कोड को डायरेक्टरी में आउटपुट करें --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>एक C# MemoryPackable टाइप को <code>[GenerateTypeScript]</code> के साथ एनोटेट किया जाना चाहिए।</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">GenerateTypeScript</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> required Guid Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> FirstName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> LastName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required DateTime DateOfBirth { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required Gender Gender { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span>[] Emails { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Gender
{
    Male, Female, Other
}
</code></pre>
<p>रनटाइम कोड और TypeScript टाइप लक्ष्य डायरेक्टरी में जेनरेट हो जाएंगे।</p>
<p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p>
<p>जेनरेट किया गया कोड निम्नानुसार है, जिसमें सरल फील्ड्स और serialize/serializeArray व deserialize/deserializeArray के लिए स्टैटिक मेथड्स होते हैं।</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackWriter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackWriter.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackReader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackReader.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Gender</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./Gender.js"</span>; 

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">dateOfBirth</span>: <span class="hljs-title class_">Date</span>;
    <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>;
    <span class="hljs-attr">emails</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArray</span>(<span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArrayCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArray</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArrayCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }
}
</code></pre>
<p>आप इस टाइप का उपयोग निम्नानुसार कर सकते हैं।</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
person.<span class="hljs-property">id</span> = crypto.<span class="hljs-title function_">randomUUID</span>();
person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;
person.<span class="hljs-property">firstName</span> = <span class="hljs-string">"foo"</span>;
person.<span class="hljs-property">lastName</span> = <span class="hljs-string">"bar"</span>;
person.<span class="hljs-property">dateOfBirth</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1999</span>, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
person.<span class="hljs-property">gender</span> = <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Other</span>;
person.<span class="hljs-property">emails</span> = [<span class="hljs-string">"foo@bar.com"</span>, <span class="hljs-string">"zoo@bar.net"</span>];

<span class="hljs-comment">// Uint8Array में सीरियलाइज़ करें</span>
<span class="hljs-keyword">let</span> bin = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">serialize</span>(person);

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([bin.<span class="hljs-property">buffer</span>], { <span class="hljs-attr">type</span>: <span class="hljs-string">"application/x-memorypack"</span> })

<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"http://localhost:5260/api"</span>,
    { <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>, <span class="hljs-attr">body</span>: blob, <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/x-memorypack"</span> } });

<span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();

<span class="hljs-comment">// ArrayBuffer से डीसीरियलाइज़ करें </span>
<span class="hljs-keyword">let</span> person2 = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">deserialize</span>(buffer);
</code></pre>
<p><code>MemoryPack.AspNetCoreMvcFormatter</code> पैकेज ASP.NET Core MVC के लिए <code>MemoryPack</code> इनपुट और आउटपुट फॉर्मेटर जोड़ता है। आप निम्नलिखित कोड के साथ ASP.NET Core MVC में <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> जोड़ सकते हैं।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackInputFormatter());
    <span class="hljs-comment">// यदि checkContentType: true है तो मल्टीपल फॉर्मेट (JSON/MemoryPack, आदि) आउटपुट कर सकते हैं। डिफ़ॉल्ट false है।</span>
    options.OutputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackOutputFormatter(checkContentType: <span class="hljs-literal">false</span>));
});
</code></pre>
<p>यदि आप HttpClient से कॉल करते हैं, तो आप कंटेंट-हेडर में <code>application/x-memorypack</code> सेट कर सकते हैं।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> content = <span class="hljs-keyword">new</span> ByteArrayContent(bin)
content.Headers.ContentType = <span class="hljs-keyword">new</span> MediaTypeHeaderValue(<span class="hljs-string">"application/x-memorypack"</span>);
</code></pre>
<h3>TypeScript टाइप मैपिंग</h3>
<p>उन टाइप्स पर कुछ प्रतिबंध हैं जिन्हें जेनरेट किया जा सकता है। प्रिमिटिव्स में, <code>char</code> और <code>decimal</code> समर्थित नहीं हैं। इसके अलावा, OpenGenerics टाइप का उपयोग नहीं किया जा सकता।</p>
<table>
<thead>
<tr>
<th>C#</th>
<th>TypeScript</th>
<th>विवरण</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>sbyte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>bigint</code></td>
<td></td>
</tr>
</tbody></table>
<pre><code class="hljs language-xml">| `ulong` |  `bigint` |
| `float` |  `number` |
| `double` |  `number` |
| `string` |  `string \| null`  | 
| `Guid` |  `string`  | TypeScript में string के रूप में प्रस्तुत किया जाता है, लेकिन 16 बाइट बाइनरी के रूप में serialize/deserialize होता है
| `DateTime` | `Date` | DateTimeKind को अनदेखा किया जाएगा
| `enum` | `const enum` | `long` और `ulong` आधारभूत प्रकार समर्थित नहीं हैं
| `T?` | `T \| null` |
| `T[]` | `T[] \| null` |
| `byte[]` | `Uint8Array \| null` |
| `: ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `T[] \| null` | सभी `ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` लागू प्रकार जैसे `List<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` को समर्थन करता है
| `: ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `Set<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> \| null` | सभी `ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` लागू प्रकार जैसे `HashSet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` को समर्थन करता है
| `: IDictionary&lt;K,V&gt;` | `Map&lt;K, V&gt; \| null` | सभी `IDictionary&lt;K,V&gt;` लागू प्रकार जैसे `Dictionary&lt;K,V&gt;` को समर्थन करता है।
| `[MemoryPackable]` | `class` | केवल class को समर्थन करता है
| `[MemoryPackUnion]` | `abstract class` |

`[GenerateTypeScript]` केवल classes पर लागू किया जा सकता है और वर्तमान में struct द्वारा समर्थित नहीं है।

### इम्पोर्ट फाइल एक्सटेंशन और सदस्य नाम केसिंग कॉन्फ़िगर करें

डिफ़ॉल्ट रूप में, MemoryPack फाइल एक्सटेंशन को `.js` के रूप में जेनरेट करता है जैसे कि `import { MemoryPackWriter } from "./MemoryPackWriter.js";`। यदि आप कोई अन्य एक्सटेंशन या खाली रखना चाहते हैं, तो इसे कॉन्फ़िगर करने के लिए `MemoryPackGenerator_TypeScriptImportExtension` का उपयोग करें।
साथ ही सदस्य नाम अपने आप camelCase में बदल जाता है। यदि आप मूल नाम का उपयोग करना चाहते हैं, तो `MemoryPackGenerator_TypeScriptConvertPropertyName` को `false` पर सेट करें।

```xml
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptImportExtension"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptConvertPropertyName"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptEnableNullableTypes"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- खाली रखना संभव है --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- डिफ़ॉल्ट true है --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- डिफ़ॉल्ट false है --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> C# nullable एनोटेशन को TypeScript कोड में प्रतिबिंबित करने की अनुमति देता है। डिफ़ॉल्ट रूप से false है, जिससे सब कुछ nullable बन जाता है।</p>
<h2>Streaming Serialization</h2>
<p><code>MemoryPack.Streaming</code> <code>MemoryPackStreamingSerializer</code> प्रदान करता है, जो streams के साथ collections को serialize और deserialize करने के लिए अतिरिक्त समर्थन जोड़ता है।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackStreamingSerializer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeWriter pipeWriter, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeReader pipeReader, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, [EnumeratorCancellation] CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
}
</span></code></pre>
<h2>Formatter/Provider API</h2>
<p>यदि आप formatter को मैन्युअली लागू करना चाहते हैं, तो <code>MemoryPackFormatter&lt;T&gt;</code> से इनहेरिट करें और <code>Serialize</code> और <code>Deserialize</code> मेथड्स को override करें।</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SkeltonFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">Skelton</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
        {
            writer.WriteNullObjectHeader();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// writer मेथड का उपयोग करें।</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (!reader.TryReadObjectHeader(<span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> count))
        {
            <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// reader मेथड का उपयोग करें।</span>
    }
}
</code></pre>
<p>बनाए गए formatter को <code>MemoryPackFormatterProvider</code> के साथ रजिस्टर किया जाता है।</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register(<span class="hljs-keyword">new</span> SkeltonFormatter());
</code></pre>
<p>नोट: <code>unmanged struct</code> (जिसमें कोई reference types नहीं हैं) कस्टम formatter का उपयोग नहीं कर सकते, यह हमेशा native memory layout को serialize करता है।</p>
<h2>MemoryPackWriter/ReaderOptionalState</h2>
<p><code>MemoryPackWriter</code>/<code>MemoryPackReader</code> को इनिशियलाइज़ करने के लिए OptionalState की आवश्यकता होती है। यह <code>MemoryPackSerializerOptions</code> का wrapper है, जिसे <code>MemoryPackWriterOptionalStatePool</code> से बनाया जा सकता है।</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// जब dispose किया जाएगा, OptionalState pool में वापस चला जाएगा।</span>
<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> writer = <span class="hljs-keyword">new</span> MemoryPackWriter&lt;T&gt;(<span class="hljs-keyword">ref</span> t, state);
}

<span class="hljs-comment">// Reader के लिए</span>
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> MemoryPackReader(buffer, state);
}
</code></pre>
<h2>Target framework dependency</h2>
<p>MemoryPack <code>netstandard2.1</code> और <code>net7.0</code> प्रदान करता है, लेकिन दोनों संगत नहीं हैं। उदाहरण के लिए, यदि आप <code>netstandard2.1</code> प्रोजेक्ट के तहत MemoryPackable types का उपयोग करते हैं और उसे <code>net7.0</code> प्रोजेक्ट से उपयोग करते हैं, तो रनटाइम exception मिलेगा, जैसे:</p>
<blockquote>
<p>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</p>
</blockquote>
<p>चूंकि net7.0 static abstract members (<code>Virtual static method</code>) का उपयोग करता है, जो netstandard2.1 में समर्थित नहीं है, यह व्यवहार एक विशेषता है।</p>
<p>.NET 7 प्रोजेक्ट को netstandard 2.1 dll का उपयोग नहीं करना चाहिए। दूसरे शब्दों में, यदि एप्लिकेशन .NET 7 प्रोजेक्ट है, तो सभी dependencies जिन्हें MemoryPack का उपयोग करना है, उन्हें .NET 7 को समर्थन करना चाहिए। इसलिए यदि किसी लाइब्रेरी डेवलपर की dependency MemoryPack पर है, तो आपको dual target framework कॉन्फ़िगर करना होगा।</p>
<pre><code class="language-xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">TargetFrameworks</span>&gt;</span>netstandard2.1;net7.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFrameworks</span>&gt;</span>
</code></pre>
<h2>RPC</h2>
<p><a href="https://github.com/Cysharp/MagicOnion">Cysharp/MagicOnion</a> एक code-first grpc-dotnet framework है, जो protobuf के बजाय MessagePack का उपयोग करता है। MagicOnion अब MemoryPack को serialization layer के रूप में <code>MagicOnion.Serialization.MemoryPack</code> पैकेज (preview) के माध्यम से समर्थन करता है। विवरण देखें: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support">MagicOnion#MemoryPack support</a></p>
<h2>Unity</h2>
<p>न्यूनतम समर्थित Unity संस्करण <code>2022.3.12f1</code> है।</p>
<p><code>MemoryPack</code> कोर पैकेज nuget द्वारा प्रदान किया गया है। यह Unity में भी उपलब्ध है। यदि आप Unity बिल्ट-इन टाइप समर्थन प्राप्त करना चाहते हैं, तो हम अतिरिक्त रूप से MemoryPack.Unity एक्सटेंशन प्रदान करते हैं।</p>
<ol>
<li><a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a> का उपयोग कर NuGet से <code>MemoryPack</code> इंस्टॉल करें</li>
</ol>
<ul>
<li><p>NuGet -&gt; Manage NuGet Packages विंडो खोलें, "MemoryPack" सर्च करें और Install दबाएं।<br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p>
</li>
<li><p>यदि आपको version conflicts error मिलता है, तो कृपया Player Settings (Edit -&gt; Project Settings -&gt; Player -&gt; नीचे स्क्रॉल करें और "Other Settings" को विस्तार करें, फिर "Configuration" सेक्शन के तहत "Assembly Version Validation" को अनचेक करें) में version validation को disable करें।</p>
</li>
</ul>
<ol start="2">
<li>git URL का संदर्भ देकर <code>MemoryPack.Unity</code> पैकेज इंस्टॉल करें</li>
</ol>
<ul>
<li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code><br><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot"><br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></li>
</ul>
<p>MemoryPack <em>.</em>.* रिलीज़ टैग का उपयोग करता है, इसलिए आप एक version जैसे #1.0.0 निर्दिष्ट कर सकते हैं। उदाहरण: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p>
<p>.NET संस्करण की तरह, कोड जेनरेशन एक कोड जनरेटर (<code>MemoryPack.Generator.dll</code>) द्वारा होती है। Reflection-free implementation IL2CPP में भी बेहतरीन प्रदर्शन प्रदान करता है।</p>
<p>Unity और Source Generator के बारे में अधिक जानकारी के लिए, कृपया <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Unity documentation</a> देखें।</p>
<p>Source Generator का आधिकारिक रूप से Unity द्वारा <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">com.unity.properties</a> और <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html">com.unity.entities</a> में भी उपयोग होता है। दूसरे शब्दों में, यह अगली पीढ़ी के Unity में कोड जेनरेशन का मानक है।</p>
<p>आप सभी unmanaged types (जैसे कि <code>Vector3</code>, <code>Rect</code>, आदि...) और कुछ classes (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>) को serialize कर सकते हैं। यदि आप अन्य Unity-विशिष्ट प्रकार serialize करना चाहते हैं, तो <a href="#serialize-external-types">Serialize external types</a> अनुभाग देखें।</p>
<p>Unity में प्रदर्शन के मामले में, MemoryPack JsonUtility से x3~x10 गुना तेज है।</p>
<p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p>
<p>यदि साझा कोड में Unity का type (<code>Vector2</code>, आदि...) है, तो MemoryPack NuGet में <code>MemoryPack.UnityShims</code> पैकेज प्रदान करता है।</p>
<p><code>MemoryPack.UnityShims</code> पैकेज Unity के मानक structs (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) और कुछ classes (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>) के लिए shims प्रदान करता है।</p>
<blockquote>
<p>[!WARNING]<br>वर्तमान में, Unity में उपयोग के लिए निम्नलिखित सीमाएँ हैं</p>
</blockquote>
<ol>
<li>Unity संस्करण CustomFormatter को समर्थन नहीं करता।</li>
<li>यदि आप .NET7 या बाद के संस्करण का उपयोग कर रहे हैं, तो MemoryPack बाइनरी फॉर्मेट Unity के साथ पूरी तरह संगत नहीं है।<ul>
<li>यह समस्या उन value types के साथ होती है, जिनमें <code>[StructLayout(LayoutKind.Auto)]</code> स्पष्ट रूप से निर्दिष्ट है। (struct का डिफ़ॉल्ट <code>LayoutKind.Sequencil</code> होता है।) ऐसे types के लिए, .NET में serialize किया गया binary, Untiy में deserialize नहीं किया जा सकता। इसी तरह, Unity में serialize किया गया binary .NET साइड में serialize नहीं किया जा सकता।</li>
<li>प्रभावित types में आमतौर पर निम्नलिखित प्रकार शामिल हैं।<ul>
<li><code>DateTimeOffset</code></li>
<li><code>ValueTuple</code></li>
</ul>
</li>
<li>वर्तमान में, आसान समाधान यह है कि इन types का उपयोग न करें।</li>
</ul>
</li>
</ol>
<h2>Native AOT</h2>
<p>दुर्भाग्यवश, .NET 7 Native AOT में एक रनटाइम बग के कारण MemoryPack का उपयोग करते समय crash (<code>Generic virtual method pointer lookup failure</code>) होता है। यह .NET 8 में ठीक किया जाएगा। <code>Microsoft.DotNet.ILCompiler</code> के preview संस्करण का उपयोग करने से .NET 7 में इसे ठीक किया जा सकता है। कृपया <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611">issue's comment</a> देखें कि इसे कैसे सेटअप करें।</p>
<h2>Binary wire format specification</h2>
<p><code>Serialize&lt;T&gt;</code> और <code>Deserialize&lt;T&gt;</code> में परिभाषित <code>T</code> प्रकार को C# schema कहा जाता है। MemoryPack फॉर्मेट self-described फॉर्मेट नहीं है। Deserialize के लिए संबंधित C# schema की आवश्यकता होती है। ये types binaries के आंतरिक प्रतिनिधित्व के रूप में मौजूद होते हैं, लेकिन types C# schema के बिना निर्धारित नहीं किए जा सकते।</p>
<p>Endian <code>Little Endian</code> होना चाहिए। हालांकि, reference C# implementation endianness की परवाह नहीं करता, इसलिए इसे big-endian मशीन पर उपयोग नहीं किया जा सकता। हालांकि, आधुनिक कंप्यूटर आमतौर पर little-endian होते हैं।</p>
<p>फॉर्मेट के आठ प्रकार हैं।</p>
<ul>
<li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>सर्कुलर रेफरेंस ऑब्जेक्ट  </li>
<li>टपल  </li>
<li>कलेक्शन  </li>
<li>स्ट्रिंग  </li>
<li>यूनियन</li>
</ul>
<h3>अनमैनेज्ड स्ट्रक्चर</h3>
<p>अनमैनेज्ड स्ट्रक्चर वह C# स्ट्रक्चर है जिसमें रेफरेंस टाइप्स नहीं होते, यह <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# अनमैनेज्ड टाइप्स</a> जैसी कंस्ट्रेंट के समान है। स्ट्रक्चर लेआउट को जेसा है वैसा ही सीरियलाइज़ किया जाता है, जिसमें पैडिंग भी शामिल होती है।</p>
<h3>ऑब्जेक्ट</h3>
<p><code>(byte memberCount, [values...])</code></p>
<p>ऑब्जेक्ट के हैडर में 1 बाइट अनसाइन्ड बाइट के रूप में मेंबर काउंट होता है। मेंबर काउंट <code>0</code> से <code>249</code> तक हो सकता है, <code>255</code> दर्शाता है कि ऑब्जेक्ट <code>null</code> है। वैल्यूज़ में मेंबर काउंट की संख्या के लिए मेमोरीपैक वैल्यू स्टोर होती है।</p>
<h3>वर्शन टॉलरेंट ऑब्जेक्ट</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], [values...])</code></p>
<p>वर्शन टॉलरेंट ऑब्जेक्ट ऑब्जेक्ट के समान है, लेकिन इसमें हैडर में वैल्यूज़ की बाइट लेंथ होती है। वरिन्ट इन स्पेसिफिकेशन का पालन करता है, पहला sbyte वैल्यू या टाइपकोड होता है और अगले X बाइट वैल्यू होते हैं। 0 से 127 = अनसाइन्ड बाइट वैल्यू, -1 से -120 = साइनड बाइट वैल्यू, -121 = बाइट, -122 = स्बाइट, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long।</p>
<h3>सर्कुलर रेफरेंस ऑब्जेक्ट</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])</code><br><code>(250, varint referenceId)</code></p>
<p>सर्कुलर रेफरेंस ऑब्जेक्ट वर्शन टॉलरेंट ऑब्जेक्ट के समान है लेकिन अगर memberCount 250 है, तो अगला varint (unsigned-int32) referenceId होता है। यदि नहीं, तो byte-length-of-values के बाद varint referenceId लिखा जाता है।</p>
<h3>टपल</h3>
<p><code>(values...)</code></p>
<p>टपल फिक्स्ड-साइज़, नॉन-नल वैल्यू कलेक्शन है। .NET में, <code>KeyValuePair&lt;TKey, TValue&gt;</code> और <code>ValueTuple&lt;T,...&gt;</code> को टपल के रूप में सीरियलाइज़ किया जाता है।</p>
<h3>कलेक्शन</h3>
<p><code>(int length, [values...])</code></p>
<p>कलेक्शन के हैडर में 4 बाइट साइनड इन्टीजर के रूप में डेटा काउंट होता है, <code>-1</code> का अर्थ है <code>null</code>। वैल्यूज़ में लेंथ की संख्या के लिए मेमोरीपैक वैल्यू स्टोर होती है।</p>
<h3>स्ट्रिंग</h3>
<p><code>(int utf16-length, utf16-value)</code><br><code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)</code></p>
<p>स्ट्रिंग के दो रूप होते हैं, UTF16 और UTF8। अगर पहली 4-बाइट साइनड इन्टीजर <code>-1</code> है, तो यह null दर्शाता है। <code>0</code> का अर्थ है खाली। UTF16 कलेक्शन के समान है (<code>ReadOnlySpan&lt;char&gt;</code> के रूप में सीरियलाइज़), utf16-value के बाइट काउंट = utf16-length * 2। अगर पहली साइनड इन्टीजर &lt;= <code>-2</code>, तो वैल्यू UTF8 में एन्कोड की जाती है। utf8-byte-count कंप्लीमेंट में एन्कोडेड है, बाइट्स की गिनती प्राप्त करने के लिए <code>~utf8-byte-count</code>। अगला साइनड इन्टीजर utf16-length है, यह <code>-1</code> हो सकता है जो अज्ञात लंबाई दर्शाता है। utf8-bytes में utf8-byte-count की संख्या के लिए बाइट्स स्टोर होती हैं।</p>
<h3>यूनियन</h3>
<p><code>(byte tag, value)</code><br><code>(250, ushort tag, value)</code></p>
<p>पहली अनसाइन्ड बाइट टैग है जो डिस्क्रिमिनेटेड वैल्यू टाइप या फ्लैग के लिए है, <code>0</code> से <code>249</code> टैग दर्शाते हैं, <code>250</code> दर्शाता है कि अगला अनसाइन्ड शॉर्ट टैग है, <code>255</code> दर्शाता है कि यूनियन <code>null</code> है।</p>
<h2>License  </h2>
<p>यह लाइब्रेरी MIT लाइसेंस के तहत लाइसेंस प्राप्त है।</p>
<hr>
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-09</p>
<hr>
</div>
    </div>

    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async=""></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
    <script src="view.js"></script>


</body></html>