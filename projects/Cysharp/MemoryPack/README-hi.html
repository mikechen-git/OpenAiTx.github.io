<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Cysharp/MemoryPack hi</title>
    <meta name="title" content="MemoryPack - Cysharp/MemoryPack hi | MemoryPack C# और Unity के लिए शून्य एन्कोडिंग, अत्यधिक प्रदर्शन वाला बाइनरी सीरियलाइज़र। तुलना की गई है System.Text.Json, protobuf-net, MessagePack for C#, Orle...">
    <meta name="description" content="Cysharp/MemoryPack - GitHub repository hi documentation and information | MemoryPack C# और Unity के लिए शून्य एन्कोडिंग, अत्यधिक प्रदर्शन वाला बाइनरी सीरियलाइज़र। तुलना की गई है System.Text.Json, protobuf-net, MessagePack for C#, Orle...">
    <meta name="keywords" content="Cysharp, MemoryPack, GitHub, repository, hi documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/Cysharp/MemoryPack/README-hi.html">
    <meta property="og:title" content="MemoryPack - Cysharp/MemoryPack hi | MemoryPack C# और Unity के लिए शून्य एन्कोडिंग, अत्यधिक प्रदर्शन वाला बाइनरी सीरियलाइज़र। तुलना की गई है System.Text.Json, protobuf-net, MessagePack for C#, Orle...">
    <meta property="og:description" content="Cysharp/MemoryPack - GitHub repository hi documentation and information | MemoryPack C# और Unity के लिए शून्य एन्कोडिंग, अत्यधिक प्रदर्शन वाला बाइनरी सीरियलाइज़र। तुलना की गई है System.Text.Json, protobuf-net, MessagePack for C#, Orle...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/Cysharp/MemoryPack" id="githubRepoLink" target="_blank">Cysharp/MemoryPack</a>
<h1 style="display: none;">MemoryPack C# और Unity के लिए शून्य एन्कोडिंग, अत्यधिक प्रदर्शन वाला बाइनरी सीरियलाइज़र। तुलना की गई है System.Text.Json, protobuf-net, MessagePack for C#, Orle...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>MemoryPack</h1>
<p><a href="https://www.nuget.org/packages/MemoryPack"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet" /></a>
<a href="https://github.com/Cysharp/MemoryPack/actions"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions" /></a>
<a href="https://github.com/Cysharp/MemoryPack/releases"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases" /></a></p>
<p>C# और Unity के लिए शून्य एन्कोडिंग, अत्यधिक प्रदर्शन वाला बाइनरी सीरियलाइज़र।</p>
<p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image" /></p>
<blockquote>
<p>तुलना की गई है <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/">Orleans.Serialization</a> के साथ। .NET 7 / Ryzen 9 5950X मशीन द्वारा मापा गया। इन सीरियलाइज़रों में <code>IBufferWriter&lt;byte&gt;</code> विधि है, जिसे <code>ArrayBufferWriter&lt;byte&gt;</code> के उपयोग से सीरियलाइज़ किया गया है और बफर कॉपी को मापने से बचने के लिए पुन: उपयोग किया गया है।</p>
</blockquote>
<p>सामान्य ऑब्जेक्ट्स के लिए, MemoryPack x10 गुना तेज़ और अन्य बाइनरी सीरियलाइज़रों की तुलना में x2 ~ x5 गुना तेज़ है। स्ट्रक्चर एरे के लिए, MemoryPack और भी अधिक शक्तिशाली है, जिसकी गति अन्य सीरियलाइज़रों से x50 ~ x200 गुना अधिक है।</p>
<p>MemoryPack मेरा चौथा सीरियलाइज़र है, इससे पहले मैंने प्रसिद्ध सीरियलाइज़र बनाए हैं, ~~<a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a>~~, ~~<a href="https://github.com/neuecc/Utf8Json">Utf8Json</a>~~, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>। MemoryPack की गति का कारण इसकी C#-विशिष्ट, C#-अनुकूलित बाइनरी फ़ॉर्मेट और मेरे पिछले अनुभव पर आधारित एक अच्छी तरह से ट्यून की गई इम्प्लीमेंटेशन है। यह पूरी तरह से नया डिज़ाइन है, जिसमें .NET 7 और C# 11 तथा Incremental Source Generator ( .NET Standard 2.1 (.NET 5, 6) और Unity के लिए भी सपोर्ट है) का उपयोग किया गया है।</p>
<p>अन्य सीरियलाइज़र कई एन्कोडिंग ऑपरेशन्स करते हैं जैसे VarInt एन्कोडिंग, टैग, स्ट्रिंग आदि। MemoryPack फॉर्मेट शून्य-एन्कोडिंग डिज़ाइन का उपयोग करता है जो संभवतः जितना अधिक C# मेमोरी हो सके, उसे कॉपी करता है। शून्य-एन्कोडिंग FlatBuffers के समान है, लेकिन इसके लिए विशेष प्रकार की आवश्यकता नहीं है, MemoryPack का सीरियलाइज़ेशन लक्ष्य POCO है।</p>
<p>प्रदर्शन के अलावा, MemoryPack में ये विशेषताएँ हैं:</p>
<ul>
<li>आधुनिक I/O APIs का समर्थन (<code>IBufferWriter&lt;byte&gt;</code>, <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>)</li>
<li>Native AOT फ्रेंडली Source Generator आधारित कोड जनरेशन, कोई डायनामिक CodeGen (IL.Emit) नहीं</li>
<li>Reflectionless non-generics APIs</li>
<li>मौजूदा इंस्टेंस में डीसिरियलाइज़ करें</li>
<li>पॉलिमॉर्फिज्म (Union) सीरियलाइज़ेशन</li>
<li>सीमित वर्शन-टोलरेंट (फास्ट/डिफ़ॉल्ट) और पूर्ण वर्शन-टोलरेंट सपोर्ट</li>
<li>Circular reference सीरियलाइज़ेशन</li>
<li>PipeWriter/Reader आधारित स्ट्रीमिंग सीरियलाइज़ेशन</li>
<li>TypeScript कोड जनरेशन और ASP.NET Core Formatter</li>
<li>Unity (2021.3) IL2CPP सपोर्ट .NET Source Generator के माध्यम से</li>
</ul>
<h2>इंस्टॉलेशन</h2>
<p>यह लाइब्रेरी NuGet के माध्यम से वितरित की जाती है। सर्वोत्तम प्रदर्शन के लिए, <code>.NET 7</code> का उपयोग करने की सिफारिश की जाती है। न्यूनतम आवश्यकता <code>.NET Standard 2.1</code> है।</p>
<blockquote>
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/MemoryPack">MemoryPack</a></p>
</blockquote>
<p>साथ ही कोड एडिटर में Roslyn 4.3.1 सपोर्ट होना आवश्यक है, जैसे Visual Studio 2022 version 17.3, .NET SDK 6.0.401। विवरण के लिए, <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support">Roslyn Version Support</a> दस्तावेज़ देखें।</p>
<p>Unity के लिए, आवश्यकताएँ और इंस्टॉलेशन प्रक्रिया पूरी तरह से अलग है। विवरण के लिए <a href="#unity">Unity</a> अनुभाग देखें।</p>
<h2>त्वरित प्रारंभ</h2>
<p>सीरियलाइज़ करने के लिए एक struct या class को परिभाषित करें और उसे <code>[MemoryPackable]</code> एट्रिब्यूट तथा <code>partial</code> कीवर्ड से सजाएँ।</p>
<pre><code class="language-csharp">using MemoryPack;

[MemoryPackable]
public partial class Person
{
    public int Age { get; set; }
    public string Name { get; set; }
}
</code></pre>
<p>सीरियलाइज़ेशन कोड C# सोर्स जनरेटर फीचर द्वारा जनरेट किया जाता है, जो <code>IMemoryPackable&lt;T&gt;</code> इंटरफ़ेस को इम्प्लीमेंट करता है। Visual Studio में आप जेनरेटेड कोड को क्लास नाम पर <code>Ctrl+K, R</code> शॉर्टकट का उपयोग करके और <code>*.MemoryPackFormatter.g.cs</code> चुनकर देख सकते हैं।</p>
<p>किसी ऑब्जेक्ट इंस्टेंस को सीरियलाइज़/डीसीरियलाइज़ करने के लिए <code>MemoryPackSerializer.Serialize&lt;T&gt;/Deserialize&lt;T&gt;</code> कॉल करें।</p>
<pre><code class="language-csharp">var v = new Person { Age = 40, Name = &quot;John&quot; };

var bin = MemoryPackSerializer.Serialize(v);
var val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p><code>Serialize</code> मेथड <code>byte[]</code> रिटर्न टाइप को सपोर्ट करती है, साथ ही यह <code>IBufferWriter&lt;byte&gt;</code> या <code>Stream</code> में भी सीरियलाइज़ कर सकती है। <code>Deserialize</code> मेथड <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code> और <code>Stream</code> को सपोर्ट करती है। और नॉन-जनरिक वर्शन भी उपलब्ध हैं।</p>
<h2>बिल्ट-इन सपोर्टेड टाइप्स</h2>
<p>ये टाइप्स डिफ़ॉल्ट रूप से सीरियलाइज़ किए जा सकते हैं:</p>
<ul>
<li>.NET प्रिमिटिव्स (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, आदि)</li>
<li>Unmanaged टाइप्स (कोई भी <code>enum</code>, कोई भी यूज़र-डिफाइन्ड <code>struct</code> जिसमें रेफरेंस टाइप्स न हों)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code>, <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory&lt;&gt;</code>, <code>ReadOnlyMemory&lt;&gt;</code>, <code>ArraySegment&lt;&gt;</code>, <code>ReadOnlySequence&lt;&gt;</code></li>
<li><code>Nullable&lt;&gt;</code>, <code>Lazy&lt;&gt;</code>, <code>KeyValuePair&lt;,&gt;</code>, <code>Tuple&lt;,...&gt;</code>, <code>ValueTuple&lt;,...&gt;</code></li>
<li><code>List&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>SortedSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code></li>
<li><code>Dictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>,  <code>ReadOnlyDictionary&lt;,&gt;</code></li>
<li><code>Collection&lt;&gt;</code>, <code>ReadOnlyCollection&lt;&gt;</code>, <code>ObservableCollection&lt;&gt;</code>, <code>ReadOnlyObservableCollection&lt;&gt;</code></li>
<li><code>IEnumerable&lt;&gt;</code>, <code>ICollection&lt;&gt;</code>, <code>IList&lt;&gt;</code>, <code>IReadOnlyCollection&lt;&gt;</code>, <code>IReadOnlyList&lt;&gt;</code>, <code>ISet&lt;&gt;</code></li>
<li><code>IDictionary&lt;,&gt;</code>, <code>IReadOnlyDictionary&lt;,&gt;</code>, <code>ILookup&lt;,&gt;</code>, <code>IGrouping&lt;,&gt;</code>,</li>
<li><code>ConcurrentBag&lt;&gt;</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>, <code>BlockingCollection&lt;&gt;</code></li>
<li>Immutable collections (<code>ImmutableList&lt;&gt;</code>, आदि) और इंटरफेसेस (<code>IImmutableList&lt;&gt;</code>, आदि)</li>
</ul>
<h2><code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code> को परिभाषित करें</h2>
<p><code>[MemoryPackable]</code> को किसी भी <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> और <code>interface</code> पर लगाया जा सकता है। यदि कोई टाइप <code>struct</code> या <code>record struct</code> है जिसमें कोई रेफरेंस टाइप नहीं है (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>), तो कोई अतिरिक्त एट्रिब्यूट (ignore, include, constructor, callbacks) उपयोग नहीं होते, इसे सीधे मेमोरी से सीरियलाइज़/डीसीरियलाइज़ किया जाता है।</p>
<p>अन्यथा, डिफ़ॉल्ट रूप से, <code>[MemoryPackable]</code> पब्लिक इंस्टेंस प्रॉपर्टीज़ या फील्ड्स को सीरियलाइज़ करता है। आप <code>[MemoryPackIgnore]</code> का उपयोग करके किसी सीरियलाइज़ेशन टार्गेट को हटा सकते हैं, <code>[MemoryPackInclude]</code> किसी प्राइवेट सदस्य को सीरियलाइज़ेशन टार्गेट में प्रमोट करता है।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // ये टाइप्स डिफ़ॉल्ट रूप से सीरियलाइज़ होते हैं
    public int PublicField;
    public readonly int PublicReadOnlyField;
    public int PublicProperty { get; set; }
    public int PrivateSetPublicProperty { get; private set; }
    public int ReadOnlyPublicProperty { get; }
    public int InitProperty { get; init; }
    public required int RequiredInitProperty { get; init; }

    // ये टाइप्स डिफ़ॉल्ट रूप से सीरियलाइज़ नहीं होते हैं
    int privateProperty { get; set; }
    int privateField;
    readonly int privateReadOnlyField;

    // किसी पब्लिक सदस्य को टार्गेट से हटाने के लिए [MemoryPackIgnore] का उपयोग करें
    [MemoryPackIgnore]
    public int PublicProperty2 =&gt; PublicProperty + PublicField;

    // किसी प्राइवेट सदस्य को सीरियलाइज़ेशन टार्गेट में प्रमोट करने के लिए [MemoryPackInclude] का उपयोग करें
    [MemoryPackInclude]
    int privateField2;
    [MemoryPackInclude]
    int privateProperty2 { get; set; }
}
</code></pre>
<p><code>MemoryPack</code> का कोड जनरेटर <code>&lt;remarks /&gt;</code> सेक्शन में यह जानकारी जोड़ता है कि कौन से सदस्य सीरियलाइज़ किए गए हैं। इसे टाइप पर Intellisense के साथ होवर करके देखा जा सकता है।</p>
<p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image" /></p>
<p>सभी सदस्यों का मेमोरीपैक-सीरियलाइज़ेबल होना आवश्यक है, यदि नहीं, तो कोड जनरेटर त्रुटि देगा।</p>
<p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image" /></p>
<p>MemoryPack में 35 डायग्नोस्टिक्स नियम हैं (<code>MEMPACK001</code> से <code>MEMPACK035</code>) ताकि डिफ़ाइन करना सरल हो।</p>
<p>यदि टार्गेट टाइप का MemoryPack सीरियलाइज़ेशन बाहरी रूप से डिफाइन किया गया है और रजिस्टर्ड है, तो डायग्नोस्टिक्स को साइलेंट करने के लिए <code>[MemoryPackAllowSerialize]</code> का उपयोग करें।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample2
{
    [MemoryPackAllowSerialize]
    public NotSerializableType? NotSerializableProperty { get; set; }
}
</code></pre>
<p>सदस्यों का क्रम <strong>महत्वपूर्ण</strong> है, MemoryPack सदस्य-नाम या अन्य जानकारी को सीरियलाइज़ नहीं करता, बल्कि फील्ड्स को उनके डिक्लेरेशन क्रम में सीरियलाइज़ करता है। यदि टाइप इनहेरिटेड है, तो सीरियलाइज़ेशन माता-पिता → बच्चे के क्रम में किया जाता है। डीसिरियलाइज़ेशन के लिए सदस्यों का क्रम बदला नहीं जा सकता। स्कीमा इवोल्यूशन के लिए, <a href="#version-tolerant">Version tolerant</a> अनुभाग देखें।</p>
<p>डिफ़ॉल्ट क्रम अनुक्रमिक है, लेकिन आप <code>[MemoryPackable(SerializeLayout.Explicit)]</code> और <code>[MemoryPackOrder()]</code> के साथ स्पष्ट लेआउट चुन सकते हैं।</p>
<pre><code class="language-csharp">// Prop0 -&gt; Prop1 को सीरियलाइज़ करें
[MemoryPackable(SerializeLayout.Explicit)]
public partial class SampleExplicitOrder
{
    [MemoryPackOrder(1)]
    public int Prop1 { get; set; }
    [MemoryPackOrder(0)]
    public int Prop0 { get; set; }
}
</code></pre>
<h3>कन्स्ट्रक्टर चयन</h3>
<p>MemoryPack पैरामीटराइज्ड और पैरामीटरलेस दोनों कन्स्ट्रक्टर्स को सपोर्ट करता है। कन्स्ट्रक्टर का चयन ये नियम अपनाता है (क्लास और स्ट्रक्चर दोनों पर लागू):</p>
<ul>
<li>यदि <code>[MemoryPackConstructor]</code> है, तो उसी का उपयोग करें।</li>
<li>यदि कोई स्पष्ट कन्स्ट्रक्टर (प्राइवेट सहित) नहीं है, तो पैरामीटरलेस का उपयोग करें।</li>
<li>यदि एक ही पैरामीटरलेस/पैरामीटराइज्ड कन्स्ट्रक्टर (प्राइवेट सहित) है, तो उसी का उपयोग करें।</li>
<li>यदि एक से अधिक कन्स्ट्रक्टर हैं, तो वांछित कन्स्ट्रक्टर पर <code>[MemoryPackConstructor]</code> एट्रिब्यूट लगाया जाना चाहिए (जनरेटर अपने आप कोई नहीं चुनेगा), अन्यथा जनरेटर त्रुटि देगा।</li>
<li>यदि पैरामीटराइज्ड कन्स्ट्रक्टर का उपयोग करते हैं, तो सभी पैरामीटर नाम संबंधित सदस्य नामों से मेल खाने चाहिए (केस-इन्सेंसिटिव)।</li>
</ul>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Person
{
    public readonly int Age;
    public readonly string Name;

    // आप पैरामीटराइज्ड कन्स्ट्रक्टर का उपयोग कर सकते हैं - पैरामीटर नाम संबंधित सदस्यों के नाम से मेल खाने चाहिए (केस-इन्सेंसिटिव)
    public Person(int age, string name)
    {
        this.Age = age;
        this.Name = name;
    }
}

// रिकॉर्ड प्राइमरी कन्स्ट्रक्टर भी सपोर्टेड है
[MemoryPackable]
public partial record Person2(int Age, string Name);

public partial class Person3
{
    public int Age { get; set; }
    public string Name { get; set; }

    public Person3()
    {
    }
</code></pre>
<pre><code class="language-csharp">// यदि एक से अधिक कंस्ट्रक्टर हैं, तो [MemoryPackConstructor] का उपयोग किया जाना चाहिए
[MemoryPackConstructor]
public Person3(int age, string name)
{
    this.Age = age;
    this.Name = name;
}
</code></pre>
<h3>सीरियलाइज़ेशन कॉलबैक</h3>
<p>सीरियलाइज़/डिसीरियलाइज़ करते समय, MemoryPack <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code> एट्रिब्यूट्स का उपयोग कर के पहले/बाद में इवेंट को इनवोक कर सकता है। यह दोनों static और instance (non-static) मेथड्स, और public तथा private मेथड्स पर एनोनेट किया जा सकता है।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class MethodCallSample
{
    // मेथड कॉल ऑर्डर है static -&gt; instance
    [MemoryPackOnSerializing]
    public static void OnSerializing1()
    {
        Console.WriteLine(nameof(OnSerializing1));
    }

    // प्राइवेट मेथड भी अनुमति है
    [MemoryPackOnSerializing]
    void OnSerializing2()
    {
        Console.WriteLine(nameof(OnSerializing2));
    }

    // serializing -&gt; /* serialize */ -&gt; serialized
    [MemoryPackOnSerialized]
    static void OnSerialized1()
    {
        Console.WriteLine(nameof(OnSerialized1));
    }

    [MemoryPackOnSerialized]
    public void OnSerialized2()
    {
        Console.WriteLine(nameof(OnSerialized2));
    }

    [MemoryPackOnDeserializing]
    public static void OnDeserializing1()
    {
        Console.WriteLine(nameof(OnDeserializing1));
    }

    // नोट: instance मेथड जिसमें MemoryPackOnDeserializing है, वह तब नहीं कॉल होता अगर instance `ref` से पास न हो
    [MemoryPackOnDeserializing]
    public void OnDeserializing2()
    {
        Console.WriteLine(nameof(OnDeserializing2));
    }

    [MemoryPackOnDeserialized]
    public static void OnDeserialized1()
    {
        Console.WriteLine(nameof(OnDeserialized1));
    }

    [MemoryPackOnDeserialized]
    public void OnDeserialized2()
    {
        Console.WriteLine(nameof(OnDeserialized2));
    }
}
</code></pre>
<p>कॉलबैक बिना पैरामीटर वाले मेथड और <code>ref reader/writer, ref T value</code> मेथड की अनुमति देता है। उदाहरण के लिए, ref कॉलबैक सीरियलाइज़ेशन प्रोसेस से पहले कस्टम हेडर लिख/पढ़ सकते हैं।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class EmitIdData
{
    public int MyProperty { get; set; }

    [MemoryPackOnSerializing]
    static void WriteId&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, ref EmitIdData? value)
        where TBufferWriter : IBufferWriter&lt;byte&gt; // .NET Standard 2.1, उपयोग करें where TBufferWriter : class, IBufferWriter&lt;byte&gt;
    {
        writer.WriteUnmanaged(Guid.NewGuid()); // हेडर में GUID लिखें।
    }

    [MemoryPackOnDeserializing]
    static void ReadId(ref MemoryPackReader reader, ref EmitIdData? value)
    {
        // डिसीरियलाइज़ से पहले कस्टम हेडर पढ़ें
        var guid = reader.ReadUnmanaged&lt;Guid&gt;();
        Console.WriteLine(guid);
    }
}
</code></pre>
<p>यदि <code>ref value</code> में कोई मान सेट किया जाए, तो आप सीरियलाइज़ेशन/डिसीरियलाइज़ेशन के लिए उपयोग किए गए मान को बदल सकते हैं। उदाहरण के लिए, ServiceProvider से इंस्टेंसिएट करें।</p>
<pre><code class="language-csharp">// इस फॉर्मेटर का उपयोग करने से पहले, ServiceProvider सेट करें
// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };
// MemoryPackSerializer.Deserialize(value, options);

[MemoryPackable]
public partial class InstantiateFromServiceProvider
{
    static IServiceProvider serviceProvider = default!;

    public int MyProperty { get; private set; }

    [MemoryPackOnDeserializing]
    static void OnDeserializing(ref MemoryPackReader reader, ref InstantiateFromServiceProvider value)
    {
        if (value != null) return;
        value = reader.Options.ServiceProvider!.GetRequiredService&lt;InstantiateFromServiceProvider&gt;();
    }
}
</code></pre>
<h2>कस्टम कलेक्शन परिभाषित करें</h2>
<p>डिफ़ॉल्ट रूप से, एनोनेटेड <code>[MemoryPackObject]</code> टाइप अपने सदस्यों को सीरियलाइज़ करने की कोशिश करता है। हालांकि, यदि कोई टाइप कलेक्शन (<code>ICollection&lt;&gt;</code>, <code>ISet&lt;&gt;</code>, <code>IDictionary&lt;,&gt;</code>) है, तो इसे सही तरीके से सीरियलाइज़ करने के लिए <code>GenerateType.Collection</code> का उपयोग करें।</p>
<pre><code class="language-csharp">[MemoryPackable(GenerateType.Collection)]
public partial class MyList&lt;T&gt; : List&lt;T&gt;
{
}

[MemoryPackable(GenerateType.Collection)]
public partial class MyStringDictionary&lt;TValue&gt; : Dictionary&lt;string, TValue&gt;
{

}
</code></pre>
<h2>Static constructor</h2>
<p>MemoryPackable क्लास static constructor को परिभाषित नहीं कर सकती क्योंकि जेनेरेटेड partial class इसका उपयोग करती है। इसके बजाय, आप वही कार्य करने के लिए <code>static partial void StaticConstructor()</code> परिभाषित कर सकते हैं।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class CctorSample
{
    static partial void StaticConstructor()
    {
    }
}
</code></pre>
<h2>Polymorphism (Union)</h2>
<p>MemoryPack इंटरफेस और एब्सट्रैक्ट क्लास ऑब्जेक्ट्स को सीरियलाइज़ करने के लिए पोलीमॉर्फिज्म सीरियलाइज़ेशन का समर्थन करता है। MemoryPack में इस फीचर को Union कहा जाता है। केवल इंटरफेस और एब्सट्रैक्ट क्लासेज को <code>[MemoryPackUnion]</code> एट्रिब्यूट्स के साथ एनोनेट करने की अनुमति है। यूनिक यूनियन टैग्स आवश्यक हैं।</p>
<pre><code class="language-csharp">// [MemoryPackable] और इनहेरिटेंस टाइप्स को [MemoryPackUnion] से एनोनेट करें
// Union एब्सट्रैक्ट क्लास को भी सपोर्ट करता है
[MemoryPackable]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial interface IUnionSample
{
}

[MemoryPackable]
public partial class FooClass : IUnionSample
{
    public int XYZ { get; set; }
}

[MemoryPackable]
public partial class BarClass : IUnionSample
{
    public string? OPQ { get; set; }
}
// ---

IUnionSample data = new FooClass() { XYZ = 999 };

// इंटरफेस टाइप के रूप में सीरियलाइज़ करें।
var bin = MemoryPackSerializer.Serialize(data);

// इंटरफेस टाइप के रूप में डिसीरियलाइज़ करें।
var reData = MemoryPackSerializer.Deserialize&lt;IUnionSample&gt;(bin);

switch (reData)
{
    case FooClass x:
        Console.WriteLine(x.XYZ);
        break;
    case BarClass x:
        Console.WriteLine(x.OPQ);
        break;
    default:
        break;
}
</code></pre>
<p><code>tag</code> की अनुमति <code>0</code> ~ <code>65535</code> तक है, यह विशेष रूप से <code>250</code> से कम के लिए कुशल है।</p>
<pre><code>यदि कोई इंटरफ़ेस और डेराइव्ड टाइप्स अलग-अलग असेंबली में हैं, तो आप इसके बजाय `MemoryPackUnionFormatterAttribute` का उपयोग कर सकते हैं। फॉर्मेटर्स इस प्रकार जनरेट किए जाते हैं कि वे स्वचालित रूप से C# 9.0 और उसके ऊपर में `ModuleInitializer` के माध्यम से रजिस्टर हो जाते हैं।

&gt; ध्यान दें कि `ModuleInitializer` यूनिटी में समर्थित नहीं है, इसलिए फॉर्मेटर को मैन्युअली रजिस्टर करना होगा। अपने यूनियन फॉर्मेटर को रजिस्टर करने के लिए स्टार्टअप में `{name of your union formatter}Initializer.RegisterFormatter()` मैन्युअली कॉल करें। उदाहरण के लिए `UnionSampleFormatterInitializer.RegisterFormatter()`।

```csharp
// AssemblyA
[MemoryPackable(GenerateType.NoGenerate)]
public partial interface IUnionSample
{
}

// AssemblyB में टारगेट टाइप के बाहर डिफिनिशन डिफाइन करें
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(0, typeof(FooClass))]
[MemoryPackUnion(1, typeof(BarClass))]
public partial class UnionSampleFormatter
{
}
</code></pre>
<p>यूनियन को कोड में <code>DynamicUnionFormatter&lt;T&gt;</code> के माध्यम से असेंबल किया जा सकता है।</p>
<pre><code class="language-csharp">// (ushort, Type)[]
var formatter = new DynamicUnionFormatter&lt;IFooBarBaz&gt;(
    (0, typeof(Foo)),
    (1, typeof(Bar)),
    (2, typeof(Baz))
);

MemoryPackFormatterProvider.Register(formatter);
</code></pre>
<h2>Serialize API</h2>
<p><code>Serialize</code> के तीन ओवरलोड्स हैं।</p>
<pre><code class="language-csharp">// नॉन-जेनरिक API भी उपलब्ध है, इन वर्शन में पहला आर्ग्युमेंट टाइप होता है और वैल्यू ऑब्जेक्ट?
byte[] Serialize&lt;T&gt;(in T? value, MemoryPackSerializerOptions? options = default)
void Serialize&lt;T, TBufferWriter&gt;(in TBufferWriter bufferWriter, in T? value, MemoryPackSerializerOptions? options = default)
async ValueTask SerializeAsync&lt;T&gt;(Stream stream, T? value, MemoryPackSerializerOptions? options = default, CancellationToken cancellationToken = default)
</code></pre>
<p>परफॉर्मेंस के लिए, अनुशंसित API <code>BufferWriter</code> का उपयोग करता है। यह सीधे बफर में सीरियलाइज़ करता है। इसे <code>System.IO.Pipelines</code> के <code>PipeWriter</code>, ASP .NET Core के <code>BodyWriter</code> आदि पर लागू किया जा सकता है।</p>
<p>यदि <code>byte[]</code> आवश्यक है (जैसे <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a> में <code>RedisValue</code>), तो रिटर्निंग <code>byte[]</code> API सरल और लगभग उतना ही तेज़ है।</p>
<p>ध्यान दें कि <code>Stream</code> के लिए <code>SerializeAsync</code> केवल Flush के लिए असिंक्रोनस है; यह सब कुछ एक बार MemoryPack के इंटरनल पूल बफर में सीरियलाइज़ करता है और फिर <code>WriteAsync</code> का उपयोग करता है। इसलिए, <code>BufferWriter</code> ओवरलोड, जो बफर और फ्लश को अलग और नियंत्रित करता है, बेहतर है।</p>
<p>यदि आप पूरी तरह से स्ट्रीमिंग राइट करना चाहते हैं, तो <a href="#streaming-serialization">Streaming Serialization</a> सेक्शन देखें।</p>
<h3>MemoryPackSerializerOptions</h3>
<p><code>MemoryPackSerializerOptions</code> यह कॉन्फ़िगर करता है कि स्ट्रिंग्स को UTF16 या UTF8 के रूप में सीरियलाइज़ किया जाए। इसे UTF8 एन्कोडिंग के लिए <code>MemoryPackSerializerOptions.Utf8</code>, UTF16 के लिए <code>MemoryPackSerializerOptions.Utf16</code> या डिफ़ॉल्ट के लिए <code>MemoryPackSerializerOptions.Default</code> (जो डिफ़ॉल्ट रूप से UTF8 है) पास करके सेट किया जा सकता है। null पास करने या डिफ़ॉल्ट पैरामीटर का उपयोग करने पर UTF8 एन्कोडिंग होती है।</p>
<p>चूंकि C# की इंटरनल स्ट्रिंग रिप्रेजेंटेशन UTF16 है, इसलिए UTF16 परफॉर्मेंस में बेहतर है। हालांकि, पेलोड आमतौर पर बड़ा होता है; UTF8 में एक ASCII स्ट्रिंग एक बाइट है, जबकि UTF16 में दो बाइट होती है। इस पेलोड के साइज में बड़ा अंतर होने के कारण, डिफ़ॉल्ट रूप से UTF8 सेट किया गया है।</p>
<p>यदि डेटा नॉन-ASCII है (जैसे जापानी, जो 3 से अधिक बाइट हो सकता है, और UTF8 में बड़ा होता है), या यदि आपको इसे अलग से कंप्रेस करना है, तो UTF16 बेहतर परिणाम दे सकता है।</p>
<p>सीरियलाइज़ेशन के दौरान आप UTF8 या UTF16 चुन सकते हैं, लेकिन डीसिरियलाइज़ेशन के दौरान इसे स्पेसिफाई करना आवश्यक नहीं है। यह स्वचालित रूप से डिटेक्ट और सामान्य रूप से डीसिरियलाइज़ हो जाएगा।</p>
<p>इसके अलावा, आप ऑप्शंस से <code>IServiceProvider? ServiceProvider { get; init; }</code> प्राप्त/सेट कर सकते हैं। यह सीरियलाइज़ेशन प्रोसेस से DI ऑब्जेक्ट (जैसे <code>ILogger&lt;T&gt;</code>) प्राप्त करने में उपयोगी है (<code>MemoryPackReader/MemoryPackWriter</code> में .Options प्रॉपर्टी है)।</p>
<h2>Deserialize API</h2>
<p><code>Deserialize</code> में <code>ReadOnlySpan&lt;byte&gt;</code> और <code>ReadOnlySequence&lt;byte&gt;</code>, <code>Stream</code> ओवरलोड और <code>ref</code> सपोर्ट है।</p>
<pre><code class="language-csharp">T? Deserialize&lt;T&gt;(ReadOnlySpan&lt;byte&gt; buffer)
int Deserialize&lt;T&gt;(ReadOnlySpan&lt;byte&gt; buffer, ref T? value)
T? Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; buffer)
int Deserialize&lt;T&gt;(in ReadOnlySequence&lt;byte&gt; buffer, ref T? value)
async ValueTask&lt;T?&gt; DeserializeAsync&lt;T&gt;(Stream stream)
</code></pre>
<p><code>ref</code> ओवरलोड मौजूदा इंस्टेंस को ओवरराइट करता है, विवरण के लिए <a href="#overwrite">Overwrite</a> सेक्शन देखें।</p>
<p><code>DeserializeAsync(Stream)</code> पूरी तरह से स्ट्रीमिंग रीड ऑपरेशन नहीं है, पहले यह MemoryPack के इंटरनल पूल में एंड-ऑफ-स्ट्रीम तक पढ़ता है, फिर डीसिरियलाइज़ करता है।</p>
<p>यदि आप पूरी तरह से स्ट्रीमिंग रीड ऑपरेशन करना चाहते हैं, तो <a href="#streaming-serialization">Streaming Serialization</a> सेक्शन देखें।</p>
<h2>Overwrite</h2>
<p>अलोकेशन्स को कम करने के लिए, MemoryPack मौजूदा इंस्टेंस में डीसिरियलाइज़ करके उसे ओवरराइट करने को सपोर्ट करता है। इसे <code>Deserialize(ref T? value)</code> ओवरलोड के साथ उपयोग किया जा सकता है।</p>
<pre><code class="language-csharp">var person = new Person();
var bin = MemoryPackSerializer.Serialize(person);

// मौजूदा इंस्टेंस में डेटा ओवरराइट करें।
MemoryPackSerializer.Deserialize(bin, ref person);
</code></pre>
<p>MemoryPack जितना संभव हो उतना ओवरराइट करने का प्रयास करेगा, लेकिन यदि निम्नलिखित कंडीशंस मेल नहीं खातीं, तो यह नया इंस्टेंस बनाएगा (सामान्य डीसिरियलाइज़ेशन की तरह)।</p>
<ul>
<li>ref value (ऑब्जेक्ट ग्राफ में मेंबर्स सहित) null है, नया इंस्टेंस सेट करें</li>
<li>केवल पैरामीटरलेस कंस्ट्रक्टर की अनुमति है, यदि पैरामीटराइज्ड कंस्ट्रक्टर का उपयोग किया गया है, तो नया इंस्टेंस बनाएं</li>
<li>यदि value <code>T[]</code> है, तो केवल तभी री-यूज़ करें जब लेंथ समान हो, अन्यथा नया इंस्टेंस बनाएं</li>
<li>यदि value ऐसी कलेक्शन है जिसमें <code>.Clear()</code> मेथड है (<code>List&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentBag&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>) तो Clear() कॉल करें और री-यूज़ करें, अन्यथा नया इंस्टेंस बनाएं</li>
</ul>
<h2>Version tolerant</h2>
<p>डिफ़ॉल्ट में (<code>GenerateType.Object</code>), MemoryPack सीमित स्कीमा इवोल्यूशन को सपोर्ट करता है।</p>
<ul>
<li>unmanaged struct अब बदला नहीं जा सकता</li>
<li>मेंबर्स जोड़े जा सकते हैं, लेकिन हटाए नहीं जा सकते</li>
<li>मेंबर नाम बदला जा सकता है</li>
<li>मेंबर ऑर्डर बदला नहीं जा सकता</li>
<li>मेंबर टाइप बदला नहीं जा सकता</li>
</ul>
<pre><code class="language-csharp">[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}

// Add करना ठीक है।
[MemoryPackable]
public partial class VersionCheck
{
    public int Prop1 { get; set; }
    public long Prop2 { get; set; }
    public int? AddedProp { get; set; }
}

// Remove करना NG (नॉट गुड) है।
[MemoryPackable]
public partial class VersionCheck
{
    // public int Prop1 { get; set; }
    public long Prop2 { get; set; }
}

// ऑर्डर बदलना NG (नॉट गुड) है।
[MemoryPackable]
public partial class VersionCheck
{
    public long Prop2 { get; set; }
    public int Prop1 { get; set; }
}
</code></pre>
<p>उपयोग में, पुराना डेटा (फाइल में, रेडिस में आदि) स्टोर करें और नए स्कीमा में पढ़ना हमेशा ठीक है। RPC परिदृश्य में, स्कीमा क्लाइंट और सर्वर दोनों साइड पर मौजूद होता है, क्लाइंट को सर्वर से पहले अपडेट करना चाहिए। अपडेटेड क्लाइंट को पुराने सर्वर से कनेक्ट करने में कोई समस्या नहीं है, लेकिन पुराना क्लाइंट नए सर्वर से कनेक्ट नहीं कर सकता।</p>
<p>डिफ़ॉल्ट रूप से, जब पुराना डेटा नए स्कीमा में पढ़ा जाता है, तो डेटा साइड पर मौजूद न होने वाले सभी मेंबर्स को <code>default</code> लिटरल से इनिशियलाइज़ किया जाता है।
यदि आप इससे बचना चाहते हैं और फील्ड/प्रॉपर्टीज के इनिशियल वैल्यू का उपयोग करना चाहते हैं, तो आप <code>[SuppressDefaultInitialization]</code> का उपयोग कर सकते हैं।</p>
<pre><code class="language-cs">[MemoryPackable]
public partial class DefaultValue
{
    public string Prop1 { get; set; }

    [SuppressDefaultInitialization]
    public int Prop2 { get; set; } = 111; // &lt; अगर पुराना डेटा मिसिंग है तो `111` सेट करें।
    
    public int Prop3 { get; set; } = 222; // &lt; अगर पुराना डेटा मिसिंग है तो `default` सेट करें।
}
</code></pre>
<p><code>[SuppressDefaultInitialization]</code> की निम्नलिखित सीमाएँ हैं:</p>
<ul>
<li>इसे readonly, init-only, और required मोडिफायर के साथ उपयोग नहीं किया जा सकता।</li>
</ul>
<p>अगला <a href="#serialization-info">Serialization info</a> सेक्शन दिखाता है कि स्कीमा बदलावों की जांच कैसे करें, जैसे CI के द्वारा, दुर्घटनाओं को रोकने के लिए।</p>
<p>जब <code>GenerateType.VersionTolerant</code> का उपयोग करते हैं, तो यह पूर्ण वर्शन-टॉलरेंट को सपोर्ट करता है।</p>
<ul>
<li>unmanaged struct अब बदला नहीं जा सकता</li>
<li>सभी मेंबर्स को स्पष्ट रूप से <code>[MemoryPackOrder]</code> जोड़ना आवश्यक है (सिवाय <code>SerializeLayout.Sequential</code> के)</li>
<li>मेंबर्स जोड़े जा सकते हैं, हटाए जा सकते हैं लेकिन ऑर्डर को री-यूज़ नहीं किया जा सकता (मिसिंग ऑर्डर का उपयोग कर सकते हैं)</li>
<li>मेंबर नाम बदला जा सकता है</li>
<li>मेंबर ऑर्डर बदला नहीं जा सकता</li>
<li>मेंबर टाइप बदला नहीं जा सकता</li>
</ul>
<pre><code class="language-csharp">// दोनों को serialize/deserialize करना ठीक है 
// VersionTolerantObject1 -&gt; VersionTolerantObject2 और 
// VersionTolerantObject2 -&gt; VersionTolerantObject1

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject1
{
    [MemoryPackOrder(0)]
    public int MyProperty0 { get; set; } = default;

    [MemoryPackOrder(1)]
    public long MyProperty1 { get; set; } = default;

    [MemoryPackOrder(2)]
    public short MyProperty2 { get; set; } = default;
}

[MemoryPackable(GenerateType.VersionTolerant)]
public partial class VersionTolerantObject2
{
```csharp
[MemoryPackOrder(0)]
public int MyProperty0 { get; set; } = default;

// हटाया गया
//[MemoryPackOrder(1)]
//public long MyProperty1 { get; set; } = default;

[MemoryPackOrder(2)]
public short MyProperty2 { get; set; } = default;

// जोड़ा गया
[MemoryPackOrder(3)]
public short MyProperty3 { get; set; } = default;
}
</code></pre>
<pre><code class="language-csharp">// यदि SerializeLayout.Sequential को स्पष्ट रूप से सेट किया गया है, तो स्वतः क्रम की अनुमति देता है।
// लेकिन यह वर्शन-टॉलरेंट के लिए कोई सदस्य हटाने की अनुमति नहीं देता।
[MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)]
public partial class VersionTolerantObject3
{
    public int MyProperty0 { get; set; } = default;
    public long MyProperty1 { get; set; } = default;
    public short MyProperty2 { get; set; } = default;
}
</code></pre>
<p><code>GenerateType.VersionTolerant</code> को serialize करने में <code>GenerateType.Object</code> की तुलना में धीमा है। साथ ही, पेलोड का आकार थोड़ा बड़ा होगा।</p>
<h2>Serialization जानकारी</h2>
<p>आप यह देख सकते हैं कि किस प्रकार के कौन से सदस्य serialize हो रहे हैं, इसके लिए IntelliSense में चेक करें। एक विकल्प है कि इस जानकारी को compile समय पर एक फ़ाइल में लिखा जाए। <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> को निम्न प्रकार से सेट करें।</p>
<pre><code class="language-xml">&lt;!-- memorypack serialization info को directory में आउटपुट करें --&gt;
&lt;ItemGroup&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_SerializationInfoOutputDirectory&quot; /&gt;
&lt;/ItemGroup&gt;
&lt;PropertyGroup&gt;
    &lt;MemoryPackGenerator_SerializationInfoOutputDirectory&gt;$(MSBuildProjectDirectory)\MemoryPackLogs&lt;/MemoryPackGenerator_SerializationInfoOutputDirectory&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>निम्न जानकारी फ़ाइल में लिखी जाती है।</p>
<p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image" /></p>
<p>यदि प्रकार unmanaged है, तो type नाम से पहले <code>unmanaged</code> दिखाया जाता है।</p>
<pre><code class="language-txt">unmanaged FooStruct
---
int x
int y
</code></pre>
<p>इस फ़ाइल में अंतर की जाँच करके, खतरनाक schema बदलाव को रोका जा सकता है। उदाहरण के लिए, आप निम्न नियमों का पता लगाने के लिए CI का उपयोग कर सकते हैं</p>
<ul>
<li>unmanaged type को बदलना</li>
<li>सदस्य के क्रम में परिवर्तन</li>
<li>सदस्य को हटाना</li>
</ul>
<h2>Circular Reference</h2>
<p>MemoryPack सर्कुलर रेफरेंस को भी सपोर्ट करता है। इससे ट्री ऑब्जेक्ट्स को जैसा है वैसा serialize किया जा सकता है।</p>
<pre><code class="language-csharp">// सर्कुलर-रेफरेंस सक्षम करने के लिए, GenerateType.CircularReference का उपयोग करें
[MemoryPackable(GenerateType.CircularReference)]
public partial class Node
{
    [MemoryPackOrder(0)]
    public Node? Parent { get; set; }
    [MemoryPackOrder(1)]
    public Node[]? Children { get; set; }
}
</code></pre>
<p>उदाहरण के लिए, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references">System.Text.Json preserve-references</a> कोड यहां जैसा होगा।</p>
<pre><code class="language-csharp">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0
Employee tyler = new()
{
    Name = &quot;Tyler Stein&quot;
};

Employee adrian = new()
{
    Name = &quot;Adrian King&quot;
};

tyler.DirectReports = new List&lt;Employee&gt; { adrian };
adrian.Manager = tyler;

var bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize&lt;Employee&gt;(bin);

Console.WriteLine(tylerDeserialized?.DirectReports?[0].Manager == tylerDeserialized); // true

[MemoryPackable(GenerateType.CircularReference)]
public partial class Employee
{
    [MemoryPackOrder(0)]
    public string? Name { get; set; }
    [MemoryPackOrder(1)]
    public Employee? Manager { get; set; }
    [MemoryPackOrder(2)]
    public List&lt;Employee&gt;? DirectReports { get; set; }
}
</code></pre>
<p><code>GenerateType.CircularReference</code> में version-tolerant के समान विशेषताएँ हैं। हालांकि, एक अतिरिक्त बाध्यता के रूप में, केवल parameterless constructors की अनुमति है। साथ ही, object reference tracking केवल उन्हीं objects के लिए किया जाता है जिन्हें <code>GenerateType.CircularReference</code> के साथ चिह्नित किया गया है। यदि आप किसी अन्य object को ट्रैक करना चाहते हैं, तो उसे wrap करें।</p>
<h2>CustomFormatter</h2>
<p>यदि आप <code>MemoryPackCustomFormatterAttribute&lt;T&gt;</code> या <code>MemoryPackCustomFormatterAttribute&lt;TFormatter, T&gt;</code> (अधिक performant, लेकिन जटिल) को implement करते हैं, तो आप MemoryPackObject के सदस्य के लिए custom formatter का उपयोग configure कर सकते हैं।</p>
<pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
public abstract class MemoryPackCustomFormatterAttribute&lt;T&gt; : Attribute
{
    public abstract IMemoryPackFormatter&lt;T&gt; GetFormatter();
}
</code></pre>
<p>MemoryPack निम्नलिखित formatting attributes प्रदान करता है: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute&lt;TValue&gt;</code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter&lt;T&gt;</code>, <code>MemoryPoolFormatter&lt;T&gt;</code>, <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    // इस सदस्य को UTF16 String के रूप में serialize करें, यह UTF8 की तुलना में बेहतर performance देता है लेकिन ASCII में, आकार बड़ा होता है (लेकिन non ASCII में कभी-कभी छोटा भी हो सकता है)।
    [Utf16StringFormatter]
    public string? Text { get; set; }

    // deserialize में, Dictionary को StringComparer.OrdinalIgnoreCase के साथ initialize किया जाता है।
    [OrdinalIgnoreCaseStringDictionaryFormatter&lt;int&gt;]
    public Dictionary&lt;string, int&gt;? Ids { get; set; }
    
    // deserialize समय, सभी string को intern किया जाता है (देखें: String.Intern)। यदि समान मान बार-बार आते हैं, तो यह memory बचाता है।
    [InternStringFormatter]
    public string? Flag { get; set; }
}
</code></pre>
<p>Set/dictionary के equality comparer को configure करने के लिए, सभी built-in formatter में एक comparer constructor overload होता है। आप आसानी से custom equality-comparer formatter बना सकते हैं।</p>
<pre><code class="language-csharp">public sealed class OrdinalIgnoreCaseStringDictionaryFormatter&lt;TValue&gt; : MemoryPackCustomFormatterAttribute&lt;Dictionary&lt;string, TValue?&gt;&gt;
{
    static readonly DictionaryFormatter&lt;string, TValue?&gt; formatter = new DictionaryFormatter&lt;string, TValue?&gt;(StringComparer.OrdinalIgnoreCase);

    public override IMemoryPackFormatter&lt;Dictionary&lt;string, TValue?&gt;&gt; GetFormatter()
    {
        return formatter;
    }
}
</code></pre>
<p><code>BitPackFormatter</code> केवल <code>bool[]</code> प्रकार को compress करता है। <code>bool[]</code> आमतौर पर प्रत्येक boolean मान के लिए 1 बाइट के रूप में serialize होता है, लेकिन <code>BitPackFormatter</code> <code>bool[]</code> को एक <code>BitArray</code> की तरह serialize करता है, जिसमें प्रत्येक bool को 1 बिट के रूप में संग्रहित किया जाता है। <code>BitPackFormatter</code> का उपयोग करने पर, 8 bools = 1 बाइट, जबकि सामान्यतः 8 बाइट होते, जिससे आकार 8 गुना कम हो जाता है।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BitPackFormatter]
    public bool[]? Data { get; set; }
}
</code></pre>
<p><code>BrotliFormatter</code> <code>byte[]</code> के लिए है, उदाहरण के लिए आप Brotli द्वारा बड़े payload को compress कर सकते हैं।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}
</code></pre>
<p><code>BrotliStringFormatter</code> <code>string</code> के लिए है, Brotli द्वारा compressed string (UTF16) को serialize करता है।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BrotliStringFormatter]
    public string? LargeText { get; set; }
}
</code></pre>
<p><code>BrotliFormatter&lt;T&gt;</code> किसी भी प्रकार के लिए है, ब्रोटली द्वारा संपीड़ित सीरियलाइज़्ड डेटा के लिए। यदि प्रकार <code>byte[]</code> या <code>string</code> है, तो प्रदर्शन के लिए आपको <code>BrotliFormatter</code> या <code>BrotliStringFormatter</code> का उपयोग करना चाहिए।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BrotliFormatter&lt;ChildType&gt;]
    public ChildType? Child { get; set; }
}
</code></pre>
<h2>एरे पूलिंग को डिसीरियलाइज़ करना</h2>
<p>किसी बड़े एरे (किसी भी <code>T</code>) को डिसीरियलाइज़ करने के लिए, MemoryPack कई कुशल पूलिंग विधियाँ प्रदान करता है। सबसे प्रभावी तरीका है <a href="#overwrite">#Overwrite</a> फ़ंक्शन का उपयोग करना। विशेष रूप से <code>List&lt;T&gt;</code> हमेशा पुन: उपयोग होती है।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class ListBytesSample
{
    public int Id { get; set; }
    public List&lt;byte&gt; Payload { get; set; }
}

// ----

// List&lt;byte&gt; पुन: उपयोग होती है, डिसीरियलाइज़ में कोई आवंटन नहीं।
MemoryPackSerializer.Deserialize&lt;ListBytesSample&gt;(bin, ref reuseObject);

// कुशल संचालन के लिए, आप CollectionsMarshal द्वारा Span&lt;T&gt; प्राप्त कर सकते हैं
var span = CollectionsMarshal.AsSpan(value.Payload);
</code></pre>
<p>एक सुविधाजनक तरीका है डिसीरियलाइज़ के समय ArrayPool में डिसीरियलाइज़ करना। MemoryPack <code>MemoryPoolFormatter&lt;T&gt;</code> और <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code> प्रदान करता है।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class PoolModelSample : IDisposable
{
    public int Id { get; }

    [MemoryPoolFormatter&lt;byte&gt;]
    public Memory&lt;byte&gt; Payload { get; private set; }

    public PoolModelSample(int id, Memory&lt;byte&gt; payload)
    {
        Id = id;
        Payload = payload;
    }

    // आपको return कोड स्वयं लिखना होगा, यहाँ स्निपेट है।

    bool usePool;

    [MemoryPackOnDeserialized]
    void OnDeserialized()
    {
        usePool = true;
    }

    public void Dispose()
    {
        if (!usePool) return;

        Return(Payload); Payload = default;
    }

    static void Return&lt;T&gt;(Memory&lt;T&gt; memory) =&gt; Return((ReadOnlyMemory&lt;T&gt;)memory);

    static void Return&lt;T&gt;(ReadOnlyMemory&lt;T&gt; memory)
    {
        if (MemoryMarshal.TryGetArray(memory, out var segment) &amp;&amp; segment.Array is { Length: &gt; 0 })
        {
            ArrayPool&lt;T&gt;.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;());
        }
    }
}

// ---

using(var value = MemoryPackSerializer.Deserialize&lt;PoolModelSample&gt;(bin))
{
    // कुछ भी करें...
}   // ArrayPool में वापस करें
</code></pre>
<h2>प्रदर्शन</h2>
<p>मेरा ब्लॉग पोस्ट देखें <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p>
<h2>पेलोड आकार और संपीड़न</h2>
<p>पेलोड आकार लक्ष्य मान पर निर्भर करता है; JSON के विपरीत, इसमें कोई कुंजी नहीं होती और यह एक बाइनरी फॉर्मेट है, इसलिए पेलोड आकार JSON से छोटा होने की संभावना है।</p>
<p>उनके लिए जिनमें varint एन्कोडिंग है, जैसे MessagePack और Protobuf, यदि बहुत अधिक int का उपयोग किया गया हो तो MemoryPack बड़ा हो सकता है (MemoryPack में, int हमेशा 4 बाइट होते हैं फिक्स्ड साइज एन्कोडिंग के कारण, जबकि MessagePack में 1~5 बाइट होते हैं)।</p>
<p>float और double MemoryPack में 4 बाइट और 8 बाइट हैं, लेकिन MessagePack में 5 बाइट और 9 बाइट हैं। तो उदाहरण के लिए, Vector3 (float, float, float) एरे के लिए MemoryPack छोटा होता है।</p>
<p>String डिफ़ॉल्ट रूप से UTF8 है, जो अन्य सीरियलाइज़र्स के समान है, लेकिन यदि UTF16 विकल्प चुना जाता है, तो यह अलग प्रकार का होगा।</p>
<p>किसी भी स्थिति में, यदि पेलोड आकार बड़ा है, तो संपीड़न पर विचार किया जाना चाहिए। LZ4, ZStandard और Brotli अनुशंसित हैं।</p>
<h3>संपीड़न</h3>
<p>MemoryPack <a href="https://github.com/google/brotli">Brotli</a> संपीड़न के लिए <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder">BrotliEncoder</a> और <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder">BrotliDecoder</a> के माध्यम से एक कुशल हेल्पर प्रदान करता है। MemoryPack के <code>BrotliCompressor</code> और <code>BrotliDecompressor</code> MemoryPack के आंतरिक व्यवहार के लिए अनुकूलित संपीड़न/डिसम्प्रेशन प्रदान करते हैं।</p>
<pre><code class="language-csharp">using MemoryPack.Compression;

// Compression(आवश्यक using)
using var compressor = new BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, value);

// संपीड़ित byte[] प्राप्त करें
var compressedBytes = compressor.ToArray();

// या अन्य IBufferWriter&lt;byte&gt; में लिखें (जैसे PipeWriter)
compressor.CopyTo(response.BodyWriter);
</code></pre>
<pre><code class="language-csharp">using MemoryPack.Compression;

// Decompression(आवश्यक using)
using var decompressor = new BrotliDecompressor();

// ReadOnlySpan&lt;byte&gt; या ReadOnlySequence&lt;byte&gt; से डिसम्प्रेस्ड ReadOnlySequence&lt;byte&gt; प्राप्त करें
var decompressedBuffer = decompressor.Decompress(buffer);

var value = MemoryPackSerializer.Deserialize&lt;T&gt;(decompressedBuffer);
</code></pre>
<p>दोनों <code>BrotliCompressor</code> और <code>BrotliDecompressor</code> struct हैं, यह heap पर मेमोरी आवंटित नहीं करते। दोनों Serialize/Deserialize के लिए डेटा को एक आंतरिक मेमोरी पूल में संग्रहित करते हैं। इसलिए, मेमोरी पूलिंग को रिलीज़ करना आवश्यक है, <code>using</code> का उपयोग करना न भूलें।</p>
<p>संपीड़न स्तर बहुत महत्वपूर्ण है। डिफ़ॉल्ट रूप से quality-1 (CompressionLevel.Fastest) सेट किया गया है, जो .NET डिफ़ॉल्ट (CompressionLevel.Optimal, quality-4) से अलग है।</p>
<p>Fastest (quality-1) की गति <a href="https://github.com/lz4/lz4">LZ4</a> के करीब होगी, लेकिन 4 बहुत धीमा है। यह सीरियलाइज़र उपयोग परिदृश्य में महत्वपूर्ण पाया गया। मानक <code>BrotliStream</code> का उपयोग करते समय सावधान रहें (डिफ़ॉल्ट quality-4 है)। किसी भी स्थिति में, संपीड़न/डिसम्प्रेशन की गति और आकार अलग-अलग डेटा के लिए बहुत भिन्न होंगे। कृपया अपने एप्लिकेशन द्वारा उपयोग किए जाने वाले डेटा के साथ स्वयं परीक्षण करें।</p>
<p>ध्यान दें कि MemoryPack के असंपीड़ित और Brotli के संपीड़न के बीच कई गुना गति दंड है।</p>
<p>Brotli कस्टम फ़ॉर्मेटर में भी समर्थित है। <code>BrotliFormatter</code> किसी विशिष्ट सदस्य को संपीड़ित कर सकता है।</p>
<pre><code class="language-csharp">[MemoryPackable]
public partial class Sample
{
    public int Id { get; set; }

    [BrotliFormatter]
    public byte[]? Payload { get; set; }
}
</code></pre>
<h2>बाहरी प्रकारों को सीरियलाइज़ करें</h2>
<p>यदि आप बाहरी प्रकारों को सीरियलाइज़ करना चाहते हैं, तो आप एक कस्टम फ़ॉर्मेटर बना सकते हैं और उसे प्रोवाइडर में रजिस्टर कर सकते हैं, विवरण के लिए देखें <a href="#formatterprovider-api">Formatter/Provider API</a>। हालांकि, एक कस्टम फ़ॉर्मेटर बनाना कठिन है। इसलिए, हम एक रैपर टाइप बनाने की सलाह देते हैं। उदाहरण के लिए, यदि आप <code>AnimationCurve</code> नामक बाहरी प्रकार को सीरियलाइज़ करना चाहते हैं।</p>
<pre><code class="language-csharp">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)
[MemoryPackable]
public readonly partial struct SerializableAnimationCurve
{
    [MemoryPackIgnore]
    public readonly AnimationCurve AnimationCurve;

    [MemoryPackInclude]
    WrapMode preWrapMode =&gt; AnimationCurve.preWrapMode;
    [MemoryPackInclude]
    WrapMode postWrapMode =&gt; AnimationCurve.postWrapMode;
    [MemoryPackInclude]
    Keyframe[] keys =&gt; AnimationCurve.keys;

    [MemoryPackConstructor]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        var curve = new AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        this.AnimationCurve = curve;
    }

    public SerializableAnimationCurve(AnimationCurve animationCurve)
    {
        this.AnimationCurve = animationCurve;
    }
}
</code></pre>
<p>रैप करने के लिए प्रकार सार्वजनिक है, लेकिन सीरियलाइज़ेशन से बाहर रखा गया है (<code>MemoryPackIgnore</code>)। जिन गुणों को आप सीरियलाइज़ करना चाहते हैं वे निजी हैं, लेकिन शामिल किए गए हैं (<code>MemoryPackInclude</code>)। दो प्रकार के कन्स्ट्रक्टर भी तैयार किए जाने चाहिए। सीरियलाइज़र द्वारा उपयोग किया जाने वाला कन्स्ट्रक्टर निजी होना चाहिए।</p>
<p>जैसा है, इसे हर बार रैप करना होगा, जो असुविधाजनक है। और साथ ही struct wrapper null को निरूपित नहीं कर सकता। तो आइए एक कस्टम फ़ॉर्मेटर बनाते हैं।</p>
<pre><code class="language-csharp">public class AnimationCurveFormatter : MemoryPackFormatter&lt;AnimationCurve&gt;
{
    // Unity scoped और TBufferWriter को सपोर्ट नहीं करता, इसलिए signature बदलें `Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)`
    public override void Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref AnimationCurve? value)
    {
        if (value == null)
```csharp
{
    writer.WriteNullObjectHeader();
    return;
}

writer.WritePackable(new SerializableAnimationCurve(value));
}

public override void Deserialize(ref MemoryPackReader reader, scoped ref AnimationCurve? value)
{
    if (reader.PeekIsNull())
    {
        reader.Advance(1); // null ब्लॉक को छोड़ें
        value = null;
        return;
    }
    
    var wrapped = reader.ReadPackable&lt;SerializableAnimationCurve&gt;();
    value = wrapped.AnimationCurve;
}
</code></pre>
<p>अंत में, स्टार्टअप में फॉर्मेटर को रजिस्टर करें।</p>
<pre><code class="language-csharp">MemoryPackFormatterProvider.Register&lt;AnimationCurve&gt;(new AnimationCurveFormatter());
</code></pre>
<blockquote>
<p>नोट: Unity की AnimationCurve डिफ़ॉल्ट रूप से सीरियलाइज़ेबल है इसलिए AnimationCurve के लिए इस कस्टम फॉर्मेटर की आवश्यकता नहीं है।</p>
</blockquote>
<h2>Packages</h2>
<p>MemoryPack के ये पैकेज हैं।</p>
<ul>
<li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li>
</ul>
<p><code>MemoryPack</code> मुख्य लाइब्रेरी है, यह बाइनरी ऑब्जेक्ट्स के हाई परफॉर्मेंस सीरियलाइज़ेशन और डीसीरियलाइज़ेशन के लिए पूरी सपोर्ट प्रदान करता है। यह <code>MemoryPack.Core</code> पर बेस लाइब्रेरीज़ के लिए और <code>MemoryPack.Generator</code> पर कोड जेनरेशन के लिए निर्भर करता है। <code>MemoryPack.Streaming</code> <a href="#streaming-serialization">Streaming Serialization</a> के लिए अतिरिक्त एक्सटेंशन जोड़ता है।  <code>MemoryPack.AspNetCoreMvcFormatter</code> ASP.NET Core के लिए इनपुट/आउटपुट फॉर्मेटर्स जोड़ता है। <code>MemoryPack.UnityShims</code> .NET और Unity के बीच साझा किए जाने वाले टाइप्स के लिए Unity शिम टाइप्स और फॉर्मेटर्स जोड़ता है।</p>
<h2>TypeScript और ASP.NET Core Formatter</h2>
<p>MemoryPack TypeScript कोड जेनरेशन सपोर्ट करता है। यह C# से क्लास और सीरियलाइज़ेशन कोड जेनरेट करता है, दूसरे शब्दों में, आप OpenAPI, proto, आदि का उपयोग किए बिना ब्राउज़र के साथ टाइप्स साझा कर सकते हैं।</p>
<p>कोड जेनरेशन Source Generator के साथ इंटीग्रेटेड है, निम्नलिखित विकल्प (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) TypeScript कोड के लिए आउटपुट डायरेक्टरी सेट करते हैं। रनटाइम कोड भी एक ही समय पर आउटपुट होता है, इसलिए कोई अतिरिक्त डिपेंडेंसी आवश्यक नहीं है।</p>
<pre><code class="language-xml">&lt;!-- मेमोरीपैक TypeScript कोड को डायरेक्टरी में आउटपुट करें --&gt;
&lt;ItemGroup&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptOutputDirectory&quot; /&gt;
&lt;/ItemGroup&gt;
&lt;PropertyGroup&gt;
    &lt;MemoryPackGenerator_TypeScriptOutputDirectory&gt;$(MSBuildProjectDirectory)\wwwroot\js\memorypack&lt;/MemoryPackGenerator_TypeScriptOutputDirectory&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>एक C# MemoryPackable टाइप को <code>[GenerateTypeScript]</code> के साथ एनोटेट किया जाना चाहिए।</p>
<pre><code class="language-csharp">[MemoryPackable]
[GenerateTypeScript]
public partial class Person
{
    public required Guid Id { get; init; }
    public required int Age { get; init; }
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public required DateTime DateOfBirth { get; init; }
    public required Gender Gender { get; init; }
    public required string[] Emails { get; init; }
}

public enum Gender
{
    Male, Female, Other
}
</code></pre>
<p>रनटाइम कोड और TypeScript टाइप लक्ष्य डायरेक्टरी में जेनरेट हो जाएंगे।</p>
<p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image" /></p>
<p>जेनरेट किया गया कोड निम्नानुसार है, जिसमें सरल फील्ड्स और serialize/serializeArray व deserialize/deserializeArray के लिए स्टैटिक मेथड्स होते हैं।</p>
<pre><code class="language-typescript">import { MemoryPackWriter } from &quot;./MemoryPackWriter.js&quot;;
import { MemoryPackReader } from &quot;./MemoryPackReader.js&quot;;
import { Gender } from &quot;./Gender.js&quot;; 

export class Person {
    id: string;
    age: number;
    firstName: string | null;
    lastName: string | null;
    dateOfBirth: Date;
    gender: Gender;
    emails: (string | null)[] | null;

    constructor() {
        // snip...
    }

    static serialize(value: Person | null): Uint8Array {
        // snip...
    }

    static serializeCore(writer: MemoryPackWriter, value: Person | null): void {
        // snip...
    }

    static serializeArray(value: (Person | null)[] | null): Uint8Array {
        // snip...
    }

    static serializeArrayCore(writer: MemoryPackWriter, value: (Person | null)[] | null): void {
        // snip...
    }
    static deserialize(buffer: ArrayBuffer): Person | null {
        // snip...
    }

    static deserializeCore(reader: MemoryPackReader): Person | null {
        // snip...
    }

    static deserializeArray(buffer: ArrayBuffer): (Person | null)[] | null {
        // snip...
    }

    static deserializeArrayCore(reader: MemoryPackReader): (Person | null)[] | null {
        // snip...
    }
}
</code></pre>
<p>आप इस टाइप का उपयोग निम्नानुसार कर सकते हैं।</p>
<pre><code class="language-typescript">let person = new Person();
person.id = crypto.randomUUID();
person.age = 30;
person.firstName = &quot;foo&quot;;
person.lastName = &quot;bar&quot;;
person.dateOfBirth = new Date(1999, 12, 31, 0, 0, 0);
person.gender = Gender.Other;
person.emails = [&quot;foo@bar.com&quot;, &quot;zoo@bar.net&quot;];

// Uint8Array में सीरियलाइज़ करें
let bin = Person.serialize(person);

let blob = new Blob([bin.buffer], { type: &quot;application/x-memorypack&quot; })

let response = await fetch(&quot;http://localhost:5260/api&quot;,
    { method: &quot;POST&quot;, body: blob, headers: { &quot;Content-Type&quot;: &quot;application/x-memorypack&quot; } });

let buffer = await response.arrayBuffer();

// ArrayBuffer से डीसीरियलाइज़ करें 
let person2 = Person.deserialize(buffer);
</code></pre>
<p><code>MemoryPack.AspNetCoreMvcFormatter</code> पैकेज ASP.NET Core MVC के लिए <code>MemoryPack</code> इनपुट और आउटपुट फॉर्मेटर जोड़ता है। आप निम्नलिखित कोड के साथ ASP.NET Core MVC में <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> जोड़ सकते हैं।</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(0, new MemoryPackInputFormatter());
    // यदि checkContentType: true है तो मल्टीपल फॉर्मेट (JSON/MemoryPack, आदि) आउटपुट कर सकते हैं। डिफ़ॉल्ट false है।
    options.OutputFormatters.Insert(0, new MemoryPackOutputFormatter(checkContentType: false));
});
</code></pre>
<p>यदि आप HttpClient से कॉल करते हैं, तो आप कंटेंट-हेडर में <code>application/x-memorypack</code> सेट कर सकते हैं।</p>
<pre><code class="language-csharp">var content = new ByteArrayContent(bin)
content.Headers.ContentType = new MediaTypeHeaderValue(&quot;application/x-memorypack&quot;);
</code></pre>
<h3>TypeScript टाइप मैपिंग</h3>
<p>उन टाइप्स पर कुछ प्रतिबंध हैं जिन्हें जेनरेट किया जा सकता है। प्रिमिटिव्स में, <code>char</code> और <code>decimal</code> समर्थित नहीं हैं। इसके अलावा, OpenGenerics टाइप का उपयोग नहीं किया जा सकता।</p>
<p>|  C#  |  TypeScript  | विवरण |
| ---- | ---- | ---- |
| <code>bool</code> |  <code>boolean</code>  |
| <code>byte</code> |  <code>number</code>  |
| <code>sbyte</code> |  <code>number</code>  |
| <code>int</code> |  <code>number</code> |
| <code>uint</code> |  <code>number</code> |
| <code>short</code> |  <code>number</code> |
| <code>ushort</code> |  <code>number</code> |
| <code>long</code> |  <code>bigint</code> |</p>
<pre><code>| `ulong` |  `bigint` |
| `float` |  `number` |
| `double` |  `number` |
| `string` |  `string \| null`  | 
| `Guid` |  `string`  | TypeScript में string के रूप में प्रस्तुत किया जाता है, लेकिन 16 बाइट बाइनरी के रूप में serialize/deserialize होता है
| `DateTime` | `Date` | DateTimeKind को अनदेखा किया जाएगा
| `enum` | `const enum` | `long` और `ulong` आधारभूत प्रकार समर्थित नहीं हैं
| `T?` | `T \| null` |
| `T[]` | `T[] \| null` |
| `byte[]` | `Uint8Array \| null` |
| `: ICollection&lt;T&gt;` | `T[] \| null` | सभी `ICollection&lt;T&gt;` लागू प्रकार जैसे `List&lt;T&gt;` को समर्थन करता है
| `: ISet&lt;T&gt;` | `Set&lt;T&gt; \| null` | सभी `ISet&lt;T&gt;` लागू प्रकार जैसे `HashSet&lt;T&gt;` को समर्थन करता है
| `: IDictionary&lt;K,V&gt;` | `Map&lt;K, V&gt; \| null` | सभी `IDictionary&lt;K,V&gt;` लागू प्रकार जैसे `Dictionary&lt;K,V&gt;` को समर्थन करता है।
| `[MemoryPackable]` | `class` | केवल class को समर्थन करता है
| `[MemoryPackUnion]` | `abstract class` |

`[GenerateTypeScript]` केवल classes पर लागू किया जा सकता है और वर्तमान में struct द्वारा समर्थित नहीं है।

### इम्पोर्ट फाइल एक्सटेंशन और सदस्य नाम केसिंग कॉन्फ़िगर करें

डिफ़ॉल्ट रूप में, MemoryPack फाइल एक्सटेंशन को `.js` के रूप में जेनरेट करता है जैसे कि `import { MemoryPackWriter } from &quot;./MemoryPackWriter.js&quot;;`। यदि आप कोई अन्य एक्सटेंशन या खाली रखना चाहते हैं, तो इसे कॉन्फ़िगर करने के लिए `MemoryPackGenerator_TypeScriptImportExtension` का उपयोग करें।
साथ ही सदस्य नाम अपने आप camelCase में बदल जाता है। यदि आप मूल नाम का उपयोग करना चाहते हैं, तो `MemoryPackGenerator_TypeScriptConvertPropertyName` को `false` पर सेट करें।

```xml
&lt;ItemGroup&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptOutputDirectory&quot; /&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptImportExtension&quot; /&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptConvertPropertyName&quot; /&gt;
    &lt;CompilerVisibleProperty Include=&quot;MemoryPackGenerator_TypeScriptEnableNullableTypes&quot; /&gt;
&lt;/ItemGroup&gt;
&lt;PropertyGroup&gt;
    &lt;MemoryPackGenerator_TypeScriptOutputDirectory&gt;$(MSBuildProjectDirectory)\wwwroot\js\memorypack&lt;/MemoryPackGenerator_TypeScriptOutputDirectory&gt;
    &lt;!-- खाली रखना संभव है --&gt;
    &lt;MemoryPackGenerator_TypeScriptImportExtension&gt;&lt;/MemoryPackGenerator_TypeScriptImportExtension&gt;
    &lt;!-- डिफ़ॉल्ट true है --&gt;
    &lt;MemoryPackGenerator_TypeScriptConvertPropertyName&gt;false&lt;/MemoryPackGenerator_TypeScriptConvertPropertyName&gt;
    &lt;!-- डिफ़ॉल्ट false है --&gt;
    &lt;MemoryPackGenerator_TypeScriptEnableNullableTypes&gt;true&lt;/MemoryPackGenerator_TypeScriptEnableNullableTypes&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> C# nullable एनोटेशन को TypeScript कोड में प्रतिबिंबित करने की अनुमति देता है। डिफ़ॉल्ट रूप से false है, जिससे सब कुछ nullable बन जाता है।</p>
<h2>Streaming Serialization</h2>
<p><code>MemoryPack.Streaming</code> <code>MemoryPackStreamingSerializer</code> प्रदान करता है, जो streams के साथ collections को serialize और deserialize करने के लिए अतिरिक्त समर्थन जोड़ता है।</p>
<pre><code class="language-csharp">public static class MemoryPackStreamingSerializer
{
    public static async ValueTask SerializeAsync&lt;T&gt;(PipeWriter pipeWriter, int count, IEnumerable&lt;T&gt; source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async ValueTask SerializeAsync&lt;T&gt;(Stream stream, int count, IEnumerable&lt;T&gt; source, int flushRate = 4096, CancellationToken cancellationToken = default)
    public static async IAsyncEnumerable&lt;T?&gt; DeserializeAsync&lt;T&gt;(PipeReader pipeReader, int bufferAtLeast = 4096, int readMinimumSize = 8192, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    public static IAsyncEnumerable&lt;T?&gt; DeserializeAsync&lt;T&gt;(Stream stream, int bufferAtLeast = 4096, int readMinimumSize = 8192, CancellationToken cancellationToken = default)
}
</code></pre>
<h2>Formatter/Provider API</h2>
<p>यदि आप formatter को मैन्युअली लागू करना चाहते हैं, तो <code>MemoryPackFormatter&lt;T&gt;</code> से इनहेरिट करें और <code>Serialize</code> और <code>Deserialize</code> मेथड्स को override करें।</p>
<pre><code class="language-csharp">public class SkeltonFormatter : MemoryPackFormatter&lt;Skelton&gt;
{
    public override void Serialize&lt;TBufferWriter&gt;(ref MemoryPackWriter&lt;TBufferWriter&gt; writer, scoped ref Skelton? value)
    {
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }

        // writer मेथड का उपयोग करें।
    }

    public override void Deserialize(ref MemoryPackReader reader, scoped ref Skelton? value)
    {
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = null;
            return;
        }

        // reader मेथड का उपयोग करें।
    }
}
</code></pre>
<p>बनाए गए formatter को <code>MemoryPackFormatterProvider</code> के साथ रजिस्टर किया जाता है।</p>
<pre><code class="language-csharp">MemoryPackFormatterProvider.Register(new SkeltonFormatter());
</code></pre>
<p>नोट: <code>unmanged struct</code> (जिसमें कोई reference types नहीं हैं) कस्टम formatter का उपयोग नहीं कर सकते, यह हमेशा native memory layout को serialize करता है।</p>
<h2>MemoryPackWriter/ReaderOptionalState</h2>
<p><code>MemoryPackWriter</code>/<code>MemoryPackReader</code> को इनिशियलाइज़ करने के लिए OptionalState की आवश्यकता होती है। यह <code>MemoryPackSerializerOptions</code> का wrapper है, जिसे <code>MemoryPackWriterOptionalStatePool</code> से बनाया जा सकता है।</p>
<pre><code class="language-csharp">// जब dispose किया जाएगा, OptionalState pool में वापस चला जाएगा।
using(var state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var writer = new MemoryPackWriter&lt;T&gt;(ref t, state);
}

// Reader के लिए
using (var state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    var reader = new MemoryPackReader(buffer, state);
}
</code></pre>
<h2>Target framework dependency</h2>
<p>MemoryPack <code>netstandard2.1</code> और <code>net7.0</code> प्रदान करता है, लेकिन दोनों संगत नहीं हैं। उदाहरण के लिए, यदि आप <code>netstandard2.1</code> प्रोजेक्ट के तहत MemoryPackable types का उपयोग करते हैं और उसे <code>net7.0</code> प्रोजेक्ट से उपयोग करते हैं, तो रनटाइम exception मिलेगा, जैसे:</p>
<blockquote>
<p>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</p>
</blockquote>
<p>चूंकि net7.0 static abstract members (<code>Virtual static method</code>) का उपयोग करता है, जो netstandard2.1 में समर्थित नहीं है, यह व्यवहार एक विशेषता है।</p>
<p>.NET 7 प्रोजेक्ट को netstandard 2.1 dll का उपयोग नहीं करना चाहिए। दूसरे शब्दों में, यदि एप्लिकेशन .NET 7 प्रोजेक्ट है, तो सभी dependencies जिन्हें MemoryPack का उपयोग करना है, उन्हें .NET 7 को समर्थन करना चाहिए। इसलिए यदि किसी लाइब्रेरी डेवलपर की dependency MemoryPack पर है, तो आपको dual target framework कॉन्फ़िगर करना होगा।</p>
<pre><code class="language-xml">&lt;TargetFrameworks&gt;netstandard2.1;net7.0&lt;/TargetFrameworks&gt;
</code></pre>
<h2>RPC</h2>
<p><a href="https://github.com/Cysharp/MagicOnion">Cysharp/MagicOnion</a> एक code-first grpc-dotnet framework है, जो protobuf के बजाय MessagePack का उपयोग करता है। MagicOnion अब MemoryPack को serialization layer के रूप में <code>MagicOnion.Serialization.MemoryPack</code> पैकेज (preview) के माध्यम से समर्थन करता है। विवरण देखें: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support">MagicOnion#MemoryPack support</a></p>
<h2>Unity</h2>
<p>न्यूनतम समर्थित Unity संस्करण <code>2022.3.12f1</code> है।</p>
<p><code>MemoryPack</code> कोर पैकेज nuget द्वारा प्रदान किया गया है। यह Unity में भी उपलब्ध है। यदि आप Unity बिल्ट-इन टाइप समर्थन प्राप्त करना चाहते हैं, तो हम अतिरिक्त रूप से MemoryPack.Unity एक्सटेंशन प्रदान करते हैं।</p>
<ol>
<li><a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a> का उपयोग कर NuGet से <code>MemoryPack</code> इंस्टॉल करें</li>
</ol>
<ul>
<li><p>NuGet -&gt; Manage NuGet Packages विंडो खोलें, &quot;MemoryPack&quot; सर्च करें और Install दबाएं।
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot" /></p>
</li>
<li><p>यदि आपको version conflicts error मिलता है, तो कृपया Player Settings (Edit -&gt; Project Settings -&gt; Player -&gt; नीचे स्क्रॉल करें और &quot;Other Settings&quot; को विस्तार करें, फिर &quot;Configuration&quot; सेक्शन के तहत &quot;Assembly Version Validation&quot; को अनचेक करें) में version validation को disable करें।</p>
</li>
</ul>
<ol start="2">
<li>git URL का संदर्भ देकर <code>MemoryPack.Unity</code> पैकेज इंस्टॉल करें</li>
</ol>
<ul>
<li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code>
<img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot" />
<img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot" /></li>
</ul>
<p>MemoryPack <em>.</em>.* रिलीज़ टैग का उपयोग करता है, इसलिए आप एक version जैसे #1.0.0 निर्दिष्ट कर सकते हैं। उदाहरण: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p>
<p>.NET संस्करण की तरह, कोड जेनरेशन एक कोड जनरेटर (<code>MemoryPack.Generator.dll</code>) द्वारा होती है। Reflection-free implementation IL2CPP में भी बेहतरीन प्रदर्शन प्रदान करता है।</p>
<p>Unity और Source Generator के बारे में अधिक जानकारी के लिए, कृपया <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Unity documentation</a> देखें।</p>
<p>Source Generator का आधिकारिक रूप से Unity द्वारा <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">com.unity.properties</a> और <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html">com.unity.entities</a> में भी उपयोग होता है। दूसरे शब्दों में, यह अगली पीढ़ी के Unity में कोड जेनरेशन का मानक है।</p>
<p>आप सभी unmanaged types (जैसे कि <code>Vector3</code>, <code>Rect</code>, आदि...) और कुछ classes (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>) को serialize कर सकते हैं। यदि आप अन्य Unity-विशिष्ट प्रकार serialize करना चाहते हैं, तो <a href="#serialize-external-types">Serialize external types</a> अनुभाग देखें।</p>
<p>Unity में प्रदर्शन के मामले में, MemoryPack JsonUtility से x3~x10 गुना तेज है।</p>
<p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image" /></p>
<p>यदि साझा कोड में Unity का type (<code>Vector2</code>, आदि...) है, तो MemoryPack NuGet में <code>MemoryPack.UnityShims</code> पैकेज प्रदान करता है।</p>
<p><code>MemoryPack.UnityShims</code> पैकेज Unity के मानक structs (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) और कुछ classes (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>) के लिए shims प्रदान करता है।</p>
<blockquote>
<p>[!WARNING]
वर्तमान में, Unity में उपयोग के लिए निम्नलिखित सीमाएँ हैं</p>
</blockquote>
<ol>
<li>Unity संस्करण CustomFormatter को समर्थन नहीं करता।</li>
<li>यदि आप .NET7 या बाद के संस्करण का उपयोग कर रहे हैं, तो MemoryPack बाइनरी फॉर्मेट Unity के साथ पूरी तरह संगत नहीं है।
<ul>
<li>यह समस्या उन value types के साथ होती है, जिनमें <code>[StructLayout(LayoutKind.Auto)]</code> स्पष्ट रूप से निर्दिष्ट है। (struct का डिफ़ॉल्ट <code>LayoutKind.Sequencil</code> होता है।) ऐसे types के लिए, .NET में serialize किया गया binary, Untiy में deserialize नहीं किया जा सकता। इसी तरह, Unity में serialize किया गया binary .NET साइड में serialize नहीं किया जा सकता।</li>
<li>प्रभावित types में आमतौर पर निम्नलिखित प्रकार शामिल हैं।
<ul>
<li><code>DateTimeOffset</code></li>
<li><code>ValueTuple</code></li>
</ul>
</li>
<li>वर्तमान में, आसान समाधान यह है कि इन types का उपयोग न करें।</li>
</ul>
</li>
</ol>
<h2>Native AOT</h2>
<p>दुर्भाग्यवश, .NET 7 Native AOT में एक रनटाइम बग के कारण MemoryPack का उपयोग करते समय crash (<code>Generic virtual method pointer lookup failure</code>) होता है। यह .NET 8 में ठीक किया जाएगा। <code>Microsoft.DotNet.ILCompiler</code> के preview संस्करण का उपयोग करने से .NET 7 में इसे ठीक किया जा सकता है। कृपया <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611">issue's comment</a> देखें कि इसे कैसे सेटअप करें।</p>
<h2>Binary wire format specification</h2>
<p><code>Serialize&lt;T&gt;</code> और <code>Deserialize&lt;T&gt;</code> में परिभाषित <code>T</code> प्रकार को C# schema कहा जाता है। MemoryPack फॉर्मेट self-described फॉर्मेट नहीं है। Deserialize के लिए संबंधित C# schema की आवश्यकता होती है। ये types binaries के आंतरिक प्रतिनिधित्व के रूप में मौजूद होते हैं, लेकिन types C# schema के बिना निर्धारित नहीं किए जा सकते।</p>
<p>Endian <code>Little Endian</code> होना चाहिए। हालांकि, reference C# implementation endianness की परवाह नहीं करता, इसलिए इसे big-endian मशीन पर उपयोग नहीं किया जा सकता। हालांकि, आधुनिक कंप्यूटर आमतौर पर little-endian होते हैं।</p>
<p>फॉर्मेट के आठ प्रकार हैं।</p>
<ul>
<li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>सर्कुलर रेफरेंस ऑब्जेक्ट</li>
<li>टपल</li>
<li>कलेक्शन</li>
<li>स्ट्रिंग</li>
<li>यूनियन</li>
</ul>
<h3>अनमैनेज्ड स्ट्रक्चर</h3>
<p>अनमैनेज्ड स्ट्रक्चर वह C# स्ट्रक्चर है जिसमें रेफरेंस टाइप्स नहीं होते, यह <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# अनमैनेज्ड टाइप्स</a> जैसी कंस्ट्रेंट के समान है। स्ट्रक्चर लेआउट को जेसा है वैसा ही सीरियलाइज़ किया जाता है, जिसमें पैडिंग भी शामिल होती है।</p>
<h3>ऑब्जेक्ट</h3>
<p><code>(byte memberCount, [values...])</code></p>
<p>ऑब्जेक्ट के हैडर में 1 बाइट अनसाइन्ड बाइट के रूप में मेंबर काउंट होता है। मेंबर काउंट <code>0</code> से <code>249</code> तक हो सकता है, <code>255</code> दर्शाता है कि ऑब्जेक्ट <code>null</code> है। वैल्यूज़ में मेंबर काउंट की संख्या के लिए मेमोरीपैक वैल्यू स्टोर होती है।</p>
<h3>वर्शन टॉलरेंट ऑब्जेक्ट</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], [values...])</code></p>
<p>वर्शन टॉलरेंट ऑब्जेक्ट ऑब्जेक्ट के समान है, लेकिन इसमें हैडर में वैल्यूज़ की बाइट लेंथ होती है। वरिन्ट इन स्पेसिफिकेशन का पालन करता है, पहला sbyte वैल्यू या टाइपकोड होता है और अगले X बाइट वैल्यू होते हैं। 0 से 127 = अनसाइन्ड बाइट वैल्यू, -1 से -120 = साइनड बाइट वैल्यू, -121 = बाइट, -122 = स्बाइट, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long।</p>
<h3>सर्कुलर रेफरेंस ऑब्जेक्ट</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])</code><br />
<code>(250, varint referenceId)</code></p>
<p>सर्कुलर रेफरेंस ऑब्जेक्ट वर्शन टॉलरेंट ऑब्जेक्ट के समान है लेकिन अगर memberCount 250 है, तो अगला varint (unsigned-int32) referenceId होता है। यदि नहीं, तो byte-length-of-values के बाद varint referenceId लिखा जाता है।</p>
<h3>टपल</h3>
<p><code>(values...)</code></p>
<p>टपल फिक्स्ड-साइज़, नॉन-नल वैल्यू कलेक्शन है। .NET में, <code>KeyValuePair&lt;TKey, TValue&gt;</code> और <code>ValueTuple&lt;T,...&gt;</code> को टपल के रूप में सीरियलाइज़ किया जाता है।</p>
<h3>कलेक्शन</h3>
<p><code>(int length, [values...])</code></p>
<p>कलेक्शन के हैडर में 4 बाइट साइनड इन्टीजर के रूप में डेटा काउंट होता है, <code>-1</code> का अर्थ है <code>null</code>। वैल्यूज़ में लेंथ की संख्या के लिए मेमोरीपैक वैल्यू स्टोर होती है।</p>
<h3>स्ट्रिंग</h3>
<p><code>(int utf16-length, utf16-value)</code><br />
<code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)</code></p>
<p>स्ट्रिंग के दो रूप होते हैं, UTF16 और UTF8। अगर पहली 4-बाइट साइनड इन्टीजर <code>-1</code> है, तो यह null दर्शाता है। <code>0</code> का अर्थ है खाली। UTF16 कलेक्शन के समान है (<code>ReadOnlySpan&lt;char&gt;</code> के रूप में सीरियलाइज़), utf16-value के बाइट काउंट = utf16-length * 2। अगर पहली साइनड इन्टीजर &lt;= <code>-2</code>, तो वैल्यू UTF8 में एन्कोड की जाती है। utf8-byte-count कंप्लीमेंट में एन्कोडेड है, बाइट्स की गिनती प्राप्त करने के लिए <code>~utf8-byte-count</code>। अगला साइनड इन्टीजर utf16-length है, यह <code>-1</code> हो सकता है जो अज्ञात लंबाई दर्शाता है। utf8-bytes में utf8-byte-count की संख्या के लिए बाइट्स स्टोर होती हैं।</p>
<h3>यूनियन</h3>
<p><code>(byte tag, value)</code><br />
<code>(250, ushort tag, value)</code></p>
<p>पहली अनसाइन्ड बाइट टैग है जो डिस्क्रिमिनेटेड वैल्यू टाइप या फ्लैग के लिए है, <code>0</code> से <code>249</code> टैग दर्शाते हैं, <code>250</code> दर्शाता है कि अगला अनसाइन्ड शॉर्ट टैग है, <code>255</code> दर्शाता है कि यूनियन <code>null</code> है।</p>
<h2>License</h2>
<p>यह लाइब्रेरी MIT लाइसेंस के तहत लाइसेंस प्राप्त है।</p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-09</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>