<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Open AI Tx</title>

    <!-- Primary Meta Tags -->
    <meta name="title" content="Open AI Tx - Markdown Viewer">
    <meta name="description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta name="keywords" content="Open AI Tx, Markdown, GitHub Style, Documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/view.html">
    <meta property="og:title" content="Open AI Tx - Markdown Viewer">
    <meta property="og:description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">

    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="icon.jpg">
    <link rel="apple-touch-icon" href="icon.jpg">

    <!-- Marked.js for Markdown rendering -->
    <script type="text/javascript" async="" src="https://www.statcounter.com/counter/recorder.js"></script><script src="js/marked.min.js"></script>
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="css/github.min.css">
    <script src="js/highlight.min.js"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="view.css">
    <style>
        /* Layout */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .main-container {
            margin: 0 auto;
            width: 100%;
            max-width: 980px;
            padding: 0 20px;
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0 15px;
            }
        }

        /* Image size restrictions */
        .markdown-body img {
            max-width: 100%;
            height: auto;
        }

        /* Existing styles */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f6f8fa;
            border-bottom: 1px solid #e1e4e8;
            position: relative;
        }

        .back-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #0366d6;
            text-decoration: none;
            display: flex;
            align-items: center;
            font-size: 14px;
            padding: 5px 10px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #fff;
        }

        .back-button:hover {
            background-color: #f6f8fa;
            border-color: #0366d6;
        }

        .back-button::before {
            content: "←";
            margin-right: 5px;
            font-size: 16px;
        }

        .header .links {
            margin-top: 10px;
            font-size: 16px;
        }

        .header .links a {
            color: #0366d6;
            text-decoration: none;
            margin-left: 5px;
        }

        .header .links a:hover {
            text-decoration: underline;
        }
        
        /* Language badges styles */
        .language-badges {
            margin-top: 15px;
            text-align: center;
        }
        .language-badges a {
            display: inline-block;
            margin: 2px;
            text-decoration: none;
        }
        .language-badges img {
            height: 20px;
            border-radius: 3px;
        }
        .language-badges a:hover img {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div class="header">
        <a href="javascript:history.back()" class="back-button">Back</a>
        <div class="links">
            GitHub Repository: <a href="https://github.com/Cysharp/MemoryPack" id="githubRepoLink" target="_blank">Cysharp/MemoryPack</a>
        </div>
        <div class="language-badges" id="languageBadges"><a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=en"><img src="https://img.shields.io/badge/EN-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-CN"><img src="https://img.shields.io/badge/简中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-TW"><img src="https://img.shields.io/badge/繁中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ja"><img src="https://img.shields.io/badge/日本語-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ko"><img src="https://img.shields.io/badge/한국어-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=th"><img src="https://img.shields.io/badge/ไทย-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=fr"><img src="https://img.shields.io/badge/Français-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=de"><img src="https://img.shields.io/badge/Deutsch-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=es"><img src="https://img.shields.io/badge/Español-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=it"><img src="https://img.shields.io/badge/Italiano-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ru"><img src="https://img.shields.io/badge/Русский-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pt"><img src="https://img.shields.io/badge/Português-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=nl"><img src="https://img.shields.io/badge/Nederlands-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pl"><img src="https://img.shields.io/badge/Polski-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ar"><img src="https://img.shields.io/badge/العربية-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=tr"><img src="https://img.shields.io/badge/Türkçe-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=vi"><img src="https://img.shields.io/badge/Tiếng Việt-white" alt="version"></a></div>
    </div>

    <div class="main-container">
        <div class="markdown-body" id="content"><h1>MemoryPack</h1>
<p><a href="https://www.nuget.org/packages/MemoryPack"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a><br><a href="https://github.com/Cysharp/MemoryPack/actions"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a><br><a href="https://github.com/Cysharp/MemoryPack/releases"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p>
<p>C# と Unity 向けのゼロエンコーディング超高速バイナリシリアライザー。</p>
<p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p>
<blockquote>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json">System.Text.Json</a>、<a href="https://github.com/protobuf-net/protobuf-net">protobuf-net</a>、<a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>、<a href="https://github.com/dotnet/orleans/">Orleans.Serialization</a> との比較。 .NET 7 / Ryzen 9 5950X マシンで計測。これらのシリアライザーは <code>IBufferWriter&lt;byte&gt;</code> メソッドを持ち、<code>ArrayBufferWriter&lt;byte&gt;</code> を使ってシリアライズし、バッファコピーの計測を避けるため再利用しています。</p>
</blockquote>
<p>標準オブジェクトの場合、MemoryPack は他のバイナリシリアライザーより x10、高速なものでも x2 ~ x5 の速度差があります。構造体配列の場合、MemoryPack はさらに強力で、他のシリアライザーより最大 x50 ~ x200 の速度を発揮します。</p>
<p>MemoryPack は私にとって4つ目のシリアライザーで、これまでに有名なシリアライザー、<del><a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a></del>、<del><a href="https://github.com/neuecc/Utf8Json">Utf8Json</a></del>、<a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a> を作成してきました。MemoryPack の高速さの理由は、C# に特化し最適化されたバイナリフォーマットと、過去の経験をもとにしたチューニングされた実装にあります。また、.NET 7 と C# 11、インクリメンタルソースジェネレーターを活用した全く新しい設計です（.NET Standard 2.1 (.NET 5, 6) および Unity サポートもあります）。</p>
<p>他のシリアライザーは VarInt エンコーディングやタグ、文字列など多くのエンコーディング処理を行いますが、MemoryPack フォーマットは可能な限り C# のメモリをそのままコピーするゼロエンコーディング設計です。ゼロエンコーディングは FlatBuffers に似ていますが、特別な型は不要であり、MemoryPack のシリアライズ対象は POCO です。</p>
<p>パフォーマンス以外にも、MemoryPack には以下の機能があります。</p>
<ul>
<li>最新のI/O API（<code>IBufferWriter&lt;byte&gt;</code>, <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>）に対応</li>
<li>ネイティブAOTフレンドリーなソースジェネレーターによるコード生成、動的CodeGen（IL.Emit）なし</li>
<li>リフレクションレスでジェネリックでないAPI</li>
<li>既存インスタンスへのデシリアライズ</li>
<li>ポリモーフィズム（Union）シリアライズ</li>
<li>限定的なバージョン耐性（高速/デフォルト）と完全なバージョン耐性のサポート</li>
<li>循環参照のシリアライズ</li>
<li>PipeWriter/Reader ベースのストリーミングシリアライズ</li>
<li>TypeScript コード生成と ASP.NET Core フォーマッター</li>
<li>Unity (2021.3) IL2CPP サポート（.NET ソースジェネレーター経由）</li>
</ul>
<h2>インストール</h2>
<p>このライブラリは NuGet で配布されています。最高のパフォーマンスを得るには <code>.NET 7</code> の使用を推奨します。最低要件は <code>.NET Standard 2.1</code> です。</p>
<blockquote>
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/MemoryPack">MemoryPack</a></p>
</blockquote>
<p>また、コードエディタには Roslyn 4.3.1 のサポートが必要です。たとえば Visual Studio 2022 バージョン 17.3、.NET SDK 6.0.401 など。詳細は <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support">Roslyn Version Support</a> ドキュメントを参照してください。</p>
<p>Unity の場合、要件およびインストール手順は完全に異なります。詳細は <a href="#unity">Unity</a> セクションをご覧ください。</p>
<h2>クイックスタート</h2>
<p>シリアライズ対象となる struct または class を定義し、<code>[MemoryPackable]</code> 属性と <code>partial</code> キーワードを付与します。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack;

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>シリアライズコードは、C# のソースジェネレーター機能によって生成され、<code>IMemoryPackable&lt;T&gt;</code> インターフェースを実装します。Visual Studio ではクラス名上でショートカット <code>Ctrl+K, R</code> を押し、<code>*.MemoryPackFormatter.g.cs</code> を選択すると生成されたコードを確認できます。</p>
<p><code>MemoryPackSerializer.Serialize&lt;T&gt;/Deserialize&lt;T&gt;</code> を呼び出して、オブジェクトインスタンスをシリアライズ/デシリアライズします。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Person { Age = <span class="hljs-number">40</span>, Name = <span class="hljs-string">"John"</span> };

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(v);
<span class="hljs-keyword">var</span> val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p><code>Serialize</code> メソッドは <code>byte[]</code> 型の戻り値だけでなく、<code>IBufferWriter&lt;byte&gt;</code> や <code>Stream</code> へのシリアライズにも対応しています。<code>Deserialize</code> メソッドは <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>, <code>Stream</code> に対応。非ジェネリック版もあります。</p>
<h2>標準対応型</h2>
<p>これらの型はデフォルトでシリアライズ可能です。</p>
<ul>
<li>.NET プリミティブ（<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code> など）</li>
<li>アンマネージド型（任意の <code>enum</code>、参照型を含まないユーザー定義 <code>struct</code>）</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code>, <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory&lt;&gt;</code>, <code>ReadOnlyMemory&lt;&gt;</code>, <code>ArraySegment&lt;&gt;</code>, <code>ReadOnlySequence&lt;&gt;</code></li>
<li><code>Nullable&lt;&gt;</code>, <code>Lazy&lt;&gt;</code>, <code>KeyValuePair&lt;,&gt;</code>, <code>Tuple&lt;,...&gt;</code>, <code>ValueTuple&lt;,...&gt;</code></li>
<li><code>List&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>SortedSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code></li>
<li><code>Dictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>,  <code>ReadOnlyDictionary&lt;,&gt;</code> </li>
<li><code>Collection&lt;&gt;</code>, <code>ReadOnlyCollection&lt;&gt;</code>, <code>ObservableCollection&lt;&gt;</code>, <code>ReadOnlyObservableCollection&lt;&gt;</code></li>
<li><code>IEnumerable&lt;&gt;</code>, <code>ICollection&lt;&gt;</code>, <code>IList&lt;&gt;</code>, <code>IReadOnlyCollection&lt;&gt;</code>, <code>IReadOnlyList&lt;&gt;</code>, <code>ISet&lt;&gt;</code></li>
<li><code>IDictionary&lt;,&gt;</code>, <code>IReadOnlyDictionary&lt;,&gt;</code>, <code>ILookup&lt;,&gt;</code>, <code>IGrouping&lt;,&gt;</code>,</li>
<li><code>ConcurrentBag&lt;&gt;</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>, <code>BlockingCollection&lt;&gt;</code></li>
<li>イミュータブルコレクション（<code>ImmutableList&lt;&gt;</code> など）やインターフェース（<code>IImmutableList&lt;&gt;</code> など）</li>
</ul>
<h2><code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code> の定義</h2>
<p><code>[MemoryPackable]</code> は任意の <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code>, <code>interface</code> に付与できます。型が参照型を含まない <code>struct</code> または <code>record struct</code>（<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# アンマネージド型</a>）の場合、追加の注釈（ignore, include, constructor, callbacks）は使用されず、メモリから直接シリアライズ/デシリアライズされます。</p>
<p>それ以外の場合、デフォルトでは <code>[MemoryPackable]</code> は公開インスタンスプロパティまたはフィールドをシリアライズします。<code>[MemoryPackIgnore]</code> でシリアライズ対象から除外し、<code>[MemoryPackInclude]</code> でプライベートメンバーをシリアライズ対象に昇格できます。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// デフォルトでシリアライズされる型</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicField;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> PublicReadOnlyField;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PrivateSetPublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ReadOnlyPublicProperty { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> RequiredInitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }

    <span class="hljs-comment">// デフォルトではシリアライズされない型</span>
    <span class="hljs-built_in">int</span> privateProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-built_in">int</span> privateField;
    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> privateReadOnlyField;

    <span class="hljs-comment">// 公開メンバーを対象外にするには [MemoryPackIgnore] を使用</span>
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty2 =&gt; PublicProperty + PublicField;

    <span class="hljs-comment">// プライベートメンバーを対象にするには [MemoryPackInclude] を使用</span>
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateField2;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>MemoryPack</code> のコードジェネレーターは、どのメンバーがシリアライズされるかの情報を <code>&lt;remarks /&gt;</code> セクションに追加します。Intellisense で型にマウスオーバーすることで確認できます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p>
<p>全てのメンバーが MemoryPack でシリアライズ可能である必要があり、そうでない場合コードジェネレーターはエラーを出力します。</p>
<p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p>
<p>MemoryPack には 35個の診断ルール（<code>MEMPACK001</code> から <code>MEMPACK035</code>）が用意されており、快適に定義できます。</p>
<p>ターゲット型が MemoryPack シリアライズを外部で定義・登録している場合、<code>[MemoryPackAllowSerialize]</code> を使うことで診断を抑制できます。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample2</span>
{
    [<span class="hljs-meta">MemoryPackAllowSerialize</span>]
    <span class="hljs-keyword">public</span> NotSerializableType? NotSerializableProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>メンバーの順序は<strong>重要</strong>です。MemoryPack はメンバー名や他の情報をシリアライズせず、宣言順にフィールドをシリアライズします。型が継承されている場合、親→子の順でシリアライズされます。メンバーの順序はデシリアライズのために変更できません。スキーマ進化については <a href="#version-tolerant">Version tolerant</a> セクションを参照してください。</p>
<p>デフォルトは順次順序ですが、<code>[MemoryPackable(SerializeLayout.Explicit)]</code> と <code>[MemoryPackOrder()]</code> で明示的なレイアウトを選択できます。</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Prop0 -&gt; Prop1 の順でシリアライズ</span>
[<span class="hljs-meta">MemoryPackable(SerializeLayout.Explicit)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleExplicitOrder</span>
{
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h3>コンストラクターの選択</h3>
<p>MemoryPack はパラメータあり・なし両方のコンストラクターに対応しています。コンストラクターの選択は以下のルールに従います（クラス・構造体に適用）。</p>
<ul>
<li><code>[MemoryPackConstructor]</code> があればそれを使用</li>
<li>明示的なコンストラクター（private含む）がなければパラメータなしを使用</li>
<li>パラメータなし/ありコンストラクターが一つだけ（private含む）ならそれを使用</li>
<li>複数コンストラクターがある場合は、希望のコンストラクターに <code>[MemoryPackConstructor]</code> 属性を付与（自動選択しない）、付与しない場合はエラー</li>
<li>パラメータ付きコンストラクターを使う場合、全パラメータ名は対応するメンバー名と一致（大文字小文字無視）</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Name;

    <span class="hljs-comment">// パラメータ付きコンストラクターも利用可能 - パラメータ名はメンバー名と一致（大文字小文字無視）</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Age = age;
        <span class="hljs-keyword">this</span>.Name = name;
    }
}

<span class="hljs-comment">// record の主コンストラクターにも対応</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Person2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Age, <span class="hljs-built_in">string</span> Name</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>()</span>
    {
    }
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// 複数のコンストラクタが存在する場合は、[MemoryPackConstructor] を使用する必要があります</span>
[<span class="hljs-meta">MemoryPackConstructor</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
{
    <span class="hljs-keyword">this</span>.Age = age;
    <span class="hljs-keyword">this</span>.Name = name;
}
</code></pre>
<h3>シリアライズコールバック</h3>
<p>シリアライズ/デシリアライズ時に、MemoryPack は <code>[MemoryPackOnSerializing]</code>、<code>[MemoryPackOnSerialized]</code>、<code>[MemoryPackOnDeserializing]</code>、<code>[MemoryPackOnDeserialized]</code> 属性を使用して前後のイベントを呼び出すことができます。静的メソッドとインスタンス（非静的）メソッド、パブリックおよびプライベートメソッドの両方に注釈を付けることができます。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MethodCallSample</span>
{
    <span class="hljs-comment">// メソッド呼び出し順は static -&gt; instance</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing1));
    }

    <span class="hljs-comment">// プライベートメソッドにも対応</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing2));
    }

    <span class="hljs-comment">// serializing -&gt; /* serialize */ -&gt; serialized</span>
    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized1));
    }

    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing1));
    }

    <span class="hljs-comment">// 注意: MemoryPackOnDeserializing のインスタンスメソッドは、`ref` でインスタンスが渡されない場合は呼び出されません</span>
    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized1));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized2));
    }
}
</code></pre>
<p>コールバックは引数なしのメソッドと <code>ref reader/writer, ref T value</code> メソッドの両方を許可します。例えば、ref コールバックでシリアライズ処理の前にカスタムヘッダを書き込んだり読んだりすることができます。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EmitIdData</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteId</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)
        <span class="hljs-keyword">where</span> TBufferWriter : IBufferWriter&lt;<span class="hljs-built_in">byte</span>&gt; <span class="hljs-comment">// .NET Standard 2.1 の場合は where TBufferWriter : class, IBufferWriter&lt;byte&gt; を使用</span></span>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); <span class="hljs-comment">// ヘッダに GUID を出力</span>
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadId</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-comment">// デシリアライズ前にカスタムヘッダを読み込む</span>
        <span class="hljs-keyword">var</span> guid = reader.ReadUnmanaged&lt;Guid&gt;();
        Console.WriteLine(guid);
    }
}
</code></pre>
<p><code>ref value</code> に値を設定すると、シリアライズ/デシリアライズに使用される値を変更できます。例えば、ServiceProvider からインスタンス化することができます。</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// このフォーマッタを使用する前に、ServiceProvider を設定してください</span>
<span class="hljs-comment">// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };</span>
<span class="hljs-comment">// MemoryPackSerializer.Deserialize(value, options);</span>

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InstantiateFromServiceProvider</span>
{
    <span class="hljs-keyword">static</span> IServiceProvider serviceProvider = <span class="hljs-literal">default</span>!;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> InstantiateFromServiceProvider <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">value</span> = reader.Options.ServiceProvider!.GetRequiredService&lt;InstantiateFromServiceProvider&gt;();
    }
}
</code></pre>
<h2>カスタムコレクションの定義</h2>
<p>デフォルトでは、<code>[MemoryPackObject]</code> で注釈された型はメンバーをシリアライズしようとします。しかし、型がコレクション（<code>ICollection&lt;&gt;</code>, <code>ISet&lt;&gt;</code>, <code>IDictionary&lt;,&gt;</code>）の場合は、正しくシリアライズするために <code>GenerateType.Collection</code> を使用してください。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt;
{
}

[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyStringDictionary</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>&gt;
{

}
</code></pre>
<h2>静的コンストラクタ</h2>
<p>MemoryPackable クラスでは静的コンストラクタは定義できません（生成された partial クラスが使用するため）。代わりに、同じ処理を行うために <code>static partial void StaticConstructor()</code> を定義できます。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CctorSample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StaticConstructor</span>()</span>
    {
    }
}
</code></pre>
<h2>ポリモーフィズム（ユニオン）</h2>
<p>MemoryPack は、インターフェースや抽象クラスオブジェクトのポリモーフィズムシリアライズをサポートします。MemoryPack ではこの機能をユニオン（Union）と呼びます。<code>[MemoryPackUnion]</code> 属性を注釈できるのはインターフェースと抽象クラスのみです。ユニークなユニオンタグが必要です。</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// [MemoryPackable] および継承型に [MemoryPackUnion] を注釈</span>
<span class="hljs-comment">// ユニオンは抽象クラスにも対応</span>
[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> XYZ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BarClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? OPQ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
<span class="hljs-comment">// ---</span>

IUnionSample data = <span class="hljs-keyword">new</span> FooClass() { XYZ = <span class="hljs-number">999</span> };

<span class="hljs-comment">// インターフェース型としてシリアライズ</span>
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(data);

<span class="hljs-comment">// インターフェース型としてデシリアライズ</span>
<span class="hljs-keyword">var</span> reData = MemoryPackSerializer.Deserialize&lt;IUnionSample&gt;(bin);

<span class="hljs-keyword">switch</span> (reData)
{
    <span class="hljs-keyword">case</span> FooClass x:
        Console.WriteLine(x.XYZ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BarClass x:
        Console.WriteLine(x.OPQ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-literal">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p><code>tag</code> は <code>0</code> ～ <code>65535</code> を許容し、特に <code>250</code> 未満では効率的です。</p>
<pre><code class="hljs language-csharp">インターフェースと派生型が異なるアセンブリにある場合は、代わりに `MemoryPackUnionFormatterAttribute` を使用できます。フォーマッタは、C<span class="hljs-meta"># 9.0 以降で `ModuleInitializer` を介して自動的に登録されるように生成されます。</span>

&gt; `ModuleInitializer` は Unity ではサポートされていないため、フォーマッタを手動で登録する必要があります。ユニオンフォーマッタを登録するには、Startup で `{ユニオンフォーマッタ名}Initializer.RegisterFormatter()` を手動で呼び出してください。例: `UnionSampleFormatterInitializer.RegisterFormatter()`。

```csharp
<span class="hljs-comment">// AssemblyA</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.NoGenerate)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

<span class="hljs-comment">// AssemblyB でターゲット型の外側に定義</span>
[<span class="hljs-meta">MemoryPackUnionFormatter(typeof(IUnionSample))</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnionSampleFormatter</span>
{
}
</code></pre>
<p>ユニオンはコード内で <code>DynamicUnionFormatter&lt;T&gt;</code> を使って組み立てることもできます。</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// (ushort, Type)[]</span>
<span class="hljs-keyword">var</span> formatter = <span class="hljs-keyword">new</span> DynamicUnionFormatter&lt;IFooBarBaz&gt;(
    (<span class="hljs-number">0</span>, <span class="hljs-keyword">typeof</span>(Foo)),
    (<span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(Bar)),
    (<span class="hljs-number">2</span>, <span class="hljs-keyword">typeof</span>(Baz))
);

MemoryPackFormatterProvider.Register(formatter);
</code></pre>
<h2>Serialize API</h2>
<p><code>Serialize</code> には 3 つのオーバーロードがあります。</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// ジェネリックでない API も利用可能。これらのバージョンは最初の引数が Type、value は object? です</span>
<span class="hljs-function"><span class="hljs-built_in">byte</span>[] <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> TBufferWriter bufferWriter, <span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
</span></code></pre>
<p>パフォーマンスのためには、<code>BufferWriter</code> を使用する API が推奨されます。これはバッファに直接シリアライズします。<code>System.IO.Pipelines</code> の <code>PipeWriter</code> や、ASP .NET Core の <code>BodyWriter</code> などに適用できます。</p>
<p><code>byte[]</code> が必要な場合（例: <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a> の <code>RedisValue</code> など）、返り値が <code>byte[]</code> の API はシンプルでほぼ同じ速さです。</p>
<p><code>Stream</code> 用の <code>SerializeAsync</code> は、Flush のみ非同期であり、すべてを一度 MemoryPack の内部プールバッファにシリアライズし、その後 <code>WriteAsync</code> で書き込みます。そのため、バッファと Flush を分離・制御できる <code>BufferWriter</code> のオーバーロードの方が優れています。</p>
<p>完全なストリーミング書き込みを行いたい場合は、<a href="#streaming-serialization">Streaming Serialization</a> セクションを参照してください。</p>
<h3>MemoryPackSerializerOptions</h3>
<p><code>MemoryPackSerializerOptions</code> では、文字列を UTF16 または UTF8 でシリアライズするかを設定できます。UTF8 エンコーディングの場合は <code>MemoryPackSerializerOptions.Utf8</code>、UTF16 では <code>MemoryPackSerializerOptions.Utf16</code>、デフォルトは <code>MemoryPackSerializerOptions.Default</code>（UTF8）です。null を渡すかデフォルトパラメータを使うと UTF8 になります。</p>
<p>C# の内部文字列表現が UTF16 であるため、UTF16 の方がパフォーマンスは良いですが、ペイロードが大きくなりがちです。ASCII 文字列の場合、UTF8 では 1 バイト、UTF16 では 2 バイトです。ペイロードサイズの違いが大きいため、デフォルトは UTF8 です。</p>
<p>データが非 ASCII（例: 日本語では 3 バイト以上となり、UTF8 の方が大きくなる）や、別途圧縮する必要がある場合は、UTF16 の方が良い場合もあります。</p>
<p>シリアライズ時に UTF8 または UTF16 を選択できますが、デシリアライズ時に指定する必要はありません。自動的に検出され、通常通りデシリアライズされます。</p>
<p>また、options から <code>IServiceProvider? ServiceProvider { get; init; }</code> を取得・設定できます。シリアライズプロセスから DI オブジェクト（例: <code>ILogger&lt;T&gt;</code> など）を取得するのに便利です（<code>MemoryPackReader/MemoryPackWriter</code> には .Options プロパティがあります）。</p>
<h2>Deserialize API</h2>
<p><code>Deserialize</code> には、<code>ReadOnlySpan&lt;byte&gt;</code> および <code>ReadOnlySequence&lt;byte&gt;</code>、<code>Stream</code> のオーバーロードと <code>ref</code> サポートがあります。</p>
<pre><code class="language-csharp hljs">T? Deserialize&lt;T&gt;(ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer)
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
T? <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer</span>)
<span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
<span class="hljs-keyword">async</span> <span class="hljs-title">ValueTask</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream</span>)
</span></code></pre>
<p><code>ref</code> オーバーロードは既存のインスタンスを上書きします。詳細は <a href="#overwrite">Overwrite</a> セクションを参照してください。</p>
<p><code>DeserializeAsync(Stream)</code> は完全なストリーミング読み取りではなく、まず MemoryPack の内部プールにストリームの終わりまで読み込んだ後、デシリアライズします。</p>
<p>完全なストリーミング読み取りを行いたい場合は、<a href="#streaming-serialization">Streaming Serialization</a> セクションを参照してください。</p>
<h2>Overwrite</h2>
<p>アロケーションを減らすために、MemoryPack では既存のインスタンスへの上書きデシリアライズがサポートされています。これは <code>Deserialize(ref T? value)</code> オーバーロードで利用できます。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(person);

<span class="hljs-comment">// 既存インスタンスにデータを上書き</span>
MemoryPackSerializer.Deserialize(bin, <span class="hljs-keyword">ref</span> person);
</code></pre>
<p>MemoryPack は可能な限り上書きを試みますが、以下の条件が一致しない場合は新しいインスタンスを作成します（通常のデシリアライズと同じ）。</p>
<ul>
<li>ref 値（オブジェクトグラフ内のメンバーを含む）が null の場合は新しいインスタンスを設定</li>
<li>引数なしコンストラクタのみ許可、引数付きコンストラクタが使われている場合は新しいインスタンスを作成</li>
<li>値が <code>T[]</code> の場合、長さが同じときのみ再利用、そうでなければ新しいインスタンスを作成</li>
<li><code>.Clear()</code> メソッドを持つコレクション（<code>List&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentBag&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>）は Clear() を呼び出して再利用、それ以外は新しいインスタンスを作成</li>
</ul>
<h2>Version tolerant</h2>
<p>デフォルト（<code>GenerateType.Object</code>）では、MemoryPack は限定的なスキーマ進化をサポートします。</p>
<ul>
<li>非管理構造体（unmanaged struct）は変更不可</li>
<li>メンバーの追加は可能、削除は不可</li>
<li>メンバー名の変更は可能</li>
<li>メンバーの順序変更は不可</li>
<li>メンバー型の変更は不可</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// 追加はOK</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? AddedProp { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// 削除はNG</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-comment">// public int Prop1 { get; set; }</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// 順序変更はNG</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>ユースケースとしては、古いデータを保存（ファイルや Redis など）し、新しいスキーマで読み出すことは常に可能です。RPC シナリオでは、スキーマがクライアントとサーバーの両方に存在するため、クライアントをサーバーより先にアップデートする必要があります。アップデート済みクライアントは古いサーバーに接続可能ですが、古いクライアントは新しいサーバーに接続できません。</p>
<p>デフォルトでは、古いデータを新しいスキーマで読み込むと、データ側に存在しないメンバーは <code>default</code> リテラルで初期化されます。<br>これを避けてフィールドやプロパティの初期値を使いたい場合は、<code>[SuppressDefaultInitialization]</code> を使用できます。</p>
<pre><code class="language-cs hljs language-csharp">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DefaultValue</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">SuppressDefaultInitialization</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">111</span>; <span class="hljs-comment">// &lt; 古いデータが欠損していれば `111` が設定される</span>
    
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">222</span>; <span class="hljs-comment">// &lt; 古いデータが欠損していれば `default` が設定される</span>
}
</code></pre>
<p> <code>[SuppressDefaultInitialization]</code> には以下の制限があります:</p>
<ul>
<li>readonly, init-only, required 修飾子とは併用不可</li>
</ul>
<p>次の <a href="#serialization-info">Serialization info</a> セクションでは、CI などによるスキーマ変更チェックの方法を示しています。</p>
<p><code>GenerateType.VersionTolerant</code> を使用すると、完全なバージョン耐性がサポートされます。</p>
<ul>
<li>非管理構造体（unmanaged struct）はこれ以上変更不可</li>
<li>すべてのメンバーで <code>[MemoryPackOrder]</code> を明示的に付与（<code>SerializeLayout.Sequential</code> を注釈した場合を除く）</li>
<li>メンバーの追加・削除は可能だが順序の再利用は不可（欠番は利用可能）</li>
<li>メンバー名の変更は可能</li>
<li>メンバーの順序変更は不可</li>
<li>メンバー型の変更は不可</li>
</ul>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// 以下のどちらのパターンもシリアライズ／デシリアライズ可能</span>
<span class="hljs-comment">// VersionTolerantObject1 -&gt; VersionTolerantObject2</span>
<span class="hljs-comment">// VersionTolerantObject2 -&gt; VersionTolerantObject1</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject1</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject2</span>
{
```csharp
[<span class="hljs-meta">MemoryPackOrder(0)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// 削除済み</span>
<span class="hljs-comment">//[MemoryPackOrder(1)]</span>
<span class="hljs-comment">//public long MyProperty1 { get; set; } = default;</span>

[<span class="hljs-meta">MemoryPackOrder(2)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// 追加済み</span>
[<span class="hljs-meta">MemoryPackOrder(3)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// SerializeLayout.Sequential を明示的に設定した場合、自動的に順序付けされます。</span>
<span class="hljs-comment">// ただし、バージョン耐性のためにメンバーを削除することはできません。</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<p><code>GenerateType.VersionTolerant</code> はシリアライズ時に <code>GenerateType.Object</code> よりも遅くなります。また、ペイロードサイズもわずかに大きくなります。</p>
<h2>シリアライズ情報</h2>
<p>型のどのメンバーがシリアライズされるかは、IntelliSense で確認できます。また、コンパイル時にその情報をファイルへ出力するオプションもあります。<code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> を以下のように設定します。</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- memorypack のシリアライズ情報をディレクトリに出力する --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_SerializationInfoOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\MemoryPackLogs<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>次のような情報がファイルに書き込まれます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p>
<p>型がアンマネージドの場合、型名の前に <code>unmanaged</code> と表示されます。</p>
<pre><code class="language-txt hljs language-plaintext">unmanaged FooStruct
---
int x
int y
</code></pre>
<p>このファイルの差分を確認することで、危険なスキーマ変更を防ぐことができます。例えば、CI を使って次のようなルールを検知できます。</p>
<ul>
<li>アンマネージド型の変更</li>
<li>メンバー順序の変更</li>
<li>メンバーの削除</li>
</ul>
<h2>循環参照</h2>
<p>MemoryPack は循環参照もサポートしています。これにより、ツリー状のオブジェクトをそのままシリアライズできます。</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// 循環参照を有効にするには GenerateType.CircularReference を使用します</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> Node? Parent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Node[]? Children { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>例えば、<a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references">System.Text.Json preserve-references</a> のコードは次のようになります。</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0</span>
Employee tyler = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Tyler Stein"</span>
};

Employee adrian = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Adrian King"</span>
};

tyler.DirectReports = <span class="hljs-keyword">new</span> List&lt;Employee&gt; { adrian };
adrian.Manager = tyler;

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize&lt;Employee&gt;(bin);

Console.WriteLine(tylerDeserialized?.DirectReports?[<span class="hljs-number">0</span>].Manager == tylerDeserialized); <span class="hljs-comment">// true</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Employee? Manager { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> List&lt;Employee&gt;? DirectReports { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>GenerateType.CircularReference</code> はバージョン耐性と同じ特性を持ちます。ただし追加の制約として、パラメータなしのコンストラクタのみが許可されます。また、オブジェクト参照の追跡は <code>GenerateType.CircularReference</code> が付与されたオブジェクトに対してのみ行われます。他のオブジェクトも追跡したい場合はラップしてください。</p>
<h2>CustomFormatter</h2>
<p><code>MemoryPackCustomFormatterAttribute&lt;T&gt;</code> あるいは（より高性能ですが複雑な）<code>MemoryPackCustomFormatterAttribute&lt;TFormatter, T&gt;</code> を実装することで、MemoryPackObject のメンバーにカスタムフォーマッタを設定できます。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Attribute</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> IMemoryPackFormatter&lt;T&gt; <span class="hljs-title">GetFormatter</span>()</span>;
}
</code></pre>
<p>MemoryPack には次のフォーマッタ属性が用意されています：<code>Utf8StringFormatterAttribute</code>、<code>Utf16StringFormatterAttribute</code>、<code>InternStringFormatterAttribute</code>、<code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute&lt;TValue&gt;</code>、<code>BitPackFormatterAttribute</code>、<code>BrotliFormatter</code>、<code>BrotliStringFormatter</code>、<code>BrotliFormatter&lt;T&gt;</code>、<code>MemoryPoolFormatter&lt;T&gt;</code>、<code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// このメンバーを UTF16 文字列としてシリアライズします。UTF8 より高速ですが、ASCII ではサイズが大きくなり（非ASCII では小さくなる場合があります）。</span>
    [<span class="hljs-meta">Utf16StringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Text { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment">// デシリアライズ時に Dictionary が StringComparer.OrdinalIgnoreCase で初期化されます。</span>
    [<span class="hljs-meta">OrdinalIgnoreCaseStringDictionaryFormatter&lt;int&gt;</span>]
    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;? Ids { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    
    <span class="hljs-comment">// デシリアライズ時、すべての文字列がインターン化されます（参照：String.Intern）。同じ値が繰り返し出現する場合、メモリを節約できます。</span>
    [<span class="hljs-meta">InternStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Flag { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>セット／ディクショナリの EqualityComparer を設定するために、すべての組み込みフォーマッタには comparer コンストラクタのオーバーロードがあります。カスタムの EqualityComparer フォーマッタも簡単に作成できます。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OrdinalIgnoreCaseStringDictionaryFormatter</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>?&gt;&gt;
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt; formatter = <span class="hljs-keyword">new</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt;(StringComparer.OrdinalIgnoreCase);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> IMemoryPackFormatter&lt;Dictionary&lt;<span class="hljs-built_in">string</span>, TValue?&gt;&gt; GetFormatter()
    {
        <span class="hljs-keyword">return</span> formatter;
    }
}
</code></pre>
<p><code>BitPackFormatter</code> は <code>bool[]</code> 型専用の圧縮フォーマッタです。通常、<code>bool[]</code> は各要素ごとに1バイトでシリアライズされますが、<code>BitPackFormatter</code> では <code>BitArray</code> のように各 bool を1ビットで格納します。<code>BitPackFormatter</code> を使うと、8個の bool が1バイトになり、通常の8分の1のサイズになります。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BitPackFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[]? Data { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter</code> は <code>byte[]</code> 用です。例えば、Brotli で大きなペイロードを圧縮できます。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliStringFormatter</code> は <code>string</code> 用で、文字列（UTF16）を Brotli で圧縮してシリアライズします。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? LargeText { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<pre><code class="hljs language-csharp">`BrotliFormatter&lt;T&gt;` は任意の型に対応しており、シリアライズされたデータをBrotliで圧縮します。型が `<span class="hljs-built_in">byte</span>[]` や `<span class="hljs-built_in">string</span>` の場合は、パフォーマンスのために `BrotliFormatter` や `BrotliStringFormatter` を使用してください。

```csharp
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter&lt;ChildType&gt;</span>]
    <span class="hljs-keyword">public</span> ChildType? Child { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>配列プーリングによるデシリアライズ</h2>
<p>大きな配列（任意の <code>T</code>）をデシリアライズするために、MemoryPackは効率的な複数のプーリング手法を提供します。最も効果的な方法は<a href="#overwrite">#Overwrite</a> 機能を使用することです。特に <code>List&lt;T&gt;</code> は常に再利用されます。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ListBytesSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">byte</span>&gt; Payload</span> { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// ----</span>

<span class="hljs-comment">// List&lt;byte&gt; は再利用され、デシリアライズ時にアロケーションが発生しません。</span>
MemoryPackSerializer.Deserialize&lt;ListBytesSample&gt;(bin, <span class="hljs-keyword">ref</span> reuseObject);

<span class="hljs-comment">// 効率的な操作のために、CollectionsMarshalでSpan&lt;T&gt;を取得できます</span>
<span class="hljs-keyword">var</span> span = CollectionsMarshal.AsSpan(<span class="hljs-keyword">value</span>.Payload);
</code></pre>
<p>便利な方法として、デシリアライズ時にArrayPoolにデシリアライズする方法もあります。MemoryPackは <code>MemoryPoolFormatter&lt;T&gt;</code> と <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code> を提供しています。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PoolModelSample</span> : <span class="hljs-title">IDisposable</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; }

    [<span class="hljs-meta">MemoryPoolFormatter&lt;byte&gt;</span>]
    <span class="hljs-keyword">public</span> Memory&lt;<span class="hljs-built_in">byte</span>&gt; Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PoolModelSample</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, Memory&lt;<span class="hljs-built_in">byte</span>&gt; payload</span>)</span>
    {
        Id = id;
        Payload = payload;
    }

    <span class="hljs-comment">// 戻り値のコードは自分で記述する必要があります。以下はスニペットです。</span>

    <span class="hljs-built_in">bool</span> usePool;

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized</span>()</span>
    {
        usePool = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span>
    {
        <span class="hljs-keyword">if</span> (!usePool) <span class="hljs-keyword">return</span>;

        Return(Payload); Payload = <span class="hljs-literal">default</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Memory&lt;T&gt; memory</span>)</span> =&gt; Return((ReadOnlyMemory&lt;T&gt;)memory);

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlyMemory&lt;T&gt; memory</span>)</span>
    {
        <span class="hljs-keyword">if</span> (MemoryMarshal.TryGetArray(memory, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> segment) &amp;&amp; segment.Array <span class="hljs-keyword">is</span> { Length: &gt; <span class="hljs-number">0</span> })
        {
            ArrayPool&lt;T&gt;.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;());
        }
    }
}

<span class="hljs-comment">// ---</span>

<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;PoolModelSample&gt;(bin))
{
    <span class="hljs-comment">// 何らかの処理...</span>
}   <span class="hljs-comment">// ArrayPoolに返却される</span>
</code></pre>
<h2>パフォーマンス</h2>
<p>私のブログ記事 <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a> をご覧ください。</p>
<h2>ペイロードサイズと圧縮</h2>
<p>ペイロードサイズはターゲット値によって異なります。JSONと異なりキーがなくバイナリ形式のため、ペイロードサイズはJSONより小さくなる傾向があります。</p>
<p>MessagePackやProtobufのようなvarintエンコーディングを持つものでは、MemoryPackはintを多用するとサイズが大きくなりがちです（MemoryPackではintは常に固定長4バイト、MessagePackでは1～5バイト）。</p>
<p>floatおよびdoubleはMemoryPackで4バイト・8バイトですが、MessagePackでは5バイト・9バイトです。したがって、例えばVector3（float, float, float）の配列ではMemoryPackの方が小さくなります。</p>
<p>文字列はデフォルトでUTF8で、これは他のシリアライザと同様ですが、UTF16オプションを選択した場合は性質が異なります。</p>
<p>いずれにしても、ペイロードサイズが大きい場合は圧縮を検討すべきです。LZ4、ZStandard、Brotliが推奨されます。</p>
<h3>圧縮</h3>
<p>MemoryPackは <a href="https://github.com/google/brotli">Brotli</a> 圧縮のための効率的なヘルパーを <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder">BrotliEncoder</a> および <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder">BrotliDecoder</a> 経由で提供します。MemoryPackの <code>BrotliCompressor</code> および <code>BrotliDecompressor</code> はMemoryPackの内部動作に最適化された圧縮・解凍を提供します。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// 圧縮（usingが必要）</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> compressor = <span class="hljs-keyword">new</span> BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, <span class="hljs-keyword">value</span>);

<span class="hljs-comment">// 圧縮されたbyte[]を取得</span>
<span class="hljs-keyword">var</span> compressedBytes = compressor.ToArray();

<span class="hljs-comment">// または他の IBufferWriter&lt;byte&gt;（例えばPipeWriter）に書き込む</span>
compressor.CopyTo(response.BodyWriter);
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// 解凍（usingが必要）</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> decompressor = <span class="hljs-keyword">new</span> BrotliDecompressor();

<span class="hljs-comment">// ReadOnlySpan&lt;byte&gt; または ReadOnlySequence&lt;byte&gt; から解凍済み ReadOnlySequence&lt;byte&gt; を取得</span>
<span class="hljs-keyword">var</span> decompressedBuffer = decompressor.Decompress(buffer);

<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;T&gt;(decompressedBuffer);
</code></pre>
<p><code>BrotliCompressor</code> と <code>BrotliDecompressor</code> はどちらもstructであり、ヒープ上にメモリを割り当てません。どちらも内部メモリプールに圧縮済みまたは解凍済みデータを格納してSerialize/Deserializeします。そのため、メモリプーリングの解放が必要です。<code>using</code> の使用を忘れないでください。</p>
<p>圧縮レベルは非常に重要です。デフォルトはquality-1（CompressionLevel.Fastest）に設定されており、.NETのデフォルト（CompressionLevel.Optimal, quality-4）とは異なります。</p>
<p>Fastest（quality-1）は <a href="https://github.com/lz4/lz4">LZ4</a> の速度に近くなりますが、4ははるかに遅くなります。これはシリアライザ利用シナリオで重要と判断されました。標準の <code>BrotliStream</code> を使用する場合（デフォルトはquality-4）には注意してください。いずれにせよ、圧縮・解凍速度やサイズはデータによって大きく異なります。ご自身のアプリケーションで扱うデータを用意し、必ずテストしてください。</p>
<p>MemoryPackの非圧縮時とBrotli圧縮追加時では、速度に数倍の差があることに注意してください。</p>
<p>Brotliはカスタムフォーマッタでもサポートされています。<code>BrotliFormatter</code> は特定のメンバを圧縮できます。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>外部型のシリアライズ</h2>
<p>外部型をシリアライズしたい場合は、カスタムフォーマッタを作成してプロバイダに登録できます。詳細は <a href="#formatterprovider-api">Formatter/Provider API</a> をご覧ください。ただし、カスタムフォーマッタの作成は難易度が高いです。したがって、ラッパー型の作成を推奨します。たとえば、<code>AnimationCurve</code> という外部型をシリアライズしたい場合は次のようになります。</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">struct</span> SerializableAnimationCurve
{
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimationCurve AnimationCurve;

    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode preWrapMode =&gt; AnimationCurve.preWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode postWrapMode =&gt; AnimationCurve.postWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    Keyframe[] keys =&gt; AnimationCurve.keys;

    [<span class="hljs-meta">MemoryPackConstructor</span>]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        <span class="hljs-keyword">var</span> curve = <span class="hljs-keyword">new</span> AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        <span class="hljs-keyword">this</span>.AnimationCurve = curve;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SerializableAnimationCurve</span>(<span class="hljs-params">AnimationCurve animationCurve</span>)</span>
    {
        <span class="hljs-keyword">this</span>.AnimationCurve = animationCurve;
    }
}
</code></pre>
<p>ラップする型はpublicですが、シリアライズからは除外されています（<code>MemoryPackIgnore</code>）。シリアライズしたいプロパティはprivateですが、<code>MemoryPackInclude</code> で含めています。2つのパターンのコンストラクタも用意すべきです。シリアライザが使用するコンストラクタはprivateにしてください。</p>
<p>このままだと毎回ラップする必要があり不便です。また、structラッパーではnullを表現できません。そこでカスタムフォーマッタを作成しましょう。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimationCurveFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">AnimationCurve</span>&gt;
{
    <span class="hljs-comment">// UnityはscopedとTBufferWriterをサポートしていないので、シグネチャを `Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)` に変更してください</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
```csharp
{
    writer.WriteNullObjectHeader();
    <span class="hljs-keyword">return</span>;
}

writer.WritePackable(<span class="hljs-keyword">new</span> SerializableAnimationCurve(<span class="hljs-keyword">value</span>));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (reader.PeekIsNull())
    {
        reader.Advance(<span class="hljs-number">1</span>); <span class="hljs-comment">// nullブロックをスキップ</span>
        <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">var</span> wrapped = reader.ReadPackable&lt;SerializableAnimationCurve&gt;();
    <span class="hljs-keyword">value</span> = wrapped.AnimationCurve;
}
</code></pre>
<p>最後に、スタートアップでフォーマッタを登録します。</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register&lt;AnimationCurve&gt;(<span class="hljs-keyword">new</span> AnimationCurveFormatter());
</code></pre>
<blockquote>
<p>注意: UnityのAnimationCurveはデフォルトでシリアライズ可能なので、AnimationCurve用のこのカスタムフォーマッタは不要です。</p>
</blockquote>
<h2>パッケージ</h2>
<p>MemoryPack には以下のパッケージがあります。</p>
<ul>
<li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li>
</ul>
<p><code>MemoryPack</code> はメインライブラリであり、高速なバイナリオブジェクトのシリアライズ・デシリアライズを完全にサポートします。<code>MemoryPack.Core</code> (コアベースライブラリ)と <code>MemoryPack.Generator</code> (コード生成) に依存します。<code>MemoryPack.Streaming</code> は <a href="#streaming-serialization">ストリーミングシリアライズ</a> のための拡張機能を追加します。<code>MemoryPack.AspNetCoreMvcFormatter</code> は ASP.NET Core 用の入出力フォーマッタを追加します。<code>MemoryPack.UnityShims</code> は .NET と Unity 間で型を共有するためのUnity用シム型およびフォーマッタを追加します。</p>
<h2>TypeScript および ASP.NET Core フォーマッタ</h2>
<p>MemoryPack は TypeScript コード生成をサポートします。C# からクラスとシリアライズコードを生成します。つまり、OpenAPI や proto などを使用せずにブラウザと型を共有できます。</p>
<p>コード生成は Source Generator と統合されており、以下のオプション (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) で TypeScript コードの出力ディレクトリを設定します。ランタイムコードも同時に出力されるため、追加の依存関係は不要です。</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- memorypack の TypeScript コードをディレクトリに出力 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>C# の MemoryPackable 型は <code>[GenerateTypeScript]</code> で注釈付けする必要があります。</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">GenerateTypeScript</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> required Guid Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> FirstName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> LastName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required DateTime DateOfBirth { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required Gender Gender { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span>[] Emails { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Gender
{
    Male, Female, Other
}
</code></pre>
<p>ランタイムコードとTypeScript型がターゲットディレクトリに生成されます。</p>
<p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p>
<p>生成されたコードは以下の通りです。シンプルなフィールドおよび serialize/serializeArray、deserialize/deserializeArray の静的メソッドを持ちます。</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackWriter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackWriter.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackReader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackReader.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Gender</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./Gender.js"</span>; 

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">dateOfBirth</span>: <span class="hljs-title class_">Date</span>;
    <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>;
    <span class="hljs-attr">emails</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArray</span>(<span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArrayCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArray</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArrayCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }
}
</code></pre>
<p>この型は次のように利用できます。</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
person.<span class="hljs-property">id</span> = crypto.<span class="hljs-title function_">randomUUID</span>();
person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;
person.<span class="hljs-property">firstName</span> = <span class="hljs-string">"foo"</span>;
person.<span class="hljs-property">lastName</span> = <span class="hljs-string">"bar"</span>;
person.<span class="hljs-property">dateOfBirth</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1999</span>, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
person.<span class="hljs-property">gender</span> = <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Other</span>;
person.<span class="hljs-property">emails</span> = [<span class="hljs-string">"foo@bar.com"</span>, <span class="hljs-string">"zoo@bar.net"</span>];

<span class="hljs-comment">// Uint8Array にシリアライズ</span>
<span class="hljs-keyword">let</span> bin = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">serialize</span>(person);

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([bin.<span class="hljs-property">buffer</span>], { <span class="hljs-attr">type</span>: <span class="hljs-string">"application/x-memorypack"</span> })

<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"http://localhost:5260/api"</span>,
    { <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>, <span class="hljs-attr">body</span>: blob, <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/x-memorypack"</span> } });

<span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();

<span class="hljs-comment">// ArrayBuffer からデシリアライズ</span>
<span class="hljs-keyword">let</span> person2 = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">deserialize</span>(buffer);
</code></pre>
<p><code>MemoryPack.AspNetCoreMvcFormatter</code> パッケージは、ASP.NET Core MVC 用の <code>MemoryPack</code> 入出力フォーマッタを追加します。以下のコードで <code>MemoryPackInputFormatter</code> と <code>MemoryPackOutputFormatter</code> を ASP.NET Core MVC に追加できます。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackInputFormatter());
    <span class="hljs-comment">// checkContentType: true の場合、複数のフォーマット(JSON/MemoryPack等)を出力できます。デフォルトは false。</span>
    options.OutputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackOutputFormatter(checkContentType: <span class="hljs-literal">false</span>));
});
</code></pre>
<p>HttpClient から呼び出す場合は、content-header に <code>application/x-memorypack</code> を指定できます。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> content = <span class="hljs-keyword">new</span> ByteArrayContent(bin)
content.Headers.ContentType = <span class="hljs-keyword">new</span> MediaTypeHeaderValue(<span class="hljs-string">"application/x-memorypack"</span>);
</code></pre>
<h3>TypeScript 型マッピング</h3>
<p>生成可能な型にはいくつか制限があります。プリミティブ型のうち <code>char</code> と <code>decimal</code> はサポートされません。また、OpenGenerics型も使用できません。</p>
<table>
<thead>
<tr>
<th>C#</th>
<th>TypeScript</th>
<th>説明</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>sbyte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>bigint</code></td>
<td></td>
</tr>
</tbody></table>
<pre><code class="hljs language-xml">| `ulong` |  `bigint` |
| `float` |  `number` |
| `double` |  `number` |
| `string` |  `string \| null`  | 
| `Guid` |  `string`  | TypeScriptでは文字列として表現されますが、シリアライズ/デシリアライズ時は16バイトのバイナリとして扱われます
| `DateTime` | `Date` | DateTimeKindは無視されます
| `enum` | `const enum` | 基本型が`long`および`ulong`の場合はサポートされていません
| `T?` | `T \| null` |
| `T[]` | `T[] \| null` |
| `byte[]` | `Uint8Array \| null` |
| `: ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `T[] \| null` | `List<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`など、すべての`ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`実装型をサポート
| `: ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `Set<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> \| null` | `HashSet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`など、すべての`ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`実装型をサポート
| `: IDictionary&lt;K,V&gt;` | `Map&lt;K, V&gt; \| null` | `Dictionary&lt;K,V&gt;`など、すべての`IDictionary&lt;K,V&gt;`実装型をサポート
| `[MemoryPackable]` | `class` | クラスのみサポート
| `[MemoryPackUnion]` | `abstract class` |

`[GenerateTypeScript]`はクラスのみに適用可能で、現在structはサポートされていません。

### インポートファイル拡張子とメンバー名の大文字小文字変換の設定

デフォルトでは、MemoryPackはファイル拡張子を`.js`として生成します（例：`import { MemoryPackWriter } from "./MemoryPackWriter.js";`）。他の拡張子や空にしたい場合は、`MemoryPackGenerator_TypeScriptImportExtension`を設定してください。
また、メンバー名は自動的にcamelCaseへ変換されます。元の名前を使用したい場合は、`MemoryPackGenerator_TypeScriptConvertPropertyName`を`false`に設定します。

```xml
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptImportExtension"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptConvertPropertyName"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptEnableNullableTypes"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 空も可能 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- デフォルトはtrue --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- デフォルトはfalse --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code>を有効にすると、C#のnullableアノテーションがTypeScriptコードに反映されます。デフォルトはfalseで、すべてnullableになります。</p>
<h2>ストリーミングシリアライゼーション</h2>
<p><code>MemoryPack.Streaming</code>は、コレクションのストリームによるシリアライズ/デシリアライズを追加サポートする<code>MemoryPackStreamingSerializer</code>を提供します。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackStreamingSerializer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeWriter pipeWriter, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeReader pipeReader, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, [EnumeratorCancellation] CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
}
</span></code></pre>
<h2>フォーマッタ／プロバイダーAPI</h2>
<p>フォーマッタを手動で実装したい場合は、<code>MemoryPackFormatter&lt;T&gt;</code>を継承し、<code>Serialize</code>と<code>Deserialize</code>メソッドをオーバーライドしてください。</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SkeltonFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">Skelton</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
        {
            writer.WriteNullObjectHeader();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// writerメソッドを使用</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (!reader.TryReadObjectHeader(<span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> count))
        {
            <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// readerメソッドを使用</span>
    }
}
</code></pre>
<p>作成したフォーマッタは<code>MemoryPackFormatterProvider</code>に登録します。</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register(<span class="hljs-keyword">new</span> SkeltonFormatter());
</code></pre>
<p>注意: <code>unmanaged struct</code>（参照型を含まない構造体）はカスタムフォーマッタを使用できません。常にネイティブメモリレイアウトでシリアライズされます。</p>
<h2>MemoryPackWriter/ReaderOptionalState</h2>
<p><code>MemoryPackWriter</code>や<code>MemoryPackReader</code>の初期化にはOptionalStateが必要です。これは<code>MemoryPackSerializerOptions</code>のラッパーであり、<code>MemoryPackWriterOptionalStatePool</code>から生成できます。</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Dispose時にOptionalStateがプールに返却されます</span>
<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> writer = <span class="hljs-keyword">new</span> MemoryPackWriter&lt;T&gt;(<span class="hljs-keyword">ref</span> t, state);
}

<span class="hljs-comment">// Readerの場合</span>
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> MemoryPackReader(buffer, state);
}
</code></pre>
<h2>ターゲットフレームワーク依存関係</h2>
<p>MemoryPackは<code>netstandard2.1</code>と<code>net7.0</code>を提供しますが、両者は互換性がありません。たとえば、<code>netstandard2.1</code>プロジェクトでMemoryPackable型を作成し、それを<code>net7.0</code>プロジェクトから使用すると、以下のようなランタイム例外が発生します。</p>
<blockquote>
<p>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</p>
</blockquote>
<p>net7.0は静的抽象メンバー（<code>Virtual static method</code>）を使用しており、これはnetstandard2.1ではサポートされていないため、この動作は仕様です。</p>
<p>.NET 7プロジェクトでは、netstandard 2.1のdllを使用しないでください。つまり、アプリケーションが.NET 7プロジェクトの場合、MemoryPackを使用するすべての依存関係は.NET 7をサポートしている必要があります。ライブラリ開発者がMemoryPackへ依存する場合は、複数ターゲットフレームワークの設定が必要です。</p>
<pre><code class="language-xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">TargetFrameworks</span>&gt;</span>netstandard2.1;net7.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFrameworks</span>&gt;</span>
</code></pre>
<h2>RPC</h2>
<p><a href="https://github.com/Cysharp/MagicOnion">Cysharp/MagicOnion</a>は、protobufの代わりにMessagePackを利用するコードファーストなgrpc-dotnetフレームワークです。MagicOnionは現在、シリアライズレイヤーとしてMemoryPackを<code>MagicOnion.Serialization.MemoryPack</code>パッケージ（プレビュー）経由でサポートしています。詳細は<a href="https://github.com/Cysharp/MagicOnion#memorypack-support">MagicOnion#MemoryPack support</a>をご覧ください。</p>
<h2>Unity</h2>
<p>サポートされる最小Unityバージョンは<code>2022.3.12f1</code>です。</p>
<p><code>MemoryPack</code>コアパッケージはnugetで提供されています。Unityでも利用可能です。Unityの組み込み型サポートが必要な場合は、MemoryPack.Unity拡張を追加で提供しています。</p>
<ol>
<li><a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a>を利用してNuGetから<code>MemoryPack</code>をインストール</li>
</ol>
<ul>
<li><p>NuGetウィンドウを開き、「MemoryPack」で検索し、インストールを押します。<br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p>
</li>
<li><p>バージョン競合エラーが発生した場合は、Player Settingsでバージョンバリデーションを無効にしてください（Edit -&gt; Project Settings -&gt; Player -&gt; "Other Settings"を展開し、"Assembly Version Validation"のチェックを外す）。</p>
</li>
</ul>
<ol start="2">
<li>git URLを参照して<code>MemoryPack.Unity</code>パッケージをインストール</li>
</ol>
<ul>
<li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code><br><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot"><br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></li>
</ul>
<p>MemoryPackは*.*.*リリースタグを使用しているため、<code>#1.0.0</code>のようにバージョンを指定できます。例：<code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p>
<p>.NET版と同様に、コードはコードジェネレータ（<code>MemoryPack.Generator.dll</code>）によって生成されます。リフレクションフリーな実装はIL2CPPでも最高のパフォーマンスを提供します。</p>
<p>UnityとSource Generatorについての詳細は、<a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Unity公式ドキュメント</a>をご参照ください。</p>
<p>Source Generatorは<a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">com.unity.properties</a>や<a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html">com.unity.entities</a>でも公式に利用されています。つまり、次世代Unityにおける標準的なコード生成手法です。</p>
<p>すべてのunmanaged型（<code>Vector3</code>や<code>Rect</code>等）や、一部のクラス（<code>AnimationCurve</code>、<code>Gradient</code>、<code>RectOffset</code>）をシリアライズできます。その他のUnity固有型をシリアライズしたい場合は、<a href="#serialize-external-types">外部型のシリアライズ</a>セクションをご覧ください。</p>
<p>Unityでのパフォーマンスでは、MemoryPackはJsonUtilityより3～10倍高速です。</p>
<p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p>
<p>共有コードでUnity型（<code>Vector2</code>等）を利用する場合、MemoryPackはNuGetで<code>MemoryPack.UnityShims</code>パッケージも提供しています。</p>
<p><code>MemoryPack.UnityShims</code>パッケージは、Unity標準構造体（<code>Vector2</code>、<code>Vector3</code>、<code>Vector4</code>、<code>Quaternion</code>、<code>Color</code>、<code>Bounds</code>、<code>Rect</code>、<code>Keyframe</code>、<code>WrapMode</code>、<code>Matrix4x4</code>、<code>GradientColorKey</code>、<code>GradientAlphaKey</code>、<code>GradientMode</code>、<code>Color32</code>、<code>LayerMask</code>、<code>Vector2Int</code>、<code>Vector3Int</code>、<code>RangeInt</code>、<code>RectInt</code>、<code>BoundsInt</code>）や一部のクラス（<code>AnimationCurve</code>、<code>Gradient</code>、<code>RectOffset</code>）のShimsを提供します。</p>
<blockquote>
<p>[!WARNING]<br>現在、Unityで使用する際には以下の制限があります</p>
</blockquote>
<ol>
<li>Unity版ではCustomFormatterはサポートされていません。</li>
<li>.NET7以降を使用している場合、MemoryPackバイナリフォーマットはUnityと完全互換ではありません。<ul>
<li>この問題は、<code>[StructLayout(LayoutKind.Auto)]</code>が明示的に指定された値型で発生します（structのデフォルトは<code>LayoutKind.Sequencial</code>）。このような型では、.NETでシリアライズしたバイナリをUnityでデシリアライズできません。同様に、Unityでシリアライズしたバイナリは.NET側でデシリアライズできません。</li>
<li>影響を受ける型の代表例は以下です。<ul>
<li><code>DateTimeOffset</code></li>
<li><code>ValueTuple</code></li>
</ul>
</li>
<li>現状の簡単な解決策は、これらの型を使用しないことです。</li>
</ul>
</li>
</ol>
<h2>Native AOT</h2>
<p>残念ながら、.NET 7 Native AOTではMemoryPack使用時にランタイムバグによりクラッシュ（<code>Generic virtual method pointer lookup failure</code>）します。<br>この問題は.NET 8で修正予定です。<code>Microsoft.DotNet.ILCompiler</code>のプレビューバージョンを使用すると.NET 7でも修正されます。セットアップ方法は<a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611">issueのコメント</a>をご参照ください。</p>
<h2>バイナリワイヤフォーマット仕様</h2>
<p><code>Serialize&lt;T&gt;</code>および<code>Deserialize&lt;T&gt;</code>で定義される<code>T</code>の型をC#スキーマと呼びます。MemoryPackフォーマットは自己記述型フォーマットではありません。デシリアライズには対応するC#スキーマが必要です。これらの型はバイナリ内部表現として存在しますが、C#スキーマなしでは型を判定できません。</p>
<p>エンディアンは<code>リトルエンディアン</code>でなければなりません。ただし、C#リファレンス実装はエンディアンを考慮していないため、ビッグエンディアンマシンでは利用できません。なお、現代のコンピュータは通常リトルエンディアンです。</p>
<p>フォーマットには8種類あります。</p>
<ul>
<li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>循環参照オブジェクト</li>
<li>タプル</li>
<li>コレクション</li>
<li>文字列</li>
<li>ユニオン</li>
</ul>
<h3>アンマネージド構造体</h3>
<p>アンマネージド構造体は、参照型を含まないC#構造体であり、<a href="https://learn.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# アンマネージド型</a>の制約と同様です。構造体のレイアウトをそのままシリアライズし、パディングも含みます。</p>
<h3>オブジェクト</h3>
<p><code>(byte メンバー数, [値...])</code></p>
<p>オブジェクトは、ヘッダーとして1バイトの符号なしバイトでメンバー数を持ちます。メンバー数は<code>0</code>から<code>249</code>まで許容し、<code>255</code>はオブジェクトが<code>null</code>であることを示します。値は、メンバー数分のメモリパック値が格納されます。</p>
<h3>バージョン耐性オブジェクト</h3>
<p><code>(byte メンバー数, [varint 値のバイト長...], [値...])</code></p>
<p>バージョン耐性オブジェクトはオブジェクトと似ていますが、ヘッダーに値のバイト長を持ちます。varintは次の仕様に従います。最初のsbyteは値またはtypeCodeであり、次のXバイトが値です。0～127は符号なしバイト値、-1～-120は符号付きバイト値、-121はバイト、-122はsbyte、-123はushort、-124はshort、-125はuint、-126はint、-127はulong、-128はlong。</p>
<h3>循環参照オブジェクト</h3>
<p><code>(byte メンバー数, [varint 値のバイト長...], varint 参照ID, [値...])</code><br><code>(250, varint 参照ID)</code></p>
<p>循環参照オブジェクトはバージョン耐性オブジェクトと似ていますが、メンバー数が250の場合、次のvarint（符号なし32ビット整数）が参照IDになります。そうでない場合、値のバイト長の後にvarint 参照IDが書き込まれます。</p>
<h3>タプル</h3>
<p><code>(値...)</code></p>
<p>タプルは固定サイズでnull不可の値のコレクションです。.NETでは、<code>KeyValuePair&lt;TKey, TValue&gt;</code>および<code>ValueTuple&lt;T,...&gt;</code>がタプルとしてシリアライズされます。</p>
<h3>コレクション</h3>
<p><code>(int 長さ, [値...])</code></p>
<p>コレクションは、ヘッダーとして4バイトの符号付き整数でデータ数を持ち、<code>-1</code>は<code>null</code>を示します。値は長さ分のメモリパック値が格納されます。</p>
<h3>文字列</h3>
<p><code>(int utf16-長さ, utf16-値)</code><br><code>(int ~utf8-バイト数, int utf16-長さ, utf8-バイト列)</code></p>
<p>文字列はUTF16とUTF8の2つの形式があります。最初の4バイト符号付き整数が<code>-1</code>の場合、nullを示します。<code>0</code>は空を示します。UTF16はコレクションと同様（<code>ReadOnlySpan&lt;char&gt;</code>としてシリアライズ、utf16-値のバイト数はutf16-長さ×2）です。最初の符号付き整数が<code>-2</code>以下の場合、値はUTF8でエンコードされます。utf8-バイト数は補数でエンコードされているため、<code>~utf8-バイト数</code>でバイト数を取得します。次の符号付き整数はutf16-長さで、<code>-1</code>（不明な長さ）も許容します。utf8-バイト列はutf8-バイト数分のバイトを格納します。</p>
<h3>ユニオン</h3>
<p><code>(byte タグ, 値)</code><br><code>(250, ushort タグ, 値)</code></p>
<p>最初の符号なしバイトはタグで、判別付き値型またはフラグ用です。<code>0</code>～<code>249</code>はタグ、<code>250</code>は次の符号なしショートがタグ、<code>255</code>はユニオンが<code>null</code>であることを示します。</p>
<h2>ライセンス</h2>
<p>このライブラリはMITライセンスの下で提供されています。</p>
<hr>
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-09</p>
<hr>
</div>
    </div>

    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async=""></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
    <script src="view.js"></script>


</body></html>