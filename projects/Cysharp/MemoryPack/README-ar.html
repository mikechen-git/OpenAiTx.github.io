<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Open AI Tx</title>

    <!-- Primary Meta Tags -->
    <meta name="title" content="Open AI Tx - Markdown Viewer">
    <meta name="description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta name="keywords" content="Open AI Tx, Markdown, GitHub Style, Documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/view.html">
    <meta property="og:title" content="Open AI Tx - Markdown Viewer">
    <meta property="og:description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">

    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="icon.jpg">
    <link rel="apple-touch-icon" href="icon.jpg">

    <!-- Marked.js for Markdown rendering -->
    <script type="text/javascript" async="" src="https://www.statcounter.com/counter/recorder.js"></script><script src="js/marked.min.js"></script>
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="css/github.min.css">
    <script src="js/highlight.min.js"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="view.css">
    <style>
        /* Layout */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .main-container {
            margin: 0 auto;
            width: 100%;
            max-width: 980px;
            padding: 0 20px;
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0 15px;
            }
        }

        /* Image size restrictions */
        .markdown-body img {
            max-width: 100%;
            height: auto;
        }

        /* Existing styles */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f6f8fa;
            border-bottom: 1px solid #e1e4e8;
            position: relative;
        }

        .back-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #0366d6;
            text-decoration: none;
            display: flex;
            align-items: center;
            font-size: 14px;
            padding: 5px 10px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #fff;
        }

        .back-button:hover {
            background-color: #f6f8fa;
            border-color: #0366d6;
        }

        .back-button::before {
            content: "←";
            margin-right: 5px;
            font-size: 16px;
        }

        .header .links {
            margin-top: 10px;
            font-size: 16px;
        }

        .header .links a {
            color: #0366d6;
            text-decoration: none;
            margin-left: 5px;
        }

        .header .links a:hover {
            text-decoration: underline;
        }
        
        /* Language badges styles */
        .language-badges {
            margin-top: 15px;
            text-align: center;
        }
        .language-badges a {
            display: inline-block;
            margin: 2px;
            text-decoration: none;
        }
        .language-badges img {
            height: 20px;
            border-radius: 3px;
        }
        .language-badges a:hover img {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div class="header">
        <a href="javascript:history.back()" class="back-button">Back</a>
        <div class="links">
            GitHub Repository: <a href="https://github.com/Cysharp/MemoryPack" id="githubRepoLink" target="_blank">Cysharp/MemoryPack</a>
        </div>
        <div class="language-badges" id="languageBadges"><a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=en"><img src="https://img.shields.io/badge/EN-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-CN"><img src="https://img.shields.io/badge/简中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-TW"><img src="https://img.shields.io/badge/繁中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ja"><img src="https://img.shields.io/badge/日本語-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ko"><img src="https://img.shields.io/badge/한국어-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=th"><img src="https://img.shields.io/badge/ไทย-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=fr"><img src="https://img.shields.io/badge/Français-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=de"><img src="https://img.shields.io/badge/Deutsch-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=es"><img src="https://img.shields.io/badge/Español-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=it"><img src="https://img.shields.io/badge/Italiano-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ru"><img src="https://img.shields.io/badge/Русский-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pt"><img src="https://img.shields.io/badge/Português-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=nl"><img src="https://img.shields.io/badge/Nederlands-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pl"><img src="https://img.shields.io/badge/Polski-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ar"><img src="https://img.shields.io/badge/العربية-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=tr"><img src="https://img.shields.io/badge/Türkçe-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=vi"><img src="https://img.shields.io/badge/Tiếng Việt-white" alt="version"></a></div>
    </div>

    <div class="main-container">
        <div class="markdown-body" id="content"><h1>MemoryPack</h1>
<p><a href="https://www.nuget.org/packages/MemoryPack"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a><br><a href="https://github.com/Cysharp/MemoryPack/actions"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a><br><a href="https://github.com/Cysharp/MemoryPack/releases"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p>
<p>مُسلسل ثنائي عالي الأداء بدون ترميز للأشياء في C# و Unity.</p>
<p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p>
<blockquote>
<p>مقارنةً مع <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json">System.Text.Json</a>، <a href="https://github.com/protobuf-net/protobuf-net">protobuf-net</a>، <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>، <a href="https://github.com/dotnet/orleans/">Orleans.Serialization</a>. تم القياس باستخدام .NET 7 / Ryzen 9 5950X. هذه المسلسلات لديها طريقة <code>IBufferWriter&lt;byte&gt;</code>، تم التسلسل باستخدام <code>ArrayBufferWriter&lt;byte&gt;</code> وإعادة استخدامه لتجنب قياس نسخ الذاكرة المؤقتة.</p>
</blockquote>
<p>بالنسبة للأشياء القياسية، يعد MemoryPack أسرع بـ 10 مرات و x2 ~ x5 أسرع من مسلسلات ثنائية أخرى. بالنسبة لمصفوفة الهياكل، يكون MemoryPack أكثر قوة، بسرعة تصل إلى x50 ~ x200 مقارنةً بالمسلسلات الأخرى.</p>
<p>MemoryPack هو المسلسل الرابع الذي أنشأته، حيث أنني أنشأت سابقاً مسلسلات معروفة، <del><a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a></del>، <del><a href="https://github.com/neuecc/Utf8Json">Utf8Json</a></del>، <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>. سبب سرعة MemoryPack هو اعتماده على تنسيق ثنائي خاص ومحسن لـ C# وتنفيذ مضبوط جيداً بناءً على خبرتي السابقة. كما أنه تصميم جديد بالكامل يستفيد من .NET 7 و C# 11 وميزة Incremental Source Generator (يدعم أيضاً .NET Standard 2.1 (.NET 5, 6) ويوجد دعم لـ Unity).</p>
<p>المسلسلات الأخرى تقوم بالكثير من عمليات الترميز مثل ترميز VarInt، والعلامات، والسلاسل النصية، إلخ. يستخدم تنسيق MemoryPack تصميم "صفر ترميز" حيث يتم نسخ أكبر قدر ممكن من ذاكرة C#. صفر ترميز مشابه لـ FlatBuffers، لكنه لا يحتاج إلى نوع خاص، هدف تسلسل MemoryPack هو كائنات POCO.</p>
<p>بالإضافة إلى الأداء، يتميز MemoryPack بالخصائص التالية:</p>
<ul>
<li>دعم واجهات I/O الحديثة (<code>IBufferWriter&lt;byte&gt;</code>, <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>)</li>
<li>توليد كود معتمد على Source Generator مناسب لـ Native AOT، بدون Dynamic CodeGen (IL.Emit)</li>
<li>واجهات برمجية بدون انعكاس وغير عامة</li>
<li>فك تسلسل إلى كائن موجود مسبقاً</li>
<li>تسلسل متعدد الأشكال (الاتحاد)</li>
<li>دعم محدود للتوافق مع الإصدارات (سريع/افتراضي) ودعم كامل للتوافق مع الإصدارات</li>
<li>دعم تسلسل المراجع الدائرية</li>
<li>تسلسل تدفقي مبني على PipeWriter/Reader</li>
<li>توليد كود TypeScript و ASP.NET Core Formatter</li>
<li>دعم Unity (2021.3) IL2CPP عبر .NET Source Generator</li>
</ul>
<h2>التثبيت</h2>
<p>يتم توزيع هذه المكتبة عبر NuGet. لأفضل أداء، يوصى باستخدام <code>.NET 7</code>. الحد الأدنى هو <code>.NET Standard 2.1</code>.</p>
<blockquote>
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/MemoryPack">MemoryPack</a></p>
</blockquote>
<p>ويتطلب محرر الكود أيضاً دعم Roslyn 4.3.1، على سبيل المثال Visual Studio 2022 الإصدار 17.3، .NET SDK 6.0.401. للمزيد من التفاصيل، راجع <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support">وثيقة دعم إصدار Roslyn</a>.</p>
<p>بالنسبة لـ Unity، المتطلبات وطريقة التثبيت مختلفة تماماً. راجع قسم <a href="#unity">Unity</a> للمزيد من التفاصيل.</p>
<h2>بداية سريعة</h2>
<p>عرّف هيكل أو فئة ليتم تسلسلها وعلّمها بوسم <code>[MemoryPackable]</code> وكلمة <code>partial</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack;

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>يتم توليد كود التسلسل بواسطة ميزة مولد الكود المصدر في C# والتي تنفذ واجهة <code>IMemoryPackable&lt;T&gt;</code>. في Visual Studio يمكنك معاينة الكود المولد باستخدام اختصار <code>Ctrl+K, R</code> على اسم الفئة واختيار <code>*.MemoryPackFormatter.g.cs</code>.</p>
<p>استدعِ <code>MemoryPackSerializer.Serialize&lt;T&gt;/Deserialize&lt;T&gt;</code> لتسلسل/فك تسلسل نسخة من الكائن.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Person { Age = <span class="hljs-number">40</span>, Name = <span class="hljs-string">"John"</span> };

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(v);
<span class="hljs-keyword">var</span> val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p>تدعم طريقة <code>Serialize</code> نوع الإرجاع <code>byte[]</code> كما يمكنها التسلسل إلى <code>IBufferWriter&lt;byte&gt;</code> أو <code>Stream</code>. تدعم طريقة <code>Deserialize</code> كل من <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code> و <code>Stream</code>. وهناك أيضاً إصدارات غير عامة.</p>
<h2>الأنواع المدعومة افتراضياً</h2>
<p>هذه الأنواع يمكن تسلسلها افتراضياً:</p>
<ul>
<li>الأنواع الأولية في .NET (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, إلخ)</li>
<li>الأنواع غير المُدارة (أي <code>enum</code>, أي هيكل معرفة من المستخدم لا يحتوي على أنواع مرجعية)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code> <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory&lt;&gt;</code>, <code>ReadOnlyMemory&lt;&gt;</code>, <code>ArraySegment&lt;&gt;</code>, <code>ReadOnlySequence&lt;&gt;</code></li>
<li><code>Nullable&lt;&gt;</code>, <code>Lazy&lt;&gt;</code>, <code>KeyValuePair&lt;,&gt;</code>, <code>Tuple&lt;,...&gt;</code>, <code>ValueTuple&lt;,...&gt;</code></li>
<li><code>List&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>SortedSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code></li>
<li><code>Dictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>,  <code>ReadOnlyDictionary&lt;,&gt;</code> </li>
<li><code>Collection&lt;&gt;</code>, <code>ReadOnlyCollection&lt;&gt;</code>, <code>ObservableCollection&lt;&gt;</code>, <code>ReadOnlyObservableCollection&lt;&gt;</code></li>
<li><code>IEnumerable&lt;&gt;</code>, <code>ICollection&lt;&gt;</code>, <code>IList&lt;&gt;</code>, <code>IReadOnlyCollection&lt;&gt;</code>, <code>IReadOnlyList&lt;&gt;</code>, <code>ISet&lt;&gt;</code></li>
<li><code>IDictionary&lt;,&gt;</code>, <code>IReadOnlyDictionary&lt;,&gt;</code>, <code>ILookup&lt;,&gt;</code>, <code>IGrouping&lt;,&gt;</code>,</li>
<li><code>ConcurrentBag&lt;&gt;</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>, <code>BlockingCollection&lt;&gt;</code></li>
<li>المجموعات الثابتة (<code>ImmutableList&lt;&gt;</code>, إلخ) والواجهات (<code>IImmutableList&lt;&gt;</code>, إلخ)</li>
</ul>
<h2>تعريف <code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code></h2>
<p>يمكن وسم <code>[MemoryPackable]</code> لأي <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> و <code>interface</code>. إذا كان النوع <code>struct</code> أو <code>record struct</code> ولا يحتوي على أنواع مرجعية (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">أنواع C# غير المُدارة</a>) فلن يتم استخدام أي وسم إضافي (تجاهل، تضمين، مُنشئ، ردود نداء)، حيث يتم التسلسل/فك التسلسل مباشرةً من الذاكرة.</p>
<p>أما خلاف ذلك، فبشكل افتراضي، يقوم <code>[MemoryPackable]</code> بتسلسل الخصائص أو الحقول العامة فقط. يمكنك استخدام <code>[MemoryPackIgnore]</code> لإزالة الهدف من التسلسل، ويقوم <code>[MemoryPackInclude]</code> بترقية عضو خاص ليكون هدفاً للتسلسل.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// يتم تسلسل هذه الأنواع افتراضياً</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicField;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> PublicReadOnlyField;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PrivateSetPublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ReadOnlyPublicProperty { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> RequiredInitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }

    <span class="hljs-comment">// هذه الأنواع لا يتم تسلسلها افتراضياً</span>
    <span class="hljs-built_in">int</span> privateProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-built_in">int</span> privateField;
    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> privateReadOnlyField;

    <span class="hljs-comment">// استخدم [MemoryPackIgnore] لإزالة عضو عام من التسلسل</span>
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty2 =&gt; PublicProperty + PublicField;

    <span class="hljs-comment">// استخدم [MemoryPackInclude] لترقية عضو خاص ليكون هدفاً للتسلسل</span>
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateField2;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>يضيف مولد كود MemoryPack معلومات حول الأعضاء التي تم تسلسلها إلى قسم <code>&lt;remarks /&gt;</code>. يمكن مشاهدة ذلك بالتمرير فوق النوع في Intellisense.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p>
<p>يجب أن تكون جميع الأعضاء قابلة للتسلسل بواسطة memorypack، وإلا سيصدر مولد الكود خطأ.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p>
<p>لـ MemoryPack 35 قاعدة تشخيص (<code>MEMPACK001</code> إلى <code>MEMPACK035</code>) لتعريفها بشكل مريح.</p>
<p>إذا تم تعريف نوع الهدف لتسلسل MemoryPack خارجياً وتم تسجيله، استخدم <code>[MemoryPackAllowSerialize]</code> لكتم التشخيص.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample2</span>
{
    [<span class="hljs-meta">MemoryPackAllowSerialize</span>]
    <span class="hljs-keyword">public</span> NotSerializableType? NotSerializableProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>ترتيب الأعضاء <strong>مهم جداً</strong>، حيث أن MemoryPack لا يسلسل أسماء الأعضاء أو معلومات أخرى، بل يسلسل الحقول حسب ترتيب تعريفها. إذا كان النوع موروث، يتم التسلسل بترتيب الوالد → الابن. لا يمكن تغيير ترتيب الأعضاء لعملية فك التسلسل. لمزيد من التفاصيل حول تطوير المخطط، راجع قسم <a href="#version-tolerant">التوافق مع الإصدارات</a>.</p>
<p>الترتيب الافتراضي هو تسلسلي، لكن يمكنك اختيار الترتيب الصريح باستخدام <code>[MemoryPackable(SerializeLayout.Explicit)]</code> و <code>[MemoryPackOrder()]</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// تسلسل Prop0 -&gt; Prop1</span>
[<span class="hljs-meta">MemoryPackable(SerializeLayout.Explicit)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleExplicitOrder</span>
{
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h3>اختيار المُنشئ</h3>
<p>يدعم MemoryPack كل من المُنشئات ذات المعاملات وبدون معاملات. اختيار المُنشئ يتبع القواعد التالية (ينطبق على الكلاسات والهياكل):</p>
<ul>
<li>إذا كان هناك <code>[MemoryPackConstructor]</code>، يتم استخدامه.</li>
<li>إذا لم يوجد مُنشئ صريح (بما في ذلك الخاص)، يتم استخدام مُنشئ بدون معاملات.</li>
<li>إذا كان هناك مُنشئ واحد فقط (بما في ذلك الخاص)، يتم استخدامه سواء كان بدون أو مع معاملات.</li>
<li>إذا كان هناك عدة منشئات، يجب تطبيق وسم <code>[MemoryPackConstructor]</code> على المنشئ المطلوب (لن يختار المولد تلقائياً)، وإلا سيصدر المولد خطأ.</li>
<li>إذا كان يتم استخدام مُنشئ بمعاملات، يجب أن تتطابق جميع أسماء المعاملات مع أسماء الأعضاء المقابلة (بدون حساسية لحالة الأحرف).</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Name;

    <span class="hljs-comment">// يمكنك استخدام مُنشئ بمعاملات - يجب أن تتطابق أسماء المعاملات مع أسماء الأعضاء (بدون حساسية لحالة الأحرف)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Age = age;
        <span class="hljs-keyword">this</span>.Name = name;
    }
}

<span class="hljs-comment">// يدعم أيضاً مُنشئ record الأساسي</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Person2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Age, <span class="hljs-built_in">string</span> Name</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>()</span>
    {
    }
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// إذا كان هناك عدة منشئين، يجب استخدام [MemoryPackConstructor]</span>
[<span class="hljs-meta">MemoryPackConstructor</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
{
    <span class="hljs-keyword">this</span>.Age = age;
    <span class="hljs-keyword">this</span>.Name = name;
}
</code></pre>
<h3>استدعاءات التسلسل (Serialization callbacks)</h3>
<p>عند إجراء التسلسل/إلغاء التسلسل، يمكن لـ MemoryPack استدعاء حدث قبل/بعد العملية باستخدام السمات <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. يمكن وضعها على كل من الدوال الساكنة ودوال الكائن (غير الساكنة)، وعلى الدوال العامة والخاصة.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MethodCallSample</span>
{
    <span class="hljs-comment">// ترتيب استدعاء الدوال هو: الساكنة -&gt; الكائن</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing1));
    }

    <span class="hljs-comment">// يسمح أيضًا بالدوال الخاصة</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing2));
    }

    <span class="hljs-comment">// serializing -&gt; /* serialize */ -&gt; serialized</span>
    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized1));
    }

    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing1));
    }

    <span class="hljs-comment">// ملاحظة: الدالة الكائنية مع MemoryPackOnDeserializing لن يتم استدعاؤها إذا لم يتم تمرير الكائن بواسطة `ref`</span>
    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized1));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized2));
    }
}
</code></pre>
<p>تسمح الاستدعاءات بدوال بدون معلمات ودوال من نوع <code>ref reader/writer, ref T value</code>. على سبيل المثال، يمكن لاستدعاءات ref كتابة/قراءة رأس مخصص قبل عملية التسلسل.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EmitIdData</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteId</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)
        <span class="hljs-keyword">where</span> TBufferWriter : IBufferWriter&lt;<span class="hljs-built_in">byte</span>&gt; <span class="hljs-comment">// .NET Standard 2.1، استخدم where TBufferWriter : class, IBufferWriter&lt;byte&gt;</span></span>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); <span class="hljs-comment">// كتابة GUID في رأس البيانات.</span>
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadId</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-comment">// قراءة رأس مخصص قبل إلغاء التسلسل</span>
        <span class="hljs-keyword">var</span> guid = reader.ReadUnmanaged&lt;Guid&gt;();
        Console.WriteLine(guid);
    }
}
</code></pre>
<p>إذا تم تعيين قيمة لـ <code>ref value</code>، يمكنك تغيير القيمة المستخدمة في التسلسل/إلغاء التسلسل. على سبيل المثال، الإنشاء من ServiceProvider.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// قبل استخدام هذا المنسق، عيّن ServiceProvider</span>
<span class="hljs-comment">// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };</span>
<span class="hljs-comment">// MemoryPackSerializer.Deserialize(value, options);</span>

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InstantiateFromServiceProvider</span>
{
    <span class="hljs-keyword">static</span> IServiceProvider serviceProvider = <span class="hljs-literal">default</span>!;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> InstantiateFromServiceProvider <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">value</span> = reader.Options.ServiceProvider!.GetRequiredService&lt;InstantiateFromServiceProvider&gt;();
    }
}
</code></pre>
<h2>تعريف مجموعة مخصصة</h2>
<p>بشكل افتراضي، يحاول النوع المميز بـ <code>[MemoryPackObject]</code> تسلسل أعضائه. ومع ذلك، إذا كان النوع مجموعة (<code>ICollection&lt;&gt;</code>, <code>ISet&lt;&gt;</code>, <code>IDictionary&lt;,&gt;</code>)، استخدم <code>GenerateType.Collection</code> لتسلسلها بشكل صحيح.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt;
{
}

[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyStringDictionary</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>&gt;
{

}
</code></pre>
<h2>المُنشئ الساكن</h2>
<p>لا يمكن لفئة MemoryPackable تعريف مُنشئ ساكن لأن الفئة الجزئية المولدة تستخدمه. بدلاً من ذلك، يمكنك تعريف <code>static partial void StaticConstructor()</code> للقيام بنفس الشيء.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CctorSample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StaticConstructor</span>()</span>
    {
    }
}
</code></pre>
<h2>تعدد الأشكال (Union)</h2>
<p>يدعم MemoryPack تسلسل كائنات الواجهة والفئات المجردة لتسلسل تعدد الأشكال. في MemoryPack تسمى هذه الميزة Union. يُسمح فقط للواجهات والفئات المجردة بوضع سمة <code>[MemoryPackUnion]</code> عليها. يجب أن تكون علامات الاتحاد فريدة.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// ضع [MemoryPackable] وأنواع الوراثة مع [MemoryPackUnion]</span>
<span class="hljs-comment">// يدعم الاتحاد أيضًا الفئة المجردة</span>
[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> XYZ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BarClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? OPQ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
<span class="hljs-comment">// ---</span>

IUnionSample data = <span class="hljs-keyword">new</span> FooClass() { XYZ = <span class="hljs-number">999</span> };

<span class="hljs-comment">// التسلسل كنوع واجهة.</span>
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(data);

<span class="hljs-comment">// إلغاء التسلسل كنوع واجهة.</span>
<span class="hljs-keyword">var</span> reData = MemoryPackSerializer.Deserialize&lt;IUnionSample&gt;(bin);

<span class="hljs-keyword">switch</span> (reData)
{
    <span class="hljs-keyword">case</span> FooClass x:
        Console.WriteLine(x.XYZ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BarClass x:
        Console.WriteLine(x.OPQ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-literal">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p>يسمح <code>tag</code> بقيم من <code>0</code> إلى <code>65535</code>، وهو فعال بشكل خاص للقيم الأقل من <code>250</code>.</p>
<pre><code class="hljs language-csharp">إذا كان هناك واجهة وأنواع مشتقة منها في تجمعات مختلفة، يمكنك استخدام `MemoryPackUnionFormatterAttribute` بدلاً من ذلك. يتم إنشاء المُنسّقات بحيث يتم تسجيلها تلقائيًا عبر `ModuleInitializer` في C<span class="hljs-meta"># 9.0 وما فوق.</span>

&gt; لاحظ أن `ModuleInitializer` غير مدعوم في Unity، لذلك يجب تسجيل المُنسّق يدويًا. لتسجيل مُنسّق الاتحاد الخاص بك، قم بمناداة `{اسم مُنسّق الاتحاد الخاص بك}Initializer.RegisterFormatter()` يدويًا في بدء التشغيل (Startup). على سبيل المثال `UnionSampleFormatterInitializer.RegisterFormatter()`.

```csharp
<span class="hljs-comment">// AssemblyA</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.NoGenerate)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

<span class="hljs-comment">// AssemblyB تعريف المُنسّق خارج نوع الهدف</span>
[<span class="hljs-meta">MemoryPackUnionFormatter(typeof(IUnionSample))</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnionSampleFormatter</span>
{
}
</code></pre>
<p>يمكن جمع الاتحاد في الشيفرة عبر <code>DynamicUnionFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// (ushort, Type)[]</span>
<span class="hljs-keyword">var</span> formatter = <span class="hljs-keyword">new</span> DynamicUnionFormatter&lt;IFooBarBaz&gt;(
    (<span class="hljs-number">0</span>, <span class="hljs-keyword">typeof</span>(Foo)),
    (<span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(Bar)),
    (<span class="hljs-number">2</span>, <span class="hljs-keyword">typeof</span>(Baz))
);

MemoryPackFormatterProvider.Register(formatter);
</code></pre>
<h2>واجهة برمجة التطبيقات للتسلسل</h2>
<p>لـ <code>Serialize</code> ثلاث دوال تحميل (overloads).</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// يوجد أيضًا واجهة برمجة تطبيقات غير عامة، في هذه النسخة الوسيطة الأولى هي Type والقيمة هي object?</span>
<span class="hljs-function"><span class="hljs-built_in">byte</span>[] <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> TBufferWriter bufferWriter, <span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
</span></code></pre>
<p>للحصول على أفضل أداء، يُوصى باستخدام واجهة برمجة التطبيقات التي تستخدم <code>BufferWriter</code>. هذا يقوم بالتسلسل مباشرةً إلى المخزن المؤقت. يمكن تطبيقه على <code>PipeWriter</code> في <code>System.IO.Pipelines</code>، و<code>BodyWriter</code> في ASP .NET Core، إلخ.</p>
<p>إذا كان هناك حاجة إلى <code>byte[]</code> (على سبيل المثال <code>RedisValue</code> في <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>)، فإن واجهة برمجة التطبيقات التي تعيد <code>byte[]</code> بسيطة وسريعة تقريبًا بنفس السرعة.</p>
<p>لاحظ أن <code>SerializeAsync</code> لـ <code>Stream</code> غير متزامنة إلا من حيث التفريغ (Flush)؛ حيث يتم تسلسل كل شيء مرة واحدة في مخزن مؤقت داخلي لـ MemoryPack ثم يُكتب باستخدام <code>WriteAsync</code>. لذلك، الدالة التي تعتمد على <code>BufferWriter</code> وتفصل بين المخزن المؤقت والتفريغ أفضل.</p>
<p>إذا كنت ترغب في إجراء كتابة تدفقية كاملة، راجع قسم <a href="#streaming-serialization">التسلسل المتدفق</a>.</p>
<h3>خيارات MemoryPackSerializerOptions</h3>
<p>تُحدد <code>MemoryPackSerializerOptions</code> ما إذا كانت السلاسل النصية سيتم تسلسلها كـ UTF16 أو UTF8. يمكن ضبط هذا عن طريق تمرير <code>MemoryPackSerializerOptions.Utf8</code> لترميز UTF8، أو <code>MemoryPackSerializerOptions.Utf16</code> لترميز UTF16، أو <code>MemoryPackSerializerOptions.Default</code> التي تتيح الافتراضي وهو UTF8. تمرير قيمة null أو استخدام القيمة الافتراضية يؤدي إلى ترميز UTF8.</p>
<p>نظرًا لأن التمثيل الداخلي للسلاسل في C# هو UTF16، فإن أداء UTF16 أفضل. ومع ذلك، يكون حجم الحمولة عادةً أكبر؛ في UTF8، السلسلة ASCII تأخذ بايت واحد، بينما في UTF16 تأخذ بايتين. وبما أن الفرق في حجم الحمولة كبير، فالإعداد الافتراضي هو UTF8.</p>
<p>إذا كانت البيانات غير ASCII (مثل اليابانية، والتي يمكن أن تتجاوز 3 بايت، وUTF8 يكون أكبر)، أو إذا كان عليك ضغطها بشكل منفصل، فقد يعطي UTF16 نتائج أفضل.</p>
<p>بينما يمكن اختيار UTF8 أو UTF16 أثناء التسلسل، ليس من الضروري تحديده أثناء فك التسلسل. سيتم اكتشافه تلقائيًا وفك تسلسله بشكل طبيعي.</p>
<p>بالإضافة إلى ذلك يمكنك الحصول/تعيين <code>IServiceProvider? ServiceProvider { get; init; }</code> من الخيارات. يكون هذا مفيدًا للحصول على كائن DI (مثل <code>ILogger&lt;T&gt;</code>) أثناء عملية التسلسل (<code>MemoryPackReader/MemoryPackWriter</code> يحتويان على خاصية .Options).</p>
<h2>واجهة برمجة التطبيقات لفك التسلسل</h2>
<p><code>Deserialize</code> لها تحميلات عبر <code>ReadOnlySpan&lt;byte&gt;</code> و<code>ReadOnlySequence&lt;byte&gt;</code>، ودعم <code>Stream</code> و<code>ref</code>.</p>
<pre><code class="language-csharp hljs">T? Deserialize&lt;T&gt;(ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer)
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
T? <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer</span>)
<span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
<span class="hljs-keyword">async</span> <span class="hljs-title">ValueTask</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream</span>)
</span></code></pre>
<p>تحميلات <code>ref</code> تقوم بالكتابة فوق مثيل موجود، لمزيد من التفاصيل راجع قسم <a href="#overwrite">الكتابة فوق</a>.</p>
<p><code>DeserializeAsync(Stream)</code> ليست عملية قراءة تدفقية كاملة، أولاً تقرأ إلى مخزن مؤقت داخلي خاص بـ MemoryPack حتى نهاية التدفق، ثم تقوم بفك التسلسل.</p>
<p>إذا كنت تريد القيام بعملية قراءة تدفقية كاملة، راجع قسم <a href="#streaming-serialization">التسلسل المتدفق</a>.</p>
<h2>الكتابة فوق</h2>
<p>لتقليل التخصيصات، يدعم MemoryPack فك التسلسل إلى مثيل موجود، والكتابة فوقه. يمكن استخدام ذلك مع تحميل <code>Deserialize(ref T? value)</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(person);

<span class="hljs-comment">// الكتابة فوق البيانات إلى المثيل الموجود.</span>
MemoryPackSerializer.Deserialize(bin, <span class="hljs-keyword">ref</span> person);
</code></pre>
<p>سيحاول MemoryPack الكتابة فوق أكبر قدر ممكن، ولكن إذا لم تتطابق الشروط التالية، سيتم إنشاء مثيل جديد (كما في فك التسلسل العادي):</p>
<ul>
<li>إذا كانت قيمة المرجع (بما في ذلك الأعضاء في الرسم البياني للكائنات) null، سيتم تعيين مثيل جديد</li>
<li>يسمح فقط بالمنشئ بدون معلمات، إذا تم استخدام منشئ بمعلمات، سيتم إنشاء مثيل جديد</li>
<li>إذا كانت القيمة <code>T[]</code>، يتم إعادة الاستخدام فقط إذا كان الطول متساويًا، وإلا يتم إنشاء مثيل جديد</li>
<li>إذا كانت القيمة مجموعة تحتوي على دالة <code>.Clear()</code> (<code>List&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentBag&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>) يتم مناداة Clear() وإعادة استخدامها، وإلا يتم إنشاء مثيل جديد</li>
</ul>
<h2>دعم الإصدارات (Version tolerant)</h2>
<p>في الوضع الافتراضي (<code>GenerateType.Object</code>)، يدعم MemoryPack تطور المخطط بشكل محدود.</p>
<ul>
<li>لا يمكن تغيير struct غير المدار بعد الآن</li>
<li>يمكن إضافة أعضاء، لكن لا يمكن حذفهم</li>
<li>يمكن تغيير اسم العضو</li>
<li>لا يمكن تغيير ترتيب الأعضاء</li>
<li>لا يمكن تغيير نوع العضو</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// الإضافة مسموحة.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? AddedProp { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// الحذف غير مسموح.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-comment">// public int Prop1 { get; set; }</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// تغيير الترتيب غير مسموح.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>في حالات الاستخدام، يكون تخزين البيانات القديمة (إلى ملف، إلى redis، إلخ...) وقراءتها إلى مخطط جديد دائمًا ممكنًا. في سيناريو RPC، يوجد المخطط على كل من جانب العميل والخادم، ويجب تحديث العميل قبل الخادم. لا يوجد مشكلة في اتصال عميل محدث بخادم قديم، لكن لا يمكن لعميل قديم الاتصال بخادم جديد.</p>
<p>افتراضيًا، عندما تُقرأ البيانات القديمة إلى مخطط جديد، يتم تهيئة أي أعضاء غير موجودين على جانب البيانات بقيمة <code>default</code>.<br>إذا كنت تريد تجنب ذلك واستخدام القيم الافتراضية للحقل/الخاصية، يمكنك استخدام <code>[SuppressDefaultInitialization]</code>.</p>
<pre><code class="language-cs hljs language-csharp">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DefaultValue</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">SuppressDefaultInitialization</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">111</span>; <span class="hljs-comment">// &lt; إذا كانت البيانات القديمة مفقودة، يتم تعيين `111`.</span>
    
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">222</span>; <span class="hljs-comment">// &lt; إذا كانت البيانات القديمة مفقودة، يتم تعيين `default`.</span>
}
</code></pre>
<p> <code>[SuppressDefaultInitialization]</code> لديها القيد التالي:</p>
<ul>
<li>لا يمكن استخدامها مع readonly أو init-only أو required.</li>
</ul>
<p>يعرض القسم التالي <a href="#serialization-info">معلومات التسلسل</a> كيفية التحقق من تغيرات المخطط، مثلاً عبر CI، لمنع الحوادث.</p>
<p>عند استخدام <code>GenerateType.VersionTolerant</code>، فهو يدعم التوافق الكامل مع الإصدارات.</p>
<ul>
<li>لا يمكن تغيير struct غير المدار بعد الآن</li>
<li>يجب أن يضاف لجميع الأعضاء <code>[MemoryPackOrder]</code> صراحةً (إلا إذا تم وضع الخاصية <code>SerializeLayout.Sequential</code>)</li>
<li>يمكن إضافة الأعضاء أو حذفهم لكن لا يمكن إعادة استخدام الترتيب (يمكن استخدام الترتيب المفقود)</li>
<li>يمكن تغيير اسم العضو</li>
<li>لا يمكن تغيير ترتيب الأعضاء</li>
<li>لا يمكن تغيير نوع العضو</li>
</ul>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// يمكن التسلسل/فك التسلسل بين </span>
<span class="hljs-comment">// VersionTolerantObject1 -&gt; VersionTolerantObject2 و </span>
<span class="hljs-comment">// VersionTolerantObject2 -&gt; VersionTolerantObject1</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject1</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject2</span>
{
```csharp
[<span class="hljs-meta">MemoryPackOrder(0)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// تم الحذف</span>
<span class="hljs-comment">//[MemoryPackOrder(1)]</span>
<span class="hljs-comment">//public long MyProperty1 { get; set; } = default;</span>

[<span class="hljs-meta">MemoryPackOrder(2)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// تم الإضافة</span>
[<span class="hljs-meta">MemoryPackOrder(3)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// إذا تم تعيين SerializeLayout.Sequential بشكل صريح، يسمح بالترتيب التلقائي.</span>
<span class="hljs-comment">// لكن لا يمكن حذف أي عضو لدعم تحمل الإصدارات.</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<p><code>GenerateType.VersionTolerant</code> أبطأ من <code>GenerateType.Object</code> في التسلسل. وأيضاً، سيكون حجم الحمولة أكبر قليلاً.</p>
<h2>معلومات التسلسل</h2>
<p>يمكنك التحقق من IntelliSense في النوع لمعرفة الأعضاء التي يتم تسلسلها. هناك خيار لكتابة هذه المعلومات إلى ملف أثناء وقت الترجمة. قم بتعيين <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> كما يلي.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- إخراج معلومات تسلسل memorypack إلى الدليل --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_SerializationInfoOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\MemoryPackLogs<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>المعلومات التالية تُكتب إلى الملف.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p>
<p>إذا كان النوع unmanaged، يتم عرض <code>unmanaged</code> قبل اسم النوع.</p>
<pre><code class="language-txt hljs language-plaintext">unmanaged FooStruct
---
int x
int y
</code></pre>
<p>من خلال فحص الفروقات في هذا الملف، يمكن منع تغييرات المخطط الخطرة. على سبيل المثال، قد ترغب في استخدام CI لاكتشاف القواعد التالية</p>
<ul>
<li>تعديل نوع unmanaged</li>
<li>تغيير ترتيب الأعضاء</li>
<li>حذف الأعضاء</li>
</ul>
<h2>المرجعية الدائرية</h2>
<p>يدعم MemoryPack أيضاً المرجعية الدائرية. هذا يسمح بتسلسل كائنات الشجرة كما هي.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// لتمكين المرجعية الدائرية، استخدم GenerateType.CircularReference</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> Node? Parent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Node[]? Children { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>على سبيل المثال، كود <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references">System.Text.Json preserve-references</a> سيصبح هكذا.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0</span>
Employee tyler = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Tyler Stein"</span>
};

Employee adrian = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Adrian King"</span>
};

tyler.DirectReports = <span class="hljs-keyword">new</span> List&lt;Employee&gt; { adrian };
adrian.Manager = tyler;

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize&lt;Employee&gt;(bin);

Console.WriteLine(tylerDeserialized?.DirectReports?[<span class="hljs-number">0</span>].Manager == tylerDeserialized); <span class="hljs-comment">// true</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Employee? Manager { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> List&lt;Employee&gt;? DirectReports { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>GenerateType.CircularReference</code> له نفس خصائص تحمل الإصدارات. ولكن، كقيد إضافي، يُسمح فقط بالمنشئين بدون معلمات. أيضاً، تتبع مراجع الكائنات يتم فقط للكائنات التي تم تعليمها بـ <code>GenerateType.CircularReference</code>. إذا كنت تريد تتبع أي كائن آخر، قم بتغليفه.</p>
<h2>المحول المخصص (CustomFormatter)</h2>
<p>إذا قمت بتنفيذ <code>MemoryPackCustomFormatterAttribute&lt;T&gt;</code> أو <code>MemoryPackCustomFormatterAttribute&lt;TFormatter, T&gt;</code> (أكثر كفاءة، لكن معقدة)، يمكنك تكوين استخدام محول مخصص لعضو في MemoryPackObject.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Attribute</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> IMemoryPackFormatter&lt;T&gt; <span class="hljs-title">GetFormatter</span>()</span>;
}
</code></pre>
<p>يوفر MemoryPack سمات التنسيق التالية: <code>Utf8StringFormatterAttribute</code>، <code>Utf16StringFormatterAttribute</code>، <code>InternStringFormatterAttribute</code>، <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute&lt;TValue&gt;</code>، <code>BitPackFormatterAttribute</code>، <code>BrotliFormatter</code>، <code>BrotliStringFormatter</code>، <code>BrotliFormatter&lt;T&gt;</code>، <code>MemoryPoolFormatter&lt;T&gt;</code>، <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// يتم تسلسل هذا العضو كسلسلة UTF16، وهو أسرع من UTF8 لكن في ASCII، الحجم يكون أكبر (لكن في غير ASCII، أحياناً أصغر).</span>
    [<span class="hljs-meta">Utf16StringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Text { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment">// عند فك التسلسل، تتم تهيئة Dictionary باستخدام StringComparer.OrdinalIgnoreCase.</span>
    [<span class="hljs-meta">OrdinalIgnoreCaseStringDictionaryFormatter&lt;int&gt;</span>]
    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;? Ids { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    
    <span class="hljs-comment">// عند فك التسلسل، جميع السلاسل تُحفظ في الذاكرة (انظر: String.Intern). إذا تكررت القيم المشابهة، يتم توفير الذاكرة.</span>
    [<span class="hljs-meta">InternStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Flag { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>لكي تقوم بتكوين مقارن التساوي للمجموعات/القواميس، جميع المحولات المدمجة لديها زيادة مُنشئ مع المقارن. يمكنك بسهولة إنشاء محولات مخصصة لمقارن التساوي.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OrdinalIgnoreCaseStringDictionaryFormatter</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>?&gt;&gt;
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt; formatter = <span class="hljs-keyword">new</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt;(StringComparer.OrdinalIgnoreCase);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> IMemoryPackFormatter&lt;Dictionary&lt;<span class="hljs-built_in">string</span>, TValue?&gt;&gt; GetFormatter()
    {
        <span class="hljs-keyword">return</span> formatter;
    }
}
</code></pre>
<p><code>BitPackFormatter</code> يضغط فقط أنواع <code>bool[]</code>. عادةً يتم تسلسل <code>bool[]</code> كبايت واحد لكل قيمة منطقية، ومع ذلك فإن <code>BitPackFormatter</code> يسلسل <code>bool[]</code> مثل <code>BitArray</code> حيث يتم تخزين كل قيمة منطقية كبت واحد. باستخدام <code>BitPackFormatter</code>، تتحول 8 قيم منطقية إلى بايت واحد حيث كانت ستكون 8 بايت، مما يؤدي إلى حجم أصغر بـ 8 مرات.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BitPackFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[]? Data { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter</code> مخصص لـ <code>byte[]</code>، على سبيل المثال يمكنك ضغط حمولة كبيرة باستخدام Brotli.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliStringFormatter</code> مخصص لـ <code>string</code>، يقوم بتسلسل السلسلة المضغوطة (UTF16) باستخدام Brotli.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? LargeText { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<pre><code class="hljs language-csharp">`BrotliFormatter&lt;T&gt;` مخصص لأي نوع، حيث يتم ضغط البيانات المسلسلة باستخدام Brotli. إذا كان النوع هو `<span class="hljs-built_in">byte</span>[]` أو `<span class="hljs-built_in">string</span>`، يجب عليك استخدام `BrotliFormatter` أو `BrotliStringFormatter` لتحقيق أفضل أداء.

```csharp
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter&lt;ChildType&gt;</span>]
    <span class="hljs-keyword">public</span> ChildType? Child { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>تجميع مصفوفة أثناء فك التسلسل</h2>
<p>من أجل فك تسلسل مصفوفة كبيرة (أي <code>T</code>)، يوفر MemoryPack عدة طرق فعالة للتجميع المؤقت (pooling). الطريقة الأكثر فعالية هي استخدام وظيفة <a href="#overwrite">#Overwrite</a>. وخاصةً، يتم دائمًا إعادة استخدام <code>List&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ListBytesSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">byte</span>&gt; Payload</span> { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// ----</span>

<span class="hljs-comment">// يتم إعادة استخدام List&lt;byte&gt;، ولا يوجد تخصيص جديد أثناء فك التسلسل.</span>
MemoryPackSerializer.Deserialize&lt;ListBytesSample&gt;(bin, <span class="hljs-keyword">ref</span> reuseObject);

<span class="hljs-comment">// للحصول على عمليات فعالة، يمكنك الحصول على Span&lt;T&gt; باستخدام CollectionsMarshal</span>
<span class="hljs-keyword">var</span> span = CollectionsMarshal.AsSpan(<span class="hljs-keyword">value</span>.Payload);
</code></pre>
<p>هناك طريقة مريحة وهي فك التسلسل إلى ArrayPool في وقت فك التسلسل. يوفر MemoryPack كل من <code>MemoryPoolFormatter&lt;T&gt;</code> و <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PoolModelSample</span> : <span class="hljs-title">IDisposable</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; }

    [<span class="hljs-meta">MemoryPoolFormatter&lt;byte&gt;</span>]
    <span class="hljs-keyword">public</span> Memory&lt;<span class="hljs-built_in">byte</span>&gt; Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PoolModelSample</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, Memory&lt;<span class="hljs-built_in">byte</span>&gt; payload</span>)</span>
    {
        Id = id;
        Payload = payload;
    }

    <span class="hljs-comment">// يجب عليك كتابة كود الإرجاع بنفسك، هنا مثال مقتطف.</span>

    <span class="hljs-built_in">bool</span> usePool;

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized</span>()</span>
    {
        usePool = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span>
    {
        <span class="hljs-keyword">if</span> (!usePool) <span class="hljs-keyword">return</span>;

        Return(Payload); Payload = <span class="hljs-literal">default</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Memory&lt;T&gt; memory</span>)</span> =&gt; Return((ReadOnlyMemory&lt;T&gt;)memory);

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlyMemory&lt;T&gt; memory</span>)</span>
    {
        <span class="hljs-keyword">if</span> (MemoryMarshal.TryGetArray(memory, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> segment) &amp;&amp; segment.Array <span class="hljs-keyword">is</span> { Length: &gt; <span class="hljs-number">0</span> })
        {
            ArrayPool&lt;T&gt;.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;());
        }
    }
}

<span class="hljs-comment">// ---</span>

<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;PoolModelSample&gt;(bin))
{
    <span class="hljs-comment">// تنفيذ أي عملية...</span>
}   <span class="hljs-comment">// الإرجاع إلى ArrayPool</span>
</code></pre>
<h2>الأداء</h2>
<p>راجع منشور مدونتي <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p>
<h2>حجم الحمولة والضغط</h2>
<p>يعتمد حجم الحمولة على القيمة المستهدفة؛ على عكس JSON، لا توجد مفاتيح وهو تنسيق ثنائي، لذلك من المحتمل أن يكون حجم الحمولة أصغر من JSON.</p>
<p>بالنسبة لأولئك الذين يستخدمون ترميز varint، مثل MessagePack و Protobuf، يميل حجم MemoryPack إلى أن يكون أكبر إذا تم استخدام الكثير من الأعداد الصحيحة (في MemoryPack، الأعداد الصحيحة دائمًا 4 بايت بسبب ترميز الحجم الثابت، بينما MessagePack من 1 إلى 5 بايت).</p>
<p>float و double هما 4 بايت و 8 بايت في MemoryPack، لكن 5 بايت و 9 بايت في MessagePack. لذلك، يكون MemoryPack أصغر، على سبيل المثال، لمصفوفات Vector3 (float, float, float).</p>
<p>السلسلة (String) تكون UTF8 افتراضيًا، وهو مشابه لمجمعات التسلسل الأخرى، ولكن إذا تم اختيار خيار UTF16، فسيكون الأمر ذا طبيعة مختلفة.</p>
<p>على أي حال، إذا كان حجم الحمولة كبيرًا، يجب التفكير في الضغط. يوصى باستخدام LZ4، ZStandard و Brotli.</p>
<h3>الضغط</h3>
<p>يوفر MemoryPack أداة مساعدة فعّالة لضغط <a href="https://github.com/google/brotli">Brotli</a> عبر <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder">BrotliEncoder</a> و <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder">BrotliDecoder</a>. يوفر كل من <code>BrotliCompressor</code> و <code>BrotliDecompressor</code> الخاصين بـ MemoryPack ضغط/فك ضغط مُحسّن لسلوك MemoryPack الداخلي.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// الضغط (يتطلب using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> compressor = <span class="hljs-keyword">new</span> BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, <span class="hljs-keyword">value</span>);

<span class="hljs-comment">// الحصول على مصفوفة byte[] مضغوطة</span>
<span class="hljs-keyword">var</span> compressedBytes = compressor.ToArray();

<span class="hljs-comment">// أو الكتابة إلى IBufferWriter&lt;byte&gt; آخر (مثال PipeWriter)</span>
compressor.CopyTo(response.BodyWriter);
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// فك الضغط (يتطلب using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> decompressor = <span class="hljs-keyword">new</span> BrotliDecompressor();

<span class="hljs-comment">// الحصول على ReadOnlySequence&lt;byte&gt; بعد فك الضغط من ReadOnlySpan&lt;byte&gt; أو ReadOnlySequence&lt;byte&gt;</span>
<span class="hljs-keyword">var</span> decompressedBuffer = decompressor.Decompress(buffer);

<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;T&gt;(decompressedBuffer);
</code></pre>
<p>كل من <code>BrotliCompressor</code> و <code>BrotliDecompressor</code> هما struct، ولا يقومان بتخصيص الذاكرة في الكومة (heap). كلاهما يخزن البيانات المضغوطة أو المفكوكة الضغط في تجميع ذاكرة داخلي لعمليات Serialize/Deserialize. لذلك، من الضروري تحرير ذاكرة التجميع، لا تنس استخدام <code>using</code>.</p>
<p>مستوى الضغط مهم جدًا. الافتراضي مضبوط على quality-1 (CompressionLevel.Fastest)، وهو يختلف عن الافتراضي في .NET (CompressionLevel.Optimal, quality-4).</p>
<p>Fastest (quality-1) سيكون قريبًا من سرعة <a href="https://github.com/lz4/lz4">LZ4</a>، لكن الجودة 4 أبطأ بكثير. تم اعتبار ذلك أمرًا حرجًا في سيناريو استخدام المجمع التسلسلي. كن حذرًا عند استخدام <code>BrotliStream</code> القياسي (quality-4 هو الافتراضي). على أي حال، سرعات الضغط/فك الضغط والأحجام ستنتج نتائج مختلفة جدًا مع أنواع البيانات المختلفة. يرجى تحضير البيانات التي ستتعامل معها تطبيقك واختبارها بنفسك.</p>
<p>لاحظ أن هناك عقوبة سرعة كبيرة بين MemoryPack غير المضغوط وضغط Brotli المضاف.</p>
<p>Brotli مدعوم أيضًا في formatter مخصص. يمكن لـ <code>BrotliFormatter</code> ضغط عضو معين.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>تسلسل الأنواع الخارجية</h2>
<p>إذا كنت ترغب في تسلسل أنواع خارجية، يمكنك إنشاء formatter مخصص وتسجيله في provider، راجع <a href="#formatterprovider-api">Formatter/Provider API</a> للمزيد من التفاصيل. ومع ذلك، فإن إنشاء formatter مخصص أمر صعب. لذلك نوصي بإنشاء نوع wrapper. على سبيل المثال، إذا كنت ترغب في تسلسل نوع خارجي يُسمى <code>AnimationCurve</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">struct</span> SerializableAnimationCurve
{
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimationCurve AnimationCurve;

    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode preWrapMode =&gt; AnimationCurve.preWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode postWrapMode =&gt; AnimationCurve.postWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    Keyframe[] keys =&gt; AnimationCurve.keys;

    [<span class="hljs-meta">MemoryPackConstructor</span>]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        <span class="hljs-keyword">var</span> curve = <span class="hljs-keyword">new</span> AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        <span class="hljs-keyword">this</span>.AnimationCurve = curve;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SerializableAnimationCurve</span>(<span class="hljs-params">AnimationCurve animationCurve</span>)</span>
    {
        <span class="hljs-keyword">this</span>.AnimationCurve = animationCurve;
    }
}
</code></pre>
<p>النوع الذي يتم تغليفه (wrap) هو عام (public)، ولكن تم استثناؤه من التسلسل (<code>MemoryPackIgnore</code>). أما الخصائص التي تريد تسلسلها فهي خاصة (private)، لكن تم تضمينها (<code>MemoryPackInclude</code>). يجب أيضًا تجهيز نمطين من المنشئين (constructors). يجب أن يكون المنشئ الذي يستخدمه المجمع التسلسلي خاصًا (private).</p>
<p>كما هو، يجب تغليفه في كل مرة، وهذا غير مريح. وأيضًا غلاف struct لا يمكنه تمثيل null. لذا دعنا ننشئ formatter مخصص.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimationCurveFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">AnimationCurve</span>&gt;
{
    <span class="hljs-comment">// Unity لا تدعم scoped و TBufferWriter لذا غيّر التوقيع إلى `Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)`</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
```csharp
{
    writer.WriteNullObjectHeader();
    <span class="hljs-keyword">return</span>;
}

writer.WritePackable(<span class="hljs-keyword">new</span> SerializableAnimationCurve(<span class="hljs-keyword">value</span>));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (reader.PeekIsNull())
    {
        reader.Advance(<span class="hljs-number">1</span>); <span class="hljs-comment">// skip null block</span>
        <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">var</span> wrapped = reader.ReadPackable&lt;SerializableAnimationCurve&gt;();
    <span class="hljs-keyword">value</span> = wrapped.AnimationCurve;
}
</code></pre>
<p>أخيرًا، قم بتسجيل المهيئ في بدء التشغيل.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register&lt;AnimationCurve&gt;(<span class="hljs-keyword">new</span> AnimationCurveFormatter());
</code></pre>
<blockquote>
<p>ملاحظة: يمكن تسلسل AnimationCurve الخاصة بـ Unity افتراضيًا، لذلك لا تحتاج إلى هذا المهيئ المخصص لـ AnimationCurve</p>
</blockquote>
<h2>الحزم</h2>
<p>يمتلك MemoryPack الحزم التالية.</p>
<ul>
<li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li>
</ul>
<p>الحزمة <code>MemoryPack</code> هي المكتبة الرئيسية، توفر دعمًا كاملاً للتسلسل وإلغاء التسلسل عالي الأداء للكائنات الثنائية. تعتمد على <code>MemoryPack.Core</code> لمكتبات الأساسيات و <code>MemoryPack.Generator</code> لتوليد الشيفرة. تضيف <code>MemoryPack.Streaming</code> توسعات إضافية لـ <a href="#streaming-serialization">التسلسل المتدفق</a>. تضيف <code>MemoryPack.AspNetCoreMvcFormatter</code> مهيئات إدخال/إخراج لـ ASP.NET Core. تضيف <code>MemoryPack.UnityShims</code> أنواع وملحقات Unity للمشاركة بين .NET و Unity.</p>
<h2>TypeScript ومهيئ ASP.NET Core</h2>
<p>يدعم MemoryPack توليد الشيفرة لـ TypeScript. يقوم بتوليد الأصناف وشيفرة التسلسل من C#، بمعنى آخر، يمكنك مشاركة الأنواع مع المتصفح بدون استخدام OpenAPI أو proto أو ما شابه.</p>
<p>توليد الشيفرة مدمج مع الـ Source Generator، الخيارات التالية (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) تحدد دليل إخراج شيفرة TypeScript. يتم إخراج شيفرة وقت التشغيل في نفس الوقت، لذلك لا توجد تبعيات إضافية مطلوبة.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- إخراج شيفرة TypeScript الخاصة بـ memorypack إلى الدليل --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>يجب أن يكون نوع MemoryPackable في C# مشروحًا بـ <code>[GenerateTypeScript]</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">GenerateTypeScript</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> required Guid Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> FirstName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> LastName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required DateTime DateOfBirth { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required Gender Gender { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span>[] Emails { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Gender
{
    Male, Female, Other
}
</code></pre>
<p>سيتم توليد شيفرة وقت التشغيل ونوع TypeScript في الدليل المستهدف.</p>
<p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p>
<p>الشيفرة المولدة كما يلي، مع حقول بسيطة ودوال ساكنة لـ serialize/serializeArray و deserialize/deserializeArray.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackWriter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackWriter.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackReader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackReader.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Gender</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./Gender.js"</span>; 

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">dateOfBirth</span>: <span class="hljs-title class_">Date</span>;
    <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>;
    <span class="hljs-attr">emails</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArray</span>(<span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArrayCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArray</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArrayCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }
}
</code></pre>
<p>يمكنك استخدام هذا النوع كما يلي.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
person.<span class="hljs-property">id</span> = crypto.<span class="hljs-title function_">randomUUID</span>();
person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;
person.<span class="hljs-property">firstName</span> = <span class="hljs-string">"foo"</span>;
person.<span class="hljs-property">lastName</span> = <span class="hljs-string">"bar"</span>;
person.<span class="hljs-property">dateOfBirth</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1999</span>, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
person.<span class="hljs-property">gender</span> = <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Other</span>;
person.<span class="hljs-property">emails</span> = [<span class="hljs-string">"foo@bar.com"</span>, <span class="hljs-string">"zoo@bar.net"</span>];

<span class="hljs-comment">// تسلسل إلى Uint8Array</span>
<span class="hljs-keyword">let</span> bin = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">serialize</span>(person);

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([bin.<span class="hljs-property">buffer</span>], { <span class="hljs-attr">type</span>: <span class="hljs-string">"application/x-memorypack"</span> })

<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"http://localhost:5260/api"</span>,
    { <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>, <span class="hljs-attr">body</span>: blob, <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/x-memorypack"</span> } });

<span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();

<span class="hljs-comment">// إلغاء التسلسل من ArrayBuffer </span>
<span class="hljs-keyword">let</span> person2 = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">deserialize</span>(buffer);
</code></pre>
<p>تضيف حزمة <code>MemoryPack.AspNetCoreMvcFormatter</code> مهيئات إدخال وإخراج MemoryPack لـ ASP.NET Core MVC. يمكنك إضافة <code>MemoryPackInputFormatter</code> و <code>MemoryPackOutputFormatter</code> إلى ASP.NET Core MVC بالشيفرة التالية.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackInputFormatter());
    <span class="hljs-comment">// إذا كان checkContentType: true يمكن حينها إخراج عدة تنسيقات (JSON/MemoryPack، إلخ...). القيمة الافتراضية هي false.</span>
    options.OutputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackOutputFormatter(checkContentType: <span class="hljs-literal">false</span>));
});
</code></pre>
<p>إذا قمت بالاتصال من HttpClient، يمكنك تعيين <code>application/x-memorypack</code> في ترويسة المحتوى.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> content = <span class="hljs-keyword">new</span> ByteArrayContent(bin)
content.Headers.ContentType = <span class="hljs-keyword">new</span> MediaTypeHeaderValue(<span class="hljs-string">"application/x-memorypack"</span>);
</code></pre>
<h3>تطابق أنواع TypeScript</h3>
<p>هناك بعض القيود على الأنواع التي يمكن توليدها. من بين الأنواع البدائية، لا يتم دعم <code>char</code> و <code>decimal</code>. كما لا يمكن استخدام النوع OpenGenerics.</p>
<table>
<thead>
<tr>
<th>C#</th>
<th>TypeScript</th>
<th>الوصف</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>sbyte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>bigint</code></td>
<td></td>
</tr>
</tbody></table>
<pre><code class="hljs language-xml">| `ulong` |  `bigint` |
| `float` |  `number` |
| `double` |  `number` |
| `string` |  `string \| null`  | 
| `Guid` |  `string`  | في TypeScript، يمثّل كسلسلة نصية لكن يُسلسل/يُفك تسلسلها كثنائية 16 بايت
| `DateTime` | `Date` | سيتم تجاهل DateTimeKind
| `enum` | `const enum` | نوع الأساس `long` و `ulong` غير مدعوم
| `T?` | `T \| null` |
| `T[]` | `T[] \| null` |
| `byte[]` | `Uint8Array \| null` |
| `: ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `T[] \| null` | يدعم جميع الأنواع التي تطبق `ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` مثل `List<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`
| `: ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `Set<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> \| null` | يدعم جميع الأنواع التي تطبق `ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` مثل `HashSet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`
| `: IDictionary&lt;K,V&gt;` | `Map&lt;K, V&gt; \| null` | يدعم جميع الأنواع التي تطبق `IDictionary&lt;K,V&gt;` مثل `Dictionary&lt;K,V&gt;`.
| `[MemoryPackable]` | `class` | يدعم الأصناف فقط
| `[MemoryPackUnion]` | `abstract class` |

يمكن تطبيق `[GenerateTypeScript]` على الأصناف فقط، وغير مدعوم حاليًا للهياكل (struct).

### ضبط امتداد ملف الاستيراد وحالة أسماء الأعضاء

بشكل افتراضي، يقوم MemoryPack بتوليد امتداد الملف كـ `.js` مثل `import { MemoryPackWriter } from "./MemoryPackWriter.js";`. إذا أردت تغييره إلى امتداد آخر أو تركه فارغًا، استخدم الخاصية `MemoryPackGenerator_TypeScriptImportExtension` لضبط ذلك.
أيضًا، يتم تحويل اسم العضو تلقائيًا إلى صيغة camelCase. إذا أردت استخدام الاسم الأصلي، اضبط الخاصية `MemoryPackGenerator_TypeScriptConvertPropertyName` إلى `false`.

```xml
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptImportExtension"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptConvertPropertyName"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptEnableNullableTypes"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- يسمح بتركها فارغة --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- الافتراضي هو true --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- الافتراضي هو false --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>تسمح الخاصية <code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> بأن تنعكس تعليقات Nullable في C# على كود TypeScript. الافتراضي هو false، مما يجعل كل شيء قابلًا للإهمال (nullable).</p>
<h2>تسلسل البث (Streaming Serialization)</h2>
<p>يوفر <code>MemoryPack.Streaming</code> الفئة <code>MemoryPackStreamingSerializer</code>، والتي تضيف دعمًا إضافيًا لتسلسل وفك تسلسل المجموعات باستخدام التدفقات (streams).</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackStreamingSerializer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeWriter pipeWriter, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeReader pipeReader, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, [EnumeratorCancellation] CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
}
</span></code></pre>
<h2>واجهة برمجة تطبيقات Formatter/Provider</h2>
<p>إذا كنت تريد تنفيذ Formatter يدويًا، قم بوراثة <code>MemoryPackFormatter&lt;T&gt;</code> وأعد تعريف طريقتي <code>Serialize</code> و <code>Deserialize</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SkeltonFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">Skelton</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
        {
            writer.WriteNullObjectHeader();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// استخدم طريقة writer.</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (!reader.TryReadObjectHeader(<span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> count))
        {
            <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// استخدم طريقة reader.</span>
    }
}
</code></pre>
<p>يتم تسجيل الـ Formatter الذي تم إنشاؤه باستخدام <code>MemoryPackFormatterProvider</code>.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register(<span class="hljs-keyword">new</span> SkeltonFormatter());
</code></pre>
<p>ملاحظة: لا يمكن استخدام Formatter مخصص مع <code>unmanged struct</code> (الذي لا يحتوي على أنواع مرجعية)، حيث يتم دومًا تسلسل تخطيط الذاكرة الأصلي.</p>
<h2>MemoryPackWriter/ReaderOptionalState</h2>
<p>تهيئة <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> تتطلب OptionalState. وهو غلاف لـ <code>MemoryPackSerializerOptions</code>، ويمكن إنشاؤه من <code>MemoryPackWriterOptionalStatePool</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// عند التخلص، سيتم إعادة OptionalState إلى التجمع.</span>
<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> writer = <span class="hljs-keyword">new</span> MemoryPackWriter&lt;T&gt;(<span class="hljs-keyword">ref</span> t, state);
}

<span class="hljs-comment">// للقراءة</span>
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> MemoryPackReader(buffer, state);
}
</code></pre>
<h2>الاعتمادية على إطار العمل المستهدف</h2>
<p>يوفر MemoryPack كلاً من <code>netstandard2.1</code> و <code>net7.0</code> لكن كلاهما غير متوافقين مع بعضهما. على سبيل المثال، إذا كانت الأنواع MemoryPackable ضمن مشروع <code>netstandard2.1</code> وتستخدمها من مشروع <code>net7.0</code>، سيتم رمي استثناء وقت التشغيل مثل:</p>
<blockquote>
<p>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</p>
</blockquote>
<p>نظرًا لأن net7.0 يستخدم أعضاء ثابتة مجردة (<code>Virtual static method</code>)، التي لا يدعمها netstandard2.1، فهذا السلوك هو ضمن المواصفات.</p>
<p>يجب ألا يستخدم مشروع .NET 7 مكتبة netstandard 2.1 dll. بمعنى آخر، إذا كان التطبيق هو مشروع .NET 7، يجب أن تدعم جميع الاعتمادات التي تستخدم MemoryPack .NET 7. إذا كان مطور مكتبة لديه اعتماد على MemoryPack، يجب عليه ضبط إطار عمل مزدوج.</p>
<pre><code class="language-xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">TargetFrameworks</span>&gt;</span>netstandard2.1;net7.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFrameworks</span>&gt;</span>
</code></pre>
<h2>RPC</h2>
<p><a href="https://github.com/Cysharp/MagicOnion">Cysharp/MagicOnion</a> هو إطار عمل grpc-dotnet يعتمد على الكود أولًا ويستخدم MessagePack بدلًا من protobuf. يدعم MagicOnion الآن MemoryPack كطبقة تسلسل عبر الحزمة <code>MagicOnion.Serialization.MemoryPack</code> (نسخة تجريبية). لمزيد من التفاصيل: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support">MagicOnion#MemoryPack support</a></p>
<h2>Unity</h2>
<p>أقل إصدار Unity مدعوم هو <code>2022.3.12f1</code>.</p>
<p>حزمة MemoryPack الأساسية متوفرة عبر nuget. وهي متوفرة أيضًا في Unity. إذا كنت تريد دعم أنواع Unity المدمجة، نوفر إضافة MemoryPack.Unity.</p>
<ol>
<li>قم بتثبيت <code>MemoryPack</code> من NuGet باستخدام <a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a></li>
</ol>
<ul>
<li><p>افتح نافذة NuGet -&gt; إدارة حزم NuGet، وابحث عن "MemoryPack" واضغط على تثبيت.<br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p>
</li>
<li><p>إذا واجهت خطأ تعارض الإصدارات، يرجى تعطيل التحقق من الإصدار في إعدادات المشغل (Edit -&gt; Project Settings -&gt; Player -&gt; مرر للأسفل وافتح "Other Settings" ثم ألغِ تحديد "Assembly Version Validation" تحت قسم "Configuration").</p>
</li>
</ul>
<ol start="2">
<li>قم بتثبيت الحزمة <code>MemoryPack.Unity</code> عن طريق الإشارة إلى عنوان git</li>
</ol>
<ul>
<li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code><br><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot"><br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></li>
</ul>
<p>يستخدم MemoryPack علامة إصدار <em>.</em>.*، لذا يمكنك تحديد إصدار مثل #1.0.0. على سبيل المثال: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p>
<p>كما هو الحال مع إصدار .NET، يتم توليد الكود بواسطة مولد الكود (<code>MemoryPack.Generator.dll</code>). كما يوفر التنفيذ الخالي من الانعكاس أفضل أداء في IL2CPP.</p>
<p>لمزيد من المعلومات حول Unity وSource Generator، يرجى الرجوع إلى <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">توثيق Unity</a>.</p>
<p>يتم استخدام Source Generator رسميًا أيضًا من قبل Unity عبر <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">com.unity.properties</a> و<a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html">com.unity.entities</a>. بمعنى آخر، إنه المعيار لتوليد الكود في الجيل القادم من Unity.</p>
<p>يمكنك تسلسل جميع الأنواع غير المدارة (مثل <code>Vector3</code>، <code>Rect</code>، إلخ...) وبعض الأصناف (<code>AnimationCurve</code>، <code>Gradient</code>، <code>RectOffset</code>). إذا أردت تسلسل أنواع Unity-specific أخرى، راجع قسم <a href="#serialize-external-types">تسلسل الأنواع الخارجية</a>.</p>
<p>في الأداء على Unity، MemoryPack أسرع من JsonUtility بمعدل x3~x10.</p>
<p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p>
<p>إذا كان الكود المشترك يحتوي على أنواع Unity (<code>Vector2</code>، إلخ...)، يوفر MemoryPack حزمة <code>MemoryPack.UnityShims</code> على NuGet.</p>
<p>توفر حزمة <code>MemoryPack.UnityShims</code> شيمز للهياكل القياسية في Unity (<code>Vector2</code>، <code>Vector3</code>، <code>Vector4</code>، <code>Quaternion</code>، <code>Color</code>، <code>Bounds</code>، <code>Rect</code>، <code>Keyframe</code>، <code>WrapMode</code>، <code>Matrix4x4</code>، <code>GradientColorKey</code>، <code>GradientAlphaKey</code>، <code>GradientMode</code>، <code>Color32</code>، <code>LayerMask</code>، <code>Vector2Int</code>، <code>Vector3Int</code>، <code>RangeInt</code>، <code>RectInt</code>، <code>BoundsInt</code>) وبعض الأصناف (<code>AnimationCurve</code>، <code>Gradient</code>، <code>RectOffset</code>).</p>
<blockquote>
<p>[!تحذير]<br>حاليًا، هناك القيود التالية للاستخدام في Unity</p>
</blockquote>
<ol>
<li>إصدار Unity لا يدعم CustomFormatter.</li>
<li>إذا كنت تستخدم .NET7 أو أحدث، فإن تنسيق MemoryPack الثنائي غير متوافق بالكامل مع Unity.<ul>
<li>تحدث هذه المشكلة مع الأنواع القيمية التي تم تحديد <code>[StructLayout(LayoutKind.Auto)]</code> لها صراحة. (الإفتراضي للهيكل هو <code>LayoutKind.Sequencil</code>). لهذه الأنواع، لا يمكن فك تسلسل الثنائي الذي تم تسلسله في .NET في Unity. وبالمثل، لا يمكن تسلسل الثنائي الذي تم تسلسله في Unity في جانب .NET.</li>
<li>الأنواع المتأثرة تشمل عادةً الأنواع التالية:<ul>
<li><code>DateTimeOffset</code></li>
<li><code>ValueTuple</code></li>
</ul>
</li>
<li>الحل البسيط حاليًا هو عدم استخدام هذه الأنواع.</li>
</ul>
</li>
</ol>
<h2>Native AOT</h2>
<p>للأسف، .NET 7 Native AOT يسبب تعطل (<code>Generic virtual method pointer lookup failure</code>) عند استخدام MemoryPack بسبب خطأ في وقت التشغيل.<br>سيتم إصلاحه في .NET 8. باستخدام نسخة المعاينة من <code>Microsoft.DotNet.ILCompiler</code>، سيتم إصلاحه في .NET 7. يرجى مراجعة <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611">تعليق المشكلة</a> لمعرفة كيفية الإعداد.</p>
<h2>مواصفات تنسيق السلك الثنائي (Binary wire format specification)</h2>
<p>نوع <code>T</code> المعرّف في <code>Serialize&lt;T&gt;</code> و <code>Deserialize&lt;T&gt;</code> يسمى مخطط C#. تنسيق MemoryPack ليس تنسيقًا معرّفًا ذاتيًا. فك التسلسل يتطلب مخطط C# المقابل. هذه الأنواع موجودة كممثلات داخلية للثنائي، لكن لا يمكن تحديد الأنواع بدون مخطط C#.</p>
<p>يجب أن يكون Endian هو <code>Little Endian</code>. مع ذلك، تنفيذ C# المرجعي لا يهتم بالـ endianness لذلك لا يمكن استخدامه على أجهزة big-endian. ومع ذلك، الحواسيب الحديثة عادةً ما تكون little-endian.</p>
<p>هناك ثمانية أنواع من التنسيق.</p>
<ul>
<li>هيكل غير مُدار (Unmanaged struct)</li>
<li>كائن (Object)</li>
<li>كائن متحمل للإصدارات (Version Tolerant Object)</li>
<li>كائن المرجع الدائري</li>
<li>Tuple</li>
<li>المجموعة (Collection)</li>
<li>السلسلة النصية (String)</li>
<li>الاتحاد (Union)</li>
</ul>
<h3>الهيكل غير المُدار (Unmanaged struct)</h3>
<p>الهيكل غير المُدار هو هيكل (struct) في C# لا يحتوي على أنواع مرجعية، وهو مشابه للقيود الموجودة في <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">أنواع C# غير المُدارة</a>. يتم تسلسل تخطيط الهيكل كما هو، بما في ذلك الحشو.</p>
<h3>الكائن (Object)</h3>
<p><code>(byte memberCount, [values...])</code></p>
<p>الكائن يحتوي على بايت واحد غير موقّع كعدد الأعضاء في الترويسة. عدد الأعضاء يسمح بالقيم من <code>0</code> إلى <code>249</code>، ويمثل <code>255</code> أن الكائن هو <code>null</code>. القيم تخزن قيمة memorypack بعدد الأعضاء.</p>
<h3>كائن متسامح مع الإصدارات (Version Tolerant Object)</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], [values...])</code></p>
<p>الكائن المتسامح مع الإصدارات مشابه للكائن العادي ولكن يحتوي على طول القيم بالبايت في الترويسة. varint يتبع هذه المواصفات: أول sbyte هو القيمة أو typeCode، والبايتات التالية هي القيمة. من 0 إلى 127 = قيمة بايت غير موقّع، من -1 إلى -120 = قيمة بايت موقّع، -121 = بايت، -122 = sbyte، -123 = ushort، -124 = short، -125 = uint، -126 = int، -127 = ulong، -128 = long.</p>
<h3>كائن المرجع الدائري (Circular Reference Object)</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])</code><br><code>(250, varint referenceId)</code></p>
<p>كائن المرجع الدائري مشابه لكائن متسامح مع الإصدارات، ولكن إذا كان memberCount يساوي 250، فإن varint (unsigned-int32) التالي هو referenceId. إذا لم يكن كذلك، بعد byte-length-of-values، تتم كتابة varint referenceId.</p>
<h3>Tuple</h3>
<p><code>(values...)</code></p>
<p>الـ Tuple هو مجموعة ذات حجم ثابت وغير قابلة لأن تكون null من القيم. في .NET، يتم تسلسل كل من <code>KeyValuePair&lt;TKey, TValue&gt;</code> و<code>ValueTuple&lt;T,...&gt;</code> كـ Tuple.</p>
<h3>المجموعة (Collection)</h3>
<p><code>(int length, [values...])</code></p>
<p>المجموعة تحتوي على عدد صحيح موقّع من 4 بايت كعدد البيانات في الترويسة، ويمثل <code>-1</code> قيمة <code>null</code>. القيم تخزن قيمة memorypack بعدد الطول.</p>
<h3>السلسلة النصية (String)</h3>
<p><code>(int utf16-length, utf16-value)</code><br><code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)</code></p>
<p>السلسلة النصية لها شكلان: UTF16 وUTF8. إذا كان أول عدد صحيح موقّع من 4 بايت هو <code>-1</code>، فهذا يعني أنها null. وإذا كان <code>0</code>، فهذا يعني أنها فارغة. UTF16 مماثلة للمجموعة (تسلسل كـ <code>ReadOnlySpan&lt;char&gt;</code>، وعدد بايتات utf16-value هو utf16-length * 2). إذا كان العدد الصحيح الأول &lt;= <code>-2</code>، يتم ترميز القيمة بـ UTF8. يتم ترميز utf8-byte-count بطريقة متممة، استخدم <code>~utf8-byte-count</code> لاسترداد عدد البايتات. العدد الصحيح التالي هو utf16-length، ويسمح بأن يكون <code>-1</code> ليمثل طول غير معروف. utf8-bytes تخزن البايتات بعدد utf8-byte-count.</p>
<h3>الاتحاد (Union)</h3>
<p><code>(byte tag, value)</code><br><code>(250, ushort tag, value)</code></p>
<p>أول بايت غير موقّع هو tag الذي يُستخدم لتمييز نوع القيمة أو العلم، من <code>0</code> إلى <code>249</code> تمثل tag، و<code>250</code> تعني أن الـ unsigned short التالي هو tag، و<code>255</code> تعني أن الاتحاد هو <code>null</code>.</p>
<h2>الترخيص (License)</h2>
<p>هذه المكتبة مرخصة بموجب رخصة MIT.</p>
<hr>
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-09</p>
<hr>
</div>
    </div>

    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async=""></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
    <script src="view.js"></script>


</body></html>