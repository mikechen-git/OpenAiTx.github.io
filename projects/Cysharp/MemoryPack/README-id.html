<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Open AI Tx</title>

    <!-- Primary Meta Tags -->
    <meta name="title" content="Open AI Tx - Markdown Viewer">
    <meta name="description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta name="keywords" content="Open AI Tx, Markdown, GitHub Style, Documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/view.html">
    <meta property="og:title" content="Open AI Tx - Markdown Viewer">
    <meta property="og:description" content="GitHub style markdown viewer for Open AI Tx projects">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">

    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="icon.jpg">
    <link rel="apple-touch-icon" href="icon.jpg">

    <!-- Marked.js for Markdown rendering -->
    <script type="text/javascript" async="" src="https://www.statcounter.com/counter/recorder.js"></script><script src="js/marked.min.js"></script>
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="css/github.min.css">
    <script src="js/highlight.min.js"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="view.css">
    <style>
        /* Layout */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .main-container {
            margin: 0 auto;
            width: 100%;
            max-width: 980px;
            padding: 0 20px;
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0 15px;
            }
        }

        /* Image size restrictions */
        .markdown-body img {
            max-width: 100%;
            height: auto;
        }

        /* Existing styles */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f6f8fa;
            border-bottom: 1px solid #e1e4e8;
            position: relative;
        }

        .back-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #0366d6;
            text-decoration: none;
            display: flex;
            align-items: center;
            font-size: 14px;
            padding: 5px 10px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #fff;
        }

        .back-button:hover {
            background-color: #f6f8fa;
            border-color: #0366d6;
        }

        .back-button::before {
            content: "←";
            margin-right: 5px;
            font-size: 16px;
        }

        .header .links {
            margin-top: 10px;
            font-size: 16px;
        }

        .header .links a {
            color: #0366d6;
            text-decoration: none;
            margin-left: 5px;
        }

        .header .links a:hover {
            text-decoration: underline;
        }
        
        /* Language badges styles */
        .language-badges {
            margin-top: 15px;
            text-align: center;
        }
        .language-badges a {
            display: inline-block;
            margin: 2px;
            text-decoration: none;
        }
        .language-badges img {
            height: 20px;
            border-radius: 3px;
        }
        .language-badges a:hover img {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div class="header">
        <a href="javascript:history.back()" class="back-button">Back</a>
        <div class="links">
            GitHub Repository: <a href="https://github.com/Cysharp/MemoryPack" id="githubRepoLink" target="_blank">Cysharp/MemoryPack</a>
        </div>
        <div class="language-badges" id="languageBadges"><a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=en"><img src="https://img.shields.io/badge/EN-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-CN"><img src="https://img.shields.io/badge/简中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-TW"><img src="https://img.shields.io/badge/繁中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ja"><img src="https://img.shields.io/badge/日本語-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ko"><img src="https://img.shields.io/badge/한국어-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=th"><img src="https://img.shields.io/badge/ไทย-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=fr"><img src="https://img.shields.io/badge/Français-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=de"><img src="https://img.shields.io/badge/Deutsch-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=es"><img src="https://img.shields.io/badge/Español-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=it"><img src="https://img.shields.io/badge/Italiano-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ru"><img src="https://img.shields.io/badge/Русский-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pt"><img src="https://img.shields.io/badge/Português-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=nl"><img src="https://img.shields.io/badge/Nederlands-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pl"><img src="https://img.shields.io/badge/Polski-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ar"><img src="https://img.shields.io/badge/العربية-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=tr"><img src="https://img.shields.io/badge/Türkçe-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=vi"><img src="https://img.shields.io/badge/Tiếng Việt-white" alt="version"></a></div>
    </div>

    <div class="main-container">
        <div class="markdown-body" id="content"><h1>MemoryPack</h1>
<p><a href="https://www.nuget.org/packages/MemoryPack"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a><br><a href="https://github.com/Cysharp/MemoryPack/actions"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a><br><a href="https://github.com/Cysharp/MemoryPack/releases"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p>
<p>Serializer biner dengan performa ekstrim dan zero encoding untuk C# dan Unity.</p>
<p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p>
<blockquote>
<p>Dibandingkan dengan <a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/">Orleans.Serialization</a>. Diukur menggunakan mesin .NET 7 / Ryzen 9 5950X. Serializer-serializer ini memiliki metode <code>IBufferWriter&lt;byte&gt;</code>, diserialisasi menggunakan <code>ArrayBufferWriter&lt;byte&gt;</code> dan digunakan ulang untuk menghindari pengukuran copy buffer.</p>
</blockquote>
<p>Untuk objek standar, MemoryPack sekitar 10x lebih cepat dan 2 ~ 5x lebih cepat dari serializer biner lainnya. Untuk array struct, MemoryPack bahkan lebih unggul, dengan kecepatan hingga 50 ~ 200x lebih cepat dibanding serializer lain.</p>
<p>MemoryPack adalah serializer ke-4 yang saya buat, sebelumnya saya telah membuat serializer yang cukup dikenal, <del><a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a></del>, <del><a href="https://github.com/neuecc/Utf8Json">Utf8Json</a></del>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>. Alasan kecepatan MemoryPack adalah karena format binernya yang spesifik untuk C#, dioptimalkan untuk C#, serta implementasi yang telah disetel berdasarkan pengalaman saya sebelumnya. Ini juga merupakan desain baru yang memanfaatkan .NET 7 dan C# 11 serta Incremental Source Generator (Juga mendukung .NET Standard 2.1 (.NET 5, 6) dan Unity).</p>
<p>Serializer lain melakukan banyak operasi encoding seperti VarInt encoding, tag, string, dll. Format MemoryPack menggunakan desain zero-encoding yang menyalin memori C# sebanyak mungkin. Zero-encoding mirip dengan FlatBuffers, tetapi tidak memerlukan tipe khusus, target serialisasi MemoryPack adalah POCO.</p>
<p>Selain performa, MemoryPack memiliki fitur-fitur berikut:</p>
<ul>
<li>Mendukung API I/O modern (<code>IBufferWriter&lt;byte&gt;</code>, <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>)</li>
<li>Native AOT friendly code generation berbasis Source Generator, tanpa Dynamic CodeGen (IL.Emit)</li>
<li>API non-generic tanpa refleksi</li>
<li>Deserialisasi ke instance yang sudah ada</li>
<li>Serialisasi polimorfisme (Union)</li>
<li>Dukungan version-tolerant terbatas (cepat/default) dan version-tolerant penuh</li>
<li>Serialisasi circular reference</li>
<li>Serialisasi streaming berbasis PipeWriter/Reader</li>
<li>Code generation TypeScript dan ASP.NET Core Formatter</li>
<li>Dukungan Unity (2021.3) IL2CPP melalui .NET Source Generator</li>
</ul>
<h2>Instalasi</h2>
<p>Library ini didistribusikan melalui NuGet. Untuk performa terbaik, disarankan menggunakan <code>.NET 7</code>. Persyaratan minimum adalah <code>.NET Standard 2.1</code>.</p>
<blockquote>
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/MemoryPack">MemoryPack</a></p>
</blockquote>
<p>Editor kode juga membutuhkan dukungan Roslyn 4.3.1, misalnya Visual Studio 2022 versi 17.3, .NET SDK 6.0.401. Untuk detailnya, lihat dokumen <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support">Roslyn Version Support</a>.</p>
<p>Untuk Unity, persyaratan dan proses instalasinya berbeda sepenuhnya. Lihat bagian <a href="#unity">Unity</a> untuk detailnya.</p>
<h2>Quick Start</h2>
<p>Definisikan sebuah struct atau class yang akan diserialisasikan dan anotasi dengan atribut <code>[MemoryPackable]</code> serta gunakan keyword <code>partial</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack;

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Kode serialisasi dihasilkan oleh fitur source generator C# yang mengimplementasikan interface <code>IMemoryPackable&lt;T&gt;</code>. Di Visual Studio Anda dapat memeriksa kode yang dihasilkan dengan shortcut <code>Ctrl+K, R</code> pada nama kelas dan pilih <code>*.MemoryPackFormatter.g.cs</code>.</p>
<p>Panggil <code>MemoryPackSerializer.Serialize&lt;T&gt;/Deserialize&lt;T&gt;</code> untuk serialisasi/deserialisasi instance objek.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Person { Age = <span class="hljs-number">40</span>, Name = <span class="hljs-string">"John"</span> };

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(v);
<span class="hljs-keyword">var</span> val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p>Metode <code>Serialize</code> mendukung tipe return <code>byte[]</code> serta dapat melakukan serialisasi ke <code>IBufferWriter&lt;byte&gt;</code> atau <code>Stream</code>. Metode <code>Deserialize</code> mendukung <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code> dan <code>Stream</code>. Tersedia juga versi non-generic.</p>
<h2>Tipe yang didukung secara bawaan</h2>
<p>Tipe-tipe berikut dapat diserialisasikan secara default:</p>
<ul>
<li>Primitive .NET (<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code>, dll.)</li>
<li>Tipe unmanaged (Semua <code>enum</code>, struct buatan pengguna yang tidak mengandung tipe referensi)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code> <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory&lt;&gt;</code>, <code>ReadOnlyMemory&lt;&gt;</code>, <code>ArraySegment&lt;&gt;</code>, <code>ReadOnlySequence&lt;&gt;</code></li>
<li><code>Nullable&lt;&gt;</code>, <code>Lazy&lt;&gt;</code>, <code>KeyValuePair&lt;,&gt;</code>, <code>Tuple&lt;,...&gt;</code>, <code>ValueTuple&lt;,...&gt;</code></li>
<li><code>List&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>SortedSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code></li>
<li><code>Dictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>,  <code>ReadOnlyDictionary&lt;,&gt;</code> </li>
<li><code>Collection&lt;&gt;</code>, <code>ReadOnlyCollection&lt;&gt;</code>, <code>ObservableCollection&lt;&gt;</code>, <code>ReadOnlyObservableCollection&lt;&gt;</code></li>
<li><code>IEnumerable&lt;&gt;</code>, <code>ICollection&lt;&gt;</code>, <code>IList&lt;&gt;</code>, <code>IReadOnlyCollection&lt;&gt;</code>, <code>IReadOnlyList&lt;&gt;</code>, <code>ISet&lt;&gt;</code></li>
<li><code>IDictionary&lt;,&gt;</code>, <code>IReadOnlyDictionary&lt;,&gt;</code>, <code>ILookup&lt;,&gt;</code>, <code>IGrouping&lt;,&gt;</code>,</li>
<li><code>ConcurrentBag&lt;&gt;</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>, <code>BlockingCollection&lt;&gt;</code></li>
<li>Immutable collections (<code>ImmutableList&lt;&gt;</code>, dll.) dan interface (<code>IImmutableList&lt;&gt;</code>, dll.)</li>
</ul>
<h2>Definisikan <code>[MemoryPackable]</code> pada <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code></h2>
<p><code>[MemoryPackable]</code> dapat digunakan pada <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code> maupun <code>interface</code>. Jika tipe adalah <code>struct</code> atau <code>record struct</code> yang tidak mengandung tipe referensi (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>), anotasi tambahan (ignore, include, constructor, callbacks) tidak digunakan, sehingga serialisasi/deserialisasi langsung dari memori.</p>
<p>Selain itu, secara default, <code>[MemoryPackable]</code> akan mensialisikan properti atau field instance yang public. Anda dapat menggunakan <code>[MemoryPackIgnore]</code> untuk menghapus target serialisasi, <code>[MemoryPackInclude]</code> untuk mempromosikan member privat ke target serialisasi.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// tipe-tipe berikut diserialisasikan secara default</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicField;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> PublicReadOnlyField;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PrivateSetPublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ReadOnlyPublicProperty { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> RequiredInitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }

    <span class="hljs-comment">// tipe-tipe berikut tidak diserialisasikan secara default</span>
    <span class="hljs-built_in">int</span> privateProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-built_in">int</span> privateField;
    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> privateReadOnlyField;

    <span class="hljs-comment">// gunakan [MemoryPackIgnore] untuk menghapus target dari anggota public</span>
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty2 =&gt; PublicProperty + PublicField;

    <span class="hljs-comment">// gunakan [MemoryPackInclude] untuk mempromosikan anggota privat ke target serialisasi</span>
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateField2;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Generator kode <code>MemoryPack</code> menambahkan informasi tentang anggota mana saja yang diserialisasikan ke bagian <code>&lt;remarks /&gt;</code>. Ini dapat dilihat dengan mengarahkan kursor ke tipe tersebut menggunakan Intellisense.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p>
<p>Semua anggota harus dapat diserialisasikan oleh memorypack, jika tidak generator kode akan mengeluarkan error.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p>
<p>MemoryPack memiliki 35 aturan diagnostik (<code>MEMPACK001</code> hingga <code>MEMPACK035</code>) agar dapat didefinisikan dengan nyaman.</p>
<p>Jika tipe target telah didefinisikan serialisasi MemoryPack secara eksternal dan didaftarkan, gunakan <code>[MemoryPackAllowSerialize]</code> untuk membisukan diagnostik.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample2</span>
{
    [<span class="hljs-meta">MemoryPackAllowSerialize</span>]
    <span class="hljs-keyword">public</span> NotSerializableType? NotSerializableProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Urutan anggota <strong>penting</strong>, MemoryPack tidak menyimpan nama anggota atau informasi lain, melainkan menyimpan field sesuai urutan deklarasi. Jika tipe merupakan turunan, serialisasi dilakukan dalam urutan parent → child. Urutan anggota tidak boleh berubah untuk proses deserialisasi. Untuk evolusi skema, lihat bagian <a href="#version-tolerant">Version tolerant</a>.</p>
<p>Urutan default adalah sequential, tetapi Anda bisa memilih explicit layout dengan <code>[MemoryPackable(SerializeLayout.Explicit)]</code> dan <code>[MemoryPackOrder()]</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// serialize Prop0 -&gt; Prop1</span>
[<span class="hljs-meta">MemoryPackable(SerializeLayout.Explicit)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleExplicitOrder</span>
{
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h3>Pemilihan konstruktor</h3>
<p>MemoryPack mendukung konstruktor dengan parameter maupun tanpa parameter. Pemilihan konstruktor mengikuti aturan berikut (berlaku untuk class dan struct):</p>
<ul>
<li>Jika terdapat <code>[MemoryPackConstructor]</code>, maka digunakan.</li>
<li>Jika tidak ada konstruktor eksplisit (termasuk private), digunakan konstruktor tanpa parameter.</li>
<li>Jika hanya ada satu konstruktor tanpa parameter/berparameter (termasuk private), maka digunakan.</li>
<li>Jika ada beberapa konstruktor, atribut <code>[MemoryPackConstructor]</code> harus diterapkan pada konstruktor yang diinginkan (generator tidak akan memilih otomatis), jika tidak generator akan mengeluarkan error.</li>
<li>Jika menggunakan konstruktor dengan parameter, semua nama parameter harus sesuai dengan nama anggota yang bersesuaian (case-insensitive).</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Name;

    <span class="hljs-comment">// Anda dapat menggunakan konstruktor berparameter - nama parameter harus sesuai dengan nama anggota yang bersesuaian (case-insensitive)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Age = age;
        <span class="hljs-keyword">this</span>.Name = name;
    }
}

<span class="hljs-comment">// juga mendukung record primary constructor</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Person2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Age, <span class="hljs-built_in">string</span> Name</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>()</span>
    {
    }
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Jika ada beberapa konstruktor, maka [MemoryPackConstructor] harus digunakan</span>
[<span class="hljs-meta">MemoryPackConstructor</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
{
    <span class="hljs-keyword">this</span>.Age = age;
    <span class="hljs-keyword">this</span>.Name = name;
}
</code></pre>
<h3>Callback Serialisasi</h3>
<p>Saat melakukan serialisasi/deserialisasi, MemoryPack dapat memanggil event sebelum/sesudah menggunakan atribut <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code>. Atribut ini dapat digunakan pada metode statis maupun instance (non-statis), serta metode public maupun private.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MethodCallSample</span>
{
    <span class="hljs-comment">// urutan pemanggilan metode adalah statis -&gt; instance</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing1));
    }

    <span class="hljs-comment">// juga mendukung metode private</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing2));
    }

    <span class="hljs-comment">// serializing -&gt; /* serialize */ -&gt; serialized</span>
    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized1));
    }

    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing1));
    }

    <span class="hljs-comment">// Catatan: metode instance dengan MemoryPackOnDeserializing, tidak akan dipanggil jika instance tidak dilewatkan dengan `ref`</span>
    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized1));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized2));
    }
}
</code></pre>
<p>Callback memungkinkan metode tanpa parameter dan metode <code>ref reader/writer, ref T value</code>. Sebagai contoh, callback ref dapat menulis/membaca header kustom sebelum proses serialisasi.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EmitIdData</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteId</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)
        <span class="hljs-keyword">where</span> TBufferWriter : IBufferWriter&lt;<span class="hljs-built_in">byte</span>&gt; <span class="hljs-comment">// .NET Standard 2.1, gunakan where TBufferWriter : class, IBufferWriter&lt;byte&gt;</span></span>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); <span class="hljs-comment">// menulis GUID di header.</span>
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadId</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-comment">// membaca header kustom sebelum deserialisasi</span>
        <span class="hljs-keyword">var</span> guid = reader.ReadUnmanaged&lt;Guid&gt;();
        Console.WriteLine(guid);
    }
}
</code></pre>
<p>Jika mengatur nilai pada <code>ref value</code>, Anda dapat mengubah nilai yang digunakan untuk serialisasi/deserialisasi. Misalnya, melakukan instansiasi dari ServiceProvider.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// sebelum menggunakan formatter ini, set ServiceProvider</span>
<span class="hljs-comment">// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };</span>
<span class="hljs-comment">// MemoryPackSerializer.Deserialize(value, options);</span>

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InstantiateFromServiceProvider</span>
{
    <span class="hljs-keyword">static</span> IServiceProvider serviceProvider = <span class="hljs-literal">default</span>!;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> InstantiateFromServiceProvider <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">value</span> = reader.Options.ServiceProvider!.GetRequiredService&lt;InstantiateFromServiceProvider&gt;();
    }
}
</code></pre>
<h2>Definisikan koleksi kustom</h2>
<p>Secara default, tipe yang dianotasi <code>[MemoryPackObject]</code> akan mencoba men-serialisasi anggotanya. Namun, jika tipe tersebut adalah koleksi (<code>ICollection&lt;&gt;</code>, <code>ISet&lt;&gt;</code>, <code>IDictionary&lt;,&gt;</code>), gunakan <code>GenerateType.Collection</code> agar serialisasi berjalan dengan benar.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt;
{
}

[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyStringDictionary</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>&gt;
{

}
</code></pre>
<h2>Konstruktor statis</h2>
<p>Kelas MemoryPackable tidak dapat mendefinisikan konstruktor statis karena partial class yang dihasilkan menggunakannya. Sebagai gantinya, Anda dapat mendefinisikan <code>static partial void StaticConstructor()</code> untuk melakukan hal yang sama.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CctorSample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StaticConstructor</span>()</span>
    {
    }
}
</code></pre>
<h2>Polimorfisme (Union)</h2>
<p>MemoryPack mendukung serialisasi objek interface dan kelas abstrak untuk kebutuhan serialisasi polimorfisme. Di MemoryPack, fitur ini disebut Union. Hanya interface dan kelas abstrak yang diperbolehkan diberi atribut <code>[MemoryPackUnion]</code>. Diperlukan tag union yang unik.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Tandai [MemoryPackable] dan tipe turunan dengan [MemoryPackUnion]</span>
<span class="hljs-comment">// Union juga mendukung kelas abstrak</span>
[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> XYZ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BarClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? OPQ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
<span class="hljs-comment">// ---</span>

IUnionSample data = <span class="hljs-keyword">new</span> FooClass() { XYZ = <span class="hljs-number">999</span> };

<span class="hljs-comment">// Serialisasi sebagai tipe interface.</span>
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(data);

<span class="hljs-comment">// Deserialisasi sebagai tipe interface.</span>
<span class="hljs-keyword">var</span> reData = MemoryPackSerializer.Deserialize&lt;IUnionSample&gt;(bin);

<span class="hljs-keyword">switch</span> (reData)
{
    <span class="hljs-keyword">case</span> FooClass x:
        Console.WriteLine(x.XYZ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BarClass x:
        Console.WriteLine(x.OPQ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-literal">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p><code>tag</code> memperbolehkan nilai <code>0</code> ~ <code>65535</code>, sangat efisien terutama untuk nilai kurang dari <code>250</code>.</p>
<pre><code class="hljs language-kotlin">Jika sebuah <span class="hljs-keyword">interface</span> <span class="hljs-title class_">dan</span> <span class="hljs-title">tipe</span> <span class="hljs-title">turunannya</span> <span class="hljs-title">berada</span> <span class="hljs-title">di</span> <span class="hljs-title">assembly</span> <span class="hljs-title">yang</span> <span class="hljs-title">berbeda</span>, <span class="hljs-type">Anda</span> <span class="hljs-title">dapat</span> <span class="hljs-title">menggunakan</span> `<span class="hljs-title">MemoryPackUnionFormatterAttribute</span>` <span class="hljs-title">sebagai</span> <span class="hljs-title">gantinya</span>. <span class="hljs-title">Formatter</span> <span class="hljs-title">akan</span> <span class="hljs-title">dihasilkan</span> <span class="hljs-title">sedemikian</span> <span class="hljs-title">rupa</span> <span class="hljs-title">sehingga</span> <span class="hljs-title">secara</span> <span class="hljs-title">otomatis</span> <span class="hljs-title">terdaftar</span> <span class="hljs-title">melalui</span> `<span class="hljs-title">ModuleInitializer</span>` <span class="hljs-title">di</span> <span class="hljs-title">C</span># 9.0 <span class="hljs-title">dan</span> <span class="hljs-title">yang</span> <span class="hljs-title">lebih</span> <span class="hljs-title">baru</span>.

&gt; Perhatikan bahwa `ModuleInitializer` tidak didukung di Unity, sehingga formatter harus didaftarkan secara manual. Untuk mendaftarkan union formatter Anda, panggil `{nama union formatter Anda}Initializer.RegisterFormatter()` secara manual di Startup. Misalnya `UnionSampleFormatterInitializer.RegisterFormatter()`.

```csharp
<span class="hljs-comment">// AssemblyA</span>
[MemoryPackable(GenerateType.NoGenerate)]
<span class="hljs-keyword">public</span> partial <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUnionSample</span>
{
}

<span class="hljs-comment">// AssemblyB mendefinisikan definisi di luar target type</span>
[MemoryPackUnionFormatter(typeof(IUnionSample))]
[MemoryPackUnion(<span class="hljs-number">0</span>, typeof(FooClass))]
[MemoryPackUnion(<span class="hljs-number">1</span>, typeof(BarClass))]
<span class="hljs-keyword">public</span> partial <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionSampleFormatter</span>
{
}
</code></pre>
<p>Union dapat dirakit dalam kode melalui <code>DynamicUnionFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// (ushort, Type)[]</span>
<span class="hljs-keyword">var</span> formatter = <span class="hljs-keyword">new</span> DynamicUnionFormatter&lt;IFooBarBaz&gt;(
    (<span class="hljs-number">0</span>, <span class="hljs-keyword">typeof</span>(Foo)),
    (<span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(Bar)),
    (<span class="hljs-number">2</span>, <span class="hljs-keyword">typeof</span>(Baz))
);

MemoryPackFormatterProvider.Register(formatter);
</code></pre>
<h2>Serialize API</h2>
<p><code>Serialize</code> memiliki tiga overload.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Non generic API juga tersedia, versi ini argumen pertama adalah Type dan value adalah object?</span>
<span class="hljs-function"><span class="hljs-built_in">byte</span>[] <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> TBufferWriter bufferWriter, <span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
</span></code></pre>
<p>Untuk performa, API yang direkomendasikan menggunakan <code>BufferWriter</code>. Ini melakukan serialisasi langsung ke buffer. Dapat diterapkan ke <code>PipeWriter</code> di <code>System.IO.Pipelines</code>, <code>BodyWriter</code> di ASP .NET Core, dll.</p>
<p>Jika diperlukan <code>byte[]</code> (misal <code>RedisValue</code> di <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>), API return <code>byte[]</code> sederhana dan hampir secepat itu.</p>
<p>Perhatikan bahwa <code>SerializeAsync</code> untuk <code>Stream</code> hanya asinkron untuk Flush; ia melakukan serialisasi semuanya sekaligus ke buffer internal pool MemoryPack lalu menulis menggunakan <code>WriteAsync</code>. Oleh karena itu, overload <code>BufferWriter</code>, yang memisahkan dan mengontrol buffer serta flush, lebih baik.</p>
<p>Jika Anda ingin melakukan streaming write secara penuh, lihat bagian <a href="#streaming-serialization">Streaming Serialization</a>.</p>
<h3>MemoryPackSerializerOptions</h3>
<p><code>MemoryPackSerializerOptions</code> mengatur apakah string diserialisasi sebagai UTF16 atau UTF8. Ini dapat dikonfigurasi dengan melewatkan <code>MemoryPackSerializerOptions.Utf8</code> untuk encoding UTF8, <code>MemoryPackSerializerOptions.Utf16</code> untuk encoding UTF16, atau <code>MemoryPackSerializerOptions.Default</code> yang secara default menggunakan UTF8. Melewatkan null atau menggunakan parameter default menghasilkan encoding UTF8.</p>
<p>Karena representasi string internal C# adalah UTF16, performa UTF16 lebih baik. Namun, payload cenderung lebih besar; pada UTF8, string ASCII adalah satu byte, sedangkan di UTF16 dua byte. Karena perbedaan ukuran payload sangat besar, UTF8 dijadikan default.</p>
<p>Jika data bukan ASCII (misal Jepang, yang bisa lebih dari 3 byte, dan UTF8 jadi lebih besar), atau Anda harus mengompresnya secara terpisah, UTF16 mungkin memberikan hasil lebih baik.</p>
<p>Meskipun UTF8 atau UTF16 bisa dipilih saat serialisasi, tidak perlu ditentukan saat deserialisasi. Akan dideteksi dan didekode secara otomatis.</p>
<p>Selain itu, Anda bisa mendapatkan/mengatur <code>IServiceProvider? ServiceProvider { get; init; }</code> dari options. Ini berguna untuk mengambil objek DI (seperti <code>ILogger&lt;T&gt;</code>) dari proses serialisasi (<code>MemoryPackReader/MemoryPackWriter</code> memiliki properti .Options).</p>
<h2>Deserialize API</h2>
<p><code>Deserialize</code> memiliki overload untuk <code>ReadOnlySpan&lt;byte&gt;</code> dan <code>ReadOnlySequence&lt;byte&gt;</code>, <code>Stream</code> serta dukungan <code>ref</code>.</p>
<pre><code class="language-csharp hljs">T? Deserialize&lt;T&gt;(ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer)
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
T? <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer</span>)
<span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
<span class="hljs-keyword">async</span> <span class="hljs-title">ValueTask</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream</span>)
</span></code></pre>
<p>Overload <code>ref</code> menimpa instance yang sudah ada, untuk detail lihat bagian <a href="#overwrite">Overwrite</a>.</p>
<p><code>DeserializeAsync(Stream)</code> bukan operasi baca streaming penuh, pertama ia membaca ke dalam pool internal MemoryPack hingga akhir stream, lalu mendeserialisasi.</p>
<p>Jika Anda ingin melakukan operasi baca streaming penuh, lihat bagian <a href="#streaming-serialization">Streaming Serialization</a>.</p>
<h2>Overwrite</h2>
<p>Untuk mengurangi alokasi, MemoryPack mendukung deserialisasi ke instance yang sudah ada, menimpanya. Ini dapat digunakan dengan overload <code>Deserialize(ref T? value)</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(person);

<span class="hljs-comment">// timpa data ke instance yang sudah ada.</span>
MemoryPackSerializer.Deserialize(bin, <span class="hljs-keyword">ref</span> person);
</code></pre>
<p>MemoryPack akan mencoba menimpa sebanyak mungkin, tetapi jika kondisi berikut tidak terpenuhi, maka akan membuat instance baru (seperti pada deserialisasi normal).</p>
<ul>
<li>nilai ref (termasuk anggota dalam object graph) adalah null, set instance baru</li>
<li>hanya memperbolehkan konstruktor tanpa parameter, jika konstruktor berparameter digunakan, buat instance baru</li>
<li>jika value adalah <code>T[]</code>, digunakan kembali hanya jika panjang sama, jika tidak buat instance baru</li>
<li>jika value adalah koleksi yang memiliki metode <code>.Clear()</code> (<code>List&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentBag&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>) maka panggil Clear() dan gunakan kembali, jika tidak buat instance baru</li>
</ul>
<h2>Version tolerant</h2>
<p>Secara default (<code>GenerateType.Object</code>), MemoryPack mendukung evolusi skema terbatas.</p>
<ul>
<li>struct unmanaged tidak dapat diubah lagi</li>
<li>anggota dapat ditambahkan, tapi tidak dapat dihapus</li>
<li>dapat mengganti nama anggota</li>
<li>tidak dapat mengubah urutan anggota</li>
<li>tidak dapat mengubah tipe anggota</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Add is OK.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? AddedProp { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Remove is NG.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-comment">// public int Prop1 { get; set; }</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Change order is NG.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Dalam penggunaannya, menyimpan data lama (ke file, ke redis, dll...) dan membaca ke skema baru selalu aman. Dalam skenario RPC, skema ada di sisi klien dan server, klien harus diperbarui sebelum server. Klien yang sudah diperbarui tidak masalah terhubung ke server lama, tapi klien lama tidak dapat terhubung ke server baru.</p>
<p>Secara default, ketika data lama dibaca ke skema baru, semua anggota yang tidak ada pada sisi data akan diinisialisasi dengan literal <code>default</code>.<br>Jika Anda ingin menghindari ini dan menggunakan nilai awal field/properti, Anda dapat menggunakan <code>[SuppressDefaultInitialization]</code>.</p>
<pre><code class="language-cs hljs language-csharp">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DefaultValue</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">SuppressDefaultInitialization</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">111</span>; <span class="hljs-comment">// &lt; jika data lama tidak ada, set `111`.</span>
    
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">222</span>; <span class="hljs-comment">// &lt; jika data lama tidak ada, set `default`.</span>
}
</code></pre>
<p> <code>[SuppressDefaultInitialization]</code> memiliki batasan berikut:</p>
<ul>
<li>Tidak dapat digunakan dengan modifier readonly, init-only, dan required.</li>
</ul>
<p>Bagian selanjutnya <a href="#serialization-info">Serialization info</a> menunjukkan cara memeriksa perubahan skema, misalnya, dengan CI, untuk mencegah kecelakaan.</p>
<p>Saat menggunakan <code>GenerateType.VersionTolerant</code>, ini mendukung toleransi versi penuh.</p>
<ul>
<li>struct unmanaged tidak bisa diubah lagi</li>
<li>semua anggota harus menambahkan <code>[MemoryPackOrder]</code> secara eksplisit (kecuali diberi anotasi <code>SerializeLayout.Sequential</code>)</li>
<li>anggota bisa ditambah, bisa dihapus tapi tidak boleh menggunakan ulang order (boleh menggunakan order yang hilang)</li>
<li>bisa mengubah nama anggota</li>
<li>tidak bisa mengubah urutan anggota</li>
<li>tidak bisa mengubah tipe anggota</li>
</ul>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Ok untuk serialize/deserialize kedua arah </span>
<span class="hljs-comment">// VersionTolerantObject1 -&gt; VersionTolerantObject2 dan </span>
<span class="hljs-comment">// VersionTolerantObject2 -&gt; VersionTolerantObject1</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject1</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject2</span>
{
```csharp
[<span class="hljs-meta">MemoryPackOrder(0)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// dihapus</span>
<span class="hljs-comment">//[MemoryPackOrder(1)]</span>
<span class="hljs-comment">//public long MyProperty1 { get; set; } = default;</span>

[<span class="hljs-meta">MemoryPackOrder(2)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// ditambahkan</span>
[<span class="hljs-meta">MemoryPackOrder(3)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Jika SerializeLayout.Sequential diatur secara eksplisit, maka pengurutan otomatis diizinkan.</span>
<span class="hljs-comment">// Namun, tidak dapat menghapus anggota apa pun untuk versi-tolerant.</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<p><code>GenerateType.VersionTolerant</code> lebih lambat daripada <code>GenerateType.Object</code> dalam proses serialisasi. Selain itu, ukuran payload akan sedikit lebih besar.</p>
<h2>Info Serialisasi</h2>
<p>Anda dapat memeriksa IntelliSense pada tipe untuk mengetahui anggota mana yang diserialisasi. Ada opsi untuk menuliskan informasi tersebut ke dalam file pada saat kompilasi. Atur <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code> seperti berikut.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- output info serialisasi memorypack ke direktori --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_SerializationInfoOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\MemoryPackLogs<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>Informasi berikut akan dituliskan ke dalam file.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p>
<p>Jika tipe tersebut unmanaged, akan ditampilkan <code>unmanaged</code> sebelum nama tipe.</p>
<pre><code class="language-txt hljs language-plaintext">unmanaged FooStruct
---
int x
int y
</code></pre>
<p>Dengan memeriksa perbedaan pada file ini, perubahan skema yang berbahaya dapat dicegah. Misalnya, Anda dapat menggunakan CI untuk mendeteksi aturan berikut</p>
<ul>
<li>memodifikasi tipe unmanaged</li>
<li>perubahan urutan anggota</li>
<li>penghapusan anggota</li>
</ul>
<h2>Referensi Sirkular</h2>
<p>MemoryPack juga mendukung referensi sirkular. Ini memungkinkan objek pohon untuk diserialisasi apa adanya.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// untuk mengaktifkan circular-reference, gunakan GenerateType.CircularReference</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> Node? Parent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Node[]? Children { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Sebagai contoh, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references">System.Text.Json preserve-references</a> kodenya akan menjadi seperti berikut.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0</span>
Employee tyler = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Tyler Stein"</span>
};

Employee adrian = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Adrian King"</span>
};

tyler.DirectReports = <span class="hljs-keyword">new</span> List&lt;Employee&gt; { adrian };
adrian.Manager = tyler;

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize&lt;Employee&gt;(bin);

Console.WriteLine(tylerDeserialized?.DirectReports?[<span class="hljs-number">0</span>].Manager == tylerDeserialized); <span class="hljs-comment">// true</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Employee? Manager { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> List&lt;Employee&gt;? DirectReports { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>GenerateType.CircularReference</code> memiliki karakteristik yang sama seperti version-tolerant. Namun, sebagai batasan tambahan, hanya konstruktor tanpa parameter yang diizinkan. Selain itu, pelacakan referensi objek hanya dilakukan untuk objek yang ditandai dengan <code>GenerateType.CircularReference</code>. Jika Anda ingin melacak objek lain, bungkus objek tersebut.</p>
<h2>CustomFormatter</h2>
<p>Jika mengimplementasikan <code>MemoryPackCustomFormatterAttribute&lt;T&gt;</code> atau <code>MemoryPackCustomFormatterAttribute&lt;TFormatter, T&gt;</code> (lebih cepat, namun lebih kompleks), Anda dapat mengonfigurasi agar anggota MemoryPackObject menggunakan custom formatter.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Attribute</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> IMemoryPackFormatter&lt;T&gt; <span class="hljs-title">GetFormatter</span>()</span>;
}
</code></pre>
<p>MemoryPack menyediakan atribut pemformatan berikut: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute&lt;TValue&gt;</code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter&lt;T&gt;</code>, <code>MemoryPoolFormatter&lt;T&gt;</code>, <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// serialisasikan anggota ini sebagai UTF16 String, performa lebih baik daripada UTF8 tetapi untuk ASCII, ukuran lebih besar (namun untuk non-ASCII, kadang lebih kecil).</span>
    [<span class="hljs-meta">Utf16StringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Text { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment">// Saat deserialisasi, Dictionary diinisialisasi dengan StringComparer.OrdinalIgnoreCase.</span>
    [<span class="hljs-meta">OrdinalIgnoreCaseStringDictionaryFormatter&lt;int&gt;</span>]
    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;? Ids { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    
    <span class="hljs-comment">// Saat deserialisasi, semua string di-intern (lihat: String.Intern). Jika nilai serupa sering muncul, ini menghemat memori.</span>
    [<span class="hljs-meta">InternStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Flag { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>Untuk mengonfigurasi equality comparer pada set/dictionary, semua formatter bawaan memiliki overload konstruktor comparer. Anda dapat dengan mudah membuat custom equality-comparer formatter.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OrdinalIgnoreCaseStringDictionaryFormatter</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>?&gt;&gt;
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt; formatter = <span class="hljs-keyword">new</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt;(StringComparer.OrdinalIgnoreCase);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> IMemoryPackFormatter&lt;Dictionary&lt;<span class="hljs-built_in">string</span>, TValue?&gt;&gt; GetFormatter()
    {
        <span class="hljs-keyword">return</span> formatter;
    }
}
</code></pre>
<p><code>BitPackFormatter</code> hanya mengompresi tipe <code>bool[]</code>. <code>bool[]</code> biasanya diserialisasi sebagai 1 byte per nilai boolean, namun <code>BitPackFormatter</code> menserialisasi <code>bool[]</code> seperti <code>BitArray</code> dengan menyimpan setiap bool sebagai 1 bit. Dengan menggunakan <code>BitPackFormatter</code>, 8 nilai bool menjadi 1 byte, yang biasanya membutuhkan 8 byte, sehingga ukurannya menjadi 8x lebih kecil.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BitPackFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[]? Data { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter</code> digunakan untuk <code>byte[]</code>, misalnya Anda dapat mengompresi payload besar dengan Brotli.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliStringFormatter</code> digunakan untuk <code>string</code>, serialisasi string terkompresi (UTF16) dengan Brotli.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? LargeText { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter&lt;T&gt;</code> digunakan untuk tipe apa pun, data ter-serialisasi dikompresi oleh Brotli. Jika tipe tersebut adalah <code>byte[]</code> atau <code>string</code>, Anda sebaiknya menggunakan <code>BrotliFormatter</code> atau <code>BrotliStringFormatter</code> demi performa.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter&lt;ChildType&gt;</span>]
    <span class="hljs-keyword">public</span> ChildType? Child { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>Deserialisasi dengan Array Pooling</h2>
<p>Untuk mendeserialisasi array besar (tipe apa pun <code>T</code>), MemoryPack menawarkan beberapa metode pooling yang efisien. Cara paling efektif adalah menggunakan fungsi <a href="#overwrite">#Overwrite</a>. Khusus untuk <code>List&lt;T&gt;</code>, selalu digunakan kembali.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ListBytesSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">byte</span>&gt; Payload</span> { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// ----</span>

<span class="hljs-comment">// List&lt;byte&gt; digunakan kembali, tanpa alokasi saat deserialisasi.</span>
MemoryPackSerializer.Deserialize&lt;ListBytesSample&gt;(bin, <span class="hljs-keyword">ref</span> reuseObject);

<span class="hljs-comment">// untuk operasi yang efisien, Anda dapat mengambil Span&lt;T&gt; melalui CollectionsMarshal</span>
<span class="hljs-keyword">var</span> span = CollectionsMarshal.AsSpan(<span class="hljs-keyword">value</span>.Payload);
</code></pre>
<p>Cara yang praktis adalah mendeserialisasi ke ArrayPool saat waktu deserialisasi. MemoryPack menyediakan <code>MemoryPoolFormatter&lt;T&gt;</code> dan <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PoolModelSample</span> : <span class="hljs-title">IDisposable</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; }

    [<span class="hljs-meta">MemoryPoolFormatter&lt;byte&gt;</span>]
    <span class="hljs-keyword">public</span> Memory&lt;<span class="hljs-built_in">byte</span>&gt; Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PoolModelSample</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, Memory&lt;<span class="hljs-built_in">byte</span>&gt; payload</span>)</span>
    {
        Id = id;
        Payload = payload;
    }

    <span class="hljs-comment">// Anda harus menulis kode pengembalian sendiri, berikut cuplikannya.</span>

    <span class="hljs-built_in">bool</span> usePool;

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized</span>()</span>
    {
        usePool = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span>
    {
        <span class="hljs-keyword">if</span> (!usePool) <span class="hljs-keyword">return</span>;

        Return(Payload); Payload = <span class="hljs-literal">default</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Memory&lt;T&gt; memory</span>)</span> =&gt; Return((ReadOnlyMemory&lt;T&gt;)memory);

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlyMemory&lt;T&gt; memory</span>)</span>
    {
        <span class="hljs-keyword">if</span> (MemoryMarshal.TryGetArray(memory, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> segment) &amp;&amp; segment.Array <span class="hljs-keyword">is</span> { Length: &gt; <span class="hljs-number">0</span> })
        {
            ArrayPool&lt;T&gt;.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;());
        }
    }
}

<span class="hljs-comment">// ---</span>

<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;PoolModelSample&gt;(bin))
{
    <span class="hljs-comment">// lakukan apapun...</span>
}   <span class="hljs-comment">// kembali ke ArrayPool</span>
</code></pre>
<h2>Performa</h2>
<p>Lihat postingan blog saya <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p>
<h2>Ukuran Payload dan Kompresi</h2>
<p>Ukuran payload tergantung pada nilai target; berbeda dengan JSON, tidak ada key dan ini adalah format biner, sehingga ukuran payload kemungkinan lebih kecil daripada JSON.</p>
<p>Untuk yang menggunakan varint encoding, seperti MessagePack dan Protobuf, MemoryPack cenderung lebih besar jika banyak menggunakan int (pada MemoryPack, int selalu 4 byte karena fixed size encoding, sedangkan MessagePack adalah 1~5 byte).</p>
<p>float dan double adalah 4 byte dan 8 byte di MemoryPack, namun 5 byte dan 9 byte di MessagePack. Jadi MemoryPack lebih kecil, misalnya, untuk array Vector3 (float, float, float).</p>
<p>String secara default adalah UTF8, yang mirip dengan serializer lain, namun jika opsi UTF16 dipilih, akan berbeda sifatnya.</p>
<p>Dalam kasus apa pun, jika ukuran payload besar, kompresi harus dipertimbangkan. LZ4, ZStandard, dan Brotli direkomendasikan.</p>
<h3>Kompresi</h3>
<p>MemoryPack menyediakan helper efisien untuk kompresi <a href="https://github.com/google/brotli">Brotli</a> melalui <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder">BrotliEncoder</a> dan <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder">BrotliDecoder</a>. <code>BrotliCompressor</code> dan <code>BrotliDecompressor</code> dari MemoryPack menyediakan kompresi/dekompresi yang dioptimalkan untuk perilaku internal MemoryPack.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// Kompresi (perlu using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> compressor = <span class="hljs-keyword">new</span> BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, <span class="hljs-keyword">value</span>);

<span class="hljs-comment">// Dapatkan byte[] terkompresi</span>
<span class="hljs-keyword">var</span> compressedBytes = compressor.ToArray();

<span class="hljs-comment">// Atau tulis ke IBufferWriter&lt;byte&gt; lain (misal PipeWriter)</span>
compressor.CopyTo(response.BodyWriter);
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// Dekompresi (perlu using)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> decompressor = <span class="hljs-keyword">new</span> BrotliDecompressor();

<span class="hljs-comment">// Dapatkan ReadOnlySequence&lt;byte&gt; terdekompresi dari ReadOnlySpan&lt;byte&gt; atau ReadOnlySequence&lt;byte&gt;</span>
<span class="hljs-keyword">var</span> decompressedBuffer = decompressor.Decompress(buffer);

<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;T&gt;(decompressedBuffer);
</code></pre>
<p>Baik <code>BrotliCompressor</code> maupun <code>BrotliDecompressor</code> adalah struct, tidak mengalokasikan memori di heap. Keduanya menyimpan data yang terkompresi atau terdekompresi dalam memory pool internal untuk Serialize/Deserialize. Oleh karena itu, perlu melepaskan pooling memory, jangan lupa gunakan <code>using</code>.</p>
<p>Level kompresi sangat penting. Default diatur ke quality-1 (CompressionLevel.Fastest), berbeda dengan default .NET (CompressionLevel.Optimal, quality-4).</p>
<p>Fastest (quality-1) akan mendekati kecepatan <a href="https://github.com/lz4/lz4">LZ4</a>, tetapi 4 jauh lebih lambat. Ini dianggap krusial dalam skenario penggunaan serializer. Hati-hati saat menggunakan <code>BrotliStream</code> standar (quality-4 adalah default). Dalam kasus apa pun, kecepatan dan ukuran kompresi/dekompresi akan menghasilkan hasil yang sangat berbeda untuk data berbeda. Silakan siapkan data yang akan ditangani aplikasi Anda dan uji sendiri.</p>
<p>Perlu dicatat bahwa terdapat penalti kecepatan beberapa kali lipat antara MemoryPack tanpa kompresi dan MemoryPack dengan kompresi Brotli.</p>
<p>Brotli juga didukung di custom formatter. <code>BrotliFormatter</code> dapat mengompres member tertentu.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>Serialisasi tipe eksternal</h2>
<p>Jika Anda ingin men-serialisasi tipe eksternal, Anda bisa membuat custom formatter dan mendaftarkannya ke provider, lihat <a href="#formatterprovider-api">Formatter/Provider API</a> untuk detailnya. Namun, membuat custom formatter itu sulit. Oleh karena itu, kami menyarankan untuk membuat tipe pembungkus (wrapper). Contohnya, jika Anda ingin men-serialisasi tipe eksternal bernama <code>AnimationCurve</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">struct</span> SerializableAnimationCurve
{
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimationCurve AnimationCurve;

    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode preWrapMode =&gt; AnimationCurve.preWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode postWrapMode =&gt; AnimationCurve.postWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    Keyframe[] keys =&gt; AnimationCurve.keys;

    [<span class="hljs-meta">MemoryPackConstructor</span>]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        <span class="hljs-keyword">var</span> curve = <span class="hljs-keyword">new</span> AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        <span class="hljs-keyword">this</span>.AnimationCurve = curve;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SerializableAnimationCurve</span>(<span class="hljs-params">AnimationCurve animationCurve</span>)</span>
    {
        <span class="hljs-keyword">this</span>.AnimationCurve = animationCurve;
    }
}
</code></pre>
<p>Tipe yang dibungkus bersifat public, tetapi dikecualikan dari serialisasi (<code>MemoryPackIgnore</code>). Properti yang ingin Anda serialisasi bersifat private, tetapi disertakan (<code>MemoryPackInclude</code>). Dua pola konstruktor juga harus disiapkan. Konstruktor yang digunakan oleh serializer harus bersifat private.</p>
<p>Dengan cara ini, harus dibungkus setiap kali, yang cukup merepotkan. Selain itu, struct wrapper tidak dapat merepresentasikan nilai null. Jadi mari kita buat custom formatter.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimationCurveFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">AnimationCurve</span>&gt;
{
    <span class="hljs-comment">// Unity tidak mendukung scoped dan TBufferWriter sehingga tandatangan diubah menjadi `Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)`</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
```csharp
{
    writer.WriteNullObjectHeader();
    <span class="hljs-keyword">return</span>;
}

writer.WritePackable(<span class="hljs-keyword">new</span> SerializableAnimationCurve(<span class="hljs-keyword">value</span>));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (reader.PeekIsNull())
    {
        reader.Advance(<span class="hljs-number">1</span>); <span class="hljs-comment">// skip null block</span>
        <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">var</span> wrapped = reader.ReadPackable&lt;SerializableAnimationCurve&gt;();
    <span class="hljs-keyword">value</span> = wrapped.AnimationCurve;
}
</code></pre>
<p>Terakhir, daftarkan formatter di saat startup.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register&lt;AnimationCurve&gt;(<span class="hljs-keyword">new</span> AnimationCurveFormatter());
</code></pre>
<blockquote>
<p>Catatan: AnimationCurve milik Unity sudah dapat diserialisasi secara default sehingga tidak membutuhkan formatter kustom ini untuk AnimationCurve</p>
</blockquote>
<h2>Paket</h2>
<p>MemoryPack memiliki paket-paket berikut.</p>
<ul>
<li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li>
</ul>
<p><code>MemoryPack</code> adalah pustaka utama, menyediakan dukungan penuh untuk serialisasi dan deserialisasi objek biner dengan performa tinggi. Pustaka ini bergantung pada <code>MemoryPack.Core</code> untuk pustaka dasar inti dan <code>MemoryPack.Generator</code> untuk pembuatan kode. <code>MemoryPack.Streaming</code> menambahkan ekstensi untuk <a href="#streaming-serialization">Streaming Serialization</a>. <code>MemoryPack.AspNetCoreMvcFormatter</code> menambahkan input/output formatters untuk ASP.NET Core. <code>MemoryPack.UnityShims</code> menambahkan tipe shim Unity dan formatter untuk berbagi tipe antara .NET dan Unity.</p>
<h2>TypeScript dan ASP.NET Core Formatter</h2>
<p>MemoryPack mendukung pembuatan kode TypeScript. Ia menghasilkan kelas dan kode serialisasi dari C#, dengan kata lain, Anda dapat berbagi tipe dengan Browser tanpa menggunakan OpenAPI, proto, dll.</p>
<p>Pembuatan kode diintegrasikan dengan Source Generator, opsi berikut (<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>) mengatur direktori output untuk kode TypeScript. Kode runtime juga dihasilkan pada saat yang sama, sehingga tidak diperlukan dependensi tambahan.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- output memorypack TypeScript code to directory --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>Tipe MemoryPackable C# harus dianotasi dengan <code>[GenerateTypeScript]</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">GenerateTypeScript</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> required Guid Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> FirstName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> LastName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required DateTime DateOfBirth { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required Gender Gender { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span>[] Emails { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Gender
{
    Male, Female, Other
}
</code></pre>
<p>Kode runtime dan tipe TypeScript akan dihasilkan di direktori target.</p>
<p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p>
<p>Kode yang dihasilkan adalah sebagai berikut, dengan field sederhana dan metode statis untuk serialize/serializeArray dan deserialize/deserializeArray.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackWriter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackWriter.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackReader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackReader.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Gender</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./Gender.js"</span>; 

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">dateOfBirth</span>: <span class="hljs-title class_">Date</span>;
    <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>;
    <span class="hljs-attr">emails</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArray</span>(<span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArrayCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// snip...</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArray</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArrayCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// snip...</span>
    }
}
</code></pre>
<p>Anda dapat menggunakan tipe ini seperti berikut.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
person.<span class="hljs-property">id</span> = crypto.<span class="hljs-title function_">randomUUID</span>();
person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;
person.<span class="hljs-property">firstName</span> = <span class="hljs-string">"foo"</span>;
person.<span class="hljs-property">lastName</span> = <span class="hljs-string">"bar"</span>;
person.<span class="hljs-property">dateOfBirth</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1999</span>, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
person.<span class="hljs-property">gender</span> = <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Other</span>;
person.<span class="hljs-property">emails</span> = [<span class="hljs-string">"foo@bar.com"</span>, <span class="hljs-string">"zoo@bar.net"</span>];

<span class="hljs-comment">// serialize ke Uint8Array</span>
<span class="hljs-keyword">let</span> bin = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">serialize</span>(person);

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([bin.<span class="hljs-property">buffer</span>], { <span class="hljs-attr">type</span>: <span class="hljs-string">"application/x-memorypack"</span> })

<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"http://localhost:5260/api"</span>,
    { <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>, <span class="hljs-attr">body</span>: blob, <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/x-memorypack"</span> } });

<span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();

<span class="hljs-comment">// deserialize dari ArrayBuffer </span>
<span class="hljs-keyword">let</span> person2 = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">deserialize</span>(buffer);
</code></pre>
<p>Paket <code>MemoryPack.AspNetCoreMvcFormatter</code> menambahkan input dan output formatter <code>MemoryPack</code> untuk ASP.NET Core MVC. Anda dapat menambahkan <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code> ke ASP.NET Core MVC dengan kode berikut.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackInputFormatter());
    <span class="hljs-comment">// Jika checkContentType: true maka dapat output beberapa format (JSON/MemoryPack, dll...). default-nya adalah false.</span>
    options.OutputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackOutputFormatter(checkContentType: <span class="hljs-literal">false</span>));
});
</code></pre>
<p>Jika Anda memanggil dari HttpClient, Anda dapat mengatur <code>application/x-memorypack</code> ke content-header.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> content = <span class="hljs-keyword">new</span> ByteArrayContent(bin)
content.Headers.ContentType = <span class="hljs-keyword">new</span> MediaTypeHeaderValue(<span class="hljs-string">"application/x-memorypack"</span>);
</code></pre>
<h3>TypeScript Type Mapping</h3>
<p>Ada beberapa batasan pada tipe yang dapat dihasilkan. Di antara tipe primitif, <code>char</code> dan <code>decimal</code> tidak didukung. Selain itu, tipe OpenGenerics tidak dapat digunakan.</p>
<table>
<thead>
<tr>
<th>C#</th>
<th>TypeScript</th>
<th>Deskripsi</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>sbyte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>bigint</code></td>
<td></td>
</tr>
</tbody></table>
<pre><code class="hljs language-xml">| `ulong` |  `bigint` |
| `float` |  `number` |
| `double` |  `number` |
| `string` |  `string \| null`  | 
| `Guid` |  `string`  | Di TypeScript, direpresentasikan sebagai string namun serialisasi/deserialisasi sebagai binary 16byte
| `DateTime` | `Date` | DateTimeKind akan diabaikan
| `enum` | `const enum` | Tipe dasar `long` dan `ulong` tidak didukung
| `T?` | `T \| null` |
| `T[]` | `T[] \| null` |
| `byte[]` | `Uint8Array \| null` |
| `: ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `T[] \| null` | Mendukung semua tipe yang mengimplementasikan `ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` seperti `List<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`
| `: ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `Set<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> \| null` | Mendukung semua tipe yang mengimplementasikan `ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` seperti `HashSet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>`
| `: IDictionary&lt;K,V&gt;` | `Map&lt;K, V&gt; \| null` | Mendukung semua tipe yang mengimplementasikan `IDictionary&lt;K,V&gt;` seperti `Dictionary&lt;K,V&gt;`.
| `[MemoryPackable]` | `class` | Hanya mendukung kelas
| `[MemoryPackUnion]` | `abstract class` |

`[GenerateTypeScript]` hanya dapat diterapkan pada kelas dan saat ini tidak didukung oleh struct.

### Konfigurasi ekstensi file import dan penamaan anggota

Secara default, MemoryPack menghasilkan ekstensi file `.js` seperti `import { MemoryPackWriter } from "./MemoryPackWriter.js";`. Jika Anda ingin mengubah ke ekstensi lain atau kosong, gunakan `MemoryPackGenerator_TypeScriptImportExtension` untuk mengaturnya.
Selain itu, nama anggota secara otomatis dikonversi ke camelCase. Jika Anda ingin menggunakan nama asli, gunakan `MemoryPackGenerator_TypeScriptConvertPropertyName` ke `false`.

```xml
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptImportExtension"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptConvertPropertyName"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptEnableNullableTypes"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- bisa dikosongkan --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- default adalah true --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- default adalah false --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code> memungkinkan anotasi nullable C# tercermin dalam kode TypeScript. Default-nya adalah false, sehingga semuanya menjadi nullable.</p>
<h2>Serialisasi Streaming</h2>
<p><code>MemoryPack.Streaming</code> menyediakan <code>MemoryPackStreamingSerializer</code>, yang menambahkan dukungan tambahan untuk serialisasi dan deserialisasi koleksi menggunakan stream.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackStreamingSerializer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeWriter pipeWriter, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeReader pipeReader, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, [EnumeratorCancellation] CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
}
</span></code></pre>
<h2>Formatter/Provider API</h2>
<p>Jika Anda ingin mengimplementasikan formatter secara manual, turunkan dari <code>MemoryPackFormatter&lt;T&gt;</code> dan override metode <code>Serialize</code> dan <code>Deserialize</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SkeltonFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">Skelton</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
        {
            writer.WriteNullObjectHeader();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// gunakan metode writer.</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (!reader.TryReadObjectHeader(<span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> count))
        {
            <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// gunakan metode reader.</span>
    }
}
</code></pre>
<p>Formatter yang dibuat didaftarkan dengan <code>MemoryPackFormatterProvider</code>.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register(<span class="hljs-keyword">new</span> SkeltonFormatter());
</code></pre>
<p>Catatan: <code>unmanged struct</code> (tidak mengandung tipe referensi) tidak dapat menggunakan custom formatter, selalu diserialisasi dengan native memory layout.</p>
<h2>MemoryPackWriter/ReaderOptionalState</h2>
<p>Inisialisasi <code>MemoryPackWriter</code>/<code>MemoryPackReader</code> memerlukan OptionalState. Ini adalah pembungkus dari <code>MemoryPackSerializerOptions</code>, bisa dibuat dari <code>MemoryPackWriterOptionalStatePool</code>.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// ketika di-dispose, OptionalState akan dikembalikan ke pool.</span>
<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> writer = <span class="hljs-keyword">new</span> MemoryPackWriter&lt;T&gt;(<span class="hljs-keyword">ref</span> t, state);
}

<span class="hljs-comment">// untuk Reader</span>
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> MemoryPackReader(buffer, state);
}
</code></pre>
<h2>Dependensi target framework</h2>
<p>MemoryPack menyediakan <code>netstandard2.1</code> dan <code>net7.0</code> namun keduanya tidak kompatibel. Misalnya, tipe MemoryPackable di bawah proyek <code>netstandard2.1</code> dan digunakan dari proyek <code>net7.0</code>, akan menimbulkan exception runtime seperti berikut</p>
<blockquote>
<p>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</p>
</blockquote>
<p>Karena net7.0 menggunakan anggota static abstract (<code>Virtual static method</code>), yang tidak didukung oleh netstandard2.1, perilaku ini adalah spesifikasi.</p>
<p>Proyek .NET 7 sebaiknya tidak menggunakan dll netstandard 2.1. Dengan kata lain, jika aplikasinya adalah Proyek .NET 7, semua dependensi yang menggunakan MemoryPack harus mendukung .NET 7. Jadi jika pengembang library memiliki dependensi pada MemoryPack, Anda perlu mengonfigurasi target framework ganda.</p>
<pre><code class="language-xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">TargetFrameworks</span>&gt;</span>netstandard2.1;net7.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFrameworks</span>&gt;</span>
</code></pre>
<h2>RPC</h2>
<p><a href="https://github.com/Cysharp/MagicOnion">Cysharp/MagicOnion</a> adalah framework grpc-dotnet code-first menggunakan MessagePack sebagai pengganti protobuf. MagicOnion kini mendukung MemoryPack sebagai lapisan serialisasi melalui paket <code>MagicOnion.Serialization.MemoryPack</code> (preview). Lihat detailnya: <a href="https://github.com/Cysharp/MagicOnion#memorypack-support">MagicOnion#MemoryPack support</a></p>
<h2>Unity</h2>
<p>Versi Unity minimum yang didukung adalah <code>2022.3.12f1</code>.</p>
<p>Paket inti <code>MemoryPack</code> disediakan melalui nuget. Ini juga tersedia di Unity. Jika Anda ingin mendapatkan dukungan tipe bawaan Unity, kami juga menyediakan ekstensi MemoryPack.Unity.</p>
<ol>
<li>Instal <code>MemoryPack</code> dari NuGet menggunakan <a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a></li>
</ol>
<ul>
<li><p>Buka Window dari NuGet -&gt; Manage NuGet Packages, Cari "MemoryPack" dan tekan Install.<br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p>
</li>
<li><p>Jika Anda menemui error konflik versi, silakan nonaktifkan validasi versi di Player Settings (Edit -&gt; Project Settings -&gt; Player -&gt; Scroll ke bawah dan expand "Other Settings" lalu hilangkan centang "Assembly Version Validation" di bagian "Configuration").</p>
</li>
</ul>
<ol start="2">
<li>Instal paket <code>MemoryPack.Unity</code> dengan mereferensikan URL git</li>
</ol>
<ul>
<li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code><br><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot"><br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></li>
</ul>
<p>MemoryPack menggunakan tag rilis <em>.</em>.*, jadi Anda dapat menentukan versi seperti #1.0.0. Contoh: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p>
<p>Seperti halnya versi .NET, kode dihasilkan oleh code generator (<code>MemoryPack.Generator.dll</code>). Implementasi tanpa refleksi juga memberikan performa terbaik di IL2CPP.</p>
<p>Untuk informasi lebih lanjut tentang Unity dan Source Generator, silakan lihat <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">dokumentasi Unity</a>.</p>
<p>Source Generator juga digunakan secara resmi oleh Unity oleh <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">com.unity.properties</a> dan <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html">com.unity.entities</a>. Dengan kata lain, ini adalah standar untuk code generation di Unity generasi berikutnya.</p>
<p>Anda dapat melakukan serialisasi semua tipe unmanaged (seperti <code>Vector3</code>, <code>Rect</code>, dll...) dan beberapa kelas (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>). Jika Anda ingin melakukan serialisasi tipe khusus Unity lainnya, lihat bagian <a href="#serialize-external-types">Serialize external types</a>.</p>
<p>Dalam performa Unity, MemoryPack x3~x10 lebih cepat dari JsonUtility.</p>
<p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p>
<p>Jika kode bersama memiliki tipe Unity (<code>Vector2</code>, dll...), MemoryPack menyediakan paket <code>MemoryPack.UnityShims</code> di NuGet.</p>
<p>Paket <code>MemoryPack.UnityShims</code> menyediakan shim untuk struct standar Unity (<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) dan beberapa kelas (<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>).</p>
<blockquote>
<p>[!WARNING]<br>Saat ini, terdapat batasan-batasan berikut untuk penggunaan di Unity</p>
</blockquote>
<ol>
<li>Versi Unity tidak mendukung CustomFormatter.</li>
<li>Jika Anda menggunakan .NET7 atau lebih baru, format biner MemoryPack tidak sepenuhnya kompatibel dengan Unity.<ul>
<li>Masalah ini terjadi pada tipe value yang secara eksplisit diberikan <code>[StructLayout(LayoutKind.Auto)]</code>. (Default untuk struct adalah <code>LayoutKind.Sequencial</code>.) Untuk tipe seperti ini, binary yang diserialisasi di .NET tidak dapat dideserialisasi di Unity. Begitu juga sebaliknya, binary yang diserialisasi di Unity tidak dapat dideserialisasi di sisi .NET.</li>
<li>Tipe yang terpengaruh biasanya meliputi tipe berikut.<ul>
<li><code>DateTimeOffset</code></li>
<li><code>ValueTuple</code></li>
</ul>
</li>
<li>Solusi sederhana saat ini adalah tidak menggunakan tipe-tipe ini.</li>
</ul>
</li>
</ol>
<h2>Native AOT</h2>
<p>Sayangnya, .NET 7 Native AOT menyebabkan crash (<code>Generic virtual method pointer lookup failure</code>) saat menggunakan MemoryPack karena bug runtime.<br>Akan diperbaiki di .NET 8. Menggunakan versi preview <code>Microsoft.DotNet.ILCompiler</code> akan memperbaikinya di .NET 7. Silakan lihat <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611">komentar issue</a> untuk cara setup-nya.</p>
<h2>Spesifikasi format wire biner</h2>
<p>Tipe <code>T</code> yang didefinisikan dalam <code>Serialize&lt;T&gt;</code> dan <code>Deserialize&lt;T&gt;</code> disebut skema C#. Format MemoryPack bukanlah format self-described. Deserialisasi membutuhkan skema C# yang sesuai. Tipe-tipe ini ada sebagai representasi internal dari binary, namun tipe tidak dapat ditentukan tanpa skema C#.</p>
<p>Endian harus <code>Little Endian</code>. Namun, implementasi referensi C# tidak memperhatikan endianness sehingga tidak dapat digunakan pada mesin big-endian. Namun, komputer modern biasanya menggunakan little-endian.</p>
<p>Ada delapan tipe format.</p>
<ul>
<li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>Circular Reference Object</li>
<li>Tuple</li>
<li>Collection</li>
<li>String</li>
<li>Union</li>
</ul>
<h3>Unmanaged struct</h3>
<p>Unmanaged struct adalah struct C# yang tidak mengandung tipe referensi, dengan batasan serupa pada <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>. Serialisasi struct sesuai dengan layout aslinya, termasuk padding.</p>
<h3>Object</h3>
<p><code>(byte memberCount, [values...])</code></p>
<p>Object memiliki 1 byte unsigned sebagai jumlah anggota di header. Jumlah anggota mengizinkan <code>0</code> hingga <code>249</code>, <code>255</code> merepresentasikan object adalah <code>null</code>. Values menyimpan nilai memorypack sebanyak jumlah anggota.</p>
<h3>Version Tolerant Object</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], [values...])</code></p>
<p>Version Tolerant Object mirip dengan Object tetapi memiliki panjang byte dari values di header. varint mengikuti spesifikasi ini, sbyte pertama adalah nilai atau typeCode dan X byte berikutnya adalah nilai. 0 hingga 127 = unsigned byte value, -1 hingga -120 = signed byte value, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p>
<h3>Circular Reference Object</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])</code><br><code>(250, varint referenceId)</code></p>
<p>Circular Reference Object mirip dengan Version Tolerant Object tetapi jika memberCount adalah 250, varint(unsigned-int32) berikutnya adalah referenceId. Jika tidak, setelah byte-length-of-values, varint referenceId ditulis.</p>
<h3>Tuple</h3>
<p><code>(values...)</code></p>
<p>Tuple adalah koleksi nilai dengan ukuran tetap dan tidak dapat bernilai null. Di .NET, <code>KeyValuePair&lt;TKey, TValue&gt;</code> dan <code>ValueTuple&lt;T,...&gt;</code> diserialisasi sebagai Tuple.</p>
<h3>Collection</h3>
<p><code>(int length, [values...])</code></p>
<p>Collection memiliki 4 byte signed integer sebagai jumlah data di header, <code>-1</code> merepresentasikan <code>null</code>. Values menyimpan nilai memorypack sebanyak jumlah length.</p>
<h3>String</h3>
<p><code>(int utf16-length, utf16-value)</code><br><code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)</code></p>
<p>String memiliki dua bentuk, UTF16 dan UTF8. Jika 4 byte signed integer pertama adalah <code>-1</code>, merepresentasikan null. <code>0</code>, merepresentasikan kosong. UTF16 sama seperti collection (diserialisasi sebagai <code>ReadOnlySpan&lt;char&gt;</code>, jumlah byte utf16-value adalah utf16-length * 2). Jika signed integer pertama &lt;= <code>-2</code>, nilai diencode dengan UTF8. utf8-byte-count diencode dalam bentuk komplemen, gunakan <code>~utf8-byte-count</code> untuk mendapatkan jumlah byte. Signed integer berikutnya adalah utf16-length, mengizinkan <code>-1</code> yang berarti panjang tidak diketahui. utf8-bytes menyimpan byte sebanyak utf8-byte-count.</p>
<h3>Union</h3>
<p><code>(byte tag, value)</code><br><code>(250, ushort tag, value)</code></p>
<p>Byte unsigned pertama adalah tag untuk tipe nilai yang dibedakan atau flag, <code>0</code> hingga <code>249</code> merepresentasikan tag, <code>250</code> berarti unsigned short berikutnya adalah tag, <code>255</code> merepresentasikan union adalah <code>null</code>.</p>
<h2>License</h2>
<p>Perpustakaan ini dilisensikan di bawah MIT License.</p>
<hr>
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-09</p>
<hr>
</div>
    </div>

    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async=""></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
    <script src="view.js"></script>


</body></html>