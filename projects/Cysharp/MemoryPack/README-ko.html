<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemoryPack - Cysharp/MemoryPack</title>

    <!-- Primary Meta Tags -->
    <meta name="title" content="MemoryPack - Cysharp/MemoryPack">
    <meta name="description" content="Cysharp/MemoryPack - GitHub repository ko documentation and information">
    <meta name="keywords" content="Cysharp, MemoryPack, GitHub, repository, ko documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/Cysharp/MemoryPack/README-ko.html">
    <meta property="og:title" content="MemoryPack - Cysharp/MemoryPack">
    <meta property="og:description" content="Cysharp/MemoryPack - GitHub repository ko documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">

    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">

    <!-- Marked.js for Markdown rendering -->
    <script type="text/javascript" async="" src="https://www.statcounter.com/counter/recorder.js"></script><script src="/js/marked.min.js?v=20250613"></script>
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        /* Layout */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .main-container {
            margin: 0 auto;
            width: 100%;
            max-width: 980px;
            padding: 0 20px;
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0 15px;
            }
        }

        /* Image size restrictions */
        .markdown-body img {
            max-width: 100%;
            height: auto;
        }

        /* Existing styles */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f6f8fa;
            border-bottom: 1px solid #e1e4e8;
            position: relative;
        }

        .back-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #0366d6;
            text-decoration: none;
            display: flex;
            align-items: center;
            font-size: 14px;
            padding: 5px 10px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            background-color: #fff;
        }

        .back-button:hover {
            background-color: #f6f8fa;
            border-color: #0366d6;
        }

        .back-button::before {
            content: "←";
            margin-right: 5px;
            font-size: 16px;
        }

        .header .links {
            margin-top: 10px;
            font-size: 16px;
        }

        .header .links a {
            color: #0366d6;
            text-decoration: none;
            margin-left: 5px;
        }

        .header .links a:hover {
            text-decoration: underline;
        }
        
        /* Language badges styles */
        .language-badges {
            margin-top: 15px;
            text-align: center;
        }
        .language-badges a {
            display: inline-block;
            margin: 2px;
            text-decoration: none;
        }
        .language-badges img {
            height: 20px;
            border-radius: 3px;
        }
        .language-badges a:hover img {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/Cysharp/MemoryPack" id="githubRepoLink" target="_blank">Cysharp/MemoryPack</a>
        </div>
        <div class="language-badges" id="languageBadges"><a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=en"><img src="https://img.shields.io/badge/EN-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-CN"><img src="https://img.shields.io/badge/简中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=zh-TW"><img src="https://img.shields.io/badge/繁中-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ja"><img src="https://img.shields.io/badge/日本語-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ko"><img src="https://img.shields.io/badge/한국어-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=th"><img src="https://img.shields.io/badge/ไทย-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=fr"><img src="https://img.shields.io/badge/Français-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=de"><img src="https://img.shields.io/badge/Deutsch-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=es"><img src="https://img.shields.io/badge/Español-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=it"><img src="https://img.shields.io/badge/Italiano-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ru"><img src="https://img.shields.io/badge/Русский-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pt"><img src="https://img.shields.io/badge/Português-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=nl"><img src="https://img.shields.io/badge/Nederlands-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=pl"><img src="https://img.shields.io/badge/Polski-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=ar"><img src="https://img.shields.io/badge/العربية-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=tr"><img src="https://img.shields.io/badge/Türkçe-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=vi"><img src="https://img.shields.io/badge/Tiếng Việt-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=hi"><img src="https://img.shields.io/badge/हिंदी-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=fa"><img src="https://img.shields.io/badge/فارسی-white" alt="version"></a> <a href="https://openaitx.github.io/view.html?user=Cysharp&amp;project=MemoryPack&amp;lang=id"><img src="https://img.shields.io/badge/Bahasa Indonesia-white" alt="version"></a></div>
    </div>

    <div class="main-container">
        <div class="markdown-body" id="content"><h1>MemoryPack</h1>
<p><a href="https://www.nuget.org/packages/MemoryPack"><img src="https://img.shields.io/nuget/v/MemoryPack.svg" alt="NuGet"></a><br><a href="https://github.com/Cysharp/MemoryPack/actions"><img src="https://github.com/Cysharp/MemoryPack/workflows/Build-Debug/badge.svg" alt="GitHub Actions"></a><br><a href="https://github.com/Cysharp/MemoryPack/releases"><img src="https://img.shields.io/github/release/Cysharp/MemoryPack.svg" alt="Releases"></a></p>
<p>C#와 Unity를 위한 제로 인코딩 초고성능 바이너리 직렬화기입니다.</p>
<p><img src="https://user-images.githubusercontent.com/46207/200979655-63ed38ae-dad2-4ca0-bbb7-9e0aa98914af.png" alt="image"></p>
<blockquote>
<p><a href="https://learn.microsoft.com/ja-jp/dotnet/api/system.text.json">System.Text.Json</a>, <a href="https://github.com/protobuf-net/protobuf-net">protobuf-net</a>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>, <a href="https://github.com/dotnet/orleans/">Orleans.Serialization</a>과 비교하였습니다. .NET 7 / Ryzen 9 5950X 머신에서 측정하였습니다. 이 직렬화기들은 <code>IBufferWriter&lt;byte&gt;</code> 메서드를 가지고 있으며, <code>ArrayBufferWriter&lt;byte&gt;</code>를 사용하여 직렬화하고, 버퍼 복사를 측정하지 않도록 재사용하였습니다.</p>
</blockquote>
<p>일반 객체의 경우, MemoryPack은 x10 더 빠르며, 다른 바이너리 직렬화기보다 x2 ~ x5 더 빠릅니다. 구조체 배열의 경우, MemoryPack은 더욱 강력해서 다른 직렬화기보다 x50 ~ x200까지 빠른 속도를 자랑합니다.</p>
<p>MemoryPack은 제가 만든 네 번째 직렬화기로, 이전에는 유명한 직렬화기인 <del><a href="https://github.com/neuecc/ZeroFormatter">ZeroFormatter</a></del>, <del><a href="https://github.com/neuecc/Utf8Json">Utf8Json</a></del>, <a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack for C#</a>을 만들었습니다. MemoryPack이 빠른 이유는 C#에 특화되고 최적화된 바이너리 포맷과, 과거의 경험을 바탕으로 잘 다듬어진 구현 덕분입니다. 또한 .NET 7, C# 11 및 Incremental Source Generator를 활용한 완전히 새로운 설계이며 (.NET Standard 2.1 (.NET 5, 6) 및 Unity 지원 포함)입니다.</p>
<p>다른 직렬화기는 VarInt 인코딩, 태그, 문자열 등 다양한 인코딩 작업을 많이 수행합니다. MemoryPack 포맷은 가능한 한 많은 C# 메모리를 복사하는 제로 인코딩 설계를 사용합니다. 제로 인코딩은 FlatBuffers와 유사하지만, 특별한 타입이 필요 없으며, MemoryPack의 직렬화 대상은 POCO입니다.</p>
<p>성능 외에도, MemoryPack은 다음과 같은 기능을 제공합니다.</p>
<ul>
<li>최신 I/O API 지원 (<code>IBufferWriter&lt;byte&gt;</code>, <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>)</li>
<li>Native AOT 친화적인 Source Generator 기반 코드 생성, Dynamic CodeGen(IL.Emit) 미사용</li>
<li>리플렉션 없는 비제네릭 API</li>
<li>기존 인스턴스에 대한 역직렬화 지원</li>
<li>다형성(Union) 직렬화 지원</li>
<li>제한적 버전 내성(fast/default) 및 완전한 버전 내성 지원</li>
<li>순환 참조 직렬화 지원</li>
<li>PipeWriter/Reader 기반 스트리밍 직렬화 지원</li>
<li>TypeScript 코드 생성 및 ASP.NET Core Formatter</li>
<li>Unity(2021.3) IL2CPP 지원(.NET Source Generator 기반)</li>
</ul>
<h2>설치</h2>
<p>이 라이브러리는 NuGet을 통해 배포됩니다. 최고의 성능을 위해 <code>.NET 7</code> 사용을 권장합니다. 최소 요구 사항은 <code>.NET Standard 2.1</code>입니다.</p>
<blockquote>
<p>PM&gt; Install-Package <a href="https://www.nuget.org/packages/MemoryPack">MemoryPack</a></p>
</blockquote>
<p>그리고 코드 에디터는 Roslyn 4.3.1 지원이 필요합니다. 예를 들어 Visual Studio 2022 버전 17.3, .NET SDK 6.0.401 등이 해당됩니다. 자세한 사항은 <a href="https://learn.microsoft.com/en-us/visualstudio/extensibility/roslyn-version-support">Roslyn Version Support</a> 문서를 참고하세요.</p>
<p>Unity의 경우 요구 사항 및 설치 과정이 완전히 다릅니다. 자세한 내용은 <a href="#unity">Unity</a> 섹션을 참고하세요.</p>
<h2>빠른 시작</h2>
<p>직렬화할 struct 또는 class를 정의하고 <code>[MemoryPackable]</code> 특성과 <code>partial</code> 키워드를 지정하세요.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack;

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>직렬화 코드는 C# 소스 생성기 기능에 의해 생성되며, <code>IMemoryPackable&lt;T&gt;</code> 인터페이스를 구현합니다. Visual Studio에서는 클래스 이름에 커서를 두고 단축키 <code>Ctrl+K, R</code>을 사용하여 생성된 코드인 <code>*.MemoryPackFormatter.g.cs</code>를 확인할 수 있습니다.</p>
<p>객체 인스턴스의 직렬화/역직렬화는 <code>MemoryPackSerializer.Serialize&lt;T&gt;/Deserialize&lt;T&gt;</code>를 호출하세요.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Person { Age = <span class="hljs-number">40</span>, Name = <span class="hljs-string">"John"</span> };

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(v);
<span class="hljs-keyword">var</span> val = MemoryPackSerializer.Deserialize&lt;Person&gt;(bin);
</code></pre>
<p><code>Serialize</code> 메서드는 <code>byte[]</code> 반환뿐만 아니라 <code>IBufferWriter&lt;byte&gt;</code> 또는 <code>Stream</code>에도 직렬화할 수 있습니다. <code>Deserialize</code> 메서드는 <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>, <code>Stream</code>을 지원합니다. 또한 비제네릭 버전도 존재합니다.</p>
<h2>내장 지원 타입</h2>
<p>다음 타입들은 기본적으로 직렬화가 가능합니다:</p>
<ul>
<li>.NET 프리미티브(<code>byte</code>, <code>int</code>, <code>bool</code>, <code>char</code>, <code>double</code> 등)</li>
<li>비관리형 타입(모든 <code>enum</code>, 참조 타입을 포함하지 않는 사용자 정의 <code>struct</code>)</li>
<li><code>string</code>, <code>decimal</code>, <code>Half</code>, <code>Int128</code>, <code>UInt128</code>, <code>Guid</code>, <code>Rune</code>, <code>BigInteger</code></li>
<li><code>TimeSpan</code>,  <code>DateTime</code>, <code>DateTimeOffset</code>, <code>TimeOnly</code>, <code>DateOnly</code>, <code>TimeZoneInfo</code></li>
<li><code>Complex</code>, <code>Plane</code>, <code>Quaternion</code>, <code>Matrix3x2</code>, <code>Matrix4x4</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code></li>
<li><code>Uri</code>, <code>Version</code>, <code>StringBuilder</code>, <code>Type</code>, <code>BitArray</code>, <code>CultureInfo</code></li>
<li><code>T[]</code>, <code>T[,]</code>, <code>T[,,]</code>, <code>T[,,,]</code>, <code>Memory&lt;&gt;</code>, <code>ReadOnlyMemory&lt;&gt;</code>, <code>ArraySegment&lt;&gt;</code>, <code>ReadOnlySequence&lt;&gt;</code></li>
<li><code>Nullable&lt;&gt;</code>, <code>Lazy&lt;&gt;</code>, <code>KeyValuePair&lt;,&gt;</code>, <code>Tuple&lt;,...&gt;</code>, <code>ValueTuple&lt;,...&gt;</code></li>
<li><code>List&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>SortedSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code></li>
<li><code>Dictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>,  <code>ReadOnlyDictionary&lt;,&gt;</code> </li>
<li><code>Collection&lt;&gt;</code>, <code>ReadOnlyCollection&lt;&gt;</code>, <code>ObservableCollection&lt;&gt;</code>, <code>ReadOnlyObservableCollection&lt;&gt;</code></li>
<li><code>IEnumerable&lt;&gt;</code>, <code>ICollection&lt;&gt;</code>, <code>IList&lt;&gt;</code>, <code>IReadOnlyCollection&lt;&gt;</code>, <code>IReadOnlyList&lt;&gt;</code>, <code>ISet&lt;&gt;</code></li>
<li><code>IDictionary&lt;,&gt;</code>, <code>IReadOnlyDictionary&lt;,&gt;</code>, <code>ILookup&lt;,&gt;</code>, <code>IGrouping&lt;,&gt;</code>,</li>
<li><code>ConcurrentBag&lt;&gt;</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>, <code>BlockingCollection&lt;&gt;</code></li>
<li>불변 컬렉션(<code>ImmutableList&lt;&gt;</code> 등) 및 인터페이스(<code>IImmutableList&lt;&gt;</code> 등)</li>
</ul>
<h2><code>[MemoryPackable]</code> <code>class</code> / <code>struct</code> / <code>record</code> / <code>record struct</code> 정의</h2>
<p><code>[MemoryPackable]</code>은 모든 <code>class</code>, <code>struct</code>, <code>record</code>, <code>record struct</code>, <code>interface</code>에 지정할 수 있습니다. 만약 타입이 참조 타입을 포함하지 않는 <code>struct</code> 또는 <code>record struct</code>( <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# 비관리형 타입</a>)이라면 추가 어노테이션(무시, 포함, 생성자, 콜백)은 사용되지 않고 메모리에서 직접 직렬화/역직렬화됩니다.</p>
<p>그 외의 경우, 기본적으로 <code>[MemoryPackable]</code>은 public 인스턴스 프로퍼티나 필드를 직렬화합니다. <code>[MemoryPackIgnore]</code>를 사용하면 직렬화 대상에서 제외할 수 있고, <code>[MemoryPackInclude]</code>를 사용하면 private 멤버를 직렬화 대상으로 승격할 수 있습니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// 기본적으로 직렬화되는 멤버</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicField;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> PublicReadOnlyField;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PrivateSetPublicProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ReadOnlyPublicProperty { <span class="hljs-keyword">get</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> RequiredInitProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }

    <span class="hljs-comment">// 기본적으로 직렬화되지 않는 멤버</span>
    <span class="hljs-built_in">int</span> privateProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-built_in">int</span> privateField;
    <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> privateReadOnlyField;

    <span class="hljs-comment">// public 멤버를 직렬화 대상에서 제외하려면 [MemoryPackIgnore] 사용</span>
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> PublicProperty2 =&gt; PublicProperty + PublicField;

    <span class="hljs-comment">// private 멤버를 직렬화 대상으로 승격하려면 [MemoryPackInclude] 사용</span>
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateField2;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    <span class="hljs-built_in">int</span> privateProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>MemoryPack</code>의 코드 생성기는 어떤 멤버가 직렬화되는지 <code>&lt;remarks /&gt;</code> 섹션에 정보를 추가합니다. 이는 Intellisense에서 타입에 마우스를 올리면 확인할 수 있습니다.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192393984-9af01fcb-872e-46fb-b08f-4783e8cef4ae.png" alt="image"></p>
<p>모든 멤버는 memorypack-직렬화가 가능해야 하며, 그렇지 않으면 코드 생성기가 오류를 발생시킵니다.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192413557-8a47d668-5339-46c5-a3da-a77841666f81.png" alt="image"></p>
<p>MemoryPack에는 쾌적한 사용을 위한 35개의 진단 규칙(<code>MEMPACK001</code> ~ <code>MEMPACK035</code>)이 있습니다.</p>
<p>타입이 외부에서 MemoryPack 직렬화가 정의되어 있고 등록된 경우, <code>[MemoryPackAllowSerialize]</code>를 사용하여 진단을 무시할 수 있습니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample2</span>
{
    [<span class="hljs-meta">MemoryPackAllowSerialize</span>]
    <span class="hljs-keyword">public</span> NotSerializableType? NotSerializableProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>멤버 순서는 <strong>중요</strong>합니다. MemoryPack은 멤버 이름이나 기타 정보를 직렬화하지 않고, 선언된 순서대로 필드를 직렬화합니다. 타입이 상속된 경우, 직렬화는 부모 → 자식 순서로 진행됩니다. 역직렬화 시 멤버 순서는 변경할 수 없습니다. 스키마 진화에 대해서는 <a href="#version-tolerant">버전 내성</a> 섹션을 참고하세요.</p>
<p>기본 순서는 선언순이지만, <code>[MemoryPackable(SerializeLayout.Explicit)]</code> 및 <code>[MemoryPackOrder()]</code>를 사용하여 명시적 레이아웃을 선택할 수 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Prop0 -&gt; Prop1 순서로 직렬화</span>
[<span class="hljs-meta">MemoryPackable(SerializeLayout.Explicit)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleExplicitOrder</span>
{
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h3>생성자 선택</h3>
<p>MemoryPack은 매개변수가 있는 생성자와 매개변수가 없는 생성자 모두를 지원합니다. 생성자 선택 규칙은 다음과 같습니다(클래스 및 구조체에 적용).</p>
<ul>
<li><code>[MemoryPackConstructor]</code>가 있으면 이를 사용합니다.</li>
<li>명시적 생성자가 없으면(비공개 포함) 매개변수 없는 생성자를 사용합니다.</li>
<li>매개변수 없는/있는 생성자가 하나만 있으면(비공개 포함) 이를 사용합니다.</li>
<li>여러 생성자가 있으면, 원하는 생성자에 반드시 <code>[MemoryPackConstructor]</code> 특성을 지정해야 하며(생성기가 자동으로 선택하지 않음), 그렇지 않으면 생성기가 오류를 발생시킵니다.</li>
<li>매개변수 있는 생성자를 사용할 경우, 모든 매개변수 이름은 해당 멤버 이름과 일치해야 합니다(대소문자 무관).</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> Age;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Name;

    <span class="hljs-comment">// 매개변수 생성자 사용 가능 - 매개변수 이름은 대응되는 멤버 이름과 일치해야 함(대소문자 무관)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
    {
        <span class="hljs-keyword">this</span>.Age = age;
        <span class="hljs-keyword">this</span>.Name = name;
    }
}

<span class="hljs-comment">// record의 primary constructor도 지원</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Person2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> Age, <span class="hljs-built_in">string</span> Name</span>)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>()</span>
    {
    }
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// 생성자가 여러 개인 경우, [MemoryPackConstructor]를 사용해야 합니다.</span>
[<span class="hljs-meta">MemoryPackConstructor</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person3</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> age, <span class="hljs-built_in">string</span> name</span>)</span>
{
    <span class="hljs-keyword">this</span>.Age = age;
    <span class="hljs-keyword">this</span>.Name = name;
}
</code></pre>
<h3>직렬화 콜백</h3>
<p>직렬화/역직렬화 시, MemoryPack은 <code>[MemoryPackOnSerializing]</code>, <code>[MemoryPackOnSerialized]</code>, <code>[MemoryPackOnDeserializing]</code>, <code>[MemoryPackOnDeserialized]</code> 속성을 사용하여 직렬화 전/후 이벤트를 호출할 수 있습니다. 이 속성은 static 및 인스턴스(비-static) 메서드, public 및 private 메서드 모두에 적용할 수 있습니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MethodCallSample</span>
{
    <span class="hljs-comment">// 메서드 호출 순서는 static -&gt; instance 입니다.</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing1));
    }

    <span class="hljs-comment">// private 메서드도 허용됩니다.</span>
    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerializing2));
    }

    <span class="hljs-comment">// serializing -&gt; /* serialize */ -&gt; serialized</span>
    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized1));
    }

    [<span class="hljs-meta">MemoryPackOnSerialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnSerialized2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing1));
    }

    <span class="hljs-comment">// 참고: MemoryPackOnDeserializing이 붙은 인스턴스 메서드는 인스턴스가 `ref`로 전달되지 않으면 호출되지 않습니다.</span>
    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserializing2));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized1</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized1));
    }

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized2</span>()</span>
    {
        Console.WriteLine(<span class="hljs-keyword">nameof</span>(OnDeserialized2));
    }
}
</code></pre>
<p>콜백은 매개변수가 없는 메서드와 <code>ref reader/writer, ref T value</code> 메서드를 허용합니다. 예를 들어, ref 콜백을 사용하면 직렬화 과정 전에 커스텀 헤더를 기록/읽기할 수 있습니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EmitIdData</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnSerializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteId</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)
        <span class="hljs-keyword">where</span> TBufferWriter : IBufferWriter&lt;<span class="hljs-built_in">byte</span>&gt; <span class="hljs-comment">// .NET Standard 2.1, 사용할 경우 where TBufferWriter : class, IBufferWriter&lt;byte&gt;</span></span>
    {
        writer.WriteUnmanaged(Guid.NewGuid()); <span class="hljs-comment">// 헤더에 GUID 기록</span>
    }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadId</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> EmitIdData? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-comment">// 역직렬화 전에 커스텀 헤더 읽기</span>
        <span class="hljs-keyword">var</span> guid = reader.ReadUnmanaged&lt;Guid&gt;();
        Console.WriteLine(guid);
    }
}
</code></pre>
<p><code>ref value</code>에 값을 할당하면 직렬화/역직렬화에 사용되는 값을 변경할 수 있습니다. 예를 들어, ServiceProvider에서 인스턴스를 생성할 수 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// 이 포매터를 사용하기 전에 ServiceProvider를 설정하세요.</span>
<span class="hljs-comment">// var options = MemoryPackSerializerOptions.Default with { ServiceProvider = provider };</span>
<span class="hljs-comment">// MemoryPackSerializer.Deserialize(value, options);</span>

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InstantiateFromServiceProvider</span>
{
    <span class="hljs-keyword">static</span> IServiceProvider serviceProvider = <span class="hljs-literal">default</span>!;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">MemoryPackOnDeserializing</span>]
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializing</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">ref</span> InstantiateFromServiceProvider <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">value</span> = reader.Options.ServiceProvider!.GetRequiredService&lt;InstantiateFromServiceProvider&gt;();
    }
}
</code></pre>
<h2>커스텀 컬렉션 정의</h2>
<p>기본적으로 <code>[MemoryPackObject]</code>가 적용된 타입은 멤버를 직렬화합니다. 하지만 타입이 컬렉션(<code>ICollection&lt;&gt;</code>, <code>ISet&lt;&gt;</code>, <code>IDictionary&lt;,&gt;</code>)인 경우, 올바른 직렬화를 위해 <code>GenerateType.Collection</code>을 사용해야 합니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt;
{
}

[<span class="hljs-meta">MemoryPackable(GenerateType.Collection)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyStringDictionary</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>&gt;
{

}
</code></pre>
<h2>정적 생성자</h2>
<p>MemoryPackable 클래스는 생성된 partial 클래스가 정적 생성자를 사용하기 때문에 정적 생성자를 정의할 수 없습니다. 대신, 동일한 동작을 위해 <code>static partial void StaticConstructor()</code>를 정의할 수 있습니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CctorSample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StaticConstructor</span>()</span>
    {
    }
}
</code></pre>
<h2>다형성(유니온)</h2>
<p>MemoryPack은 다형성 직렬화를 위해 인터페이스와 추상 클래스 객체의 직렬화를 지원합니다. MemoryPack에서는 이 기능을 Union이라고 부릅니다. <code>[MemoryPackUnion]</code> 속성은 인터페이스와 추상 클래스에만 적용할 수 있습니다. 고유한 union 태그가 필요합니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// [MemoryPackable]과 상속 타입에 [MemoryPackUnion]을 지정</span>
<span class="hljs-comment">// Union은 추상 클래스도 지원합니다.</span>
[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FooClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> XYZ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BarClass</span> : <span class="hljs-title">IUnionSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? OPQ { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
<span class="hljs-comment">// ---</span>

IUnionSample data = <span class="hljs-keyword">new</span> FooClass() { XYZ = <span class="hljs-number">999</span> };

<span class="hljs-comment">// 인터페이스 타입으로 직렬화</span>
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(data);

<span class="hljs-comment">// 인터페이스 타입으로 역직렬화</span>
<span class="hljs-keyword">var</span> reData = MemoryPackSerializer.Deserialize&lt;IUnionSample&gt;(bin);

<span class="hljs-keyword">switch</span> (reData)
{
    <span class="hljs-keyword">case</span> FooClass x:
        Console.WriteLine(x.XYZ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> BarClass x:
        Console.WriteLine(x.OPQ);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-literal">default</span>:
        <span class="hljs-keyword">break</span>;
}
</code></pre>
<p><code>tag</code>는 <code>0</code> ~ <code>65535</code>를 허용하며, <code>250</code> 미만에서는 특히 효율적입니다.</p>
<pre><code class="hljs language-csharp">인터페이스와 파생 타입이 서로 다른 어셈블리에 있는 경우, 대신 `MemoryPackUnionFormatterAttribute`를 사용할 수 있습니다. 포매터는 C<span class="hljs-meta"># 9.0 이상에서 `ModuleInitializer`를 통해 자동으로 등록되도록 생성됩니다.</span>

&gt; `ModuleInitializer`는 Unity에서 지원되지 않으므로, 포매터를 수동으로 등록해야 합니다. 유니언 포매터를 등록하려면 Startup에서 `{유니언 포매터 이름}Initializer.RegisterFormatter()`를 직접 호출하세요. 예를 들어, `UnionSampleFormatterInitializer.RegisterFormatter()`와 같이 사용합니다.

```csharp
<span class="hljs-comment">// AssemblyA</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.NoGenerate)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUnionSample</span>
{
}

<span class="hljs-comment">// AssemblyB에서 대상 타입 외부에 정의</span>
[<span class="hljs-meta">MemoryPackUnionFormatter(typeof(IUnionSample))</span>]
[<span class="hljs-meta">MemoryPackUnion(0, typeof(FooClass))</span>]
[<span class="hljs-meta">MemoryPackUnion(1, typeof(BarClass))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnionSampleFormatter</span>
{
}
</code></pre>
<p>유니언은 코드에서 <code>DynamicUnionFormatter&lt;T&gt;</code>를 통해 조립할 수 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// (ushort, Type)[]</span>
<span class="hljs-keyword">var</span> formatter = <span class="hljs-keyword">new</span> DynamicUnionFormatter&lt;IFooBarBaz&gt;(
    (<span class="hljs-number">0</span>, <span class="hljs-keyword">typeof</span>(Foo)),
    (<span class="hljs-number">1</span>, <span class="hljs-keyword">typeof</span>(Bar)),
    (<span class="hljs-number">2</span>, <span class="hljs-keyword">typeof</span>(Baz))
);

MemoryPackFormatterProvider.Register(formatter);
</code></pre>
<h2>Serialize API</h2>
<p><code>Serialize</code>는 세 가지 오버로드가 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// 제네릭이 아닌 API도 제공됩니다. 이 버전은 첫 번째 인자가 Type이고 값은 object?입니다.</span>
<span class="hljs-function"><span class="hljs-built_in">byte</span>[] <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> TBufferWriter bufferWriter, <span class="hljs-keyword">in</span> T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span></span>)
<span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, T? <span class="hljs-keyword">value</span>, MemoryPackSerializerOptions? options = <span class="hljs-literal">default</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
</span></code></pre>
<p>성능을 위해 권장되는 API는 <code>BufferWriter</code>를 사용하는 것입니다. 이 방식은 버퍼에 직접 직렬화합니다. <code>System.IO.Pipelines</code>의 <code>PipeWriter</code>, ASP .NET Core의 <code>BodyWriter</code> 등에 적용할 수 있습니다.</p>
<p>만약 <code>byte[]</code>가 필요한 경우(예: <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a>의 <code>RedisValue</code>), 반환되는 <code>byte[]</code> API는 간단하며 거의 동일한 속도를 보입니다.</p>
<p><code>Stream</code>용 <code>SerializeAsync</code>는 Flush에만 비동기식입니다. 모든 내용을 한 번에 MemoryPack의 내부 풀 버퍼에 직렬화한 뒤, <code>WriteAsync</code>로 작성합니다. 따라서 버퍼와 flush를 분리·제어할 수 있는 <code>BufferWriter</code> 오버로드가 더 우수합니다.</p>
<p>완전한 스트리밍 쓰기를 하고 싶다면, <a href="#streaming-serialization">Streaming Serialization</a> 섹션을 참고하세요.</p>
<h3>MemoryPackSerializerOptions</h3>
<p><code>MemoryPackSerializerOptions</code>는 문자열을 UTF16 또는 UTF8로 직렬화할지 여부를 설정합니다. UTF8 인코딩에는 <code>MemoryPackSerializerOptions.Utf8</code>, UTF16에는 <code>MemoryPackSerializerOptions.Utf16</code>, 기본값인 UTF8에는 <code>MemoryPackSerializerOptions.Default</code>를 전달하여 설정할 수 있습니다. null을 전달하거나 기본 파라미터를 사용할 경우 UTF8 인코딩이 됩니다.</p>
<p>C# 내부 문자열 표현은 UTF16이므로, UTF16이 더 나은 성능을 보입니다. 그러나 페이로드가 더 커질 수 있습니다. UTF8에서 ASCII 문자열은 1바이트이지만, UTF16에서는 2바이트입니다. 페이로드 크기 차이가 커서 기본값이 UTF8입니다.</p>
<p>데이터가 비ASCII(예: 일본어 등 3바이트 이상, UTF8이 더 커짐)이거나, 별도로 압축해야 하는 경우라면 UTF16이 더 나은 결과를 제공할 수 있습니다.</p>
<p>직렬화 시에는 UTF8 또는 UTF16을 선택할 수 있지만, 역직렬화 시에는 명시할 필요가 없습니다. 자동으로 감지되어 정상적으로 역직렬화됩니다.</p>
<p>또한 옵션에서 <code>IServiceProvider? ServiceProvider { get; init; }</code>를 get/set할 수 있습니다. 직렬화 과정에서 DI 객체(예: <code>ILogger&lt;T&gt;</code>)를 가져올 때 유용합니다(<code>MemoryPackReader/MemoryPackWriter</code>는 .Options 속성이 있습니다).</p>
<h2>Deserialize API</h2>
<p><code>Deserialize</code>는 <code>ReadOnlySpan&lt;byte&gt;</code>, <code>ReadOnlySequence&lt;byte&gt;</code>, <code>Stream</code> 오버로드 및 <code>ref</code> 지원을 제공합니다.</p>
<pre><code class="language-csharp hljs">T? Deserialize&lt;T&gt;(ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer)
<span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlySpan&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
T? <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer</span>)
<span class="hljs-built_in">int</span> <span class="hljs-title">Deserialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">in</span> ReadOnlySequence&lt;<span class="hljs-built_in">byte</span>&gt; buffer, <span class="hljs-keyword">ref</span> T? <span class="hljs-keyword">value</span></span>)
<span class="hljs-keyword">async</span> <span class="hljs-title">ValueTask</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream</span>)
</span></code></pre>
<p><code>ref</code> 오버로드는 기존 인스턴스를 덮어씁니다. 자세한 내용은 <a href="#overwrite">Overwrite</a> 섹션을 참고하세요.</p>
<p><code>DeserializeAsync(Stream)</code>는 완전한 스트리밍 읽기 작업이 아니며, 우선 MemoryPack의 내부 풀에 스트림 끝까지 읽은 후 역직렬화합니다.</p>
<p>완전한 스트리밍 읽기를 원한다면, <a href="#streaming-serialization">Streaming Serialization</a> 섹션을 참고하세요.</p>
<h2>Overwrite</h2>
<p>할당을 줄이기 위해, MemoryPack은 기존 인스턴스에 역직렬화하여 덮어쓰는 기능을 지원합니다. 이는 <code>Deserialize(ref T? value)</code> 오버로드와 함께 사용할 수 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();
<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(person);

<span class="hljs-comment">// 기존 인스턴스에 데이터를 덮어씁니다.</span>
MemoryPackSerializer.Deserialize(bin, <span class="hljs-keyword">ref</span> person);
</code></pre>
<p>MemoryPack은 가능한 한 많이 덮어쓰려 하지만, 아래 조건이 맞지 않으면(일반 역직렬화처럼) 새 인스턴스를 생성합니다.</p>
<ul>
<li>ref 값(객체 그래프 내 멤버 포함)이 null이면 새 인스턴스 할당</li>
<li>매개변수 없는 생성자만 허용, 매개변수 생성자 사용 시 새 인스턴스 생성</li>
<li>값이 <code>T[]</code>일 때 길이가 같으면 재사용, 다르면 새 인스턴스 생성</li>
<li><code>.Clear()</code> 메서드가 있는 컬렉션(<code>List&lt;&gt;</code>, <code>Stack&lt;&gt;</code>, <code>Queue&lt;&gt;</code>, <code>LinkedList&lt;&gt;</code>, <code>HashSet&lt;&gt;</code>, <code>PriorityQueue&lt;,&gt;</code>, <code>ObservableCollection</code>, <code>Collection</code>, <code>ConcurrentQueue&lt;&gt;</code>, <code>ConcurrentStack&lt;&gt;</code>, <code>ConcurrentBag&lt;&gt;</code>, <code>Dictionary&lt;,&gt;</code>, <code>SortedDictionary&lt;,&gt;</code>, <code>SortedList&lt;,&gt;</code>, <code>ConcurrentDictionary&lt;,&gt;</code>)이면 Clear() 호출 후 재사용, 아니면 새 인스턴스 생성</li>
</ul>
<h2>Version tolerant</h2>
<p>기본값(<code>GenerateType.Object</code>)에서 MemoryPack은 제한된 스키마 진화를 지원합니다.</p>
<ul>
<li>언매니지드 struct는 더 이상 변경할 수 없습니다</li>
<li>멤버는 추가할 수 있지만 삭제할 수 없습니다</li>
<li>멤버 이름 변경 가능</li>
<li>멤버 순서 변경 불가</li>
<li>멤버 타입 변경 불가</li>
</ul>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// 추가는 OK.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? AddedProp { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// 삭제는 NG.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-comment">// public int Prop1 { get; set; }</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// 순서 변경은 NG.</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionCheck</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>실제 사용 사례에서는, 이전 데이터를 저장(파일, Redis 등)하고 새 스키마로 읽는 것은 항상 가능합니다. RPC 시나리오에서는 클라이언트와 서버 양쪽에 스키마가 존재하므로, 반드시 클라이언트를 먼저 업데이트해야 합니다. 업데이트된 클라이언트는 이전 서버에 접속해도 문제가 없지만, 이전 클라이언트는 새 서버에 접속할 수 없습니다.</p>
<p>기본적으로 이전 데이터를 새 스키마로 읽을 때, 데이터 쪽에 없는 멤버는 <code>default</code> 리터럴로 초기화됩니다.<br>이것을 피하고 필드/프로퍼티의 초기값을 사용하고 싶다면 <code>[SuppressDefaultInitialization]</code>을 사용할 수 있습니다.</p>
<pre><code class="language-cs hljs language-csharp">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DefaultValue</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Prop1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">SuppressDefaultInitialization</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">111</span>; <span class="hljs-comment">// &lt; 이전 데이터에 없으면 `111` 할당.</span>
    
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Prop3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-number">222</span>; <span class="hljs-comment">// &lt; 이전 데이터에 없으면 `default` 할당.</span>
}
</code></pre>
<p><code>[SuppressDefaultInitialization]</code>는 다음과 같은 제한이 있습니다:</p>
<ul>
<li>readonly, init-only, required 한정자와 함께 사용할 수 없습니다.</li>
</ul>
<p>다음 <a href="#serialization-info">Serialization info</a> 섹션에서는 CI 등을 통해 스키마 변화를 검사하여 사고를 방지하는 방법을 보여줍니다.</p>
<p><code>GenerateType.VersionTolerant</code>를 사용하는 경우, 완전한 버전 관용성을 지원합니다.</p>
<ul>
<li>언매니지드 struct는 더 이상 변경할 수 없습니다</li>
<li>모든 멤버는 <code>[MemoryPackOrder]</code>를 명시적으로 추가해야 합니다(<code>SerializeLayout.Sequential</code>을 주석 처리한 경우 제외)</li>
<li>멤버는 추가/삭제 가능하나 순서 재사용 불가(누락된 순서 사용 가능)</li>
<li>멤버 이름 변경 가능</li>
<li>멤버 순서 변경 불가</li>
<li>멤버 타입 변경 불가</li>
</ul>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// 양방향 직렬화/역직렬화 가능</span>
<span class="hljs-comment">// VersionTolerantObject1 -&gt; VersionTolerantObject2 및 </span>
<span class="hljs-comment">// VersionTolerantObject2 -&gt; VersionTolerantObject1</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject1</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}

[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject2</span>
{
```csharp
[<span class="hljs-meta">MemoryPackOrder(0)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// 삭제됨</span>
<span class="hljs-comment">//[MemoryPackOrder(1)]</span>
<span class="hljs-comment">//public long MyProperty1 { get; set; } = default;</span>

[<span class="hljs-meta">MemoryPackOrder(2)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;

<span class="hljs-comment">// 추가됨</span>
[<span class="hljs-meta">MemoryPackOrder(3)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty3 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// SerializeLayout.Sequential을 명시적으로 설정하면, 자동으로 순서를 정렬할 수 있습니다.</span>
<span class="hljs-comment">// 하지만 버전-내성(Version-Tolerant)을 위해서는 멤버를 제거할 수 없습니다.</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.VersionTolerant, SerializeLayout.Sequential)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VersionTolerantObject3</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty0 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> MyProperty1 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">short</span> MyProperty2 { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>;
}
</code></pre>
<p><code>GenerateType.VersionTolerant</code>는 직렬화에서 <code>GenerateType.Object</code>보다 느립니다. 또한, 페이로드 크기가 약간 더 커집니다.</p>
<h2>Serialization info</h2>
<p>직렬화되는 멤버가 무엇인지 타입의 IntelliSense에서 확인할 수 있습니다. 이 정보를 컴파일 시 파일로 출력하는 옵션도 있습니다. <code>MemoryPackGenerator_SerializationInfoOutputDirectory</code>를 아래와 같이 설정하세요.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- memorypack 직렬화 정보를 디렉터리에 출력 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_SerializationInfoOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\MemoryPackLogs<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_SerializationInfoOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>아래와 같은 정보가 파일에 기록됩니다.</p>
<p><img src="https://user-images.githubusercontent.com/46207/192460684-c2fd8bcb-375e-41dd-9960-58205d5b1b7a.png" alt="image"></p>
<p>타입이 unmanaged인 경우, 타입 이름 앞에 <code>unmanaged</code>가 표시됩니다.</p>
<pre><code class="language-txt hljs language-plaintext">unmanaged FooStruct
---
int x
int y
</code></pre>
<p>이 파일의 차이점을 확인하면 위험한 스키마 변경을 방지할 수 있습니다. 예를 들어, CI를 사용해 다음 규칙을 감지할 수 있습니다.</p>
<ul>
<li>unmanaged 타입 수정</li>
<li>멤버 순서 변경</li>
<li>멤버 삭제</li>
</ul>
<h2>Circular Reference</h2>
<p>MemoryPack는 순환 참조(circular reference)도 지원합니다. 이를 통해 트리 구조 객체를 있는 그대로 직렬화할 수 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// 순환 참조를 활성화하려면 GenerateType.CircularReference를 사용하세요.</span>
[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> Node? Parent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Node[]? Children { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>예를 들어, <a href="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references">System.Text.Json preserve-references</a> 코드는 아래와 같습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/preserve-references?pivots=dotnet-7-0</span>
Employee tyler = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Tyler Stein"</span>
};

Employee adrian = <span class="hljs-keyword">new</span>()
{
    Name = <span class="hljs-string">"Adrian King"</span>
};

tyler.DirectReports = <span class="hljs-keyword">new</span> List&lt;Employee&gt; { adrian };
adrian.Manager = tyler;

<span class="hljs-keyword">var</span> bin = MemoryPackSerializer.Serialize(tyler);
Employee? tylerDeserialized = MemoryPackSerializer.Deserialize&lt;Employee&gt;(bin);

Console.WriteLine(tylerDeserialized?.DirectReports?[<span class="hljs-number">0</span>].Manager == tylerDeserialized); <span class="hljs-comment">// true</span>

[<span class="hljs-meta">MemoryPackable(GenerateType.CircularReference)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>
{
    [<span class="hljs-meta">MemoryPackOrder(0)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(1)</span>]
    <span class="hljs-keyword">public</span> Employee? Manager { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    [<span class="hljs-meta">MemoryPackOrder(2)</span>]
    <span class="hljs-keyword">public</span> List&lt;Employee&gt;? DirectReports { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>GenerateType.CircularReference</code>는 버전-내성(Version-Tolerant)과 동일한 특성을 가집니다. 하지만 추가 제약으로, 파라미터가 없는 생성자만 허용됩니다. 또한, 객체 참조 추적은 <code>GenerateType.CircularReference</code>로 표시된 객체에만 적용됩니다. 다른 객체도 추적하고 싶다면 래핑(wrap)하세요.</p>
<h2>CustomFormatter</h2>
<p><code>MemoryPackCustomFormatterAttribute&lt;T&gt;</code> 또는 <code>MemoryPackCustomFormatterAttribute&lt;TFormatter, T&gt;</code>(더 성능이 뛰어나지만 복잡함)를 구현하면, MemoryPackObject의 멤버에 사용자 지정 포매터(custom formatter)를 사용할 수 있습니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = false, Inherited = false)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">Attribute</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> IMemoryPackFormatter&lt;T&gt; <span class="hljs-title">GetFormatter</span>()</span>;
}
</code></pre>
<p>MemoryPack는 다음과 같은 포매팅 어트리뷰트를 제공합니다: <code>Utf8StringFormatterAttribute</code>, <code>Utf16StringFormatterAttribute</code>, <code>InternStringFormatterAttribute</code>, <code>OrdinalIgnoreCaseStringDictionaryFormatterAttribute&lt;TValue&gt;</code>, <code>BitPackFormatterAttribute</code>, <code>BrotliFormatter</code>, <code>BrotliStringFormatter</code>, <code>BrotliFormatter&lt;T&gt;</code>, <code>MemoryPoolFormatter&lt;T&gt;</code>, <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-comment">// 이 멤버를 UTF16 String으로 직렬화합니다. 이는 UTF8보다 성능이 좋지만, ASCII에서는 크기가 크고(비 ASCII에서는 경우에 따라 더 작음).</span>
    [<span class="hljs-meta">Utf16StringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Text { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment">// 역직렬화 시, Dictionary가 StringComparer.OrdinalIgnoreCase로 초기화됩니다.</span>
    [<span class="hljs-meta">OrdinalIgnoreCaseStringDictionaryFormatter&lt;int&gt;</span>]
    <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;? Ids { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    
    <span class="hljs-comment">// 역직렬화 시, 모든 string은 interned 됩니다(참고: String.Intern). 유사한 값이 반복되면 메모리를 절약할 수 있습니다.</span>
    [<span class="hljs-meta">InternStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? Flag { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>집합/딕셔너리의 equality comparer를 구성하려면, 모든 내장 포매터에 comparer 생성자 오버로드가 있습니다. 커스텀 equality-comparer 포매터를 쉽게 만들 수 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OrdinalIgnoreCaseStringDictionaryFormatter</span>&lt;<span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">MemoryPackCustomFormatterAttribute</span>&lt;<span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">string</span>, <span class="hljs-title">TValue</span>?&gt;&gt;
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt; formatter = <span class="hljs-keyword">new</span> DictionaryFormatter&lt;<span class="hljs-built_in">string</span>, TValue?&gt;(StringComparer.OrdinalIgnoreCase);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> IMemoryPackFormatter&lt;Dictionary&lt;<span class="hljs-built_in">string</span>, TValue?&gt;&gt; GetFormatter()
    {
        <span class="hljs-keyword">return</span> formatter;
    }
}
</code></pre>
<p><code>BitPackFormatter</code>는 <code>bool[]</code> 타입만 압축합니다. <code>bool[]</code>은 일반적으로 boolean 값 하나당 1바이트로 직렬화되지만, <code>BitPackFormatter</code>는 각 bool을 1비트로 저장하는 <code>BitArray</code>처럼 직렬화합니다. <code>BitPackFormatter</code>를 사용하면 8개의 bool이 1바이트가 되어, 기존 8바이트에서 8배 더 작은 크기가 됩니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BitPackFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>[]? Data { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter</code>는 <code>byte[]</code>용으로, 예를 들어 큰 페이로드를 Brotli로 압축할 수 있습니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliStringFormatter</code>는 <code>string</code>용으로, 문자열(UTF16)을 Brotli로 압축하여 직렬화합니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliStringFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>? LargeText { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p><code>BrotliFormatter&lt;T&gt;</code>는 모든 타입에 사용할 수 있으며, 직렬화된 데이터는 Brotli로 압축됩니다. 타입이 <code>byte[]</code> 또는 <code>string</code>인 경우 성능을 위해 <code>BrotliFormatter</code> 또는 <code>BrotliStringFormatter</code>를 사용하는 것이 좋습니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter&lt;ChildType&gt;</span>]
    <span class="hljs-keyword">public</span> ChildType? Child { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>배열 풀링을 이용한 역직렬화</h2>
<p>대용량 배열(임의의 <code>T</code>)을 역직렬화하기 위해 MemoryPack은 여러 효율적인 풀링 방법을 제공합니다. 가장 효과적인 방법은 <a href="#overwrite">#Overwrite</a> 기능을 사용하는 것입니다. 특히 <code>List&lt;T&gt;</code>는 항상 재사용됩니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ListBytesSample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">byte</span>&gt; Payload</span> { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// ----</span>

<span class="hljs-comment">// List&lt;byte&gt;는 재사용되며, 역직렬화 시 별도의 할당이 없습니다.</span>
MemoryPackSerializer.Deserialize&lt;ListBytesSample&gt;(bin, <span class="hljs-keyword">ref</span> reuseObject);

<span class="hljs-comment">// 효율적인 작업을 위해 CollectionsMarshal을 사용하여 Span&lt;T&gt;를 얻을 수 있습니다.</span>
<span class="hljs-keyword">var</span> span = CollectionsMarshal.AsSpan(<span class="hljs-keyword">value</span>.Payload);
</code></pre>
<p>간편하게 ArrayPool로 역직렬화할 수도 있습니다. MemoryPack은 <code>MemoryPoolFormatter&lt;T&gt;</code>와 <code>ReadOnlyMemoryPoolFormatter&lt;T&gt;</code>를 제공합니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PoolModelSample</span> : <span class="hljs-title">IDisposable</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; }

    [<span class="hljs-meta">MemoryPoolFormatter&lt;byte&gt;</span>]
    <span class="hljs-keyword">public</span> Memory&lt;<span class="hljs-built_in">byte</span>&gt; Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PoolModelSample</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, Memory&lt;<span class="hljs-built_in">byte</span>&gt; payload</span>)</span>
    {
        Id = id;
        Payload = payload;
    }

    <span class="hljs-comment">// 반환 코드는 직접 작성해야 하며, 아래는 예시입니다.</span>

    <span class="hljs-built_in">bool</span> usePool;

    [<span class="hljs-meta">MemoryPackOnDeserialized</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserialized</span>()</span>
    {
        usePool = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span>
    {
        <span class="hljs-keyword">if</span> (!usePool) <span class="hljs-keyword">return</span>;

        Return(Payload); Payload = <span class="hljs-literal">default</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Memory&lt;T&gt; memory</span>)</span> =&gt; Return((ReadOnlyMemory&lt;T&gt;)memory);

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Return</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">ReadOnlyMemory&lt;T&gt; memory</span>)</span>
    {
        <span class="hljs-keyword">if</span> (MemoryMarshal.TryGetArray(memory, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> segment) &amp;&amp; segment.Array <span class="hljs-keyword">is</span> { Length: &gt; <span class="hljs-number">0</span> })
        {
            ArrayPool&lt;T&gt;.Shared.Return(segment.Array, clearArray: RuntimeHelpers.IsReferenceOrContainsReferences&lt;T&gt;());
        }
    }
}

<span class="hljs-comment">// ---</span>

<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;PoolModelSample&gt;(bin))
{
    <span class="hljs-comment">// do anything...</span>
}   <span class="hljs-comment">// ArrayPool로 반환됨</span>
</code></pre>
<h2>성능</h2>
<p>블로그 글을 참고하세요: <a href="https://medium.com/@neuecc/how-to-make-the-fastest-net-serializer-with-net-7-c-11-case-of-memorypack-ad28c0366516">How to make the fastest .NET Serializer with .NET 7 / C# 11, case of MemoryPack</a></p>
<h2>페이로드 크기 및 압축</h2>
<p>페이로드 크기는 대상 값에 따라 다릅니다. JSON과 달리 키가 없고 이진 포맷이기 때문에 페이로드 크기는 대체로 JSON보다 작습니다.</p>
<p>varint 인코딩(MessagePack, Protobuf 등)이 있는 경우, int를 많이 사용할 때 MemoryPack이 더 커지는 경향이 있습니다(MemoryPack에서는 고정 크기 인코딩으로 int가 항상 4바이트, MessagePack에서는 1~5바이트).</p>
<p>float와 double은 MemoryPack에서는 각각 4바이트, 8바이트이고, MessagePack에서는 각각 5바이트, 9바이트입니다. 따라서 예를 들어 Vector3(float, float, float) 배열의 경우 MemoryPack이 더 작습니다.</p>
<p>문자열은 기본적으로 UTF8로, 다른 직렬화기와 유사하지만, UTF16 옵션을 선택하면 성격이 달라집니다.</p>
<p>어쨌든 페이로드 크기가 크면 압축을 고려해야 합니다. LZ4, ZStandard, Brotli를 추천합니다.</p>
<h3>압축</h3>
<p>MemoryPack은 <a href="https://github.com/google/brotli">Brotli</a> 압축을 위해 <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotliencoder">BrotliEncoder</a> 및 <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.compression.brotlidecoder">BrotliDecoder</a>를 통한 효율적인 헬퍼를 제공합니다. MemoryPack의 <code>BrotliCompressor</code>와 <code>BrotliDecompressor</code>는 MemoryPack의 내부 동작에 최적화된 압축/해제압축을 제공합니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// 압축(사용 필요)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> compressor = <span class="hljs-keyword">new</span> BrotliCompressor();
MemoryPackSerializer.Serialize(compressor, <span class="hljs-keyword">value</span>);

<span class="hljs-comment">// 압축된 byte[] 가져오기</span>
<span class="hljs-keyword">var</span> compressedBytes = compressor.ToArray();

<span class="hljs-comment">// 또는 다른 IBufferWriter&lt;byte&gt;(예: PipeWriter)에 쓰기</span>
compressor.CopyTo(response.BodyWriter);
</code></pre>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">using</span> MemoryPack.Compression;

<span class="hljs-comment">// 해제압축(사용 필요)</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> decompressor = <span class="hljs-keyword">new</span> BrotliDecompressor();

<span class="hljs-comment">// ReadOnlySpan&lt;byte&gt; 또는 ReadOnlySequence&lt;byte&gt;에서 해제압축된 ReadOnlySequence&lt;byte&gt; 가져오기</span>
<span class="hljs-keyword">var</span> decompressedBuffer = decompressor.Decompress(buffer);

<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = MemoryPackSerializer.Deserialize&lt;T&gt;(decompressedBuffer);
</code></pre>
<p><code>BrotliCompressor</code>와 <code>BrotliDecompressor</code> 모두 struct로, 힙에 메모리를 할당하지 않습니다. 둘 다 직렬화/역직렬화 시 내부 메모리 풀에 압축/해제압축 데이터를 저장합니다. 따라서 메모리 풀링 해제가 필요하므로 <code>using</code>을 잊지 마세요.</p>
<p>압축 레벨이 매우 중요합니다. 기본값은 quality-1(CompressionLevel.Fastest)로, .NET 기본값(CompressionLevel.Optimal, quality-4)과 다릅니다.</p>
<p>Fastest(quality-1)는 <a href="https://github.com/lz4/lz4">LZ4</a>와 거의 비슷한 속도를 보이지만, 4는 훨씬 느립니다. 이는 직렬화기 사용 시나리오에서 매우 중요하다고 판단되었습니다. 표준 <code>BrotliStream</code>을 사용할 때(기본값 quality-4) 주의하세요. 데이터에 따라 압축/해제압축 속도 및 크기는 매우 다르게 나타날 수 있습니다. 반드시 애플리케이션에서 처리할 데이터를 준비하여 직접 테스트하시기 바랍니다.</p>
<p>MemoryPack의 비압축과 Brotli 압축 추가 시에는 속도 저하가 몇 배 발생할 수 있습니다.</p>
<p>Brotli는 커스텀 포매터에서도 지원됩니다. <code>BrotliFormatter</code>를 사용하면 특정 멤버만 압축할 수 있습니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    [<span class="hljs-meta">BrotliFormatter</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">byte</span>[]? Payload { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<h2>외부 타입 직렬화하기</h2>
<p>외부 타입을 직렬화하고 싶다면 커스텀 포매터를 만들어 provider에 등록할 수 있습니다. 자세한 내용은 <a href="#formatterprovider-api">Formatter/Provider API</a>를 참고하세요. 하지만 커스텀 포매터 작성은 어렵기 때문에 래퍼 타입을 만드는 것을 추천합니다. 예를 들어, <code>AnimationCurve</code>라는 외부 타입을 직렬화하고 싶을 때:</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Keyframe: (float time, float inTangent, float outTangent, int tangentMode, int weightedMode, float inWeight, float outWeight)</span>
[<span class="hljs-meta">MemoryPackable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">struct</span> SerializableAnimationCurve
{
    [<span class="hljs-meta">MemoryPackIgnore</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> AnimationCurve AnimationCurve;

    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode preWrapMode =&gt; AnimationCurve.preWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    WrapMode postWrapMode =&gt; AnimationCurve.postWrapMode;
    [<span class="hljs-meta">MemoryPackInclude</span>]
    Keyframe[] keys =&gt; AnimationCurve.keys;

    [<span class="hljs-meta">MemoryPackConstructor</span>]
    SerializableAnimationCurve(WrapMode preWrapMode, WrapMode postWrapMode, Keyframe[] keys)
    {
        <span class="hljs-keyword">var</span> curve = <span class="hljs-keyword">new</span> AnimationCurve(keys);
        curve.preWrapMode = preWrapMode;
        curve.postWrapMode = postWrapMode;
        <span class="hljs-keyword">this</span>.AnimationCurve = curve;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SerializableAnimationCurve</span>(<span class="hljs-params">AnimationCurve animationCurve</span>)</span>
    {
        <span class="hljs-keyword">this</span>.AnimationCurve = animationCurve;
    }
}
</code></pre>
<p>래핑할 타입은 public이지만, 직렬화에서는 제외(<code>MemoryPackIgnore</code>)됩니다. 직렬화할 속성은 private이지만, 포함(<code>MemoryPackInclude</code>)됩니다. 두 가지 형태의 생성자도 준비해야 합니다. 직렬화기가 사용하는 생성자는 private이어야 합니다.</p>
<p>이대로라면 매번 래핑해야 하므로 불편합니다. 그리고 구조체 래퍼는 null을 표현할 수 없습니다. 따라서 커스텀 포매터를 만들어 봅시다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnimationCurveFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">AnimationCurve</span>&gt;
{
    <span class="hljs-comment">// Unity는 scoped와 TBufferWriter를 지원하지 않으므로 시그니처를 `Serialize(ref MemoryPackWriter writer, ref AnimationCurve value)`로 변경합니다.</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
```csharp
{
    writer.WriteNullObjectHeader();
    <span class="hljs-keyword">return</span>;
}

writer.WritePackable(<span class="hljs-keyword">new</span> SerializableAnimationCurve(<span class="hljs-keyword">value</span>));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> AnimationCurve? <span class="hljs-keyword">value</span></span>)</span>
{
    <span class="hljs-keyword">if</span> (reader.PeekIsNull())
    {
        reader.Advance(<span class="hljs-number">1</span>); <span class="hljs-comment">// skip null block</span>
        <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-keyword">var</span> wrapped = reader.ReadPackable&lt;SerializableAnimationCurve&gt;();
    <span class="hljs-keyword">value</span> = wrapped.AnimationCurve;
}
</code></pre>
<p>마지막으로, 시작 시 포매터를 등록하세요.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register&lt;AnimationCurve&gt;(<span class="hljs-keyword">new</span> AnimationCurveFormatter());
</code></pre>
<blockquote>
<p>참고: Unity의 AnimationCurve는 기본적으로 직렬화가 가능하므로 AnimationCurve에 대한 이 커스텀 포매터가 필요하지 않습니다.</p>
</blockquote>
<h2>패키지</h2>
<p>MemoryPack에는 다음과 같은 패키지들이 있습니다.</p>
<ul>
<li>MemoryPack</li>
<li>MemoryPack.Core</li>
<li>MemoryPack.Generator</li>
<li>MemoryPack.Streaming</li>
<li>MemoryPack.AspNetCoreMvcFormatter</li>
<li>MemoryPack.UnityShims</li>
</ul>
<p><code>MemoryPack</code>는 메인 라이브러리로, 고성능 이진 객체의 직렬화 및 역직렬화를 완벽하게 지원합니다. <code>MemoryPack.Core</code>는 핵심 베이스 라이브러리에 의존하고, <code>MemoryPack.Generator</code>는 코드 생성에 사용됩니다. <code>MemoryPack.Streaming</code>은 <a href="#streaming-serialization">Streaming Serialization</a>에 대한 확장 기능을 추가합니다. <code>MemoryPack.AspNetCoreMvcFormatter</code>는 ASP.NET Core용 입력/출력 포매터를 추가합니다. <code>MemoryPack.UnityShims</code>는 .NET과 Unity 간의 타입 공유를 위한 Unity Shim 타입과 포매터를 추가합니다.</p>
<h2>TypeScript 및 ASP.NET Core Formatter</h2>
<p>MemoryPack은 TypeScript 코드 생성을 지원합니다. C#에서 클래스 및 직렬화 코드를 생성하며, 즉 OpenAPI, proto 등을 사용하지 않고도 브라우저와 타입을 공유할 수 있습니다.</p>
<p>코드 생성은 Source Generator와 통합되어 있으며, 다음 옵션(<code>MemoryPackGenerator_TypeScriptOutputDirectory</code>)은 TypeScript 코드의 출력 디렉터리를 설정합니다. 런타임 코드는 동시에 출력되므로 추가 의존성이 필요하지 않습니다.</p>
<pre><code class="language-xml hljs"><span class="hljs-comment">&lt;!-- memorypack TypeScript 코드를 디렉터리에 출력 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p>C#의 MemoryPackable 타입은 <code>[GenerateTypeScript]</code>로 어노테이션되어야 합니다.</p>
<pre><code class="language-csharp hljs">[<span class="hljs-meta">MemoryPackable</span>]
[<span class="hljs-meta">GenerateTypeScript</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> required Guid Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> FirstName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span> LastName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required DateTime DateOfBirth { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required Gender Gender { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
    <span class="hljs-keyword">public</span> required <span class="hljs-built_in">string</span>[] Emails { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Gender
{
    Male, Female, Other
}
</code></pre>
<p>런타임 코드와 TypeScript 타입이 대상 디렉터리에 생성됩니다.</p>
<p><img src="https://user-images.githubusercontent.com/46207/194916544-1b6bb5ed-966b-43c3-a378-3eac297c2b40.png" alt="image"></p>
<p>생성된 코드는 다음과 같으며, serialize/serializeArray 및 deserialize/deserializeArray를 위한 단순한 필드와 정적 메서드를 포함합니다.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackWriter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackWriter.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MemoryPackReader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./MemoryPackReader.js"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Gender</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./Gender.js"</span>; 

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">lastName</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
    <span class="hljs-attr">dateOfBirth</span>: <span class="hljs-title class_">Date</span>;
    <span class="hljs-attr">gender</span>: <span class="hljs-title class_">Gender</span>;
    <span class="hljs-attr">emails</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 생략...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// 생략...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// 생략...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArray</span>(<span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-title class_">Uint8Array</span> {
        <span class="hljs-comment">// 생략...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">serializeArrayCore</span>(<span class="hljs-attr">writer</span>: <span class="hljs-title class_">MemoryPackWriter</span>, <span class="hljs-attr">value</span>: (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">void</span> {
        <span class="hljs-comment">// 생략...</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserialize</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// 생략...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// 생략...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArray</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// 생략...</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">deserializeArrayCore</span>(<span class="hljs-attr">reader</span>: <span class="hljs-title class_">MemoryPackReader</span>): (<span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span>)[] | <span class="hljs-literal">null</span> {
        <span class="hljs-comment">// 생략...</span>
    }
}
</code></pre>
<p>이 타입은 다음과 같이 사용할 수 있습니다.</p>
<pre><code class="language-typescript hljs"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
person.<span class="hljs-property">id</span> = crypto.<span class="hljs-title function_">randomUUID</span>();
person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;
person.<span class="hljs-property">firstName</span> = <span class="hljs-string">"foo"</span>;
person.<span class="hljs-property">lastName</span> = <span class="hljs-string">"bar"</span>;
person.<span class="hljs-property">dateOfBirth</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1999</span>, <span class="hljs-number">12</span>, <span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
person.<span class="hljs-property">gender</span> = <span class="hljs-title class_">Gender</span>.<span class="hljs-property">Other</span>;
person.<span class="hljs-property">emails</span> = [<span class="hljs-string">"foo@bar.com"</span>, <span class="hljs-string">"zoo@bar.net"</span>];

<span class="hljs-comment">// Uint8Array로 직렬화</span>
<span class="hljs-keyword">let</span> bin = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">serialize</span>(person);

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([bin.<span class="hljs-property">buffer</span>], { <span class="hljs-attr">type</span>: <span class="hljs-string">"application/x-memorypack"</span> })

<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"http://localhost:5260/api"</span>,
    { <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>, <span class="hljs-attr">body</span>: blob, <span class="hljs-attr">headers</span>: { <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/x-memorypack"</span> } });

<span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">arrayBuffer</span>();

<span class="hljs-comment">// ArrayBuffer에서 역직렬화</span>
<span class="hljs-keyword">let</span> person2 = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">deserialize</span>(buffer);
</code></pre>
<p><code>MemoryPack.AspNetCoreMvcFormatter</code> 패키지는 ASP.NET Core MVC를 위한 <code>MemoryPack</code> 입력 및 출력 포매터를 추가합니다. 다음 코드로 ASP.NET Core MVC에 <code>MemoryPackInputFormatter</code>, <code>MemoryPackOutputFormatter</code>를 추가할 수 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.AddControllers(options =&gt;
{
    options.InputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackInputFormatter());
    <span class="hljs-comment">// checkContentType: true로 설정하면 여러 포맷(JSON/MemoryPack 등) 출력을 지원합니다. 기본값은 false입니다.</span>
    options.OutputFormatters.Insert(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> MemoryPackOutputFormatter(checkContentType: <span class="hljs-literal">false</span>));
});
</code></pre>
<p>HttpClient에서 호출할 경우, content-header에 <code>application/x-memorypack</code>를 설정할 수 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">var</span> content = <span class="hljs-keyword">new</span> ByteArrayContent(bin)
content.Headers.ContentType = <span class="hljs-keyword">new</span> MediaTypeHeaderValue(<span class="hljs-string">"application/x-memorypack"</span>);
</code></pre>
<h3>TypeScript 타입 매핑</h3>
<p>생성할 수 있는 타입에는 몇 가지 제한이 있습니다. 기본형 중 <code>char</code>와 <code>decimal</code>은 지원하지 않습니다. 또한 OpenGenerics 타입은 사용할 수 없습니다.</p>
<table>
<thead>
<tr>
<th>C#</th>
<th>TypeScript</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>bool</code></td>
<td><code>boolean</code></td>
<td></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>sbyte</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>number</code></td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>bigint</code></td>
<td></td>
</tr>
</tbody></table>
<pre><code class="hljs language-xml">| `ulong` |  `bigint` |
| `float` |  `number` |
| `double` |  `number` |
| `string` |  `string \| null`  | 
| `Guid` |  `string`  | TypeScript에서는 문자열로 표현되지만 직렬화/역직렬화 시 16바이트 바이너리로 처리됨
| `DateTime` | `Date` | DateTimeKind는 무시됨
| `enum` | `const enum` | `long` 및 `ulong` 기반 형식은 지원되지 않음
| `T?` | `T \| null` |
| `T[]` | `T[] \| null` |
| `byte[]` | `Uint8Array \| null` |
| `: ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `T[] \| null` | `List<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` 등 모든 `ICollection<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` 구현 타입 지원
| `: ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` | `Set<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> \| null` | `HashSet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` 등 모든 `ISet<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>` 구현 타입 지원
| `: IDictionary&lt;K,V&gt;` | `Map&lt;K, V&gt; \| null` | `Dictionary&lt;K,V&gt;` 등 모든 `IDictionary&lt;K,V&gt;` 구현 타입 지원
| `[MemoryPackable]` | `class` | 클래스만 지원
| `[MemoryPackUnion]` | `abstract class` |

`[GenerateTypeScript]`는 클래스에만 적용 가능하며, 현재 struct는 지원하지 않습니다.

### import 파일 확장자 및 멤버 이름 케이싱 설정

기본적으로 MemoryPack은 `.js` 확장자를 사용하여 파일을 생성합니다(예: `import { MemoryPackWriter } from "./MemoryPackWriter.js";`). 다른 확장자나 빈 값으로 변경하려면 `MemoryPackGenerator_TypeScriptImportExtension`을 사용해 설정할 수 있습니다.
또한 멤버 이름은 자동으로 camelCase로 변환됩니다. 원래 이름을 사용하려면 `MemoryPackGenerator_TypeScriptConvertPropertyName`을 `false`로 설정하세요.

```xml
<span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptOutputDirectory"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptImportExtension"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptConvertPropertyName"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">CompilerVisibleProperty</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"MemoryPackGenerator_TypeScriptEnableNullableTypes"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>$(MSBuildProjectDirectory)\wwwroot\js\memorypack<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptOutputDirectory</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 빈 값 허용 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptImportExtension</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 기본값은 true --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptConvertPropertyName</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 기본값은 false --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">MemoryPackGenerator_TypeScriptEnableNullableTypes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
</code></pre>
<p><code>MemoryPackGenerator_TypeScriptEnableNullableTypes</code>를 설정하면 C#의 Nullable 주석이 TypeScript 코드에 반영됩니다. 기본값은 false로, 모든 항목이 Nullable 처리됩니다.</p>
<h2>스트리밍 직렬화</h2>
<p><code>MemoryPack.Streaming</code>은 컬렉션을 스트림으로 직렬화 및 역직렬화할 수 있도록 추가 지원을 제공하는 <code>MemoryPackStreamingSerializer</code>를 제공합니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryPackStreamingSerializer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeWriter pipeWriter, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> ValueTask <span class="hljs-title">SerializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> count, IEnumerable&lt;T&gt; source, <span class="hljs-built_in">int</span> flushRate = <span class="hljs-number">4096</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">PipeReader pipeReader, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, [EnumeratorCancellation] CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IAsyncEnumerable</span>&lt;<span class="hljs-title">T</span>?&gt; <span class="hljs-title">DeserializeAsync</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">Stream stream, <span class="hljs-built_in">int</span> bufferAtLeast = <span class="hljs-number">4096</span>, <span class="hljs-built_in">int</span> readMinimumSize = <span class="hljs-number">8192</span>, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)
}
</span></code></pre>
<h2>Formatter/Provider API</h2>
<p>Formatter를 직접 구현하려면 <code>MemoryPackFormatter&lt;T&gt;</code>를 상속받아 <code>Serialize</code>와 <code>Deserialize</code> 메서드를 오버라이드 하세요.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SkeltonFormatter</span> : <span class="hljs-title">MemoryPackFormatter</span>&lt;<span class="hljs-title">Skelton</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Serialize</span>&lt;<span class="hljs-title">TBufferWriter</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackWriter&lt;TBufferWriter&gt; writer, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> == <span class="hljs-literal">null</span>)
        {
            writer.WriteNullObjectHeader();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// writer 메서드 사용.</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deserialize</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> MemoryPackReader reader, <span class="hljs-keyword">scoped</span> <span class="hljs-keyword">ref</span> Skelton? <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">if</span> (!reader.TryReadObjectHeader(<span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> count))
        {
            <span class="hljs-keyword">value</span> = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// reader 메서드 사용.</span>
    }
}
</code></pre>
<p>생성된 포매터는 <code>MemoryPackFormatterProvider</code>에 등록해야 합니다.</p>
<pre><code class="language-csharp hljs">MemoryPackFormatterProvider.Register(<span class="hljs-keyword">new</span> SkeltonFormatter());
</code></pre>
<p>참고: <code>unmanaged struct</code>(참조 타입을 포함하지 않는 구조체)는 커스텀 포매터를 사용할 수 없으며 항상 네이티브 메모리 레이아웃으로 직렬화됩니다.</p>
<h2>MemoryPackWriter/ReaderOptionalState</h2>
<p><code>MemoryPackWriter</code>/<code>MemoryPackReader</code>를 초기화하려면 OptionalState가 필요합니다. 이는 <code>MemoryPackSerializerOptions</code>의 래퍼이며, <code>MemoryPackWriterOptionalStatePool</code>에서 생성할 수 있습니다.</p>
<pre><code class="language-csharp hljs"><span class="hljs-comment">// Dispose 시 OptionalState는 풀로 반환됨.</span>
<span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> state = MemoryPackWriterOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> writer = <span class="hljs-keyword">new</span> MemoryPackWriter&lt;T&gt;(<span class="hljs-keyword">ref</span> t, state);
}

<span class="hljs-comment">// Reader의 경우</span>
<span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> state = MemoryPackReaderOptionalStatePool.Rent(MemoryPackSerializerOptions.Default))
{
    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> MemoryPackReader(buffer, state);
}
</code></pre>
<h2>대상 프레임워크 의존성</h2>
<p>MemoryPack은 <code>netstandard2.1</code>과 <code>net7.0</code>을 지원하지만, 두 버전은 호환되지 않습니다. 예를 들어, <code>netstandard2.1</code> 프로젝트의 MemoryPackable 타입을 <code>net7.0</code> 프로젝트에서 사용할 경우 다음과 같은 런타임 예외가 발생합니다.</p>
<blockquote>
<p>Unhandled exception. System.TypeLoadException: Virtual static method '<em>' is not implemented on type '</em>' from assembly '*'.</p>
</blockquote>
<p>net7.0은 static abstract 멤버(<code>Virtual static method</code>)를 사용하지만, 이는 netstandard2.1에서 지원되지 않으므로 발생하는 명세상 동작입니다.</p>
<p>.NET 7 프로젝트는 netstandard 2.1 DLL을 사용해서는 안 됩니다. 즉, 애플리케이션이 .NET 7 프로젝트라면, MemoryPack을 사용하는 모든 의존성 역시 .NET 7을 지원해야 합니다. 라이브러리 개발자가 MemoryPack에 의존성이 있다면, 듀얼 타겟 프레임워크를 설정해야 합니다.</p>
<pre><code class="language-xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">TargetFrameworks</span>&gt;</span>netstandard2.1;net7.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFrameworks</span>&gt;</span>
</code></pre>
<h2>RPC</h2>
<p><a href="https://github.com/Cysharp/MagicOnion">Cysharp/MagicOnion</a>은 protobuf 대신 MessagePack을 사용하는 코드 우선 grpc-dotnet 프레임워크입니다. MagicOnion은 이제 <code>MagicOnion.Serialization.MemoryPack</code> 패키지(preview)를 통해 MemoryPack을 직렬화 계층으로 지원합니다. 자세한 내용은 <a href="https://github.com/Cysharp/MagicOnion#memorypack-support">MagicOnion#MemoryPack support</a>를 참고하세요.</p>
<h2>Unity</h2>
<p>최소 지원 Unity 버전은 <code>2022.3.12f1</code>입니다.</p>
<p><code>MemoryPack</code> 코어 패키지는 nuget을 통해 제공되며, Unity에서도 사용할 수 있습니다. Unity의 내장 타입 지원이 필요한 경우, 추가로 MemoryPack.Unity 확장 패키지를 제공합니다.</p>
<ol>
<li><a href="https://github.com/GlitchEnzo/NuGetForUnity">NuGetForUnity</a>를 이용해 NuGet에서 <code>MemoryPack</code> 설치</li>
</ol>
<ul>
<li><p>NuGet -&gt; Manage NuGet Packages 창을 열고, "MemoryPack"을 검색하여 Install을 누르세요.<br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/599ff1ed-6cca-4724-be67-3edddb5e62ee" alt="screenshot"></p>
</li>
<li><p>버전 충돌 오류가 발생하면, Player Settings(Edit -&gt; Project Settings -&gt; Player -&gt; "Other Settings" 펼친 후 "Configuration" 섹션의 "Assembly Version Validation" 체크 해제)를 통해 버전 검증을 비활성화하세요.</p>
</li>
</ul>
<ol start="2">
<li>git URL 참조로 <code>MemoryPack.Unity</code> 패키지 설치</li>
</ol>
<ul>
<li><code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity</code><br><img src="https://github.com/Cysharp/ZLogger/assets/46207/7325d266-05b4-47c9-b06a-a67a40368dd2" alt="screenshot"><br><img src="https://github.com/Cysharp/MemoryPack/assets/727159/9a4af1df-ce07-49d7-9420-922dfb139b55" alt="screenshot"></li>
</ul>
<p>MemoryPack은 <em>.</em>.* 릴리스 태그를 사용하므로, 버전을 명시할 수 있습니다(예: #1.0.0). 예시: <code>https://github.com/Cysharp/MemoryPack.git?path=src/MemoryPack.Unity/Assets/MemoryPack.Unity#1.0.0</code></p>
<p>.NET 버전과 동일하게, 코드는 코드 생성기(<code>MemoryPack.Generator.dll</code>)에 의해 생성됩니다. 리플렉션 없는 구현으로 IL2CPP에서도 최고의 성능을 제공합니다.</p>
<p>Unity와 소스 생성기에 대한 자세한 내용은 <a href="https://docs.unity3d.com/Manual/roslyn-analyzers.html">Unity documentation</a>을 참고하세요.</p>
<p>소스 생성기는 Unity에서 공식적으로 <a href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/index.html">com.unity.properties</a>, <a href="https://docs.unity3d.com/Packages/com.unity.properties@2.0/changelog/CHANGELOG.html">com.unity.entities</a> 등에서 사용되고 있습니다. 즉, 차세대 Unity 코드 생성의 표준입니다.</p>
<p>모든 언매니지드 타입(<code>Vector3</code>, <code>Rect</code> 등)과 일부 클래스(<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>)를 직렬화할 수 있습니다. Unity 고유 타입을 추가로 직렬화하고 싶다면 <a href="#serialize-external-types">외부 타입 직렬화</a> 섹션을 참고하세요.</p>
<p>Unity에서의 성능은 JsonUtility 대비 MemoryPack이 x3~x10 더 빠릅니다.</p>
<p><img src="https://user-images.githubusercontent.com/46207/209254561-79ec18fe-c421-4d8c-9c86-b55276dd1a45.png" alt="image"></p>
<p>공유 코드에 Unity 타입(<code>Vector2</code> 등)이 포함되어 있다면, NuGet에서 <code>MemoryPack.UnityShims</code> 패키지를 제공합니다.</p>
<p><code>MemoryPack.UnityShims</code> 패키지는 Unity 표준 구조체(<code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>Quaternion</code>, <code>Color</code>, <code>Bounds</code>, <code>Rect</code>, <code>Keyframe</code>, <code>WrapMode</code>, <code>Matrix4x4</code>, <code>GradientColorKey</code>, <code>GradientAlphaKey</code>, <code>GradientMode</code>, <code>Color32</code>, <code>LayerMask</code>, <code>Vector2Int</code>, <code>Vector3Int</code>, <code>RangeInt</code>, <code>RectInt</code>, <code>BoundsInt</code>) 및 일부 클래스(<code>AnimationCurve</code>, <code>Gradient</code>, <code>RectOffset</code>)의 shim을 제공합니다.</p>
<blockquote>
<p>[!WARNING]<br>현재 Unity에서 다음과 같은 제한 사항이 있습니다.</p>
</blockquote>
<ol>
<li>Unity 버전에서는 CustomFormatter를 지원하지 않습니다.</li>
<li>.NET7 이상을 사용하는 경우, MemoryPack 바이너리 포맷이 Unity와 완전히 호환되지 않습니다.<ul>
<li><code>[StructLayout(LayoutKind.Auto)]</code>가 명시된 값 타입에서 이 문제가 발생합니다(구조체의 기본은 <code>LayoutKind.Sequential</code>). 이러한 타입은 .NET에서 직렬화한 바이너리를 Unity에서 역직렬화할 수 없고, 반대로도 마찬가지입니다.</li>
<li>영향받는 대표 타입은 다음과 같습니다.<ul>
<li><code>DateTimeOffset</code></li>
<li><code>ValueTuple</code></li>
</ul>
</li>
<li>현재로선, 해당 타입을 사용하지 않는 것이 가장 간단한 해결책입니다.</li>
</ul>
</li>
</ol>
<h2>Native AOT</h2>
<p>아쉽게도 .NET 7 Native AOT에서 런타임 버그로 인해 MemoryPack을 사용할 경우 크래시(<code>Generic virtual method pointer lookup failure</code>)가 발생합니다.<br>.NET 8에서 수정될 예정입니다. ``Microsoft.DotNet.ILCompiler` preview 버전을 사용하면 .NET 7에서도 해결할 수 있습니다. <a href="https://github.com/Cysharp/MemoryPack/issues/75#issuecomment-1386884611">이슈 코멘트</a>를 참고해 설정하세요.</p>
<h2>바이너리 와이어 포맷 명세</h2>
<p><code>Serialize&lt;T&gt;</code>와 <code>Deserialize&lt;T&gt;</code>에 정의된 <code>T</code>의 타입을 C# 스키마라고 합니다. MemoryPack 포맷은 자기 기술적(self-described) 포맷이 아닙니다. 역직렬화 시에는 반드시 대응되는 C# 스키마가 필요합니다. 이러한 타입은 바이너리 내부 표현으로 존재하지만, C# 스키마 없이는 타입을 판별할 수 없습니다.</p>
<p>Endian은 반드시 <code>Little Endian</code>이어야 합니다. 단, 참조 C# 구현체는 Endian을 고려하지 않으므로 빅 엔디언 머신에서는 사용할 수 없습니다. 그러나 현대 컴퓨터는 대부분 리틀 엔디언입니다.</p>
<p>포맷 종류는 총 8가지가 있습니다.</p>
<ul>
<li>Unmanaged struct</li>
<li>Object</li>
<li>Version Tolerant Object</li>
<li>순환 참조 객체</li>
<li>튜플</li>
<li>컬렉션</li>
<li>문자열</li>
<li>유니언</li>
</ul>
<h3>Unmanaged struct</h3>
<p>Unmanaged struct는 참조 타입을 포함하지 않는 C# struct로, <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">C# Unmanaged types</a>와 유사한 제약을 가집니다. struct 레이아웃을 그대로 직렬화하며, 패딩도 포함됩니다.</p>
<h3>Object</h3>
<p><code>(byte memberCount, [values...])</code></p>
<p>Object는 헤더에 멤버 수를 나타내는 1바이트 부호 없는 바이트가 있습니다. 멤버 수는 <code>0</code>부터 <code>249</code>까지 허용되며, <code>255</code>는 객체가 <code>null</code>임을 나타냅니다. Values는 멤버 수만큼의 memorypack 값을 저장합니다.</p>
<h3>Version Tolerant Object</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], [values...])</code></p>
<p>Version Tolerant Object는 Object와 유사하지만, 헤더에 값의 바이트 길이가 포함됩니다. varint는 다음 사양을 따릅니다. 첫 번째 sbyte는 값 또는 typeCode이고, 그 다음 X 바이트가 값입니다. 0<del>127 = 부호 없는 바이트 값, -1</del> -120 = 부호 있는 바이트 값, -121 = byte, -122 = sbyte, -123 = ushort, -124 = short, -125 = uint, -126 = int, -127 = ulong, -128 = long.</p>
<h3>순환 참조 객체</h3>
<p><code>(byte memberCount, [varint byte-length-of-values...], varint referenceId, [values...])</code><br><code>(250, varint referenceId)</code></p>
<p>순환 참조 객체는 Version Tolerant Object와 유사하지만, memberCount가 250이면 다음 varint(unsigned-int32)는 referenceId가 됩니다. 그렇지 않으면, byte-length-of-values 다음에 varint referenceId가 기록됩니다.</p>
<h3>튜플</h3>
<p><code>(values...)</code></p>
<p>튜플은 고정 크기의 null이 될 수 없는 값 컬렉션입니다. .NET에서 <code>KeyValuePair&lt;TKey, TValue&gt;</code>와 <code>ValueTuple&lt;T,...&gt;</code>는 튜플로 직렬화됩니다.</p>
<h3>컬렉션</h3>
<p><code>(int length, [values...])</code></p>
<p>컬렉션은 헤더에 데이터 개수를 나타내는 4바이트 부호 있는 정수를 가지며, <code>-1</code>은 <code>null</code>을 나타냅니다. Values는 length만큼의 memorypack 값을 저장합니다.</p>
<h3>문자열</h3>
<p><code>(int utf16-length, utf16-value)</code><br><code>(int ~utf8-byte-count, int utf16-length, utf8-bytes)</code></p>
<p>문자열은 두 가지 형식, UTF16과 UTF8을 가집니다. 첫 4바이트 부호 있는 정수가 <code>-1</code>이면 null을 나타냅니다. <code>0</code>이면 빈 문자열을 의미합니다. UTF16은 컬렉션과 동일하게 처리되며(<code>ReadOnlySpan&lt;char&gt;</code>로 직렬화), utf16-value의 바이트 수는 utf16-length * 2입니다. 첫 정수가 <code>-2</code> 이하이면, 값은 UTF8로 인코딩됩니다. utf8-byte-count는 보수로 인코딩되며, 바이트 수를 얻으려면 <code>~utf8-byte-count</code>를 사용합니다. 다음 정수는 utf16-length이며, <code>-1</code>이 허용되어 길이를 알 수 없는 경우를 나타냅니다. utf8-bytes는 utf8-byte-count만큼의 바이트를 저장합니다.</p>
<h3>유니언</h3>
<p><code>(byte tag, value)</code><br><code>(250, ushort tag, value)</code></p>
<p>첫 번째 부호 없는 바이트는 구분 값 타입이나 플래그를 위한 태그입니다. <code>0</code>부터 <code>249</code>까지는 태그를 나타내고, <code>250</code>은 다음 부호 없는 short가 태그임을 나타내며, <code>255</code>는 유니언이 <code>null</code>임을 나타냅니다.</p>
<h2>License</h2>
<p>이 라이브러리는 MIT 라이선스 하에 제공됩니다.</p>
<hr>
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-09</p>
<hr>
</div>
    </div>

    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async=""></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
    


</body></html>