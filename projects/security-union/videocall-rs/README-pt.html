<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>videocall-rs - security-union/videocall-rs pt</title>
    <meta name="title" content="videocall-rs - security-union/videocall-rs pt | videocall.rs Uma plataforma de videoconferência de alto desempenho e código aberto construída com Rust, oferecendo comunicação em tempo real com baixa latência....">
    <meta name="description" content="security-union/videocall-rs - GitHub repository pt documentation and information | videocall.rs Uma plataforma de videoconferência de alto desempenho e código aberto construída com Rust, oferecendo comunicação em tempo real com baixa latência....">
    <meta name="keywords" content="security-union, videocall-rs, GitHub, repository, pt documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/security-union/videocall-rs/README-pt.html">
    <meta property="og:title" content="videocall-rs - security-union/videocall-rs pt | videocall.rs Uma plataforma de videoconferência de alto desempenho e código aberto construída com Rust, oferecendo comunicação em tempo real com baixa latência....">
    <meta property="og:description" content="security-union/videocall-rs - GitHub repository pt documentation and information | videocall.rs Uma plataforma de videoconferência de alto desempenho e código aberto construída com Rust, oferecendo comunicação em tempo real com baixa latência....">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/security-union/videocall-rs" id="githubRepoLink" target="_blank">security-union/videocall-rs</a>
<h1 style="display: none;">videocall.rs Uma plataforma de videoconferência de alto desempenho e código aberto construída com Rust, oferecendo comunicação em tempo real com baixa latência....</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>videocall.rs</h1>
<p><a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-blue.svg" alt="License: MIT" height="28"></a>
<a href="https://discord.gg/JP38NRe4CJ"><img src="https://img.shields.io/badge/Discord-Join%20Chat-7289DA?logo=discord&logoColor=white" alt="Discord" height="28"></a>
<a href="https://www.digitalocean.com/?refcode=6de4e19c5193&utm_campaign=Referral_Invite&utm_medium=Referral_Program&utm_source=badge"><img src="https://raw.githubusercontent.com/security-union/videocall-rs/main/web-platforms.sfo2.cdn.digitaloceanspaces.com/WWW/Badge%201.svg" alt="DigitalOcean Referral Badge" height="28"></a></p>
<p>Uma plataforma de videoconferência de alto desempenho e código aberto construída com Rust, oferecendo comunicação em tempo real com baixa latência.</p>
<p><strong><a href="https://videocall.rs">Website</a></strong> | <strong><a href="https://discord.gg/JP38NRe4CJ">Comunidade Discord</a></strong></p>
<h2>Índice</h2>
<ul>
<li><a href="#overview">Visão Geral</a></li>
<li><a href="#features">Recursos</a></li>
<li><a href="#why-webtransport-instead-of-webrtc">Por que WebTransport em vez de WebRTC?</a></li>
<li><a href="#system-architecture">Arquitetura do Sistema</a></li>
<li><a href="#getting-started">Primeiros Passos</a>
<ul>
<li><a href="#prerequisites">Pré-requisitos</a></li>
<li><a href="#docker-setup">Configuração com Docker</a></li>
<li><a href="#manual-setup">Configuração Manual</a></li>
</ul>
</li>
<li><a href="#usage">Uso</a></li>
<li><a href="#performance">Desempenho</a></li>
<li><a href="#security">Segurança</a></li>
<li><a href="#roadmap">Roteiro</a></li>
<li><a href="#contributing">Contribuição</a></li>
<li><a href="#project-structure">Estrutura do Projeto</a></li>
<li><a href="#demos-and-media">Demonstrações e Mídia</a></li>
<li><a href="#contributors">Contribuidores</a></li>
<li><a href="#license">Licença</a></li>
</ul>
<h2>Visão Geral</h2>
<p>videocall.rs é um sistema moderno e de código aberto para videoconferência, escrito inteiramente em Rust, projetado para desenvolvedores que precisam de capacidades confiáveis, escaláveis e seguras de comunicação em tempo real. Ele fornece uma base para construir soluções personalizadas de comunicação por vídeo, com suporte tanto para clientes baseados em navegador quanto nativos.</p>
<p><strong>Status do Projeto:</strong> Beta - Ativamente desenvolvido e adequado para uso em produção não crítico</p>
<h2>Recursos</h2>
<ul>
<li><strong>Alto Desempenho:</strong> Construído com Rust para uso ótimo de recursos e baixa latência</li>
<li><strong>Múltiplos Protocolos de Transporte:</strong> Suporte para WebSockets e WebTransport</li>
<li><strong>Criptografia de Ponta a Ponta (E2EE):</strong> Comunicações seguras opcionais entre pares</li>
<li><strong>Arquitetura Escalável:</strong> Projetado com modelo pub/sub usando NATS para escalonamento horizontal</li>
<li><strong>Suporte Multiplataforma:</strong> Funciona em navegadores baseados em Chromium (Chrome, Edge, Brave) com suporte a Safari em desenvolvimento. Firefox não é suportado devido à implementação incompleta do MediaStreamTrackProcessor.</li>
<li><strong>Suporte a Cliente Nativo:</strong> Ferramenta CLI para streaming de vídeo sem interface gráfica de dispositivos como Raspberry Pi</li>
<li><strong>Código Aberto:</strong> Licenciado sob MIT para máxima flexibilidade</li>
</ul>
<h2>Por que WebTransport em vez de WebRTC?</h2>
<p>WebTransport é uma tecnologia central que diferencia o videocall.rs das soluções tradicionais de videoconferência. Como desenvolvedor, veja por que nossa abordagem com WebTransport é tecnicamente superior:</p>
<h3>Vantagens Técnicas</h3>
<ul>
<li><p><strong>Sem SFUs, Sem Traversal de NAT:</strong> WebTransport elimina a necessidade de unidades de encaminhamento seletivo complexas e mecanismos de traversal de NAT que afetam as implementações WebRTC e causam inúmeros problemas para os desenvolvedores.</p>
</li>
<li><p><strong>Arquitetura Simplificada:</strong> Sem servidores STUN/TURN complexos, negociação de candidatos ICE ou danças de sinalização complicadas exigidas pelo WebRTC. Apenas conexões diretas e simples.</p>
</li>
<li><p><strong>Eficiência do Protocolo:</strong> Construído sobre HTTP/3 e QUIC, o WebTransport oferece streams multiplexados e bidirecionais com melhor controle de congestionamento e recuperação de perda de pacotes do que os canais de dados SCTP datados do WebRTC.</p>
</li>
<li><p><strong>Menor Latência:</strong> O estabelecimento de conexão 0-RTT do QUIC reduz o tempo inicial de conexão em comparação com as múltiplas idas e vindas do WebRTC.</p>
</li>
<li><p><strong>Experiência de Desenvolvimento Limpa:</strong> WebTransport oferece uma API para desenvolvedores mais intuitiva com design baseado em promessas e gerenciamento de streams mais limpo.</p>
</li>
<li><p><strong>Tecnologia para o Futuro:</strong> Como parte da plataforma web moderna desenvolvida pelo IETF e W3C, o WebTransport conta com forte suporte dos fornecedores de navegadores e especificação em evolução ativa.</p>
</li>
</ul>
<h3>Implicações para Desenvolvedores</h3>
<p>Para os desenvolvedores que integram o videocall.rs, isso significa:</p>
<ul>
<li>✅ Arquitetura de implantação drasticamente mais simples</li>
<li>✅ Sem configurações complexas de rede ou problemas de firewall</li>
<li>✅ Melhor desempenho em condições de rede desafiadoras</li>
<li>✅ Comportamento mais previsível entre implementações</li>
<li>✅ Menos tempo gasto depurando problemas de conectividade</li>
<li>✅ Um investimento tecnológico com visão de futuro</li>
</ul>
<p>Leia nosso <a href="https://raw.githubusercontent.com/security-union/videocall-rs/main/ARCHITECTURE.md">Documento de Arquitetura</a> para um mergulho profundo sobre como implementamos WebTransport e os benefícios técnicos que ele oferece.</p>
<h2>Arquitetura do Sistema</h2>
<p>videocall.rs segue uma arquitetura de microsserviços com estes componentes principais:</p>
<pre><code class="language-mermaid">graph TD
    Clients[Clientes&lt;br&gt;Navegadores, Mobile, CLI] --&gt;|WebSocket| ActixAPI[API Actix&lt;br&gt;WebSocket]
    Clients --&gt;|WebTransport| WebTransportServer[Servidor&lt;br&gt;WebTransport]
    ActixAPI --&gt; NATS[NATS&lt;br&gt;Mensageria]
    WebTransportServer --&gt; NATS
</code></pre>
<ol>
<li><strong>actix-api:</strong> Servidor backend em Rust usando o framework Actix Web</li>
<li><strong>yew-ui:</strong> Frontend web construído com o framework Yew e compilado para WebAssembly</li>
<li><strong>videocall-types:</strong> Tipos de dados compartilhados e definições de protocolo</li>
<li><strong>videocall-client:</strong> Biblioteca cliente para integração nativa</li>
<li><strong>videocall-cli:</strong> Interface de linha de comando para streaming de vídeo sem interface gráfica</li>
</ol>
<p>Para uma explicação mais detalhada da arquitetura do sistema, consulte nosso <a href="https://raw.githubusercontent.com/security-union/videocall-rs/main/ARCHITECTURE.md">Documento de Arquitetura</a>.</p>
<h2>Primeiros Passos</h2>
<p><strong>⭐ RECOMENDADO: Docker é o único método de desenvolvimento totalmente suportado ⭐</strong></p>
<p>Recomendamos fortemente o uso da configuração baseada em Docker para desenvolvimento, pois é bem mantida e oferece comportamento consistente entre plataformas. A configuração manual descrita abaixo não é tão bem mantida e pode exigir solução de problemas adicional.</p>
<h3>Pré-requisitos</h3>
<ul>
<li>Distribuição moderna Linux, macOS ou Windows 10/11</li>
<li><a href="https://docs.docker.com/engine/install/">Docker</a> e Docker Compose (para configuração em contêiner)</li>
<li><a href="https://rustup.rs/">Toolchain Rust</a> 1.85+ (para configuração manual)</li>
<li>Navegador baseado em Chromium (Chrome, Edge, Brave) para acesso ao frontend - Firefox não é suportado</li>
</ul>
<h3>Configuração com Docker</h3>
<p>A maneira mais rápida de começar é com nossa configuração baseada em Docker:</p>
<ol>
<li><p>Clone o repositório:</p>
<pre><code>git clone https://github.com/security-union/videocall-rs.git
cd videocall-rs
</code></pre>
</li>
<li><p>Inicie o servidor (substitua <code>&lt;server-ip&gt;</code> pelo IP da sua máquina):</p>
<pre><code>make up
</code></pre>
</li>
<li><p>Abra o Chrome usando o script fornecido para WebTransport local:</p>
<pre><code>./launch_chrome.sh
</code></pre>
</li>
<li><p>Acesse a aplicação em:</p>
<pre><code>http://&lt;server-ip&gt;/meeting/&lt;username&gt;/&lt;meeting-id&gt;
</code></pre>
</li>
</ol>
<h3>Configuração Manual (Experimental)</h3>
<p>⚠️ <strong>Aviso</strong>: Este método de configuração é experimental e não é tão bem mantido quanto a abordagem com Docker. Você pode encontrar problemas que exigem depuração manual.</p>
<p>Para usuários avançados que preferem rodar os serviços diretamente em sua máquina:</p>
<ol>
<li><p>Crie um banco de dados PostgreSQL:</p>
<pre><code>createdb actix-api-db
</code></pre>
</li>
<li><p>Instale as ferramentas necessárias:</p>
<pre><code># Instalar servidor NATS
curl -L https://github.com/nats-io/nats-server/releases/download/v2.9.8/nats-server-v2.9.8-linux-amd64.tar.gz | tar xz
sudo mv nats-server-v2.9.8-linux-amd64/nats-server /usr/local/bin

# Instalar trurl
cargo install trurl
</code></pre>
</li>
<li><p>Inicie o ambiente de desenvolvimento:</p>
<pre><code>./start_dev.sh
</code></pre>
</li>
<li><p>Conecte-se em:</p>
<pre><code>http://localhost:8081/meeting/&lt;username&gt;/&lt;meeting-id&gt;
</code></pre>
</li>
</ol>
<p>Para opções detalhadas de configuração, consulte nossa <a href="https://docs.videocall.rs/setup">documentação de setup</a>.</p>
<h2>Uso</h2>
<h3>Clientes Baseados em Navegador</h3>
<ol>
<li><p>Navegue até sua instância implantada ou configuração local:</p>
<pre><code>http://&lt;server-address&gt;/meeting/&lt;username&gt;/&lt;meeting-id&gt;
</code></pre>
</li>
<li><p>Conceda permissões de câmera e microfone quando solicitado</p>
</li>
<li><p>Clique em &quot;Conectar&quot; para entrar na reunião</p>
</li>
</ol>
<h3>Streaming via CLI</h3>
<p>Para dispositivos sem interface gráfica, como Raspberry Pi:</p>
<pre><code class="language-bash"># Instale a ferramenta CLI
cargo install videocall-cli

# Faça streaming de uma câmera
videocall-cli stream \
  --user-id &lt;seu-user-id&gt; \
  --video-device-index 0 \
  --meeting-id &lt;meeting-id&gt; \
  --resolution 1280x720 \
  --fps 30 \
  --frame-format NV12 \
  --bitrate-kbps 500
</code></pre>
<p>Para informações detalhadas sobre a ferramenta CLI e todas as opções disponíveis, veja o <a href="https://raw.githubusercontent.com/security-union/videocall-rs/main/videocall-cli/README.md">videocall-cli README</a>.</p>
<h2>Performance</h2>
<p>videocall.rs foi testado e otimizado para os seguintes cenários:</p>
<ul>
<li><strong>Chamadas 1-a-1:</strong> Utilização mínima de recursos com latência &lt;100ms em conexões típicas</li>
<li><strong>Pequenos Grupos (3-10):</strong> Topologia mesh eficiente com qualidade adaptativa baseada nas condições da rede</li>
<li><strong>Grandes Conferências:</strong> Testado com até 1000 participantes usando arquitetura de encaminhamento seletivo</li>
</ul>
<h3>Otimizações Técnicas</h3>
<ul>
<li><strong>Design Zero-Copy:</strong> Minimiza a cópia de dados entre a pilha de rede e o código da aplicação</li>
<li><strong>Núcleo Assíncrono:</strong> Construído sobre o ecossistema async/await do Rust com runtime Tokio</li>
<li><strong>Processamento Acelerado por SIMD:</strong> Usa vetorização da CPU para operações de mídia quando disponível</li>
<li><strong>Estruturas de Dados Sem Locks:</strong> Minimiza contenção em cenários de alta taxa de transferência</li>
<li><strong>Otimizações no Nível de Protocolo:</strong> Controle de congestionamento e agendamento de pacotes customizados</li>
</ul>
<h3>Utilização de Recursos</h3>
<p>Nossa arquitetura do lado servidor é projetada para eficiência em escala:</p>
<ul>
<li><strong>Escalabilidade Horizontal:</strong> Escalabilidade linear de desempenho com instâncias adicionais do servidor</li>
<li><strong>Distribuição de Carga:</strong> Balanceamento automático de conexões entre o pool de servidores</li>
<li><strong>Governança de Recursos:</strong> Limites configuráveis para largura de banda, conexões e utilização de CPU</li>
<li><strong>Otimizado para Containers:</strong> Projetado para implantação eficiente em ambientes Kubernetes</li>
</ul>
<p>Métricas de performance e diretrizes de ajuste estarão disponíveis em nossa <a href="https://raw.githubusercontent.com/security-union/videocall-rs/main/PERFORMANCE.md">documentação de performance</a>. (Em andamento)</p>
<h2>Segurança</h2>
<p>A segurança é um foco central do videocall.rs:</p>
<ul>
<li><strong>Segurança de Transporte:</strong> Todas as comunicações usam TLS/HTTPS.</li>
<li><strong>Criptografia End-to-End:</strong> E2EE opcional entre pares sem acesso do servidor ao conteúdo.</li>
<li><strong>Autenticação:</strong> Integração flexível com provedores de identidade.</li>
<li><strong>Controles de Acesso:</strong> Sistema de permissões detalhado para salas de reunião.</li>
</ul>
<p>Para detalhes sobre nosso modelo de segurança e melhores práticas, veja nossa <a href="https://docs.videocall.rs/security">documentação de segurança</a>.</p>
<h2>Roteiro</h2>
<p>| Versão | Data Alvo | Principais Recursos |
|---------|------------|--------------|
| 0.5.0   | Q2 2023    | ✅ Criptografia End-to-End |
| 0.6.0   | Q3 2023    | ✅ Suporte ao Navegador Safari |
| 0.7.0   | Q4 2023    | ✅ SDKs Nativos para Mobile |
| 0.8.0   | Q1 2024    | 🔄 Melhorias no Compartilhamento de Tela |
| 1.0.0   | Q2 2024    | 🔄 Lançamento de Produção com Estabilidade Total da API |</p>
<h2>Contribuindo</h2>
<p>Recebemos contribuições da comunidade! Veja como participar:</p>
<ol>
<li><strong>Issues:</strong> Reporte bugs ou sugira recursos via <a href="https://github.com/security-union/videocall-rs/issues">GitHub Issues</a></li>
<li><strong>Pull Requests:</strong> Envie PRs para correções de bugs ou melhorias</li>
<li><strong>Processo RFC:</strong> Para mudanças significativas, participe do nosso <a href="https://raw.githubusercontent.com/security-union/videocall-rs/main/rfc">processo RFC</a></li>
<li><strong>Comunidade:</strong> Junte-se ao nosso <a href="https://discord.gg/JP38NRe4CJ">servidor Discord</a> para discutir desenvolvimento</li>
</ol>
<p>Veja nossas <a href="https://raw.githubusercontent.com/security-union/videocall-rs/main/CONTRIBUTING.md">Diretrizes de Contribuição</a> para informações mais detalhadas.</p>
<h3>Pilha Tecnológica</h3>
<ul>
<li><strong>Backend</strong>: Rust + Actix Web + PostgreSQL + NATS</li>
<li><strong>Frontend</strong>: Rust + Yew + WebAssembly + Tailwind CSS</li>
<li><strong>Transporte</strong>: WebTransport (QUIC/HTTP3) + WebSockets (fallback)</li>
<li><strong>Sistema de Build</strong>: Cargo + Trunk + Docker + Helm</li>
<li><strong>Testes</strong>: Framework de testes Rust + Playwright para testes E2E</li>
</ul>
<h3>Principais Recursos Técnicos</h3>
<ul>
<li><strong>Streaming Bidirecional:</strong> Passagem de mensagens totalmente assíncrona usando streams QUIC</li>
<li><strong>Tratamento de Erros:</strong> Propagação abrangente de erros baseada em Result em todo o código</li>
<li><strong>Modularidade:</strong> Separação clara de responsabilidades com interfaces bem definidas entre componentes</li>
<li><strong>Segurança de Tipos:</strong> Uso extensivo do sistema de tipos do Rust para prevenir erros em tempo de execução</li>
<li><strong>Protocolo Binário:</strong> Serialização eficiente com Protocol Buffers para todas as mensagens</li>
</ul>
<p>Para uma visão técnica mais abrangente, veja o <a href="https://raw.githubusercontent.com/security-union/videocall-rs/main/ARCHITECTURE.md">Documento de Arquitetura</a>.</p>
<h3>Git Hooks</h3>
<p>Este repositório inclui hooks Git para garantir a qualidade do código:</p>
<ol>
<li><strong>Hook pre-commit:</strong> Executa automaticamente <code>cargo fmt</code> antes de cada commit para garantir formatação consistente.</li>
<li><strong>Hook post-commit:</strong> Executa <code>cargo clippy</code> após cada commit para verificar possíveis melhorias no código.</li>
</ol>
<p>Para instalar esses hooks, execute os seguintes comandos na raiz do projeto:</p>
<pre><code class="language-bash"># Crie o diretório hooks se não existir
mkdir -p .git/hooks

# Crie o hook pre-commit
cat &gt; .git/hooks/pre-commit &lt;&lt; 'EOF'
#!/bin/sh

# Executa cargo fmt e verifica se há alterações
echo &quot;Executando cargo fmt...&quot;
cargo fmt --all -- --check

# Verifica o código de saída do cargo fmt
if [ $? -ne 0 ]; then
    echo &quot;cargo fmt encontrou problemas de formatação. Por favor, corrija antes de commitar.&quot;
    exit 1
fi

exit 0
EOF

# Crie o hook post-commit
cat &gt; .git/hooks/post-commit &lt;&lt; 'EOF'
#!/bin/sh

# Executa cargo clippy após o commit
echo &quot;Executando cargo clippy...&quot;
ACTIX_UI_BACKEND_URL=&quot;&quot; WEBTRANSPORT_HOST=&quot;&quot; LOGIN_URL=&quot;&quot; WEBTRANSPORT_URL=&quot;&quot; ACTIX_API_URL=&quot;&quot; cargo clippy -- -D warnings

# Verifica o código de saída do cargo clippy
if [ $? -ne 0 ]; then
    echo &quot;Cargo clippy encontrou problemas no seu código. Por favor, corrija-os.&quot;
    # Não podemos abortar o commit pois já foi realizado, mas podemos informar o usuário
    echo &quot;O commit foi realizado com sucesso, mas considere corrigir os problemas indicados pelo clippy antes de enviar.&quot;
fi

exit 0
EOF

# Torne os hooks executáveis
chmod +x .git/hooks/pre-commit .git/hooks/post-commit
</code></pre>
<p>Esses hooks ajudam a manter a qualidade do código assegurando formatação adequada e verificando problemas comuns.</p>
<h2>Demos e Mídia</h2>
<h3>Apresentações Técnicas</h3>
<ul>
<li><a href="https://youtu.be/LWwOSZJwEJI">Escalando para 1000 Usuários por Chamada</a></li>
<li><a href="https://www.youtube.com/watch?v=kZ9isFw1TQ8">Prova de Conceito Inicial (2022)</a></li>
</ul>
<h3>Canais</h3>
<ul>
<li><a href="https://www.youtube.com/@dario.lencina">Canal no YouTube</a></li>
</ul>
<h2>Contribuidores</h2>
<table>
<tr>
<td align="center"><a href="https://github.com/darioalessandro"><img src="https://avatars0.githubusercontent.com/u/1176339?s=400&v=4" width="100" alt=""/><br /><sub><b>Dario Lencina</b></sub></a></td>
<td align="center"><a href="https://github.com/griffobeid"><img src="https://avatars1.githubusercontent.com/u/12220672?s=400&u=639c5cafe1c504ee9c68ad3a5e09d1b2c186462c&v=4" width="100" alt=""/><br /><sub><b>Griffin Obeid</b></sub></a></td>    
<td align="center"><a href="https://github.com/ronen"><img src="https://avatars.githubusercontent.com/u/125620?v=4" width="100" alt=""/><br /><sub><b>Ronen Barzel</b></sub></a></td>
<td align="center"><a href="https://github.com/leon3s"><img src="https://avatars.githubusercontent.com/u/7750950?v=4" width="100" alt=""/><br /><sub><b>Leone</b></sub></a></td>
<td align="center"><a href="https://github.com/JasterV"><img src="https://avatars3.githubusercontent.com/u/49537445?v=4" width="100" alt=""/><br /><sub><b>Victor Martínez</b></sub></a></td>
</tr>
</table>
<p>Agradecimentos especiais a <a href="https://github.com/JasterV">JasterV</a> pela implementação do websocket Actix que contém fragmentos do projeto <a href="https://github.com/JasterV/chat-rooms-actix">chat-rooms-actix</a>.</p>
<h2>Licença</h2>
<p>Este projeto está licenciado sob a Licença MIT - veja o arquivo <a href="https://raw.githubusercontent.com/security-union/videocall-rs/main/LICENSE.md">LICENSE.md</a> para mais detalhes.</p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-11</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>