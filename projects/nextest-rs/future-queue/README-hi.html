<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>future-queue - nextest-rs/future-queue</title>
    <meta name="title" content="future-queue - nextest-rs/future-queue">
    <meta name="description" content="nextest-rs/future-queue - GitHub repository hi documentation and informationfuture-queue future_queue कई futures को चलाने के तरीके प्रदान करता है: एक साथ (concurrently) जिस क्रम में उन्हें शुरू किया गया है वैश्विक सीमाओं के साथ और प्रत्...">
    <meta name="keywords" content="nextest-rs, future-queue, GitHub, repository, hi documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/nextest-rs/future-queue/README-hi.html">
    <meta property="og:title" content="future-queue - nextest-rs/future-queue">
    <meta property="og:description" content="nextest-rs/future-queue - GitHub repository hi documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/nextest-rs/future-queue" id="githubRepoLink" target="_blank">nextest-rs/future-queue</a>
<h1 style="display: none;">future-queue future_queue कई futures को चलाने के तरीके प्रदान करता है: एक साथ (concurrently) जिस क्रम में उन्हें शुरू किया गया है वैश्विक सीमाओं के साथ और प्रत्...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>future-queue</h1>
<p><a href="https://crates.io/crates/future-queue"><img src="https://img.shields.io/crates/v/future-queue" alt="future-queue on crates.io" /></a>
<a href="https://docs.rs/future-queue/"><img src="https://img.shields.io/badge/docs-latest-brightgreen.svg" alt="Documentation (latest release)" /></a>
<a href="https://nextest-rs.github.io/future-queue/rustdoc/future_queue"><img src="https://img.shields.io/badge/docs-main-purple" alt="Documentation (main)" /></a>
<a href="https://raw.githubusercontent.com/nextest-rs/future-queue/main/CHANGELOG.md"><img src="https://img.shields.io/badge/changelog-latest-blue" alt="Changelog" /></a>
<a href="https://raw.githubusercontent.com/nextest-rs/future-queue/main/LICENSE-APACHE"><img src="https://img.shields.io/badge/license-Apache-green.svg" alt="License" /></a>
<a href="https://raw.githubusercontent.com/nextest-rs/future-queue/main/LICENSE-MIT"><img src="https://img.shields.io/badge/license-MIT-green.svg" alt="License" /></a></p>
<p><code>future_queue</code> कई futures को चलाने के तरीके प्रदान करता है:</p>
<ul>
<li>एक साथ (concurrently)</li>
<li>जिस क्रम में उन्हें शुरू किया गया है</li>
<li>वैश्विक सीमाओं के साथ</li>
<li>और प्रत्येक future के लिए एक वैकल्पिक समूह निर्दिष्ट किया जा सकता है, जिसकी अपनी सीमाएं हैं।</li>
</ul>
<p>यह crate GitHub पर <a href="https://github.com/nextest-rs">nextest organization</a> का हिस्सा है, और इसे <a href="https://nexte.st">cargo-nextest</a> की आवश्यकताओं को पूरा करने के लिए डिज़ाइन किया गया है।</p>
<h2>उद्देश्य</h2>
<p>Rust में असिंक्रोनस प्रोग्रामिंग अक्सर एक adaptor का उपयोग करती है जिसे <a href="https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html#method.buffer_unordered"><code>buffer_unordered</code></a> कहा जाता है: यह adaptor futures की एक stream लेता है[^1], और सभी futures को अधिकतम concurrency सीमा तक चलाता है।</p>
<ul>
<li>Futures उसी क्रम में शुरू किए जाते हैं जिस क्रम में उन्हें stream लौटाती है।</li>
<li>एक बार शुरू होने के बाद, futures को एक साथ poll किया जाता है, और पूर्ण हो चुके futures के आउटपुट किसी भी क्रम में लौटाए जाते हैं (इसलिए इसे <code>unordered</code> कहा जाता है)।</li>
</ul>
<p><code>buffer_unordered</code> के सामान्य उपयोग के मामले:</p>
<ul>
<li>नेटवर्क अनुरोधों को एक साथ भेजना, लेकिन concurrency को सीमित करना ताकि रिमोट सर्वर पर भार न पड़े।</li>
<li><a href="https://nexte.st">cargo-nextest</a> जैसे टूल से टेस्ट चलाना।</li>
</ul>
<p><code>buffer_unordered</code> कई मामलों में अच्छा काम करता है। हालांकि, इसकी एक समस्या यह है कि यह सभी futures को समान भार वाला मानता है: इसमें यह बताने का कोई तरीका नहीं है कि कुछ futures अन्य की तुलना में अधिक संसाधन लेते हैं, या कुछ futures के उपसमूहों को एक-दूसरे से अलग रखना चाहिए।</p>
<p>विशेष रूप से nextest के लिए, कुछ टेस्ट अन्य की तुलना में बहुत भारी हो सकते हैं, और ऐसे टेस्ट को कम संख्या में एक साथ चलाया जाना चाहिए। साथ ही, कुछ टेस्ट को अन्य से अलग रखा जाना चाहिए, या उन पर अन्य concurrency सीमाएं लगाई जानी चाहिए।</p>
<p>[^1]: अधिकतम सामान्यता के लिए यह adaptor futures की stream लेता है। व्यवहार में यह अक्सर futures के <em>iterator</em> होते हैं, जिन्हें <a href="https://docs.rs/futures/latest/futures/stream/fn.iter.html"><code>stream::iter</code></a> के माध्यम से stream में बदला जाता है।</p>
<h2>इस crate के बारे में</h2>
<p>यह crate streams पर दो adaptor प्रदान करता है।</p>
<h3>1. <code>future_queue</code> adaptor</h3>
<p><a href="StreamExt::future_queue"><code>future_queue</code></a> adaptor कई futures को एक साथ चला सकता है, concurrency को अधिकतम <em>weight</em> तक सीमित करता है।</p>
<p>यह adaptor futures की stream के बजाय <code>(usize, F)</code> जोड़ों की stream लेता है, जहाँ <code>usize</code> प्रत्येक future का weight दर्शाता है, और <code>F</code> है <code>FnOnce(FutureQueueContext) -&gt; impl Future</code>। यह adaptor futures को शेड्यूल और बफर करेगा जब तक कि अगला future जोड़ने से अधिकतम weight पार न हो जाए।</p>
<ul>
<li>अधिकतम weight कभी पार नहीं किया जाता जब futures चल रहे होते हैं।</li>
<li>यदि किसी व्यक्तिगत future का weight अधिकतम weight से अधिक है, तो उसका weight अधिकतम weight पर सेट कर दिया जाएगा।</li>
</ul>
<p>जब तक सभी संभावित futures शेड्यूल नहीं हो जाते, यह adaptor प्रतीक्षा करेगा जब तक वर्तमान में चल रहे futures का weight अधिकतम weight से कम नहीं हो जाता, फिर नए futures शेड्यूल करेगा।</p>
<p>किसी future का weight शून्य (zero) हो सकता है, ऐसे में वह अधिकतम weight में नहीं गिना जाएगा।</p>
<p>यदि सभी weights 1 हैं, तो <code>future_queue</code> ठीक उसी तरह काम करता है जैसे <code>buffer_unordered</code>।</p>
<h4>उदाहरण</h4>
<pre><code class="language-rust">use futures::{channel::oneshot, stream, StreamExt as _};
use future_queue::{StreamExt as _};

let (send_one, recv_one) = oneshot::channel();
let (send_two, recv_two) = oneshot::channel();

let stream_of_futures = stream::iter(
    vec![(1, recv_one), (2, recv_two)],
).map(|(weight, future)| {
    (weight, move |_cx| future)
});
let mut queue = stream_of_futures.future_queue(10);

send_two.send(&quot;hello&quot;)?;
assert_eq!(queue.next().await, Some(Ok(&quot;hello&quot;)));

send_one.send(&quot;world&quot;)?;
assert_eq!(queue.next().await, Some(Ok(&quot;world&quot;)));

assert_eq!(queue.next().await, None);
</code></pre>
<h3>2. <code>future_queue_grouped</code> adaptor</h3>
<p><a href="StreamExt::future_queue_grouped"><code>future_queue_grouped</code></a> adaptor <code>future_queue</code> जैसा है, लेकिन इसमें प्रत्येक future के लिए एक वैकल्पिक <em>group</em> निर्दिष्ट किया जा सकता है। प्रत्येक group का एक अधिकतम weight होता है, और future तभी शेड्यूल किया जाएगा जब वैश्विक और समूह weight दोनों पार न हों।</p>
<p>यह adaptor दिए गए constraints के तहत जितना हो सके उतना निष्पक्ष है: यह futures को उसी क्रम में शेड्यूल करेगा जैसा stream उन्हें लौटाता है, weight के आधार पर कोई पुन: क्रमबद्धता नहीं करेगा। जब किसी समूह का future पूरा होता है, तो इस समूह के queued futures को अन्य किसी भी stream से प्राप्त future से पहले प्राथमिकता दी जाएगी।</p>
<p><a href="StreamExt::future_queue"><code>future_queue</code></a> की तरह ही:</p>
<ul>
<li>वैश्विक और समूह के अधिकतम weight कभी पार नहीं किए जाते जब futures चल रहे होते हैं।</li>
<li>वैश्विक weight के लिए, यदि किसी व्यक्तिगत future का weight अधिकतम weight से अधिक है, तो उसका weight अधिकतम weight पर सेट कर दिया जाएगा।</li>
<li><em>यदि कोई future किसी समूह का हिस्सा है:</em> समूह weight के लिए, यदि उसका weight अधिकतम समूह weight से अधिक है, तो उसका weight अधिकतम समूह weight पर सेट कर दिया जाएगा।</li>
</ul>
<h4>उदाहरण</h4>
<pre><code class="language-rust">use futures::{channel::oneshot, stream, StreamExt as _};
use future_queue::{FutureQueueContext, StreamExt as _};

let (send_one, recv_one) = oneshot::channel();
let (send_two, recv_two) = oneshot::channel();

let stream_of_futures = stream::iter(
    vec![
        (1, Some(&quot;group1&quot;), recv_one),
        (2, None, recv_two),
    ],
).map(|(weight, group, future)| {
    (weight, group, move |_cx| future)
});
let mut queue = stream_of_futures.future_queue_grouped(10, [(&quot;group1&quot;, 5)]);

send_two.send(&quot;hello&quot;)?;
assert_eq!(queue.next().await, Some(Ok(&quot;hello&quot;)));

send_one.send(&quot;world&quot;)?;
assert_eq!(queue.next().await, Some(Ok(&quot;world&quot;)));

assert_eq!(queue.next().await, None);
</code></pre>
<h2>न्यूनतम समर्थित Rust संस्करण (MSRV)</h2>
<p>न्यूनतम समर्थित Rust संस्करण <strong>Rust 1.70</strong> है। किसी भी समय, कम से कम पिछले छह महीने की Rust स्थिर रिलीज़ समर्थित हैं।</p>
<p>जब तक यह crate प्री-रिलीज़ (0.x.x) है, इसका MSRV पैच रिलीज़ में बढ़ सकता है। एक बार जब यह crate 1.x पर पहुँच जाएगा, किसी भी MSRV वृद्धि के साथ नया माइनर वर्शन आएगा।</p>
<h2>नोट्स</h2>
<p>इस crate का पहले नाम <code>buffer-unordered-weighted</code> था। इसे <code>future-queue</code> नाम दिया गया ताकि यह crate के कार्य को उसके implementation से ज्यादा स्पष्ट करे।</p>
<h2>योगदान</h2>
<p>मदद करने के तरीके के लिए <a href="https://raw.githubusercontent.com/nextest-rs/future-queue/main/CONTRIBUTING.md">CONTRIBUTING</a> फ़ाइल देखें।</p>
<h2>लाइसेंस</h2>
<p>यह परियोजना <a href="https://raw.githubusercontent.com/nextest-rs/future-queue/main/LICENSE-APACHE">Apache 2.0 license</a> या <a href="https://raw.githubusercontent.com/nextest-rs/future-queue/main/LICENSE-MIT">MIT license</a> की शर्तों के तहत उपलब्ध है।</p>
<p>यह कोड <a href="https://github.com/rust-lang/futures-rs">futures-rs</a> से लिया गया है, और Apache 2.0 तथा MIT लाइसेंस के तहत उपयोग किया गया है।</p>
<!--
README.md README.tpl से cargo readme द्वारा जनरेट किया गया है। पुनः जनरेट करने के लिए, रिपोज़िटरी root से चलाएँ:

./scripts/regenerate-readmes.sh
-->
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-07</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>