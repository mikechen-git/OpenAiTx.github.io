<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniExcel - mini-software/MiniExcel</title>
    <meta name="title" content="MiniExcel - mini-software/MiniExcel">
    <meta name="description" content="mini-software/MiniExcel - GitHub repository fr documentation and informationCe projet fait partie de la .NET Foundation et fonctionne selon leur code de conduite. English | 简体中文 | 繁體中文 Votre étoile et votre don peuvent améliorer MiniExc...">
    <meta name="keywords" content="mini-software, MiniExcel, GitHub, repository, fr documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/mini-software/MiniExcel/README-fr.html">
    <meta property="og:title" content="MiniExcel - mini-software/MiniExcel">
    <meta property="og:description" content="mini-software/MiniExcel - GitHub repository fr documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/mini-software/MiniExcel" id="githubRepoLink" target="_blank">mini-software/MiniExcel</a>
<h1 style="display: none;">Ce projet fait partie de la .NET Foundation et fonctionne selon leur code de conduite. English | 简体中文 | 繁體中文 Votre étoile et votre don peuvent améliorer MiniExc...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div style="text-align: center">
<p><a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/nuget/v/MiniExcel.svg" alt="NuGet"></a>  <a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/nuget/dt/MiniExcel.svg" alt=""></a>
<a href="https://ci.appveyor.com/project/mini-software/miniexcel/branch/master"><img src="https://ci.appveyor.com/api/projects/status/b2vustrwsuqx45f4/branch/master?svg=true" alt="Build status"></a>
<a href="https://gitee.com/dotnetchina/MiniExcel"><img src="https://gitee.com/dotnetchina/MiniExcel/badge/star.svg" alt="star"></a> <a href="https://github.com/mini-software/MiniExcel" rel="nofollow"><img src="https://img.shields.io/github/stars/mini-software/MiniExcel?logo=github" alt="GitHub stars"></a>
<a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/badge/.NET-%3E%3D%204.5-red.svg" alt="version"></a>
<a href="https://deepwiki.com/mini-software/MiniExcel"><img src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
</p>
</div>
<hr />
<p><a href="https://www.dotnetfoundation.org/"><img align="right" src="https://github.com/dotnet-foundation/swag/blob/main/logo/dotnetfoundation_v4.png?raw=true" width="100" /></a></p>
<div style="text-align: center">
<p>Ce projet fait partie de la <a href="https://www.dotnetfoundation.org/">.NET Foundation</a> et fonctionne selon leur <a href="https://www.dotnetfoundation.org/code-of-conduct">code de conduite</a>. </p>
</div>
<hr />
<div style="text-align: center">
<p><strong><a href="README.md">English</a> | <a href="README.zh-CN.md">简体中文</a> | <a href="README.zh-Hant.md">繁體中文</a></strong></p>
</div>
<hr />
<div style="text-align: center">
 Votre <a href="https://github.com/mini-software/MiniExcel">étoile</a> et votre <a href="https://miniexcel.github.io">don</a> peuvent améliorer MiniExcel
</div>
<hr />
<h3>Introduction</h3>
<p>MiniExcel est un outil .NET simple et efficace pour traiter des fichiers Excel sans provoquer d’OOM.</p>
<p>À l’heure actuelle, la plupart des frameworks populaires nécessitent de charger toutes les données en mémoire pour faciliter leur traitement, ce qui peut entraîner des problèmes de consommation de mémoire. MiniExcel tente d’utiliser un algorithme basé sur le flux afin de réduire l’occupation mémoire initiale de 1000 Mo à quelques Mo, évitant ainsi les OOM (out of memory).</p>
<p><img src="https://user-images.githubusercontent.com/12729184/113086657-ab8bd000-9214-11eb-9563-c970ac1ee35e.png" alt="image" /></p>
<h3>Fonctionnalités</h3>
<ul>
<li>Faible consommation de mémoire, évite les OOM (out of memory) et les GC complets</li>
<li>Prise en charge de l’opération en temps réel sur chaque ligne de données</li>
<li>Prise en charge de l’exécution différée LINQ, permet de faire de la pagination rapide et à faible consommation ainsi que d’autres requêtes complexes</li>
<li>Léger, sans nécessiter Microsoft Office, pas de COM+, taille du DLL inférieure à 400 Ko</li>
<li>API simple pour lire/écrire/remplir des fichiers Excel</li>
</ul>
<h3>Démarrage rapide</h3>
<ul>
<li><p><a href="#getstart1">Importer/Interroger Excel</a></p>
</li>
<li><p><a href="#getstart2">Exporter/Créer Excel</a></p>
</li>
<li><p><a href="#getstart3">Modèle Excel</a></p>
</li>
<li><p><a href="#getstart4">Nom/Index/Ignorer l’attribut de colonne Excel</a></p>
</li>
<li><p><a href="#getstart5">Exemples</a></p>
</li>
</ul>
<h3>Installation</h3>
<p>Vous pouvez installer le package <a href="https://www.nuget.org/packages/MiniExcel">depuis NuGet</a></p>
<h3>Notes de version</h3>
<p>Veuillez consulter les <a href="docs">notes de version</a></p>
<h3>TODO</h3>
<p>Veuillez consulter le <a href="https://github.com/mini-software/MiniExcel/projects/1?fullscreen=true">TODO</a></p>
<h3>Performances</h3>
<p>Le code utilisé pour les benchmarks se trouve dans <a href="benchmarks/MiniExcel.Benchmarks/Program.cs">MiniExcel.Benchmarks</a>.</p>
<p>Le fichier utilisé pour tester les performances est <a href="benchmarks/MiniExcel.Benchmarks/Test1%2C000%2C000x10.xlsx"><strong>Test1,000,000x10.xlsx</strong></a>, un document de 32 Mo contenant 1 000 000 lignes * 10 colonnes, dont les cellules sont remplies avec la chaîne &quot;HelloWorld&quot;.</p>
<p>Pour exécuter tous les benchmarks, utilisez :</p>
<pre><code class="language-bash">dotnet run -project .\benchmarks\MiniExcel.Benchmarks -c Release -f net9.0 -filter * --join
</code></pre>
<p>Vous pouvez trouver les résultats des benchmarks pour la dernière version <a href="benchmarks/results">ici</a>.</p>
<h3>Interroger/Importer Excel  <a name="getstart1"></a></h3>
<h4>1. Exécuter une requête et mapper les résultats sur un IEnumerable fortement typé <a href="https://dotnetfiddle.net/w5WD1J">[Essayer]</a></h4>
<p>Il est recommandé d’utiliser Stream.Query pour une meilleure efficacité.</p>
<pre><code class="language-csharp">public class UserAccount
{
    public Guid ID { get; set; }
    public string Name { get; set; }
    public DateTime BoD { get; set; }
    public int Age { get; set; }
    public bool VIP { get; set; }
    public decimal Points { get; set; }
}

var rows = MiniExcel.Query&lt;UserAccount&gt;(path);

// ou

using (var stream = File.OpenRead(path))
    var rows = stream.Query&lt;UserAccount&gt;();
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/111107423-c8c46b80-8591-11eb-982f-c97a2dafb379.png" alt="image" /></p>
<h4>2. Exécuter une requête et la mapper sur une liste d’objets dynamiques sans utiliser d’en-tête <a href="https://dotnetfiddle.net/w5WD1J">[Essayer]</a></h4>
<ul>
<li>la clé dynamique est <code>A.B.C.D..</code></li>
</ul>
<p>| MiniExcel | 1 |
|-----------|---|
| Github    | 2 |</p>
<pre><code class="language-csharp">
var rows = MiniExcel.Query(path).ToList();

// ou
using (var stream = File.OpenRead(path))
{
    var rows = stream.Query().ToList();

    Assert.Equal(&quot;MiniExcel&quot;, rows[0].A);
    Assert.Equal(1, rows[0].B);
    Assert.Equal(&quot;Github&quot;, rows[1].A);
    Assert.Equal(2, rows[1].B);
}
</code></pre>
<h4>3. Exécuter une requête avec la première ligne d’en-tête <a href="https://dotnetfiddle.net/w5WD1J">[Essayer]</a></h4>
<p>note : en cas de nom de colonne identique, c’est la dernière à droite qui est prise</p>
<p>Excel d’entrée :</p>
<p>| Column1   | Column2 |
|-----------|---------|
| MiniExcel | 1       |
| Github    | 2       |</p>
<pre><code class="language-csharp">
var rows = MiniExcel.Query(useHeaderRow:true).ToList();

// ou

using (var stream = File.OpenRead(path))
{
    var rows = stream.Query(useHeaderRow:true).ToList();

    Assert.Equal(&quot;MiniExcel&quot;, rows[0].Column1);
    Assert.Equal(1, rows[0].Column2);
    Assert.Equal(&quot;Github&quot;, rows[1].Column1);
    Assert.Equal(2, rows[1].Column2);
}
</code></pre>
<h4>4. La requête prend en charge les extensions LINQ First/Take/Skip ...etc</h4>
<p>Requête First</p>
<pre><code class="language-csharp">var row = MiniExcel.Query(path).First();
Assert.Equal(&quot;HelloWorld&quot;, row.A);

// ou

using (var stream = File.OpenRead(path))
{
    var row = stream.Query().First();
    Assert.Equal(&quot;HelloWorld&quot;, row.A);
}
</code></pre>
<p>Performance entre MiniExcel/ExcelDataReader/ClosedXML/EPPlus
<img src="https://user-images.githubusercontent.com/12729184/111072392-6037a900-8515-11eb-9693-5ce2dad1e460.gif" alt="queryfirst" /></p>
<h4>5. Requêter par nom de feuille</h4>
<pre><code class="language-csharp">MiniExcel.Query(path, sheetName: &quot;SheetName&quot;);
//ou
stream.Query(sheetName: &quot;SheetName&quot;);
</code></pre>
<h4>6. Requêter tous les noms de feuilles et lignes</h4>
<pre><code class="language-csharp">var sheetNames = MiniExcel.GetSheetNames(path);
foreach (var sheetName in sheetNames)
{
    var rows = MiniExcel.Query(path, sheetName: sheetName);
}
</code></pre>
<h4>7. Obtenir les colonnes</h4>
<pre><code class="language-csharp">var columns = MiniExcel.GetColumns(path); // ex : résultat : [&quot;A&quot;,&quot;B&quot;...]

var cnt = columns.Count;  // obtenir le nombre de colonnes
</code></pre>
<h4>8. Requête dynamique cast ligne en <code>IDictionary&lt;string,object&gt;</code></h4>
<pre><code class="language-csharp">foreach(IDictionary&lt;string,object&gt; row in MiniExcel.Query(path))
{
    //..
}

// ou
var rows = MiniExcel.Query(path).Cast&lt;IDictionary&lt;string,object&gt;&gt;();
// ou Requête sur des plages spécifiées (en majuscules)
// A2 représente la deuxième ligne de la colonne A, C3 représente la troisième ligne de la colonne C
// Si vous ne voulez pas limiter les lignes, n'incluez simplement pas de chiffres
var rows = MiniExcel.QueryRange(path, startCell: &quot;A2&quot;, endCell: &quot;C3&quot;).Cast&lt;IDictionary&lt;string, object&gt;&gt;();
</code></pre>
<h4>9. Requête Excel retourne DataTable</h4>
<p>Non recommandé, car DataTable chargera toutes les données en mémoire et perdra la faible consommation mémoire de MiniExcel.</p>
<pre><code class="language-C#">var table = MiniExcel.QueryAsDataTable(path, useHeaderRow: true);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/116673475-07917200-a9d6-11eb-947e-a6f68cce58df.png" alt="image" /></p>
<h4>10. Spécifier la cellule de début de lecture des données</h4>
<pre><code class="language-csharp">MiniExcel.Query(path,useHeaderRow:true,startCell:&quot;B3&quot;)
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/117260316-8593c400-ae81-11eb-9877-c087b7ac2b01.png" alt="image" /></p>
<h4>11. Remplir les cellules fusionnées</h4>
<p>Remarque : L'efficacité est plus faible comparée à l'option <code>ne pas utiliser le remplissage fusionné</code></p>
<p>Raison : La norme OpenXml place mergeCells en bas du fichier, ce qui nécessite de parcourir deux fois le sheetxml</p>
<pre><code class="language-csharp">    var config = new OpenXmlConfiguration()
    {
        FillMergedCells = true
    };
    var rows = MiniExcel.Query(path, configuration: config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/117973630-3527d500-b35f-11eb-95c3-bde255f8114e.png" alt="image" /></p>
<p>prise en charge du remplissage multi-lignes et multi-colonnes de longueur et largeur variables</p>
<p><img src="https://user-images.githubusercontent.com/12729184/117973820-6d2f1800-b35f-11eb-88d8-555063938108.png" alt="image" /></p>
<h4>12. Lecture de gros fichier par cache disque (Disk-Base Cache - SharedString)</h4>
<p>Si la taille de SharedStrings dépasse 5 Mo, MiniExcel utilisera par défaut le cache local du disque, par exemple, <a href="https://github.com/MiniExcel/MiniExcel/files/8403819/NotDuplicateSharedStrings_10x100000.xlsx">10x100000.xlsx</a> (un million de lignes de données), lorsque le cache disque est désactivé, l'utilisation maximale de la mémoire est de 195 Mo, mais avec le cache disque activé il ne faut que 65 Mo. Attention, cette optimisation a un coût en efficacité, donc dans ce cas le temps de lecture passe de 7,4 secondes à 27,2 secondes. Si vous n'en avez pas besoin, vous pouvez désactiver le cache disque avec le code suivant :</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration { EnableSharedStringCache = false };
MiniExcel.Query(path,configuration: config)
</code></pre>
<p>Vous pouvez utiliser <code>SharedStringCacheSize</code> pour changer la taille du fichier sharedString au-delà de laquelle le cache disque sera utilisé</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration { SharedStringCacheSize=500*1024*1024 };
MiniExcel.Query(path, configuration: config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/161411851-1c3f72a7-33b3-4944-84dc-ffc1d16747dd.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/12729184/161411825-17f53ec7-bef4-4b16-b234-e24799ea41b0.png" alt="image" /></p>
<h3>Créer/Exporter Excel  <a name="getstart2"></a></h3>
<ol>
<li><p>Doit être un type non abstrait avec un constructeur public sans paramètre.</p>
</li>
<li><p>MiniExcel prend en charge l'exécution différée IEnumerable, si vous souhaitez utiliser le moins de mémoire possible, veuillez ne pas appeler de méthodes telles que ToList</p>
</li>
</ol>
<p>ex : ToList ou non, utilisation mémoire
<img src="https://user-images.githubusercontent.com/12729184/112587389-752b0b00-8e38-11eb-8a52-cfb76c57e5eb.png" alt="image" /></p>
<h4>1. Anonyme ou typé fortement <a href="https://dotnetfiddle.net/w5WD1J">[Essayez-le]</a></h4>
<pre><code class="language-csharp">var path = Path.Combine(Path.GetTempPath(), $&quot;{Guid.NewGuid()}.xlsx&quot;);
MiniExcel.SaveAs(path, new[] {
    new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
    new { Column1 = &quot;Github&quot;, Column2 = 2}
});
</code></pre>
<h4>2. <code>IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;</code></h4>
<pre><code class="language-csharp">var values = new List&lt;Dictionary&lt;string, object&gt;&gt;()
{
    new Dictionary&lt;string,object&gt;{{ &quot;Column1&quot;, &quot;MiniExcel&quot; }, { &quot;Column2&quot;, 1 } },
    new Dictionary&lt;string,object&gt;{{ &quot;Column1&quot;, &quot;Github&quot; }, { &quot;Column2&quot;, 2 } }
};
MiniExcel.SaveAs(path, values);
</code></pre>
<p>Résultat du fichier créé :</p>
<p>| Column1   | Column2 |
|-----------|---------|
| MiniExcel | 1       |
| Github    | 2       |</p>
<h4>3.  IDataReader</h4>
<ul>
<li><code>Recommandé</code>, cela permet d'éviter de charger toutes les données en mémoire</li>
</ul>
<pre><code class="language-csharp">MiniExcel.SaveAs(path, reader);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/121275378-149a5e80-c8bc-11eb-85fe-5453552134f0.png" alt="image" /></p>
<p>Export DataReader vers plusieurs feuilles (recommandé via Dapper ExecuteReader)</p>
<pre><code class="language-csharp">using (var cnn = Connection)
{
    cnn.Open();
    var sheets = new Dictionary&lt;string,object&gt;();
    sheets.Add(&quot;sheet1&quot;, cnn.ExecuteReader(&quot;select 1 id&quot;));
    sheets.Add(&quot;sheet2&quot;, cnn.ExecuteReader(&quot;select 2 id&quot;));
    MiniExcel.SaveAs(&quot;Demo.xlsx&quot;, sheets);
}
</code></pre>
<h4>4. Datatable</h4>
<ul>
<li><p><code>Non recommandé</code>, cela chargera toutes les données en mémoire</p>
</li>
<li><p>DataTable utilise Caption comme nom de colonne en premier, puis le nom de colonne</p>
</li>
</ul>
<pre><code class="language-csharp">var path = Path.Combine(Path.GetTempPath(), $&quot;{Guid.NewGuid()}.xlsx&quot;);
var table = new DataTable();
{
    table.Columns.Add(&quot;Column1&quot;, typeof(string));
    table.Columns.Add(&quot;Column2&quot;, typeof(decimal));
    table.Rows.Add(&quot;MiniExcel&quot;, 1);
    table.Rows.Add(&quot;Github&quot;, 2);
}

MiniExcel.SaveAs(path, table);
</code></pre>
<h4>5. Dapper Query</h4>
<p>Merci à @shaofing #552 , veuillez utiliser <code>CommandDefinition + CommandFlags.NoCache</code></p>
<pre><code class="language-csharp">using (var connection = GetConnection(connectionString))
{
    var rows = connection.Query(
        new CommandDefinition(
            @&quot;select 'MiniExcel' as Column1,1 as Column2 union all select 'Github',2&quot;
            , flags: CommandFlags.NoCache)
        );
    // Remarque : QueryAsync provoquera une exception de connexion fermée
    MiniExcel.SaveAs(path, rows);
</code></pre>
<p>}</p>
<pre><code>
Le code ci-dessous chargera toutes les données en mémoire

```csharp
using (var connection = GetConnection(connectionString))
{
    var rows = connection.Query(@&quot;select 'MiniExcel' as Column1,1 as Column2 union all select 'Github',2&quot;);
    MiniExcel.SaveAs(path, rows);
}
</code></pre>
<h4>6. SaveAs vers MemoryStream  <a href="https://dotnetfiddle.net/JOen0e">[Essayez-le]</a></h4>
<pre><code class="language-csharp">using (var stream = new MemoryStream()) //supporte FileStream, MemoryStream etc.
{
    stream.SaveAs(values);
}
</code></pre>
<p>ex : API d’export excel</p>
<pre><code class="language-csharp">public IActionResult DownloadExcel()
{
    var values = new[] {
        new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
        new { Column1 = &quot;Github&quot;, Column2 = 2}
    };

    var memoryStream = new MemoryStream();
    memoryStream.SaveAs(values);
    memoryStream.Seek(0, SeekOrigin.Begin);
    return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
    {
        FileDownloadName = &quot;demo.xlsx&quot;
    };
}
</code></pre>
<h4>7. Créer plusieurs feuilles</h4>
<pre><code class="language-csharp">// 1. Dictionary&lt;string,object&gt;
var users = new[] { new { Name = &quot;Jack&quot;, Age = 25 }, new { Name = &quot;Mike&quot;, Age = 44 } };
var department = new[] { new { ID = &quot;01&quot;, Name = &quot;RH&quot; }, new { ID = &quot;02&quot;, Name = &quot;IT&quot; } };
var sheets = new Dictionary&lt;string, object&gt;
{
    [&quot;users&quot;] = users,
    [&quot;department&quot;] = department
};
MiniExcel.SaveAs(path, sheets);

// 2. DataSet
var sheets = new DataSet();
sheets.Add(UsersDataTable);
sheets.Add(DepartmentDataTable);
//..
MiniExcel.SaveAs(path, sheets);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/118130875-6e7c4580-b430-11eb-9b82-22f02716bd63.png" alt="image" /></p>
<h4>8. Options TableStyles</h4>
<p>Style par défaut</p>
<p><img src="https://user-images.githubusercontent.com/12729184/138234373-cfa97109-b71f-4711-b7f5-0eaaa4a0a3a6.png" alt="image" /></p>
<p>Sans configuration de style</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration()
{
     TableStyles = TableStyles.None
};
MiniExcel.SaveAs(path, value,configuration:config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/118784917-f3e57700-b8c2-11eb-8718-8d955b1bc197.png" alt="image" /></p>
<h4>9. AutoFilter</h4>
<p>Depuis la v0.19.0, <code>OpenXmlConfiguration.AutoFilter</code> permet d’activer/désactiver l’AutoFilter, la valeur par défaut est <code>true</code>, et la configuration de l’AutoFilter se fait comme suit :</p>
<pre><code class="language-csharp">MiniExcel.SaveAs(path, value, configuration: new OpenXmlConfiguration() { AutoFilter = false });
</code></pre>
<h4>10. Créer une image</h4>
<pre><code class="language-csharp">var value = new[] {
    new { Name=&quot;github&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/github_logo.png&quot;))},
    new { Name=&quot;google&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/google_logo.png&quot;))},
    new { Name=&quot;microsoft&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/microsoft_logo.png&quot;))},
    new { Name=&quot;reddit&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/reddit_logo.png&quot;))},
    new { Name=&quot;statck_overflow&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/statck_overflow_logo.png&quot;))},
};
MiniExcel.SaveAs(path, value);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/150462383-ad9931b3-ed8d-4221-a1d6-66f799743433.png" alt="image" /></p>
<h4>11. Export de fichiers sous forme de tableau d’octets (Byte Array)</h4>
<p>Depuis la version 1.22.0, lorsque le type de la valeur est <code>byte[]</code>, le système sauvegarde le chemin du fichier dans la cellule par défaut, et lors de l’import, le système peut le convertir en <code>byte[]</code>. Si vous ne souhaitez pas utiliser cette fonctionnalité, vous pouvez définir <code>OpenXmlConfiguration.EnableConvertByteArray</code> à <code>false</code>, ce qui peut améliorer l’efficacité du système.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/153702334-c3b834f4-6ae4-4ddf-bd4e-e5005d5d8c6a.png" alt="image" /></p>
<p>Depuis la version 1.22.0, lorsque le type de la valeur est <code>byte[]</code>, le système sauvegarde le chemin du fichier dans la cellule par défaut, et lors de l’import, le système peut le convertir en <code>byte[]</code>. Si vous ne souhaitez pas utiliser cette fonctionnalité, vous pouvez définir <code>OpenXmlConfiguration.EnableConvertByteArray</code> à <code>false</code>, ce qui peut améliorer l’efficacité du système.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/153702334-c3b834f4-6ae4-4ddf-bd4e-e5005d5d8c6a.png" alt="image" /></p>
<h4>12. Fusionner les cellules identiques verticalement</h4>
<p>Cette fonctionnalité n’est prise en charge que dans le format <code>xlsx</code> et fusionne les cellules verticalement entre les balises @merge et @endmerge.
Vous pouvez utiliser @mergelimit pour limiter la portée de la fusion verticale des cellules.</p>
<pre><code class="language-csharp">var mergedFilePath = Path.Combine(Path.GetTempPath(), $&quot;{Guid.NewGuid().ToString()}.xlsx&quot;);

var path = @&quot;../../../../../samples/xlsx/TestMergeWithTag.xlsx&quot;;

MiniExcel.MergeSameCells(mergedFilePath, path);
</code></pre>
<pre><code class="language-csharp">var memoryStream = new MemoryStream();

var path = @&quot;../../../../../samples/xlsx/TestMergeWithTag.xlsx&quot;;

memoryStream.MergeSameCells(path);
</code></pre>
<p>Contenu du fichier avant et après la fusion :</p>
<p>Sans limite de fusion :</p>
<img width="318" alt="Screenshot 2023-08-07 at 11 59 24" src="https://github.com/mini-software/MiniExcel/assets/38832863/49cc96b9-6c35-4bf3-8d43-a9752a15b22e">
<img width="318" alt="Screenshot 2023-08-07 at 11 59 57" src="https://github.com/mini-software/MiniExcel/assets/38832863/3fbd529b-3ae6-4bbe-b4d8-2793a5a58010">
<p>Avec limite de fusion :</p>
<img width="346" alt="Screenshot 2023-08-08 at 18 21 00" src="https://github.com/mini-software/MiniExcel/assets/38832863/04049d28-84d5-4c2a-bcff-5847547df5e1">
<img width="346" alt="Screenshot 2023-08-08 at 18 21 40" src="https://github.com/mini-software/MiniExcel/assets/38832863/f5cf8957-b0b0-4831-b8fc-8556299235c2">
<h4>13. Ignorer les valeurs nulles</h4>
<p>Nouvelle option explicite pour écrire des cellules vides pour les valeurs nulles :</p>
<pre><code class="language-csharp">DataTable dt = new DataTable();

/* ... */

DataRow dr = dt.NewRow();

dr[&quot;Name1&quot;] = &quot;Somebody once&quot;;
dr[&quot;Name2&quot;] = null;
dr[&quot;Name3&quot;] = &quot;told me.&quot;;

dt.Rows.Add(dr);

OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
     EnableWriteNullValueCell = true // Valeur par défaut.
};

MiniExcel.SaveAs(@&quot;C:\temp\Book1.xlsx&quot;, dt, configuration: configuration);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/31481586/241419455-3c0aec8a-4e5f-4d83-b7ec-6572124c165d.png" alt="image" /></p>
<pre><code class="language-xml">&lt;x:row r=&quot;2&quot;&gt;
    &lt;x:c r=&quot;A2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;Somebody once&lt;/x:v&gt;
    &lt;/x:c&gt;
    &lt;x:c r=&quot;B2&quot; s=&quot;2&quot;&gt;&lt;/x:c&gt;
    &lt;x:c r=&quot;C2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;told me.&lt;/x:v&gt;
    &lt;/x:c&gt;
&lt;/x:row&gt;
</code></pre>
<p>Comportement précédent :</p>
<pre><code class="language-csharp">/* ... */

OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
     EnableWriteNullValueCell = false // La valeur par défaut est true.
};

MiniExcel.SaveAs(@&quot;C:\temp\Book1.xlsx&quot;, dt, configuration: configuration);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/31481586/241419441-c4f27e8f-3f87-46db-a10f-08665864c874.png" alt="image" /></p>
<pre><code class="language-xml">&lt;x:row r=&quot;2&quot;&gt;
    &lt;x:c r=&quot;A2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;Somebody once&lt;/x:v&gt;
    &lt;/x:c&gt;
    &lt;x:c r=&quot;B2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;&lt;/x:v&gt;
    &lt;/x:c&gt;
    &lt;x:c r=&quot;C2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;told me.&lt;/x:v&gt;
    &lt;/x:c&gt;
&lt;/x:row&gt;
</code></pre>
<p>Fonctionne pour les valeurs null et DBNull.</p>
<h4>14. Figer les volets</h4>
<pre><code class="language-csharp">/* ... */

OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
    FreezeRowCount = 1,     // la valeur par défaut est 1
    FreezeColumnCount = 2   // la valeur par défaut est 0
};

MiniExcel.SaveAs(@&quot;C:\temp\Book1.xlsx&quot;, dt, configuration: configuration);
</code></pre>
<p><img src="https://raw.githubusercontent.com/mini-software/MiniExcel/master/docs/images/freeze-pane-1.png" alt="image" /></p>
<h3>Remplir les données dans un modèle Excel <a name="getstart3"></a></h3>
<ul>
<li>La déclaration est similaire au template Vue <code>{{nom de la variable}}</code>, ou au rendu de collection <code>{{nom de la collection.nom du champ}}</code></li>
<li>Le rendu de collection prend en charge IEnumerable/DataTable/DapperRow</li>
</ul>
<h4>1. Remplissage basique</h4>
<p>Modèle :
<img src="https://user-images.githubusercontent.com/12729184/114537556-ed8d2b00-9c84-11eb-8303-a69f62c41e5b.png" alt="image" /></p>
<p>Résultat :
<img src="https://user-images.githubusercontent.com/12729184/114537490-d8180100-9c84-11eb-8c69-db58692f3a85.png" alt="image" /></p>
<p>Code :</p>
<pre><code class="language-csharp">// 1. Par POCO
var value = new
{
    Name = &quot;Jack&quot;,
    CreateDate = new DateTime(2021, 01, 01),
    VIP = true,
    Points = 123
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);


// 2. Par Dictionnaire
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;Name&quot;] = &quot;Jack&quot;,
    [&quot;CreateDate&quot;] = new DateTime(2021, 01, 01),
    [&quot;VIP&quot;] = true,
    [&quot;Points&quot;] = 123
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>2. Remplissage de données IEnumerable</h4>
<blockquote>
<p>Note1 : Utilisez le premier IEnumerable de la même colonne comme base pour remplir la liste</p>
</blockquote>
<p>Modèle :
<img src="https://user-images.githubusercontent.com/12729184/114564652-14f2f080-9ca3-11eb-831f-09e3fedbc5fc.png" alt="image" /></p>
<p>Résultat :
<img src="https://user-images.githubusercontent.com/12729184/114564204-b2015980-9ca2-11eb-900d-e21249f93f7c.png" alt="image" /></p>
<p>Code :</p>
<pre><code class="language-csharp">//1. Par POCO
var value = new
{
    employees = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Lisa&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;HR&quot;},
        new {name=&quot;Mike&quot;,department=&quot;IT&quot;},
        new {name=&quot;Neo&quot;,department=&quot;IT&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);

//2. Par Dictionnaire
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;employees&quot;] = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Lisa&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;HR&quot;},
        new {name=&quot;Mike&quot;,department=&quot;IT&quot;},
        new {name=&quot;Neo&quot;,department=&quot;IT&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>3. Remplissage de données complexe</h4>
<blockquote>
<p>Note : Prend en charge plusieurs feuilles et l'utilisation de la même variable</p>
</blockquote>
<p>Modèle :</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114565255-acf0da00-9ca3-11eb-8a7f-8131b2265ae8.png" alt="image" /></p>
<p>Résultat :</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114565329-bf6b1380-9ca3-11eb-85e3-3969e8bf6378.png" alt="image" /></p>
<pre><code class="language-csharp">// 1. Par POCO
var value = new
{
    title = &quot;FooCompany&quot;,
    managers = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    },
    employees = new[] {
        new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
        new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
        new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
        new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);

// 2. Par Dictionnaire
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;title&quot;] = &quot;FooCompany&quot;,
    [&quot;managers&quot;] = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    },
    [&quot;employees&quot;] = new[] {
        new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
        new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
        new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
        new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>4. Remplissage de grandes données (performance)</h4>
<blockquote>
<p>REMARQUE : L'utilisation de IEnumerable en exécution différée au lieu de ToList permet d'économiser un maximum de mémoire dans MiniExcel</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/12729184/114577091-5046ec80-9cae-11eb-924b-087c7becf8da.png" alt="image" /></p>
<h4>5. Mappage automatique du type de valeur de cellule</h4>
<p>Modèle</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114802504-64830a80-9dd0-11eb-8d56-8e8c401b3ace.png" alt="image" /></p>
<p>Résultat</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114802419-43221e80-9dd0-11eb-9ffe-a2ce34fe7076.png" alt="image" /></p>
<p>Classe</p>
<pre><code class="language-csharp">public class Poco
{
    public string @string { get; set; }
    public int? @int { get; set; }
</code></pre>
<pre><code class="language-csharp">public decimal? @decimal { get; set; }
public double? @double { get; set; }
public DateTime? datetime { get; set; }
public bool? @bool { get; set; }
public Guid? Guid { get; set; }
}
</code></pre>
<p>Code</p>
<pre><code class="language-csharp">var poco = new TestIEnumerableTypePoco { @string = &quot;string&quot;, @int = 123, @decimal = decimal.Parse(&quot;123.45&quot;), @double = (double)123.33, @datetime = new DateTime(2021, 4, 1), @bool = true, @Guid = Guid.NewGuid() };
var value = new
{
    Ts = new[] {
        poco,
        new TestIEnumerableTypePoco{},
        null,
        poco
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>6. Exemple : Lister les projets Github</h4>
<p>Modèle</p>
<p><img src="https://user-images.githubusercontent.com/12729184/115068623-12073280-9f25-11eb-9124-f4b3efcdb2a7.png" alt="image" /></p>
<p>Résultat</p>
<p><img src="https://user-images.githubusercontent.com/12729184/115068639-1a5f6d80-9f25-11eb-9f45-27c434d19a78.png" alt="image" /></p>
<p>Code</p>
<pre><code class="language-csharp">var projects = new[]
{
    new {Name = &quot;MiniExcel&quot;,Link=&quot;https://github.com/mini-software/MiniExcel&quot;,Star=146, CreateTime=new DateTime(2021,03,01)},
    new {Name = &quot;HtmlTableHelper&quot;,Link=&quot;https://github.com/mini-software/HtmlTableHelper&quot;,Star=16, CreateTime=new DateTime(2020,02,01)},
    new {Name = &quot;PocoClassGenerator&quot;,Link=&quot;https://github.com/mini-software/PocoClassGenerator&quot;,Star=16, CreateTime=new DateTime(2019,03,17)}
};
var value = new
{
    User = &quot;ITWeiHan&quot;,
    Projects = projects,
    TotalStar = projects.Sum(s =&gt; s.Star)
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>7. Remplissage de données groupées</h4>
<pre><code class="language-csharp">var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;employees&quot;] = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;IT&quot;},
        new {name=&quot;Neo&quot;,department=&quot;IT&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    }
};
await MiniExcel.SaveAsByTemplateAsync(path, templatePath, value);
</code></pre>
<h5>1. Avec le tag <code>@group</code> et avec le tag <code>@header</code></h5>
<p>Avant</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646717-21b9d57a-2be2-4e9a-801b-ae212231d2b4.PNG" alt="before_with_header" /></p>
<p>Après</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646721-58a7a340-7004-4bc2-af24-cffcb2c20737.PNG" alt="after_with_header" /></p>
<h5>2. Avec le tag @group et sans le tag @header</h5>
<p>Avant</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646873-b12417fa-801b-4890-8e96-669ed3b43902.PNG" alt="before_without_header" /></p>
<p>Après</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646872-622461ba-342e-49ee-834f-b91ad9c2dac3.PNG" alt="after_without_header" /></p>
<h5>3. Sans le tag @group</h5>
<p>Avant</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646975-f52a68eb-e031-43b5-abaa-03b67c052d1a.PNG" alt="without_group" /></p>
<p>Après</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646974-4a3c0e07-7c66-4088-ad07-b4ad3695b7e1.PNG" alt="without_group_after" /></p>
<h4>8. Instructions If/ElseIf/Else à l'intérieur d'une cellule</h4>
<p>Règles :</p>
<ol>
<li>Prend en charge DateTime, Double, Int avec les opérateurs ==, !=, &gt;, &gt;=, &lt;, &lt;=.</li>
<li>Prend en charge String avec les opérateurs ==, !=.</li>
<li>Chaque instruction doit être sur une nouvelle ligne.</li>
<li>Un espace doit être ajouté avant et après les opérateurs.</li>
<li>Il ne doit pas y avoir de nouvelle ligne à l'intérieur des instructions.</li>
<li>La cellule doit être exactement au format ci-dessous.</li>
</ol>
<pre><code class="language-csharp">@if(name == Jack)
{{employees.name}}
@elseif(name == Neo)
Test {{employees.name}}
@else
{{employees.department}}
@endif
</code></pre>
<p>Avant</p>
<p><img src="https://user-images.githubusercontent.com/12729184/235360606-ca654769-ff55-4f5b-98d2-d2ec0edb8173.PNG" alt="if_before" /></p>
<p>Après</p>
<p><img src="https://user-images.githubusercontent.com/12729184/235360609-869bb960-d63d-45ae-8d64-9e8b0d0ab658.PNG" alt="if_after" /></p>
<h4>9. DataTable comme paramètre</h4>
<pre><code class="language-csharp">var managers = new DataTable();
{
    managers.Columns.Add(&quot;name&quot;);
    managers.Columns.Add(&quot;department&quot;);
    managers.Rows.Add(&quot;Jack&quot;, &quot;HR&quot;);
    managers.Rows.Add(&quot;Loan&quot;, &quot;IT&quot;);
}
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;title&quot;] = &quot;FooCompany&quot;,
    [&quot;managers&quot;] = managers,
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>10. Formules</h4>
<h5>1. Exemple</h5>
<p>Préfixez votre formule avec <code>$</code> et utilisez <code>$enumrowstart</code> et <code>$enumrowend</code> pour marquer les références au début et à la fin des lignes énumérées :</p>
<p><img src="docs/images/template-formulas-1.png" alt="image" /></p>
<p>Lorsque le modèle est rendu, le préfixe <code>$</code> sera supprimé et <code>$enumrowstart</code> et <code>$enumrowend</code> seront remplacés par les numéros de lignes de début et de fin de l'énumération :</p>
<p><img src="docs/images/template-formulas-2.png" alt="image" /></p>
<h5>2. Autres exemples de formules :</h5>
<p>|              |                                                                                           |
|--------------|-------------------------------------------------------------------------------------------|
| Somme        | <code>$=SUM(C{{$enumrowstart}}:C{{$enumrowend}})</code>                                              |
| Moyenne alt. | <code>$=SUM(C{{$enumrowstart}}:C{{$enumrowend}}) / COUNT(C{{$enumrowstart}}:C{{$enumrowend}})</code> |
| Plage        | <code>$=MAX(C{{$enumrowstart}}:C{{$enumrowend}}) - MIN(C{{$enumrowstart}}:C{{$enumrowend}})</code>   |</p>
<h4>11. Autres</h4>
<h5>1. Vérification de la clé du paramètre de modèle</h5>
<p>Depuis la version V1.24.0, la clé de paramètre manquante dans le modèle est ignorée par défaut et remplacée par une chaîne vide. <code>IgnoreTemplateParameterMissing</code> peut contrôler si une exception doit être levée ou non.</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration()
{
    IgnoreTemplateParameterMissing = false,
};
MiniExcel.SaveAsByTemplate(path, templatePath, value, config)
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/157464332-e316f829-54aa-4c84-a5aa-9aef337b668d.png" alt="image" /></p>
<h3>Attribut Nom/Index/Ignore de colonne Excel <a name="getstart4"></a></h3>
<h4>1. Spécifier le nom de colonne, l'index de colonne, ignorer la colonne</h4>
<p>Exemple Excel</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114230869-3e163700-99ac-11eb-9a90-2039d4b4b313.png" alt="image" /></p>
<p>Code</p>
<pre><code class="language-csharp">public class ExcelAttributeDemo
{
    [ExcelColumnName(&quot;Column1&quot;)]
</code></pre>
<pre><code class="language-csharp">public string Test1 { get; set; }
[ExcelColumnName(&quot;Column2&quot;)]
public string Test2 { get; set; }
[ExcelIgnore]
public string Test3 { get; set; }
[ExcelColumnIndex(&quot;I&quot;)] // le système convertira &quot;I&quot; en index 8
public string Test4 { get; set; }
public string Test5 { get; } //sans set sera ignoré
public string Test6 { get; private set; } //set non-public sera ignoré
[ExcelColumnIndex(3)] // commence à 0
public string Test7 { get; set; }
}

var rows = MiniExcel.Query&lt;ExcelAttributeDemo&gt;(path).ToList();
Assert.Equal(&quot;Column1&quot;, rows[0].Test1);
Assert.Equal(&quot;Column2&quot;, rows[0].Test2);
Assert.Null(rows[0].Test3);
Assert.Equal(&quot;Test7&quot;, rows[0].Test4);
Assert.Null(rows[0].Test5);
Assert.Null(rows[0].Test6);
Assert.Equal(&quot;Test4&quot;, rows[0].Test7);
</code></pre>
<h4>2. Format personnalisé (ExcelFormatAttribute)</h4>
<p>Depuis la version V0.21.0, prise en charge des classes contenant une méthode <code>ToString(string content)</code> pour le format</p>
<p>Classe</p>
<pre><code class="language-csharp">public class Dto
{
    public string Name { get; set; }

    [ExcelFormat(&quot;MMMM dd, yyyy&quot;)]
    public DateTime InDate { get; set; }
}
</code></pre>
<p>Code</p>
<pre><code class="language-csharp">var value = new Dto[] {
    new Issue241Dto{ Name=&quot;Jack&quot;,InDate=new DateTime(2021,01,04)},
    new Issue241Dto{ Name=&quot;Henry&quot;,InDate=new DateTime(2020,04,05)},
};
MiniExcel.SaveAs(path, value);
</code></pre>
<p>Résultat</p>
<p><img src="https://user-images.githubusercontent.com/12729184/118910788-ab2bcd80-b957-11eb-8d42-bfce36621b1b.png" alt="image" /></p>
<p>La requête prend en charge la conversion de format personnalisé</p>
<p><img src="https://user-images.githubusercontent.com/12729184/118911286-87b55280-b958-11eb-9a88-c8ff403d240a.png" alt="image" /></p>
<h4>3. Définir la largeur de colonne (ExcelColumnWidthAttribute)</h4>
<pre><code class="language-csharp">public class Dto
{
    [ExcelColumnWidth(20)]
    public int ID { get; set; }
    [ExcelColumnWidth(15.50)]
    public string Name { get; set; }
}
</code></pre>
<h4>4. Mappage de plusieurs noms de colonnes vers la même propriété.</h4>
<pre><code class="language-csharp">public class Dto
{
    [ExcelColumnName(excelColumnName:&quot;EmployeeNo&quot;,aliases:new[] { &quot;EmpNo&quot;,&quot;No&quot; })]
    public string Empno { get; set; }
    public string Name { get; set; }
}
</code></pre>
<h4>5. System.ComponentModel.DisplayNameAttribute = ExcelColumnName.excelColumnNameAttribute</h4>
<p>Depuis la version 1.24.0, le système prend en charge System.ComponentModel.DisplayNameAttribute = ExcelColumnName.excelColumnNameAttribute</p>
<pre><code class="language-C#">public class TestIssueI4TXGTDto
{
    public int ID { get; set; }
    public string Name { get; set; }
    [DisplayName(&quot;Specification&quot;)]
    public string Spc { get; set; }
    [DisplayName(&quot;Unit Price&quot;)]
    public decimal Up { get; set; }
}
</code></pre>
<h4>6. ExcelColumnAttribute</h4>
<p>Depuis la version V1.26.0, plusieurs attributs peuvent être simplifiés comme suit :</p>
<pre><code class="language-csharp">        public class TestIssueI4ZYUUDto
        {
            [ExcelColumn(Name = &quot;ID&quot;,Index =0)]
            public string MyProperty { get; set; }
            [ExcelColumn(Name = &quot;CreateDate&quot;, Index = 1,Format =&quot;yyyy-MM&quot;,Width =100)]
            public DateTime MyProperty2 { get; set; }
        }
</code></pre>
<h4>7. DynamicColumnAttribute</h4>
<p>Depuis la version V1.26.0, on peut définir dynamiquement les attributs de colonne</p>
<pre><code class="language-csharp">            var config = new OpenXmlConfiguration
            {
                DynamicColumns = new DynamicExcelColumn[] {
                    new DynamicExcelColumn(&quot;id&quot;){Ignore=true},
                    new DynamicExcelColumn(&quot;name&quot;){Index=1,Width=10},
                    new DynamicExcelColumn(&quot;createdate&quot;){Index=0,Format=&quot;yyyy-MM-dd&quot;,Width=15},
                    new DynamicExcelColumn(&quot;point&quot;){Index=2,Name=&quot;Account Point&quot;},
                }
            };
            var path = PathHelper.GetTempPath();
            var value = new[] { new { id = 1, name = &quot;Jack&quot;, createdate = new DateTime(2022, 04, 12) ,point = 123.456} };
            MiniExcel.SaveAs(path, value, configuration: config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/164510353-5aecbc4e-c3ce-41e8-b6cf-afd55eb23b68.png" alt="image" /></p>
<h4>8. DynamicSheetAttribute</h4>
<p>Depuis la version V1.31.4, on peut définir dynamiquement les attributs de la feuille. On peut définir le nom et l'état (visibilité) de la feuille.</p>
<pre><code class="language-csharp">            var configuration = new OpenXmlConfiguration
            {
                DynamicSheets = new DynamicExcelSheet[] {
                    new DynamicExcelSheet(&quot;usersSheet&quot;) { Name = &quot;Users&quot;, State = SheetState.Visible },
                    new DynamicExcelSheet(&quot;departmentSheet&quot;) { Name = &quot;Departments&quot;, State = SheetState.Hidden }
                }
            };

            var users = new[] { new { Name = &quot;Jack&quot;, Age = 25 }, new { Name = &quot;Mike&quot;, Age = 44 } };
            var department = new[] { new { ID = &quot;01&quot;, Name = &quot;HR&quot; }, new { ID = &quot;02&quot;, Name = &quot;IT&quot; } };
            var sheets = new Dictionary&lt;string, object&gt;
            {
                [&quot;usersSheet&quot;] = users,
                [&quot;departmentSheet&quot;] = department
            };

            var path = PathHelper.GetTempPath();
            MiniExcel.SaveAs(path, sheets, configuration: configuration);
</code></pre>
<p>On peut aussi utiliser le nouvel attribut ExcelSheetAttribute :</p>
<pre><code class="language-C#">   [ExcelSheet(Name = &quot;Departments&quot;, State = SheetState.Hidden)]
   private class DepartmentDto
   {
      [ExcelColumn(Name = &quot;ID&quot;,Index = 0)]
      public string ID { get; set; }
      [ExcelColumn(Name = &quot;Name&quot;,Index = 1)]
      public string Name { get; set; }
   }
</code></pre>
<h3>Ajouter, Supprimer, Mettre à jour</h3>
<h4>Ajouter</h4>
<p>Depuis la version v1.28.0, prise en charge de l'insertion de N lignes dans un fichier CSV après la dernière ligne</p>
<pre><code class="language-csharp">// Origine
{
    var value = new[] {
          new { ID=1,Name =&quot;Jack&quot;,InDate=new DateTime(2021,01,03)},
          new { ID=2,Name =&quot;Henry&quot;,InDate=new DateTime(2020,05,03)},
    };
    MiniExcel.SaveAs(path, value);
}
// Insérer 1 ligne après la dernière
{
    var value = new { ID=3,Name = &quot;Mike&quot;, InDate = new DateTime(2021, 04, 23) };
    MiniExcel.Insert(path, value);
}
// Insérer N lignes après la dernière
{
    var value = new[] {
          new { ID=4,Name =&quot;Frank&quot;,InDate=new DateTime(2021,06,07)},
          new { ID=5,Name =&quot;Gloria&quot;,InDate=new DateTime(2022,05,03)},
```csharp
};
MiniExcel.Insert(path, value);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/191023733-1e2fa732-db5c-4a3a-9722-b891fe5aa069.png" alt="image" /></p>
<p>v1.37.0 supporte l'insertion d'une nouvelle feuille dans un classeur Excel existant</p>
<pre><code class="language-csharp">// Excel d'origine
{
    var value = new[] {
          new { ID=1,Name =&quot;Jack&quot;,InDate=new DateTime(2021,01,03)},
          new { ID=2,Name =&quot;Henry&quot;,InDate=new DateTime(2020,05,03)},
    };
    MiniExcel.SaveAs(path, value, sheetName: &quot;Sheet1&quot;);
}
// Insérer une nouvelle feuille
{
    var value = new { ID=3,Name = &quot;Mike&quot;, InDate = new DateTime(2021, 04, 23) };
    MiniExcel.Insert(path, table, sheetName: &quot;Sheet2&quot;);
}
</code></pre>
<h4>Supprimer (en attente)</h4>
<h4>Mettre à jour (en attente)</h4>
<h3>Vérification automatique du type Excel <a name="getstart5"></a></h3>
<ul>
<li>MiniExcel vérifiera s'il s'agit d'un fichier xlsx ou csv en se basant sur l'<code>extension du fichier</code> par défaut, mais cela peut être inexact, veuillez le spécifier manuellement.</li>
<li>Le type de fichier ne peut pas être déterminé à partir d'un flux, veuillez le spécifier manuellement.</li>
</ul>
<pre><code class="language-csharp">stream.SaveAs(excelType:ExcelType.CSV);
//ou
stream.SaveAs(excelType:ExcelType.XLSX);
//ou
stream.Query(excelType:ExcelType.CSV);
//ou
stream.Query(excelType:ExcelType.XLSX);
</code></pre>
<h3>CSV</h3>
<h4>Remarque</h4>
<ul>
<li>Par défaut, le retour est de type <code>string</code>, et la valeur ne sera pas convertie en nombre ou en datetime, sauf si le type est défini via un générique fortement typé.</li>
</ul>
<h4>Séparateur personnalisé</h4>
<p>Le séparateur par défaut est <code>,</code>, vous pouvez modifier la propriété <code>Seperator</code> pour le personnaliser</p>
<pre><code class="language-csharp">var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    Seperator=';'
};
MiniExcel.SaveAs(path, values,configuration: config);
</code></pre>
<p>Depuis la V1.30.1, prise en charge de la fonction de séparateur personnalisé (merci @hyzx86)</p>
<pre><code class="language-csharp">var config = new CsvConfiguration()
{
    SplitFn = (row) =&gt; Regex.Split(row, $&quot;[\t,](?=(?:[^\&quot;]|\&quot;[^\&quot;]*\&quot;)*$)&quot;)
        .Select(s =&gt; Regex.Replace(s.Replace(&quot;\&quot;\&quot;&quot;, &quot;\&quot;&quot;), &quot;^\&quot;|\&quot;$&quot;, &quot;&quot;)).ToArray()
};
var rows = MiniExcel.Query(path, configuration: config).ToList();
</code></pre>
<h4>Saut de ligne personnalisé</h4>
<p>Par défaut, le saut de ligne est <code>\r\n</code>, vous pouvez modifier la propriété <code>NewLine</code> pour la personnaliser</p>
<pre><code class="language-csharp">var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    NewLine='\n'
};
MiniExcel.SaveAs(path, values,configuration: config);
</code></pre>
<h4>Encodage personnalisé</h4>
<ul>
<li>L'encodage par défaut est &quot;Detect Encoding From Byte Order Marks&quot;  (detectEncodingFromByteOrderMarks: true)</li>
<li>Si vous avez des besoins d'encodage spécifiques, veuillez modifier la propriété StreamReaderFunc / StreamWriterFunc</li>
</ul>
<pre><code class="language-csharp">// Lecture
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    StreamReaderFunc = (stream) =&gt; new StreamReader(stream,Encoding.GetEncoding(&quot;gb2312&quot;))
};
var rows = MiniExcel.Query(path, true,excelType:ExcelType.CSV,configuration: config);

// Écriture
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    StreamWriterFunc = (stream) =&gt; new StreamWriter(stream, Encoding.GetEncoding(&quot;gb2312&quot;))
};
MiniExcel.SaveAs(path, value,excelType:ExcelType.CSV, configuration: config);
</code></pre>
<h4>Lire une chaîne vide comme null</h4>
<p>Par défaut, les valeurs vides sont mappées à string.Empty. Vous pouvez modifier ce comportement</p>
<pre><code class="language-csharp">var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
   ReadEmptyStringAsNull = true
};
</code></pre>
<h3>DataReader</h3>
<h4>1. GetReader</h4>
<p>Depuis la version 1.23.0, vous pouvez utiliser GetDataReader</p>
<pre><code class="language-csharp">    using (var reader = MiniExcel.GetReader(path,true))
    {
        while (reader.Read())
        {
            for (int i = 0; i &lt; reader.FieldCount; i++)
            {
                var value = reader.GetValue(i);
            }
        }
    }
</code></pre>
<h3>Async</h3>
<ul>
<li>v0.17.0 supporte l'Async (merci à isdaniel ( SHIH,BING-SIOU)](https://github.com/isdaniel))</li>
</ul>
<pre><code class="language-csharp">public static Task SaveAsAsync(string path, object value, bool printHeader = true, string sheetName = &quot;Sheet1&quot;, ExcelType excelType = ExcelType.UNKNOWN, IConfiguration configuration = null)
public static Task SaveAsAsync(this Stream stream, object value, bool printHeader = true, string sheetName = &quot;Sheet1&quot;, ExcelType excelType = ExcelType.XLSX, IConfiguration configuration = null)
public static Task&lt;IEnumerable&lt;dynamic&gt;&gt; QueryAsync(string path, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null)
public static Task&lt;IEnumerable&lt;T&gt;&gt; QueryAsync&lt;T&gt;(this Stream stream, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null) where T : class, new()
public static Task&lt;IEnumerable&lt;T&gt;&gt; QueryAsync&lt;T&gt;(string path, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null) where T : class, new()
public static Task&lt;IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;&gt; QueryAsync(this Stream stream, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null)
public static Task SaveAsByTemplateAsync(this Stream stream, string templatePath, object value)
public static Task SaveAsByTemplateAsync(this Stream stream, byte[] templateBytes, object value)
public static Task SaveAsByTemplateAsync(string path, string templatePath, object value)
public static Task SaveAsByTemplateAsync(string path, byte[] templateBytes, object value)
public static Task&lt;DataTable&gt; QueryAsDataTableAsync(string path, bool useHeaderRow = true, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null)
</code></pre>
<ul>
<li>v1.25.0 supporte le <code>cancellationToken</code>.</li>
</ul>
<h3>Autres</h3>
<h4>1. Enum</h4>
<p>Assurez-vous que le nom dans Excel et le nom de la propriété sont identiques, le système effectuera le mapping automatiquement (insensible à la casse)</p>
<p><img src="https://user-images.githubusercontent.com/12729184/116210595-9784b100-a775-11eb-936f-8e7a8b435961.png" alt="image" /></p>
<p>Depuis la V0.18.0, prise en charge de la description des Enum</p>
<pre><code class="language-csharp">public class Dto
{
    public string Name { get; set; }
    public I49RYZUserType UserType { get; set; }
}

public enum Type
{
    [Description(&quot;Utilisateur Général&quot;)]
    V1,
    [Description(&quot;Administrateur Général&quot;)]
    V2,
    [Description(&quot;Super Administrateur&quot;)]
    V3
}
</code></pre>
<pre><code>
![image](https://user-images.githubusercontent.com/12729184/133116630-27cc7161-099a-48b8-9784-cd1e443af3d1.png)

Depuis la version 1.30.0, prise en charge de la Description Excel vers Enum, merci à @KaneLeung

#### 2. Convertir CSV en XLSX ou convertir XLSX en CSV

```csharp
MiniExcel.ConvertXlsxToCsv(xlsxPath, csvPath);
MiniExcel.ConvertXlsxToCsv(xlsxStream, csvStream);
MiniExcel.ConvertCsvToXlsx(csvPath, xlsxPath);
MiniExcel.ConvertCsvToXlsx(csvStream, xlsxStream);
</code></pre>
<pre><code class="language-csharp">using (var excelStream = new FileStream(path: filePath, FileMode.Open, FileAccess.Read))
using (var csvStream = new MemoryStream())
{
   MiniExcel.ConvertXlsxToCsv(excelStream, csvStream);
}
</code></pre>
<h4>3. Personnaliser CultureInfo</h4>
<p>Depuis la version 1.22.0, vous pouvez personnaliser CultureInfo comme ci-dessous, par défaut le système utilise <code>CultureInfo.InvariantCulture</code>.</p>
<pre><code class="language-csharp">var config = new CsvConfiguration()
{
    Culture = new CultureInfo(&quot;fr-FR&quot;),
};
MiniExcel.SaveAs(path, value, configuration: config);

// ou
MiniExcel.Query(path, configuration: config);
</code></pre>
<h4>4. Personnaliser la taille du tampon (Buffer Size)</h4>
<pre><code class="language-csharp">    public abstract class Configuration : IConfiguration
    {
        public int BufferSize { get; set; } = 1024 * 512;
    }
</code></pre>
<h4>5. FastMode</h4>
<p>Le système ne contrôle pas la mémoire, mais vous pouvez obtenir une vitesse d'enregistrement plus rapide.</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration() { FastMode = true };
MiniExcel.SaveAs(path, reader,configuration:config);
</code></pre>
<h4>6. Ajout en lot d'image (MiniExcel.AddPicture)</h4>
<pre><code class="language-csharp">var images = new[]
{
    new MiniExcelPicture
    {
        ImageBytes = File.ReadAllBytes(PathHelper.GetFile(&quot;images/github_logo.png&quot;)),
        SheetName = null, // null par défaut correspond à la première feuille
        CellAddress = &quot;C3&quot;, // requis
    },
    new MiniExcelPicture
    {
        ImageBytes = File.ReadAllBytes(PathHelper.GetFile(&quot;images/google_logo.png&quot;)),
        PictureType = &quot;image/png&quot;, // PictureType = image/png par défaut
        SheetName = &quot;Demo&quot;,
        CellAddress = &quot;C9&quot;, // requis
        WidthPx = 100,
        HeightPx = 100,
    },
};
MiniExcel.AddPicture(path, images);
</code></pre>
<p><img src="https://github.com/user-attachments/assets/19c4d241-9753-4ede-96c8-f810c1a22247" alt="Image" /></p>
<h4>7. Obtenir les dimensions des feuilles</h4>
<pre><code class="language-csharp">var dim = MiniExcel.GetSheetDimensions(path);
</code></pre>
<h3>Exemples :</h3>
<h4>1. SQLite &amp; Dapper <code>Fichier de grande taille</code> Insert SQL pour éviter OOM</h4>
<p>note : veuillez ne pas appeler les méthodes ToList/ToArray après Query, cela chargerait toutes les données en mémoire</p>
<pre><code class="language-csharp">using (var connection = new SQLiteConnection(connectionString))
{
    connection.Open();
    using (var transaction = connection.BeginTransaction())
    using (var stream = File.OpenRead(path))
    {
       var rows = stream.Query();
       foreach (var row in rows)
             connection.Execute(&quot;insert into T (A,B) values (@A,@B)&quot;, new { row.A, row.B }, transaction: transaction);
       transaction.Commit();
    }
}
</code></pre>
<p>performance :
<img src="https://user-images.githubusercontent.com/12729184/111072579-2dda7b80-8516-11eb-9843-c01a1edc88ec.png" alt="image" /></p>
<h4>2. ASP.NET Core 3.1 ou MVC 5 API de téléchargement/upload Excel Xlsx <a href="tests/MiniExcel.Tests.AspNetCore">Essayez-le</a></h4>
<pre><code class="language-csharp">public class ApiController : Controller
{
    public IActionResult Index()
    {
        return new ContentResult
        {
            ContentType = &quot;text/html&quot;,
            StatusCode = (int)HttpStatusCode.OK,
            Content = @&quot;&lt;html&gt;&lt;body&gt;
&lt;a href='api/DownloadExcel'&gt;DownloadExcel&lt;/a&gt;&lt;br&gt;
&lt;a href='api/DownloadExcelFromTemplatePath'&gt;DownloadExcelFromTemplatePath&lt;/a&gt;&lt;br&gt;
&lt;a href='api/DownloadExcelFromTemplateBytes'&gt;DownloadExcelFromTemplateBytes&lt;/a&gt;&lt;br&gt;
&lt;p&gt;Upload Excel&lt;/p&gt;
&lt;form method='post' enctype='multipart/form-data' action='/api/uploadexcel'&gt;
    &lt;input type='file' name='excel'&gt; &lt;br&gt;
    &lt;input type='submit' &gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;&quot;
        };
    }

    public IActionResult DownloadExcel()
    {
        var values = new[] {
            new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
            new { Column1 = &quot;Github&quot;, Column2 = 2}
        };
        var memoryStream = new MemoryStream();
        memoryStream.SaveAs(values);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
        {
            FileDownloadName = &quot;demo.xlsx&quot;
        };
    }

    public IActionResult DownloadExcelFromTemplatePath()
    {
        string templatePath = &quot;TestTemplateComplex.xlsx&quot;;

        Dictionary&lt;string, object&gt; value = new Dictionary&lt;string, object&gt;()
        {
            [&quot;title&quot;] = &quot;FooCompany&quot;,
            [&quot;managers&quot;] = new[] {
                new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
                new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
            },
            [&quot;employees&quot;] = new[] {
                new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
                new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
                new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
                new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
            }
        };

        MemoryStream memoryStream = new MemoryStream();
        memoryStream.SaveAsByTemplate(templatePath, value);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
        {
            FileDownloadName = &quot;demo.xlsx&quot;
        };
    }

    private static Dictionary&lt;string, Byte[]&gt; TemplateBytesCache = new Dictionary&lt;string, byte[]&gt;();

    static ApiController()
    {
        string templatePath = &quot;TestTemplateComplex.xlsx&quot;;
        byte[] bytes = System.IO.File.ReadAllBytes(templatePath);
        TemplateBytesCache.Add(templatePath, bytes);
    }

    public IActionResult DownloadExcelFromTemplateBytes()
    {
        byte[] bytes = TemplateBytesCache[&quot;TestTemplateComplex.xlsx&quot;];

        Dictionary&lt;string, object&gt; value = new Dictionary&lt;string, object&gt;()
        {
            [&quot;title&quot;] = &quot;FooCompany&quot;,
            [&quot;managers&quot;] = new[] {
                new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
                new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
</code></pre>
<pre><code class="language-csharp">            },
            [&quot;employees&quot;] = new[] {
                new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
                new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
                new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
                new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
            }
        };

        MemoryStream memoryStream = new MemoryStream();
        memoryStream.SaveAsByTemplate(bytes, value);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
        {
            FileDownloadName = &quot;demo.xlsx&quot;
        };
    }

    public IActionResult UploadExcel(IFormFile excel)
    {
        var stream = new MemoryStream();
        excel.CopyTo(stream);

        foreach (var item in stream.Query(true))
        {
            // effectuez votre logique, etc.
        }

        return Ok(&quot;Fichier téléchargé avec succès&quot;);
    }
}
</code></pre>
<h4>3. Requête paginée</h4>
<pre><code class="language-csharp">void Main()
{
    var rows = MiniExcel.Query(path);

    Console.WriteLine(&quot;==== Page n°1 ====&quot;);
    Console.WriteLine(Page(rows,pageSize:3,page:1));
    Console.WriteLine(&quot;==== Page n°50 ====&quot;);
    Console.WriteLine(Page(rows,pageSize:3,page:50));
    Console.WriteLine(&quot;==== Page n°5000 ====&quot;);
    Console.WriteLine(Page(rows,pageSize:3,page:5000));
}

public static IEnumerable&lt;T&gt; Page&lt;T&gt;(IEnumerable&lt;T&gt; en, int pageSize, int page)
{
    return en.Skip(page * pageSize).Take(pageSize);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/114679083-6ef4c400-9d3e-11eb-9f78-a86daa45fe46.gif" alt="20210419" /></p>
<h4>4. Exportation Excel WebForm via MemoryStream</h4>
<pre><code class="language-csharp">var fileName = &quot;Demo.xlsx&quot;;
var sheetName = &quot;Sheet1&quot;;
HttpResponse response = HttpContext.Current.Response;
response.Clear();
response.ContentType = &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;;
response.AddHeader(&quot;Content-Disposition&quot;, $&quot;attachment;filename=\&quot;{fileName}\&quot;&quot;);
var values = new[] {
    new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
    new { Column1 = &quot;Github&quot;, Column2 = 2}
};
var memoryStream = new MemoryStream();
memoryStream.SaveAs(values, sheetName: sheetName);
memoryStream.Seek(0, SeekOrigin.Begin);
memoryStream.CopyTo(Response.OutputStream);
response.End();
</code></pre>
<h4>5. i18n dynamique multilingue et gestion des rôles/autorités</h4>
<p>Comme dans l'exemple, créez une méthode pour gérer l’i18n et la gestion des permissions, et utilisez <code>yield return</code> pour retourner <code>IEnumerable&lt;Dictionary&lt;string, object&gt;&gt;</code> afin d’obtenir un traitement dynamique et à faible consommation mémoire.</p>
<pre><code class="language-csharp">void Main()
{
    var value = new Order[] {
        new Order(){OrderNo = &quot;SO01&quot;,CustomerID=&quot;C001&quot;,ProductID=&quot;P001&quot;,Qty=100,Amt=500},
        new Order(){OrderNo = &quot;SO02&quot;,CustomerID=&quot;C002&quot;,ProductID=&quot;P002&quot;,Qty=300,Amt=400},
    };

    Console.WriteLine(&quot;en-Us et rôle Sales&quot;);
    {
        var path = Path.GetTempPath() + Guid.NewGuid() + &quot;.xlsx&quot;;
        var lang = &quot;en-US&quot;;
        var role = &quot;Sales&quot;;
        MiniExcel.SaveAs(path, GetOrders(lang, role, value));
        MiniExcel.Query(path, true).Dump();
    }

    Console.WriteLine(&quot;zh-CN et rôle PMC&quot;);
    {
        var path = Path.GetTempPath() + Guid.NewGuid() + &quot;.xlsx&quot;;
        var lang = &quot;zh-CN&quot;;
        var role = &quot;PMC&quot;;
        MiniExcel.SaveAs(path, GetOrders(lang, role, value));
        MiniExcel.Query(path, true).Dump();
    }
}

private IEnumerable&lt;Dictionary&lt;string, object&gt;&gt; GetOrders(string lang, string role, Order[] orders)
{
    foreach (var order in orders)
    {
        var newOrder = new Dictionary&lt;string, object&gt;();

        if (lang == &quot;zh-CN&quot;)
        {
            newOrder.Add(&quot;客户编号&quot;, order.CustomerID);
            newOrder.Add(&quot;订单编号&quot;, order.OrderNo);
            newOrder.Add(&quot;产品编号&quot;, order.ProductID);
            newOrder.Add(&quot;数量&quot;, order.Qty);
            if (role == &quot;Sales&quot;)
                newOrder.Add(&quot;价格&quot;, order.Amt);
            yield return newOrder;
        }
        else if (lang == &quot;en-US&quot;)
        {
            newOrder.Add(&quot;Customer ID&quot;, order.CustomerID);
            newOrder.Add(&quot;Order No&quot;, order.OrderNo);
            newOrder.Add(&quot;Product ID&quot;, order.ProductID);
            newOrder.Add(&quot;Quantity&quot;, order.Qty);
            if (role == &quot;Sales&quot;)
                newOrder.Add(&quot;Amount&quot;, order.Amt);
            yield return newOrder;
        }
        else
        {
            throw new InvalidDataException($&quot;lang {lang} wrong&quot;);
        }
    }
}

public class Order
{
    public string OrderNo { get; set; }
    public string CustomerID { get; set; }
    public decimal Qty { get; set; }
    public string ProductID { get; set; }
    public decimal Amt { get; set; }
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/118939964-d24bc480-b982-11eb-88dd-f06655f6121a.png" alt="image" /></p>
<h3>FAQ</h3>
<h4>Q : Le titre de l’en-tête Excel n’est pas identique au nom de la propriété de la classe, comment faire le mapping ?</h4>
<p>R. Veuillez utiliser l’attribut ExcelColumnName.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/116020475-eac50980-a678-11eb-8804-129e87200e5e.png" alt="image" /></p>
<h4>Q. Comment interroger ou exporter plusieurs feuilles (multi-sheets) ?</h4>
<p>R. Utilisez la méthode <code>GetSheetNames</code> avec le paramètre sheetName dans Query.</p>
<pre><code class="language-csharp">var sheets = MiniExcel.GetSheetNames(path);
foreach (var sheet in sheets)
{
    Console.WriteLine($&quot;nom de la feuille : {sheet} &quot;);
    var rows = MiniExcel.Query(path,useHeaderRow:true,sheetName:sheet);
    Console.WriteLine(rows);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/116199841-2a1f5300-a76a-11eb-90a3-6710561cf6db.png" alt="image" /></p>
<h4>Q. Comment interroger ou exporter des informations sur la visibilité des feuilles ?</h4>
<p>R. Utilisez la méthode <code>GetSheetInformations</code>.</p>
<pre><code class="language-csharp">var sheets = MiniExcel.GetSheetInformations(path);
foreach (var sheetInfo in sheets)
{
    Console.WriteLine($&quot;index de la feuille : {sheetInfo.Index} &quot;); // index de la feuille - numéroté à partir de 0
    Console.WriteLine($&quot;nom de la feuille : {sheetInfo.Name} &quot;);   // nom de la feuille
    Console.WriteLine($&quot;état de la feuille : {sheetInfo.State} &quot;); // état de visibilité de la feuille - visible / cachée
}
</code></pre>
<h4>Q. Est-ce que l’utilisation de Count charge toutes les données en mémoire ?</h4>
<p>Non, le test d'image comporte 1 million de lignes * 10 colonnes de données, l'utilisation maximale de la mémoire est &lt;60 Mo, et cela prend 13,65 secondes</p>
<p><img src="https://user-images.githubusercontent.com/12729184/117118518-70586000-adc3-11eb-9ce3-2ba76cf8b5e5.png" alt="image" /></p>
<h4>Q. Comment Query utilise-t-il des index entiers ?</h4>
<p>L'index par défaut de Query est la clé sous forme de chaîne : A,B,C.... Si vous souhaitez passer à un index numérique, veuillez créer la méthode suivante pour convertir</p>
<pre><code class="language-csharp">void Main()
{
    var path = @&quot;D:\git\MiniExcel\samples\xlsx\TestTypeMapping.xlsx&quot;;
    var rows = MiniExcel.Query(path,true);
    foreach (var r in ConvertToIntIndexRows(rows))
    {
        Console.Write($&quot;column 0 : {r[0]} ,column 1 : {r[1]}&quot;);
        Console.WriteLine();
    }
}

private IEnumerable&lt;Dictionary&lt;int, object&gt;&gt; ConvertToIntIndexRows(IEnumerable&lt;object&gt; rows)
{
    ICollection&lt;string&gt; keys = null;
    var isFirst = true;
    foreach (IDictionary&lt;string,object&gt; r in rows)
    {
        if(isFirst)
        {
            keys = r.Keys;
            isFirst = false;
        }

        var dic = new Dictionary&lt;int, object&gt;();
        var index = 0;
        foreach (var key in keys)
            dic[index++] = r[key];
        yield return dic;
    }
}
</code></pre>
<h4>Q. Un Excel vide sans titre est généré lorsque la valeur est vide à l’export Excel</h4>
<p>Parce que MiniExcel utilise une logique similaire à JSON.NET pour obtenir dynamiquement le type à partir des valeurs afin de simplifier les opérations de l’API, le type ne peut pas être connu sans données. Vous pouvez consulter <a href="https://github.com/mini-software/MiniExcel/issues/133">issue #133</a> pour plus d'explications.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/122639771-546c0c00-d12e-11eb-800c-498db27889ca.png" alt="image" /></p>
<blockquote>
<p>Les types forts et DataTable généreront des en-têtes, mais les Dictionary donneront toujours un fichier Excel vide</p>
</blockquote>
<h4>Q. Comment arrêter le foreach lorsqu’une ligne est vide ?</h4>
<p>MiniExcel peut être utilisé avec <code>LINQ TakeWhile</code> pour arrêter l’itérateur foreach.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/130209137-162621c2-f337-4479-9996-beeac65bc4d4.png" alt="Image" /></p>
<h4>Q. Comment supprimer les lignes vides ?</h4>
<p><img src="https://user-images.githubusercontent.com/12729184/137873865-7107d8f5-eb59-42db-903a-44e80589f1b2.png" alt="image" /></p>
<p>IEnumerable :</p>
<pre><code class="language-csharp">public static IEnumerable&lt;dynamic&gt; QueryWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
{
    var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
    foreach (IDictionary&lt;string,object&gt; row in rows)
    {
        if(row.Keys.Any(key=&gt;row[key]!=null))
            yield return row;
    }
}
</code></pre>
<p>DataTable :</p>
<pre><code class="language-csharp">public static DataTable QueryAsDataTableWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
{
    if (sheetName == null &amp;&amp; excelType != ExcelType.CSV) /*Issue #279*/
        sheetName = stream.GetSheetNames().First();

    var dt = new DataTable(sheetName);
    var first = true;
    var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
    foreach (IDictionary&lt;string, object&gt; row in rows)
    {
        if (first)
        {

            foreach (var key in row.Keys)
            {
                var column = new DataColumn(key, typeof(object)) { Caption = key };
                dt.Columns.Add(column);
            }

            dt.BeginLoadData();
            first = false;
        }

        var newRow = dt.NewRow();
        var isNull=true;
        foreach (var key in row.Keys)
        {
            var _v = row[key];
            if(_v!=null)
                isNull = false;
            newRow[key] = _v;
        }

        if(!isNull)
            dt.Rows.Add(newRow);
    }

    dt.EndLoadData();
    return dt;
}
</code></pre>
<h4>Q. Comment SaveAs(path,value) peut-il remplacer un fichier existant sans lever l’erreur &quot;The file ...xlsx already exists error&quot;</h4>
<p>Veuillez utiliser la classe Stream pour personnaliser la logique de création de fichier, par exemple :</p>
<pre><code class="language-C#">    using (var stream = File.Create(&quot;Demo.xlsx&quot;))
        MiniExcel.SaveAs(stream,value);
</code></pre>
<p>ou, depuis la version V1.25.0, SaveAs prend en charge le paramètre overwriteFile pour activer/désactiver l’écrasement du fichier existant</p>
<pre><code class="language-csharp">    MiniExcel.SaveAs(path, value, overwriteFile: true);
</code></pre>
<h3>Limitations et avertissements</h3>
<ul>
<li>Ne prend pas en charge xls et les fichiers chiffrés pour le moment</li>
<li>xlsm prend uniquement en charge Query</li>
</ul>
<h3>Références</h3>
<p><a href="https://github.com/ExcelDataReader/ExcelDataReader">ExcelDataReader</a>  / <a href="https://github.com/ClosedXML/ClosedXML">ClosedXML</a> / <a href="https://github.com/DapperLib/Dapper">Dapper</a> / <a href="https://github.com/andersnm/ExcelNumberFormat">ExcelNumberFormat</a></p>
<h3>Remerciements</h3>
<h4><a href="https://www.jetbrains.com/">Jetbrains</a></h4>
<p><img src="https://user-images.githubusercontent.com/12729184/123997015-8456c180-da02-11eb-829a-aec476fe8e94.png" alt="jetbrains-variant-2" /></p>
<p>Merci d’avoir fourni une licence gratuite All product IDE pour ce projet (<a href="https://user-images.githubusercontent.com/12729184/123988233-6ab17c00-d9fa-11eb-8739-2a08c6a4a263.png">Licence</a>)</p>
<h3>Partage de contribution - dons</h3>
<p>Lien https://github.com/orgs/mini-software/discussions/754</p>
<h3>Contributeurs</h3>
<p><img src="https://contrib.rocks/image?repo=mini-software/MiniExcel" alt="" /></p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-08</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>