<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniExcel - mini-software/MiniExcel</title>
    <meta name="title" content="MiniExcel - mini-software/MiniExcel">
    <meta name="description" content="mini-software/MiniExcel - GitHub repository fa documentation and informationاین پروژه بخشی از .NET Foundation است و تحت کد رفتار آن فعالیت می‌کند. English | 简体中文 | 繁體中文 ستاره شما و حمایت مالی شما می‌تواند MiniExcel را بهتر کند معرفی Min...">
    <meta name="keywords" content="mini-software, MiniExcel, GitHub, repository, fa documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/mini-software/MiniExcel/README-fa.html">
    <meta property="og:title" content="MiniExcel - mini-software/MiniExcel">
    <meta property="og:description" content="mini-software/MiniExcel - GitHub repository fa documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/mini-software/MiniExcel" id="githubRepoLink" target="_blank">mini-software/MiniExcel</a>
<h1 style="display: none;">این پروژه بخشی از .NET Foundation است و تحت کد رفتار آن فعالیت می‌کند. English | 简体中文 | 繁體中文 ستاره شما و حمایت مالی شما می‌تواند MiniExcel را بهتر کند معرفی Min...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div style="text-align: center">
<p><a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/nuget/v/MiniExcel.svg" alt="NuGet"></a>  <a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/nuget/dt/MiniExcel.svg" alt=""></a>
<a href="https://ci.appveyor.com/project/mini-software/miniexcel/branch/master"><img src="https://ci.appveyor.com/api/projects/status/b2vustrwsuqx45f4/branch/master?svg=true" alt="Build status"></a>
<a href="https://gitee.com/dotnetchina/MiniExcel"><img src="https://gitee.com/dotnetchina/MiniExcel/badge/star.svg" alt="star"></a> <a href="https://github.com/mini-software/MiniExcel" rel="nofollow"><img src="https://img.shields.io/github/stars/mini-software/MiniExcel?logo=github" alt="GitHub stars"></a>
<a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/badge/.NET-%3E%3D%204.5-red.svg" alt="version"></a>
<a href="https://deepwiki.com/mini-software/MiniExcel"><img src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
</p>
</div>
<hr />
<p><a href="https://www.dotnetfoundation.org/"><img align="right" src="https://github.com/dotnet-foundation/swag/blob/main/logo/dotnetfoundation_v4.png?raw=true" width="100" /></a></p>
<div style="text-align: center">
<p>این پروژه بخشی از <a href="https://www.dotnetfoundation.org/">.NET Foundation</a> است و تحت <a href="https://www.dotnetfoundation.org/code-of-conduct">کد رفتار</a> آن فعالیت می‌کند. </p>
</div>
<hr />
<div style="text-align: center">
<p><strong><a href="README.md">English</a> | <a href="README.zh-CN.md">简体中文</a> | <a href="README.zh-Hant.md">繁體中文</a></strong></p>
</div>
<hr />
<div style="text-align: center">
 ستاره <a href="https://github.com/mini-software/MiniExcel">شما</a> و <a href="https://miniexcel.github.io">حمایت مالی</a> شما می‌تواند MiniExcel را بهتر کند
</div>
<hr />
<h3>معرفی</h3>
<p>MiniExcel ابزاری ساده و کارآمد برای پردازش اکسل در .NET است که از بروز خطای OOM جلوگیری می‌کند.</p>
<p>در حال حاضر، اکثر فریم‌ورک‌های محبوب برای سهولت کار، تمام داده‌ها را در حافظه بارگذاری می‌کنند، اما این کار باعث مصرف بیش از حد حافظه می‌شود. MiniExcel تلاش می‌کند با استفاده از الگوریتم جریان (stream)، اشغال حافظه را از ۱۰۰۰ مگابایت به چند مگابایت کاهش دهد تا از بروز خطای OOM (تمام شدن حافظه) جلوگیری کند.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/113086657-ab8bd000-9214-11eb-9563-c970ac1ee35e.png" alt="image" /></p>
<h3>ویژگی‌ها</h3>
<ul>
<li>مصرف پایین حافظه، جلوگیری از OOM (تمام شدن حافظه) و GC کامل</li>
<li>پشتیبانی از عملیات بلادرنگ بر روی هر ردیف داده</li>
<li>پشتیبانی از اجرای تنبل LINQ، امکان انجام پرس‌وجوهای پیچیده با مصرف پایین و صفحه‌بندی سریع</li>
<li>سبک، بدون نیاز به نصب Microsoft Office، بدون COM+، اندازه DLL کمتر از ۴۰۰ کیلوبایت</li>
<li>API ساده برای خواندن/نوشتن/پر کردن اکسل</li>
</ul>
<h3>شروع سریع</h3>
<ul>
<li><p><a href="#getstart1">وارد کردن/پرس‌وجوی اکسل</a></p>
</li>
<li><p><a href="#getstart2">خروجی/ایجاد اکسل</a></p>
</li>
<li><p><a href="#getstart3">قالب اکسل</a></p>
</li>
<li><p><a href="#getstart4">نام/ایندکس/ویژگی نادیده گرفتن ستون اکسل</a></p>
</li>
<li><p><a href="#getstart5">مثال‌ها</a></p>
</li>
</ul>
<h3>نصب</h3>
<p>می‌توانید این بسته را <a href="https://www.nuget.org/packages/MiniExcel">از NuGet</a> نصب کنید.</p>
<h3>یادداشت‌های انتشار</h3>
<p>لطفاً <a href="docs">یادداشت‌های انتشار</a> را بررسی کنید.</p>
<h3>TODO</h3>
<p>لطفاً <a href="https://github.com/mini-software/MiniExcel/projects/1?fullscreen=true">TODO</a> را بررسی کنید.</p>
<h3>کارایی</h3>
<p>کد بنچمارک‌ها را می‌توانید در <a href="benchmarks/MiniExcel.Benchmarks/Program.cs">MiniExcel.Benchmarks</a> پیدا کنید.</p>
<p>فایل مورد استفاده برای تست کارایی <a href="benchmarks/MiniExcel.Benchmarks/Test1%2C000%2C000x10.xlsx"><strong>Test1,000,000x10.xlsx</strong></a> است، یک سند ۳۲ مگابایتی که شامل ۱,۰۰۰,۰۰۰ ردیف * ۱۰ ستون است که سلول‌های آن با رشته &quot;HelloWorld&quot; پر شده‌اند.</p>
<p>برای اجرای همه بنچمارک‌ها از دستور زیر استفاده کنید:</p>
<pre><code class="language-bash">dotnet run -project .\benchmarks\MiniExcel.Benchmarks -c Release -f net9.0 -filter * --join
</code></pre>
<p>می‌توانید نتایج بنچمارک آخرین نسخه را <a href="benchmarks/results">اینجا</a> مشاهده کنید.</p>
<h3>وارد کردن/پرس‌وجوی اکسل  <a name="getstart1"></a></h3>
<h4>۱. اجرای پرس‌وجو و نگاشت نتایج به IEnumerable تایپ‌شده <a href="https://dotnetfiddle.net/w5WD1J">[امتحان کنید]</a></h4>
<p>پیشنهاد می‌شود به دلیل کارایی بهتر از Stream.Query استفاده کنید.</p>
<pre><code class="language-csharp">public class UserAccount
{
    public Guid ID { get; set; }
    public string Name { get; set; }
    public DateTime BoD { get; set; }
    public int Age { get; set; }
    public bool VIP { get; set; }
    public decimal Points { get; set; }
}

var rows = MiniExcel.Query&lt;UserAccount&gt;(path);

// یا

using (var stream = File.OpenRead(path))
    var rows = stream.Query&lt;UserAccount&gt;();
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/111107423-c8c46b80-8591-11eb-982f-c97a2dafb379.png" alt="image" /></p>
<h4>۲. اجرای پرس‌وجو و نگاشت آن به یک لیست از اشیای داینامیک بدون استفاده از هدر <a href="https://dotnetfiddle.net/w5WD1J">[امتحان کنید]</a></h4>
<ul>
<li>کلید dynamic به صورت <code>A.B.C.D..</code> است</li>
</ul>
<p>| MiniExcel | 1 |
|-----------|---|
| Github    | 2 |</p>
<pre><code class="language-csharp">
var rows = MiniExcel.Query(path).ToList();

// یا
using (var stream = File.OpenRead(path))
{
    var rows = stream.Query().ToList();

    Assert.Equal(&quot;MiniExcel&quot;, rows[0].A);
    Assert.Equal(1, rows[0].B);
    Assert.Equal(&quot;Github&quot;, rows[1].A);
    Assert.Equal(2, rows[1].B);
}
</code></pre>
<h4>۳. اجرای پرس‌وجو با اولین ردیف هدر <a href="https://dotnetfiddle.net/w5WD1J">[امتحان کنید]</a></h4>
<p>توجه: در صورت تکرار نام ستون، آخرین مقدار سمت راست استفاده می‌شود.</p>
<p>ورودی اکسل:</p>
<p>| Column1   | Column2 |
|-----------|---------|
| MiniExcel | 1       |
| Github    | 2       |</p>
<pre><code class="language-csharp">
var rows = MiniExcel.Query(useHeaderRow:true).ToList();

// یا

using (var stream = File.OpenRead(path))
{
    var rows = stream.Query(useHeaderRow:true).ToList();

    Assert.Equal(&quot;MiniExcel&quot;, rows[0].Column1);
    Assert.Equal(1, rows[0].Column2);
    Assert.Equal(&quot;Github&quot;, rows[1].Column1);
    Assert.Equal(2, rows[1].Column2);
}
</code></pre>
<h4>۴. پشتیبانی پرس‌وجو از افزونه LINQ مانند First/Take/Skip و غیره</h4>
<p>پرس‌وجوی اولین مقدار</p>
<pre><code class="language-csharp">var row = MiniExcel.Query(path).First();
Assert.Equal(&quot;HelloWorld&quot;, row.A);

// یا

using (var stream = File.OpenRead(path))
{
    var row = stream.Query().First();
    Assert.Equal(&quot;HelloWorld&quot;, row.A);
}
</code></pre>
<p>مقایسه کارایی بین MiniExcel/ExcelDataReader/ClosedXML/EPPlus
<img src="https://user-images.githubusercontent.com/12729184/111072392-6037a900-8515-11eb-9693-5ce2dad1e460.gif" alt="queryfirst" /></p>
<h4>۵. پرس‌وجو بر اساس نام شیت</h4>
<pre><code class="language-csharp">MiniExcel.Query(path, sheetName: &quot;SheetName&quot;);
//یا
stream.Query(sheetName: &quot;SheetName&quot;);
</code></pre>
<h4>۶. پرس‌وجوی همه نام‌های شیت و ردیف‌ها</h4>
<pre><code class="language-csharp">var sheetNames = MiniExcel.GetSheetNames(path);
foreach (var sheetName in sheetNames)
{
    var rows = MiniExcel.Query(path, sheetName: sheetName);
}
</code></pre>
<h4>7. دریافت ستون‌ها</h4>
<pre><code class="language-csharp">var columns = MiniExcel.GetColumns(path); // به عنوان مثال خروجی : [&quot;A&quot;,&quot;B&quot;...]

var cnt = columns.Count;  // دریافت تعداد ستون‌ها
</code></pre>
<h4>8. کوئری داینامیک: ردیف را به <code>IDictionary&lt;string,object&gt;</code> تبدیل کنید</h4>
<pre><code class="language-csharp">foreach(IDictionary&lt;string,object&gt; row in MiniExcel.Query(path))
{
    //..
}

// یا
var rows = MiniExcel.Query(path).Cast&lt;IDictionary&lt;string,object&gt;&gt;();
// یا کوئری رنج‌های مشخص شده (با حروف بزرگ)
// A2 نماینده ردیف دوم ستون A است، C3 نماینده ردیف سوم ستون C است
// اگر نمی‌خواهید ردیف‌ها را محدود کنید، عدد وارد نکنید
var rows = MiniExcel.QueryRange(path, startCell: &quot;A2&quot;, endCell: &quot;C3&quot;).Cast&lt;IDictionary&lt;string, object&gt;&gt;();
</code></pre>
<h4>9. کوئری اکسل و بازگشت DataTable</h4>
<p>توصیه نمی‌شود، زیرا DataTable تمام داده‌ها را در حافظه بارگذاری می‌کند و ویژگی مصرف حافظه پایین MiniExcel را از دست می‌دهد.</p>
<pre><code class="language-C#">var table = MiniExcel.QueryAsDataTable(path, useHeaderRow: true);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/116673475-07917200-a9d6-11eb-947e-a6f68cce58df.png" alt="image" /></p>
<h4>10. مشخص کردن سلول شروع خواندن داده</h4>
<pre><code class="language-csharp">MiniExcel.Query(path,useHeaderRow:true,startCell:&quot;B3&quot;)
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/117260316-8593c400-ae81-11eb-9877-c087b7ac2b01.png" alt="image" /></p>
<h4>11. پر کردن سلول‌های ادغام‌شده</h4>
<p>نکته: کارایی نسبت به «عدم استفاده از پر کردن ادغام» کندتر است</p>
<p>دلیل: استاندارد OpenXml ادغام سلول‌ها را در انتهای فایل قرار می‌دهد، که منجر به نیاز به دو بار پیمایش sheetxml می‌شود</p>
<pre><code class="language-csharp">    var config = new OpenXmlConfiguration()
    {
        FillMergedCells = true
    };
    var rows = MiniExcel.Query(path, configuration: config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/117973630-3527d500-b35f-11eb-95c3-bde255f8114e.png" alt="image" /></p>
<p>پشتیبانی از پر کردن چند ردیف و ستون با طول و عرض متغیر</p>
<p><img src="https://user-images.githubusercontent.com/12729184/117973820-6d2f1800-b35f-11eb-88d8-555063938108.png" alt="image" /></p>
<h4>12. خواندن فایل بزرگ با کش مبتنی بر دیسک (کش مبتنی بر دیسک - SharedString)</h4>
<p>اگر اندازه SharedStrings بیش از ۵ مگابایت باشد، MiniExcel به طور پیش‌فرض از کش دیسک محلی استفاده می‌کند، مانند <a href="https://github.com/MiniExcel/MiniExcel/files/8403819/NotDuplicateSharedStrings_10x100000.xlsx">10x100000.xlsx</a> (یک میلیون ردیف داده)، زمانی که کش دیسک غیرفعال باشد، حداکثر مصرف حافظه ۱۹۵ مگابایت است، اما با فعال بودن کش دیسک فقط ۶۵ مگابایت نیاز است. توجه کنید که این بهینه‌سازی هزینه‌ای در کارایی دارد و زمان خواندن را از ۷.۴ ثانیه به ۲۷.۲ ثانیه افزایش می‌دهد. اگر به این ویژگی نیاز ندارید، می‌توانید با کد زیر کش دیسک را غیرفعال کنید:</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration { EnableSharedStringCache = false };
MiniExcel.Query(path,configuration: config)
</code></pre>
<p>می‌توانید از <code>SharedStringCacheSize</code> استفاده کنید تا اندازه فایل sharedString برای کش دیسک را تغییر دهید</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration { SharedStringCacheSize=500*1024*1024 };
MiniExcel.Query(path, configuration: config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/161411851-1c3f72a7-33b3-4944-84dc-ffc1d16747dd.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/12729184/161411825-17f53ec7-bef4-4b16-b234-e24799ea41b0.png" alt="image" /></p>
<h3>ساخت/خروجی اکسل  <a name="getstart2"></a></h3>
<ol>
<li><p>باید یک نوع غیرانتزاعی با سازنده بدون پارامتر عمومی باشد.</p>
</li>
<li><p>MiniExcel از IEnumerable با اجرای تعلیقی پشتیبانی می‌کند، اگر می‌خواهید کمترین میزان حافظه را مصرف کنید، لطفاً متدهایی مانند ToList را فراخوانی نکنید</p>
</li>
</ol>
<p>مثال: استفاده یا عدم استفاده از ToList و مصرف حافظه
<img src="https://user-images.githubusercontent.com/12729184/112587389-752b0b00-8e38-11eb-8a52-cfb76c57e5eb.png" alt="image" /></p>
<h4>1. تایپ ناشناس یا قوی <a href="https://dotnetfiddle.net/w5WD1J">[امتحان کنید]</a></h4>
<pre><code class="language-csharp">var path = Path.Combine(Path.GetTempPath(), $&quot;{Guid.NewGuid()}.xlsx&quot;);
MiniExcel.SaveAs(path, new[] {
    new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
    new { Column1 = &quot;Github&quot;, Column2 = 2}
});
</code></pre>
<h4>2. <code>IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;</code></h4>
<pre><code class="language-csharp">var values = new List&lt;Dictionary&lt;string, object&gt;&gt;()
{
    new Dictionary&lt;string,object&gt;{{ &quot;Column1&quot;, &quot;MiniExcel&quot; }, { &quot;Column2&quot;, 1 } },
    new Dictionary&lt;string,object&gt;{{ &quot;Column1&quot;, &quot;Github&quot; }, { &quot;Column2&quot;, 2 } }
};
MiniExcel.SaveAs(path, values);
</code></pre>
<p>نتیجه ایجاد فایل :</p>
<p>| Column1   | Column2 |
|-----------|---------|
| MiniExcel | 1       |
| Github    | 2       |</p>
<h4>3.  IDataReader</h4>
<ul>
<li><code>توصیه‌شده</code>، زیرا می‌تواند از بارگذاری تمام داده‌ها در حافظه جلوگیری کند</li>
</ul>
<pre><code class="language-csharp">MiniExcel.SaveAs(path, reader);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/121275378-149a5e80-c8bc-11eb-85fe-5453552134f0.png" alt="image" /></p>
<p>خروجی چند شیتی با DataReader (توصیه شده توسط Dapper ExecuteReader)</p>
<pre><code class="language-csharp">using (var cnn = Connection)
{
    cnn.Open();
    var sheets = new Dictionary&lt;string,object&gt;();
    sheets.Add(&quot;sheet1&quot;, cnn.ExecuteReader(&quot;select 1 id&quot;));
    sheets.Add(&quot;sheet2&quot;, cnn.ExecuteReader(&quot;select 2 id&quot;));
    MiniExcel.SaveAs(&quot;Demo.xlsx&quot;, sheets);
}
</code></pre>
<h4>4. DataTable</h4>
<ul>
<li><p><code>توصیه نمی‌شود</code>، زیرا تمام داده‌ها را در حافظه بارگذاری می‌کند</p>
</li>
<li><p>DataTable ابتدا از Caption برای نام ستون استفاده می‌کند، سپس از نام ستون</p>
</li>
</ul>
<pre><code class="language-csharp">var path = Path.Combine(Path.GetTempPath(), $&quot;{Guid.NewGuid()}.xlsx&quot;);
var table = new DataTable();
{
    table.Columns.Add(&quot;Column1&quot;, typeof(string));
    table.Columns.Add(&quot;Column2&quot;, typeof(decimal));
    table.Rows.Add(&quot;MiniExcel&quot;, 1);
    table.Rows.Add(&quot;Github&quot;, 2);
}

MiniExcel.SaveAs(path, table);
</code></pre>
<h4>5. کوئری Dapper</h4>
<p>با تشکر از @shaofing #552 ، لطفاً از <code>CommandDefinition + CommandFlags.NoCache</code> استفاده کنید</p>
<pre><code class="language-csharp">using (var connection = GetConnection(connectionString))
{
    var rows = connection.Query(
        new CommandDefinition(
            @&quot;select 'MiniExcel' as Column1,1 as Column2 union all select 'Github',2&quot;
            , flags: CommandFlags.NoCache)
        );
    // توجه: QueryAsync خطای بسته بودن اتصال را ایجاد می‌کند
    MiniExcel.SaveAs(path, rows);
</code></pre>
<pre><code>}
</code></pre>
<p>کد زیر تمام داده‌ها را به حافظه بارگذاری می‌کند</p>
<pre><code class="language-csharp">using (var connection = GetConnection(connectionString))
{
    var rows = connection.Query(@&quot;select 'MiniExcel' as Column1,1 as Column2 union all select 'Github',2&quot;);
    MiniExcel.SaveAs(path, rows);
}
</code></pre>
<h4>6. ذخیره‌سازی به MemoryStream  <a href="https://dotnetfiddle.net/JOen0e">[امتحان کنید]</a></h4>
<pre><code class="language-csharp">using (var stream = new MemoryStream()) //پشتیبانی از FileStream، MemoryStream و غیره
{
    stream.SaveAs(values);
}
</code></pre>
<p>مثال: api برای خروجی گرفتن اکسل</p>
<pre><code class="language-csharp">public IActionResult DownloadExcel()
{
    var values = new[] {
        new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
        new { Column1 = &quot;Github&quot;, Column2 = 2}
    };

    var memoryStream = new MemoryStream();
    memoryStream.SaveAs(values);
    memoryStream.Seek(0, SeekOrigin.Begin);
    return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
    {
        FileDownloadName = &quot;demo.xlsx&quot;
    };
}
</code></pre>
<h4>7. ایجاد چند شیت</h4>
<pre><code class="language-csharp">// 1. Dictionary&lt;string,object&gt;
var users = new[] { new { Name = &quot;Jack&quot;, Age = 25 }, new { Name = &quot;Mike&quot;, Age = 44 } };
var department = new[] { new { ID = &quot;01&quot;, Name = &quot;HR&quot; }, new { ID = &quot;02&quot;, Name = &quot;IT&quot; } };
var sheets = new Dictionary&lt;string, object&gt;
{
    [&quot;users&quot;] = users,
    [&quot;department&quot;] = department
};
MiniExcel.SaveAs(path, sheets);

// 2. DataSet
var sheets = new DataSet();
sheets.Add(UsersDataTable);
sheets.Add(DepartmentDataTable);
//..
MiniExcel.SaveAs(path, sheets);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/118130875-6e7c4580-b430-11eb-9b82-22f02716bd63.png" alt="image" /></p>
<h4>8. گزینه‌های TableStyles</h4>
<p>استایل پیش‌فرض</p>
<p><img src="https://user-images.githubusercontent.com/12729184/138234373-cfa97109-b71f-4711-b7f5-0eaaa4a0a3a6.png" alt="image" /></p>
<p>بدون پیکربندی استایل</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration()
{
     TableStyles = TableStyles.None
};
MiniExcel.SaveAs(path, value,configuration:config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/118784917-f3e57700-b8c2-11eb-8718-8d955b1bc197.png" alt="image" /></p>
<h4>9. AutoFilter</h4>
<p>از نسخه v0.19.0، <code>OpenXmlConfiguration.AutoFilter</code> می‌تواند AutoFilter را فعال یا غیرفعال کند، مقدار پیش‌فرض <code>true</code> است و نحوه تنظیم AutoFilter به شرح زیر است:</p>
<pre><code class="language-csharp">MiniExcel.SaveAs(path, value, configuration: new OpenXmlConfiguration() { AutoFilter = false });
</code></pre>
<h4>10. ایجاد تصویر</h4>
<pre><code class="language-csharp">var value = new[] {
    new { Name=&quot;github&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/github_logo.png&quot;))},
    new { Name=&quot;google&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/google_logo.png&quot;))},
    new { Name=&quot;microsoft&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/microsoft_logo.png&quot;))},
    new { Name=&quot;reddit&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/reddit_logo.png&quot;))},
    new { Name=&quot;statck_overflow&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/statck_overflow_logo.png&quot;))},
};
MiniExcel.SaveAs(path, value);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/150462383-ad9931b3-ed8d-4221-a1d6-66f799743433.png" alt="image" /></p>
<h4>11. خروجی گرفتن فایل به صورت آرایه بایت</h4>
<p>از نسخه 1.22.0، زمانی که نوع مقدار <code>byte[]</code> باشد، سیستم به طور پیش‌فرض مسیر فایل را در سلول ذخیره می‌کند و هنگام ایمپورت، سیستم می‌تواند آن را به <code>byte[]</code> تبدیل کند. و اگر نمی‌خواهید از این ویژگی استفاده کنید، می‌توانید <code>OpenXmlConfiguration.EnableConvertByteArray</code> را به <code>false</code> تنظیم کنید تا کارایی سیستم افزایش یابد.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/153702334-c3b834f4-6ae4-4ddf-bd4e-e5005d5d8c6a.png" alt="image" /></p>
<p>از نسخه 1.22.0، زمانی که نوع مقدار <code>byte[]</code> باشد، سیستم به طور پیش‌فرض مسیر فایل را در سلول ذخیره می‌کند و هنگام ایمپورت، سیستم می‌تواند آن را به <code>byte[]</code> تبدیل کند. و اگر نمی‌خواهید از این ویژگی استفاده کنید، می‌توانید <code>OpenXmlConfiguration.EnableConvertByteArray</code> را به <code>false</code> تنظیم کنید تا کارایی سیستم افزایش یابد.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/153702334-c3b834f4-6ae4-4ddf-bd4e-e5005d5d8c6a.png" alt="image" /></p>
<h4>12. ادغام سلول‌های مشابه به صورت عمودی</h4>
<p>این قابلیت فقط در فرمت <code>xlsx</code> پشتیبانی می‌شود و سلول‌ها را به صورت عمودی بین تگ‌های @merge و @endmerge ادغام می‌کند.
می‌توانید از @mergelimit برای محدود کردن محدوده ادغام سلول‌ها به صورت عمودی استفاده کنید.</p>
<pre><code class="language-csharp">var mergedFilePath = Path.Combine(Path.GetTempPath(), $&quot;{Guid.NewGuid().ToString()}.xlsx&quot;);

var path = @&quot;../../../../../samples/xlsx/TestMergeWithTag.xlsx&quot;;

MiniExcel.MergeSameCells(mergedFilePath, path);
</code></pre>
<pre><code class="language-csharp">var memoryStream = new MemoryStream();

var path = @&quot;../../../../../samples/xlsx/TestMergeWithTag.xlsx&quot;;

memoryStream.MergeSameCells(path);
</code></pre>
<p>محتوای فایل قبل و بعد از ادغام:</p>
<p>بدون محدودیت ادغام:</p>
<img width="318" alt="Screenshot 2023-08-07 at 11 59 24" src="https://github.com/mini-software/MiniExcel/assets/38832863/49cc96b9-6c35-4bf3-8d43-a9752a15b22e">
<img width="318" alt="Screenshot 2023-08-07 at 11 59 57" src="https://github.com/mini-software/MiniExcel/assets/38832863/3fbd529b-3ae6-4bbe-b4d8-2793a5a58010">
<p>با محدودیت ادغام:</p>
<img width="346" alt="Screenshot 2023-08-08 at 18 21 00" src="https://github.com/mini-software/MiniExcel/assets/38832863/04049d28-84d5-4c2a-bcff-5847547df5e1">
<img width="346" alt="Screenshot 2023-08-08 at 18 21 40" src="https://github.com/mini-software/MiniExcel/assets/38832863/f5cf8957-b0b0-4831-b8fc-8556299235c2">
<h4>13. رد کردن مقادیر تهی (null)</h4>
<p>گزینه جدید و صریح برای نوشتن سلول‌های خالی برای مقادیر null:</p>
<pre><code class="language-csharp">DataTable dt = new DataTable();

/* ... */

DataRow dr = dt.NewRow();

dr[&quot;Name1&quot;] = &quot;Somebody once&quot;;
dr[&quot;Name2&quot;] = null;
dr[&quot;Name3&quot;] = &quot;told me.&quot;;

dt.Rows.Add(dr);

OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
     EnableWriteNullValueCell = true // مقدار پیش‌فرض.
};

MiniExcel.SaveAs(@&quot;C:\temp\Book1.xlsx&quot;, dt, configuration: configuration);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/31481586/241419455-3c0aec8a-4e5f-4d83-b7ec-6572124c165d.png" alt="image" /></p>
<pre><code class="language-xml">&lt;x:row r=&quot;2&quot;&gt;
    &lt;x:c r=&quot;A2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;Somebody once&lt;/x:v&gt;
    &lt;/x:c&gt;
    &lt;x:c r=&quot;B2&quot; s=&quot;2&quot;&gt;&lt;/x:c&gt;
    &lt;x:c r=&quot;C2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;told me.&lt;/x:v&gt;
    &lt;/x:c&gt;
&lt;/x:row&gt;
</code></pre>
<p>رفتار قبلی:</p>
<pre><code class="language-csharp">/* ... */

OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
     EnableWriteNullValueCell = false // مقدار پیش‌فرض true است.
};

MiniExcel.SaveAs(@&quot;C:\temp\Book1.xlsx&quot;, dt, configuration: configuration);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/31481586/241419441-c4f27e8f-3f87-46db-a10f-08665864c874.png" alt="image" /></p>
<pre><code class="language-xml">&lt;x:row r=&quot;2&quot;&gt;
    &lt;x:c r=&quot;A2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;Somebody once&lt;/x:v&gt;
    &lt;/x:c&gt;
    &lt;x:c r=&quot;B2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;&lt;/x:v&gt;
    &lt;/x:c&gt;
    &lt;x:c r=&quot;C2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;told me.&lt;/x:v&gt;
    &lt;/x:c&gt;
&lt;/x:row&gt;
</code></pre>
<p>برای مقادیر null و DBNull کار می‌کند.</p>
<h4>14. فریز کردن پنجره‌ها (Freeze Panes)</h4>
<pre><code class="language-csharp">/* ... */

OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
    FreezeRowCount = 1,     // مقدار پیش‌فرض 1 است
    FreezeColumnCount = 2   // مقدار پیش‌فرض 0 است
};

MiniExcel.SaveAs(@&quot;C:\temp\Book1.xlsx&quot;, dt, configuration: configuration);
</code></pre>
<p><img src="https://raw.githubusercontent.com/mini-software/MiniExcel/master/docs/images/freeze-pane-1.png" alt="image" /></p>
<h3>پر کردن داده در قالب اکسل <a name="getstart3"></a></h3>
<ul>
<li>تعریف متغیر مشابه قالب‌های Vue با <code>{{نام متغیر}}</code> یا رندر مجموعه با <code>{{نام مجموعه.نام فیلد}}</code> است.</li>
<li>رندر مجموعه از IEnumerable/DataTable/DapperRow پشتیبانی می‌کند.</li>
</ul>
<h4>1. پر کردن پایه‌ای</h4>
<p>قالب:
<img src="https://user-images.githubusercontent.com/12729184/114537556-ed8d2b00-9c84-11eb-8303-a69f62c41e5b.png" alt="image" /></p>
<p>نتیجه:
<img src="https://user-images.githubusercontent.com/12729184/114537490-d8180100-9c84-11eb-8c69-db58692f3a85.png" alt="image" /></p>
<p>کد:</p>
<pre><code class="language-csharp">// 1. با استفاده از POCO
var value = new
{
    Name = &quot;Jack&quot;,
    CreateDate = new DateTime(2021, 01, 01),
    VIP = true,
    Points = 123
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);


// 2. با استفاده از Dictionary
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;Name&quot;] = &quot;Jack&quot;,
    [&quot;CreateDate&quot;] = new DateTime(2021, 01, 01),
    [&quot;VIP&quot;] = true,
    [&quot;Points&quot;] = 123
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>2. پر کردن داده‌های IEnumerable</h4>
<blockquote>
<p>نکته۱: از اولین IEnumerable با ستون‌های یکسان به عنوان مبنا برای پر کردن لیست استفاده کنید</p>
</blockquote>
<p>قالب:
<img src="https://user-images.githubusercontent.com/12729184/114564652-14f2f080-9ca3-11eb-831f-09e3fedbc5fc.png" alt="image" /></p>
<p>نتیجه:
<img src="https://user-images.githubusercontent.com/12729184/114564204-b2015980-9ca2-11eb-900d-e21249f93f7c.png" alt="image" /></p>
<p>کد:</p>
<pre><code class="language-csharp">//1. با استفاده از POCO
var value = new
{
    employees = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Lisa&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;HR&quot;},
        new {name=&quot;Mike&quot;,department=&quot;IT&quot;},
        new {name=&quot;Neo&quot;,department=&quot;IT&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);

//2. با استفاده از Dictionary
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;employees&quot;] = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Lisa&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;HR&quot;},
        new {name=&quot;Mike&quot;,department=&quot;IT&quot;},
        new {name=&quot;Neo&quot;,department=&quot;IT&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>3. پر کردن داده‌های پیچیده</h4>
<blockquote>
<p>نکته: پشتیبانی از چند شیت و استفاده از متغیر مشابه</p>
</blockquote>
<p>قالب:</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114565255-acf0da00-9ca3-11eb-8a7f-8131b2265ae8.png" alt="image" /></p>
<p>نتیجه:</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114565329-bf6b1380-9ca3-11eb-85e3-3969e8bf6378.png" alt="image" /></p>
<pre><code class="language-csharp">// 1. با استفاده از POCO
var value = new
{
    title = &quot;FooCompany&quot;,
    managers = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    },
    employees = new[] {
        new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
        new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
        new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
        new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);

// 2. با استفاده از Dictionary
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;title&quot;] = &quot;FooCompany&quot;,
    [&quot;managers&quot;] = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    },
    [&quot;employees&quot;] = new[] {
        new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
        new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
        new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
        new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>4. عملکرد پر کردن داده‌های بزرگ</h4>
<blockquote>
<p>توجه: استفاده از IEnumerable با اجرای معوق (deferred execution) به جای ToList می‌تواند بیشترین صرفه‌جویی در حافظه را در MiniExcel داشته باشد</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/12729184/114577091-5046ec80-9cae-11eb-924b-087c7becf8da.png" alt="image" /></p>
<h4>5. نگاشت خودکار نوع مقدار سلول</h4>
<p>قالب</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114802504-64830a80-9dd0-11eb-8d56-8e8c401b3ace.png" alt="image" /></p>
<p>نتیجه</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114802419-43221e80-9dd0-11eb-9ffe-a2ce34fe7076.png" alt="image" /></p>
<p>کلاس</p>
<pre><code class="language-csharp">public class Poco
{
    public string @string { get; set; }
    public int? @int { get; set; }
</code></pre>
<pre><code class="language-csharp">public decimal? @decimal { get; set; }
public double? @double { get; set; }
public DateTime? datetime { get; set; }
public bool? @bool { get; set; }
public Guid? Guid { get; set; }
}
</code></pre>
<p>کد</p>
<pre><code class="language-csharp">var poco = new TestIEnumerableTypePoco { @string = &quot;string&quot;, @int = 123, @decimal = decimal.Parse(&quot;123.45&quot;), @double = (double)123.33, @datetime = new DateTime(2021, 4, 1), @bool = true, @Guid = Guid.NewGuid() };
var value = new
{
    Ts = new[] {
        poco,
        new TestIEnumerableTypePoco{},
        null,
        poco
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>6. مثال :  لیست پروژه‌های Github</h4>
<p>قالب</p>
<p><img src="https://user-images.githubusercontent.com/12729184/115068623-12073280-9f25-11eb-9124-f4b3efcdb2a7.png" alt="image" /></p>
<p>نتیجه</p>
<p><img src="https://user-images.githubusercontent.com/12729184/115068639-1a5f6d80-9f25-11eb-9f45-27c434d19a78.png" alt="image" /></p>
<p>کد</p>
<pre><code class="language-csharp">var projects = new[]
{
    new {Name = &quot;MiniExcel&quot;,Link=&quot;https://github.com/mini-software/MiniExcel&quot;,Star=146, CreateTime=new DateTime(2021,03,01)},
    new {Name = &quot;HtmlTableHelper&quot;,Link=&quot;https://github.com/mini-software/HtmlTableHelper&quot;,Star=16, CreateTime=new DateTime(2020,02,01)},
    new {Name = &quot;PocoClassGenerator&quot;,Link=&quot;https://github.com/mini-software/PocoClassGenerator&quot;,Star=16, CreateTime=new DateTime(2019,03,17)}
};
var value = new
{
    User = &quot;ITWeiHan&quot;,
    Projects = projects,
    TotalStar = projects.Sum(s =&gt; s.Star)
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>7. پر کردن داده‌های گروه‌بندی شده</h4>
<pre><code class="language-csharp">var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;employees&quot;] = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;IT&quot;},
        new {name=&quot;Neo&quot;,department=&quot;IT&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    }
};
await MiniExcel.SaveAsByTemplateAsync(path, templatePath, value);
</code></pre>
<h5>1. با تگ <code>@group</code> و تگ <code>@header</code></h5>
<p>قبل</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646717-21b9d57a-2be2-4e9a-801b-ae212231d2b4.PNG" alt="before_with_header" /></p>
<p>بعد</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646721-58a7a340-7004-4bc2-af24-cffcb2c20737.PNG" alt="after_with_header" /></p>
<h5>2. با تگ @group و بدون تگ @header</h5>
<p>قبل</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646873-b12417fa-801b-4890-8e96-669ed3b43902.PNG" alt="before_without_header" /></p>
<p>بعد</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646872-622461ba-342e-49ee-834f-b91ad9c2dac3.PNG" alt="after_without_header" /></p>
<h5>3. بدون تگ @group</h5>
<p>قبل</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646975-f52a68eb-e031-43b5-abaa-03b67c052d1a.PNG" alt="without_group" /></p>
<p>بعد</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646974-4a3c0e07-7c66-4088-ad07-b4ad3695b7e1.PNG" alt="without_group_after" /></p>
<h4>8. دستورات If/ElseIf/Else داخل سلول</h4>
<p>قوانین:</p>
<ol>
<li>پشتیبانی از DateTime، Double، Int با عملگرهای ==، !=، &gt;، &gt;=، &lt;، &lt;= .</li>
<li>پشتیبانی از String با عملگرهای ==، != .</li>
<li>هر دستور باید در خط جدید باشد.</li>
<li>یک فاصله قبل و بعد از عملگرها باید قرار گیرد.</li>
<li>نباید خط جدید داخل دستورات باشد.</li>
<li>سلول باید دقیقا به فرمت زیر باشد.</li>
</ol>
<pre><code class="language-csharp">@if(name == Jack)
{{employees.name}}
@elseif(name == Neo)
Test {{employees.name}}
@else
{{employees.department}}
@endif
</code></pre>
<p>قبل</p>
<p><img src="https://user-images.githubusercontent.com/38832863/235360606-ca654769-ff55-4f5b-98d2-d2ec0edb8173.PNG" alt="if_before" /></p>
<p>بعد</p>
<p><img src="https://user-images.githubusercontent.com/38832863/235360609-869bb960-d63d-45ae-8d64-9e8b0d0ab658.PNG" alt="if_after" /></p>
<h4>9. DataTable به عنوان پارامتر</h4>
<pre><code class="language-csharp">var managers = new DataTable();
{
    managers.Columns.Add(&quot;name&quot;);
    managers.Columns.Add(&quot;department&quot;);
    managers.Rows.Add(&quot;Jack&quot;, &quot;HR&quot;);
    managers.Rows.Add(&quot;Loan&quot;, &quot;IT&quot;);
}
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;title&quot;] = &quot;FooCompany&quot;,
    [&quot;managers&quot;] = managers,
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>10. فرمول‌ها</h4>
<h5>1. مثال</h5>
<p>فرمول خود را با <code>$</code> شروع کنید و از <code>$enumrowstart</code> و <code>$enumrowend</code> برای مشخص کردن رفرنس شروع و پایان ردیف‌های شمارشی استفاده کنید:</p>
<p><img src="docs/images/template-formulas-1.png" alt="image" /></p>
<p>زمانی که قالب رندر می‌شود، پیشوند <code>$</code> حذف شده و <code>$enumrowstart</code> و <code>$enumrowend</code> با شماره ردیف شروع و پایان شمارشی جایگزین می‌شوند:</p>
<p><img src="docs/images/template-formulas-2.png" alt="image" /></p>
<h5>2. مثال‌های دیگر فرمول:</h5>
<p>|              |                                                                                           |
|--------------|-------------------------------------------------------------------------------------------|
| مجموع        | <code>$=SUM(C{{$enumrowstart}}:C{{$enumrowend}})</code>                                              |
| میانگین جایگزین | <code>$=SUM(C{{$enumrowstart}}:C{{$enumrowend}}) / COUNT(C{{$enumrowstart}}:C{{$enumrowend}})</code> |
| بازه         | <code>$=MAX(C{{$enumrowstart}}:C{{$enumrowend}}) - MIN(C{{$enumrowstart}}:C{{$enumrowend}})</code>   |</p>
<h4>11. سایر</h4>
<h5>1. بررسی کلید پارامتر قالب</h5>
<p>از نسخه V1.24.0 به بعد، به طور پیش‌فرض کلید پارامتر گمشده قالب را نادیده گرفته و با رشته خالی جایگزین می‌کند، <code>IgnoreTemplateParameterMissing</code> می‌تواند کنترل کند که استثنا پرتاب شود یا نه.</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration()
{
    IgnoreTemplateParameterMissing = false,
};
MiniExcel.SaveAsByTemplate(path, templatePath, value, config)
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/157464332-e316f829-54aa-4c84-a5aa-9aef337b668d.png" alt="image" /></p>
<h3>ویژگی‌های نام/اندیس/نادیده‌گیری ستون اکسل <a name="getstart4"></a></h3>
<h4>1. تعیین نام ستون، شماره ستون، نادیده‌گیری ستون</h4>
<p>نمونه اکسل</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114230869-3e163700-99ac-11eb-9a90-2039d4b4b313.png" alt="image" /></p>
<p>کد</p>
<pre><code class="language-csharp">public class ExcelAttributeDemo
{
    [ExcelColumnName(&quot;Column1&quot;)]
</code></pre>
<pre><code class="language-csharp">public string Test1 { get; set; }
[ExcelColumnName(&quot;Column2&quot;)]
public string Test2 { get; set; }
[ExcelIgnore]
public string Test3 { get; set; }
[ExcelColumnIndex(&quot;I&quot;)] // سیستم &quot;I&quot; را به اندیس 8 تبدیل می‌کند
public string Test4 { get; set; }
public string Test5 { get; } //بدون set نادیده گرفته می‌شود
public string Test6 { get; private set; } //set غیرعمومی نادیده گرفته می‌شود
[ExcelColumnIndex(3)] // شروع از 0
public string Test7 { get; set; }
}

var rows = MiniExcel.Query&lt;ExcelAttributeDemo&gt;(path).ToList();
Assert.Equal(&quot;Column1&quot;, rows[0].Test1);
Assert.Equal(&quot;Column2&quot;, rows[0].Test2);
Assert.Null(rows[0].Test3);
Assert.Equal(&quot;Test7&quot;, rows[0].Test4);
Assert.Null(rows[0].Test5);
Assert.Null(rows[0].Test6);
Assert.Equal(&quot;Test4&quot;, rows[0].Test7);
</code></pre>
<h4>۲. فرمت سفارشی (ExcelFormatAttribute)</h4>
<p>از نسخه V0.21.0 پشتیبانی از کلاس‌هایی که متد <code>ToString(string content)</code> دارند اضافه شده است</p>
<p>کلاس</p>
<pre><code class="language-csharp">public class Dto
{
    public string Name { get; set; }

    [ExcelFormat(&quot;MMMM dd, yyyy&quot;)]
    public DateTime InDate { get; set; }
}
</code></pre>
<p>کد</p>
<pre><code class="language-csharp">var value = new Dto[] {
    new Issue241Dto{ Name=&quot;Jack&quot;,InDate=new DateTime(2021,01,04)},
    new Issue241Dto{ Name=&quot;Henry&quot;,InDate=new DateTime(2020,04,05)},
};
MiniExcel.SaveAs(path, value);
</code></pre>
<p>نتیجه</p>
<p><img src="https://user-images.githubusercontent.com/12729184/118910788-ab2bcd80-b957-11eb-8d42-bfce36621b1b.png" alt="image" /></p>
<p>کوئری از تبدیل فرمت سفارشی نیز پشتیبانی می‌کند</p>
<p><img src="https://user-images.githubusercontent.com/12729184/118911286-87b55280-b958-11eb-9a88-c8ff403d240a.png" alt="image" /></p>
<h4>۳. تنظیم عرض ستون (ExcelColumnWidthAttribute)</h4>
<pre><code class="language-csharp">public class Dto
{
    [ExcelColumnWidth(20)]
    public int ID { get; set; }
    [ExcelColumnWidth(15.50)]
    public string Name { get; set; }
}
</code></pre>
<h4>۴. نگاشت چند نام ستون به یک ویژگی</h4>
<pre><code class="language-csharp">public class Dto
{
    [ExcelColumnName(excelColumnName:&quot;EmployeeNo&quot;,aliases:new[] { &quot;EmpNo&quot;,&quot;No&quot; })]
    public string Empno { get; set; }
    public string Name { get; set; }
}
</code></pre>
<h4>۵. System.ComponentModel.DisplayNameAttribute = ExcelColumnName.excelColumnNameAttribute</h4>
<p>از نسخه 1.24.0، سیستم از نگاشت System.ComponentModel.DisplayNameAttribute = ExcelColumnName.excelColumnNameAttribute پشتیبانی می‌کند</p>
<pre><code class="language-C#">public class TestIssueI4TXGTDto
{
    public int ID { get; set; }
    public string Name { get; set; }
    [DisplayName(&quot;Specification&quot;)]
    public string Spc { get; set; }
    [DisplayName(&quot;Unit Price&quot;)]
    public decimal Up { get; set; }
}
</code></pre>
<h4>۶. ExcelColumnAttribute</h4>
<p>از نسخه V1.26.0، چندین ویژگی را می‌توان به صورت زیر ساده کرد:</p>
<pre><code class="language-csharp">        public class TestIssueI4ZYUUDto
        {
            [ExcelColumn(Name = &quot;ID&quot;,Index =0)]
            public string MyProperty { get; set; }
            [ExcelColumn(Name = &quot;CreateDate&quot;, Index = 1,Format =&quot;yyyy-MM&quot;,Width =100)]
            public DateTime MyProperty2 { get; set; }
        }
</code></pre>
<h4>۷. DynamicColumnAttribute</h4>
<p>از نسخه V1.26.0، می‌توان ویژگی‌های ستون را به صورت داینامیک تنظیم کرد</p>
<pre><code class="language-csharp">            var config = new OpenXmlConfiguration
            {
                DynamicColumns = new DynamicExcelColumn[] {
                    new DynamicExcelColumn(&quot;id&quot;){Ignore=true},
                    new DynamicExcelColumn(&quot;name&quot;){Index=1,Width=10},
                    new DynamicExcelColumn(&quot;createdate&quot;){Index=0,Format=&quot;yyyy-MM-dd&quot;,Width=15},
                    new DynamicExcelColumn(&quot;point&quot;){Index=2,Name=&quot;Account Point&quot;},
                }
            };
            var path = PathHelper.GetTempPath();
            var value = new[] { new { id = 1, name = &quot;Jack&quot;, createdate = new DateTime(2022, 04, 12) ,point = 123.456} };
            MiniExcel.SaveAs(path, value, configuration: config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/164510353-5aecbc4e-c3ce-41e8-b6cf-afd55eb23b68.png" alt="image" /></p>
<h4>۸. DynamicSheetAttribute</h4>
<p>از نسخه V1.31.4 می‌توان ویژگی‌های شیت را به صورت داینامیک تنظیم کرد. می‌توان نام و وضعیت (قابل مشاهده بودن) شیت را تعیین نمود.</p>
<pre><code class="language-csharp">            var configuration = new OpenXmlConfiguration
            {
                DynamicSheets = new DynamicExcelSheet[] {
                    new DynamicExcelSheet(&quot;usersSheet&quot;) { Name = &quot;Users&quot;, State = SheetState.Visible },
                    new DynamicExcelSheet(&quot;departmentSheet&quot;) { Name = &quot;Departments&quot;, State = SheetState.Hidden }
                }
            };

            var users = new[] { new { Name = &quot;Jack&quot;, Age = 25 }, new { Name = &quot;Mike&quot;, Age = 44 } };
            var department = new[] { new { ID = &quot;01&quot;, Name = &quot;HR&quot; }, new { ID = &quot;02&quot;, Name = &quot;IT&quot; } };
            var sheets = new Dictionary&lt;string, object&gt;
            {
                [&quot;usersSheet&quot;] = users,
                [&quot;departmentSheet&quot;] = department
            };

            var path = PathHelper.GetTempPath();
            MiniExcel.SaveAs(path, sheets, configuration: configuration);
</code></pre>
<p>همچنین می‌توان از ویژگی جدید ExcelSheetAttribute استفاده کرد:</p>
<pre><code class="language-C#">   [ExcelSheet(Name = &quot;Departments&quot;, State = SheetState.Hidden)]
   private class DepartmentDto
   {
      [ExcelColumn(Name = &quot;ID&quot;,Index = 0)]
      public string ID { get; set; }
      [ExcelColumn(Name = &quot;Name&quot;,Index = 1)]
      public string Name { get; set; }
   }
</code></pre>
<h3>افزودن، حذف، به‌روزرسانی</h3>
<h4>افزودن</h4>
<p>از نسخه v1.28.0 درج N ردیف داده پس از آخرین ردیف در CSV پشتیبانی می‌شود</p>
<pre><code class="language-csharp">// اولیه
{
    var value = new[] {
          new { ID=1,Name =&quot;Jack&quot;,InDate=new DateTime(2021,01,03)},
          new { ID=2,Name =&quot;Henry&quot;,InDate=new DateTime(2020,05,03)},
    };
    MiniExcel.SaveAs(path, value);
}
// درج ۱ ردیف پس از آخرین
{
    var value = new { ID=3,Name = &quot;Mike&quot;, InDate = new DateTime(2021, 04, 23) };
    MiniExcel.Insert(path, value);
}
// درج N ردیف پس از آخرین
{
    var value = new[] {
          new { ID=4,Name =&quot;Frank&quot;,InDate=new DateTime(2021,06,07)},
          new { ID=5,Name =&quot;Gloria&quot;,InDate=new DateTime(2022,05,03)},
</code></pre>
<pre><code class="language-csharp">};
MiniExcel.Insert(path, value);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/191023733-1e2fa732-db5c-4a3a-9722-b891fe5aa069.png" alt="image" /></p>
<p>نسخه v1.37.0 پشتیبانی از درج یک شیت جدید در فایل اکسل موجود را اضافه کرد</p>
<pre><code class="language-csharp">// فایل اکسل اولیه
{
    var value = new[] {
          new { ID=1,Name =&quot;Jack&quot;,InDate=new DateTime(2021,01,03)},
          new { ID=2,Name =&quot;Henry&quot;,InDate=new DateTime(2020,05,03)},
    };
    MiniExcel.SaveAs(path, value, sheetName: &quot;Sheet1&quot;);
}
// درج یک شیت جدید
{
    var value = new { ID=3,Name = &quot;Mike&quot;, InDate = new DateTime(2021, 04, 23) };
    MiniExcel.Insert(path, table, sheetName: &quot;Sheet2&quot;);
}
</code></pre>
<h4>حذف (در انتظار)</h4>
<h4>ویرایش (در انتظار)</h4>
<h3>تشخیص خودکار نوع اکسل <a name="getstart5"></a></h3>
<ul>
<li>MiniExcel به طور پیش‌فرض بر اساس <code>پسوند فایل</code> تشخیص می‌دهد که xlsx است یا csv، اما ممکن است این تشخیص دقیق نباشد، لطفاً به صورت دستی مشخص کنید.</li>
<li>نوع فایل استریم را نمی‌توان تشخیص داد، لطفاً به صورت دستی مشخص کنید.</li>
</ul>
<pre><code class="language-csharp">stream.SaveAs(excelType:ExcelType.CSV);
// یا
stream.SaveAs(excelType:ExcelType.XLSX);
// یا
stream.Query(excelType:ExcelType.CSV);
// یا
stream.Query(excelType:ExcelType.XLSX);
</code></pre>
<h3>CSV</h3>
<h4>نکته</h4>
<ul>
<li>به طور پیش‌فرض مقدار بازگشتی از نوع <code>string</code> است و مقدارها به عدد یا تاریخ تبدیل نمی‌شوند، مگر اینکه نوع داده با جنریک strongly typed تعریف شده باشد.</li>
</ul>
<h4>جداکننده سفارشی</h4>
<p>به طور پیش‌فرض جداکننده <code>,</code> است، می‌توانید با property مربوطه <code>Seperator</code> آن را سفارشی کنید</p>
<pre><code class="language-csharp">var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    Seperator=';'
};
MiniExcel.SaveAs(path, values,configuration: config);
</code></pre>
<p>از نسخه V1.30.1 امکان جداکننده سفارشی اضافه شد (با تشکر از @hyzx86)</p>
<pre><code class="language-csharp">var config = new CsvConfiguration()
{
    SplitFn = (row) =&gt; Regex.Split(row, $&quot;[\t,](?=(?:[^\&quot;]|\&quot;[^\&quot;]*\&quot;)*$)&quot;)
        .Select(s =&gt; Regex.Replace(s.Replace(&quot;\&quot;\&quot;&quot;, &quot;\&quot;&quot;), &quot;^\&quot;|\&quot;$&quot;, &quot;&quot;)).ToArray()
};
var rows = MiniExcel.Query(path, configuration: config).ToList();
</code></pre>
<h4>خط جدید سفارشی</h4>
<p>به طور پیش‌فرض کاراکتر خط جدید <code>\r\n</code> است، می‌توانید property مربوطه <code>NewLine</code> را تغییر دهید</p>
<pre><code class="language-csharp">var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    NewLine='\n'
};
MiniExcel.SaveAs(path, values,configuration: config);
</code></pre>
<h4>کدگذاری سفارشی</h4>
<ul>
<li>کدگذاری پیش‌فرض &quot;Detect Encoding From Byte Order Marks&quot; است (detectEncodingFromByteOrderMarks: true)</li>
<li>اگر نیاز به کدگذاری خاصی دارید، لطفاً property مربوط به StreamReaderFunc / StreamWriterFunc را تغییر دهید</li>
</ul>
<pre><code class="language-csharp">// خواندن
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    StreamReaderFunc = (stream) =&gt; new StreamReader(stream,Encoding.GetEncoding(&quot;gb2312&quot;))
};
var rows = MiniExcel.Query(path, true,excelType:ExcelType.CSV,configuration: config);

// نوشتن
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    StreamWriterFunc = (stream) =&gt; new StreamWriter(stream, Encoding.GetEncoding(&quot;gb2312&quot;))
};
MiniExcel.SaveAs(path, value,excelType:ExcelType.CSV, configuration: config);
</code></pre>
<h4>خواندن رشته خالی به عنوان null</h4>
<p>به طور پیش‌فرض مقادیر خالی به string.Empty نگاشت می‌شوند. می‌توانید این رفتار را تغییر دهید</p>
<pre><code class="language-csharp">var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
   ReadEmptyStringAsNull = true
};
</code></pre>
<h3>DataReader</h3>
<h4>1. GetReader</h4>
<p>از نسخه 1.23.0 می‌توانید GetDataReader بگیرید</p>
<pre><code class="language-csharp">    using (var reader = MiniExcel.GetReader(path,true))
    {
        while (reader.Read())
        {
            for (int i = 0; i &lt; reader.FieldCount; i++)
            {
                var value = reader.GetValue(i);
            }
        }
    }
</code></pre>
<h3>Async</h3>
<ul>
<li>از نسخه v0.17.0 پشتیبانی Async اضافه شده است (با تشکر از isdaniel ( SHIH,BING-SIOU)](https://github.com/isdaniel))</li>
</ul>
<pre><code class="language-csharp">public static Task SaveAsAsync(string path, object value, bool printHeader = true, string sheetName = &quot;Sheet1&quot;, ExcelType excelType = ExcelType.UNKNOWN, IConfiguration configuration = null)
public static Task SaveAsAsync(this Stream stream, object value, bool printHeader = true, string sheetName = &quot;Sheet1&quot;, ExcelType excelType = ExcelType.XLSX, IConfiguration configuration = null)
public static Task&lt;IEnumerable&lt;dynamic&gt;&gt; QueryAsync(string path, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null)
public static Task&lt;IEnumerable&lt;T&gt;&gt; QueryAsync&lt;T&gt;(this Stream stream, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null) where T : class, new()
public static Task&lt;IEnumerable&lt;T&gt;&gt; QueryAsync&lt;T&gt;(string path, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null) where T : class, new()
public static Task&lt;IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;&gt; QueryAsync(this Stream stream, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null)
public static Task SaveAsByTemplateAsync(this Stream stream, string templatePath, object value)
public static Task SaveAsByTemplateAsync(this Stream stream, byte[] templateBytes, object value)
public static Task SaveAsByTemplateAsync(string path, string templatePath, object value)
public static Task SaveAsByTemplateAsync(string path, byte[] templateBytes, object value)
public static Task&lt;DataTable&gt; QueryAsDataTableAsync(string path, bool useHeaderRow = true, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null)
</code></pre>
<ul>
<li>از نسخه v1.25.0 پشتیبانی از <code>cancellationToken</code> اضافه شد.</li>
</ul>
<h3>سایر</h3>
<h4>1. Enum</h4>
<p>حتماً نام اکسل و پراپرتی یکسان باشد، سیستم به صورت خودکار نگاشت را انجام می‌دهد (به حروف بزرگ و کوچک حساس نیست)</p>
<p><img src="https://user-images.githubusercontent.com/12729184/116210595-9784b100-a775-11eb-936f-8e7a8b435961.png" alt="image" /></p>
<p>از نسخه V0.18.0 پشتیبانی از Enum Description اضافه شد</p>
<pre><code class="language-csharp">public class Dto
{
    public string Name { get; set; }
    public I49RYZUserType UserType { get; set; }
}

public enum Type
{
    [Description(&quot;General User&quot;)]
    V1,
    [Description(&quot;General Administrator&quot;)]
    V2,
    [Description(&quot;Super Administrator&quot;)]
    V3
}
</code></pre>
<pre><code>
![image](https://user-images.githubusercontent.com/12729184/133116630-27cc7161-099a-48b8-9784-cd1e443af3d1.png)

از نسخه 1.30.0 پشتیبانی از تبدیل Description اکسل به Enum اضافه شده است، با تشکر از @KaneLeung

#### 2. تبدیل CSV به XLSX یا تبدیل XLSX به CSV

```csharp
MiniExcel.ConvertXlsxToCsv(xlsxPath, csvPath);
MiniExcel.ConvertXlsxToCsv(xlsxStream, csvStream);
MiniExcel.ConvertCsvToXlsx(csvPath, xlsxPath);
MiniExcel.ConvertCsvToXlsx(csvStream, xlsxStream);
</code></pre>
<pre><code class="language-csharp">using (var excelStream = new FileStream(path: filePath, FileMode.Open, FileAccess.Read))
using (var csvStream = new MemoryStream())
{
   MiniExcel.ConvertXlsxToCsv(excelStream, csvStream);
}
</code></pre>
<h4>3. سفارشی‌سازی CultureInfo</h4>
<p>از نسخه 1.22.0، می‌توانید CultureInfo را به صورت زیر سفارشی‌سازی کنید، مقدار پیش‌فرض سیستم <code>CultureInfo.InvariantCulture</code> است.</p>
<pre><code class="language-csharp">var config = new CsvConfiguration()
{
    Culture = new CultureInfo(&quot;fr-FR&quot;),
};
MiniExcel.SaveAs(path, value, configuration: config);

// یا
MiniExcel.Query(path, configuration: config);
</code></pre>
<h4>4. سفارشی‌سازی اندازه بافر</h4>
<pre><code class="language-csharp">    public abstract class Configuration : IConfiguration
    {
        public int BufferSize { get; set; } = 1024 * 512;
    }
</code></pre>
<h4>5. FastMode</h4>
<p>سیستم مدیریت حافظه را انجام نمی‌دهد، اما می‌توانید سرعت ذخیره‌سازی بالاتری داشته باشید.</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration() { FastMode = true };
MiniExcel.SaveAs(path, reader,configuration:config);
</code></pre>
<h4>6. افزودن دسته‌ای تصویر (MiniExcel.AddPicture)</h4>
<pre><code class="language-csharp">var images = new[]
{
    new MiniExcelPicture
    {
        ImageBytes = File.ReadAllBytes(PathHelper.GetFile(&quot;images/github_logo.png&quot;)),
        SheetName = null, // پیش‌فرض null، اولین شیت
        CellAddress = &quot;C3&quot;, // الزامی
    },
    new MiniExcelPicture
    {
        ImageBytes = File.ReadAllBytes(PathHelper.GetFile(&quot;images/google_logo.png&quot;)),
        PictureType = &quot;image/png&quot;, // پیش‌فرض PictureType = image/png
        SheetName = &quot;Demo&quot;,
        CellAddress = &quot;C9&quot;, // الزامی
        WidthPx = 100,
        HeightPx = 100,
    },
};
MiniExcel.AddPicture(path, images);
</code></pre>
<p><img src="https://github.com/user-attachments/assets/19c4d241-9753-4ede-96c8-f810c1a22247" alt="Image" /></p>
<h4>7. دریافت ابعاد شیت‌ها</h4>
<pre><code class="language-csharp">var dim = MiniExcel.GetSheetDimensions(path);
</code></pre>
<h3>مثال‌ها:</h3>
<h4>1. SQLite و Dapper <code>فایل با حجم زیاد</code> درج SQL و جلوگیری از OOM</h4>
<p>نکته: لطفاً بعد از Query متدهای ToList/ToArray را فراخوانی نکنید، چون تمام داده‌ها را در حافظه بارگذاری می‌کند</p>
<pre><code class="language-csharp">using (var connection = new SQLiteConnection(connectionString))
{
    connection.Open();
    using (var transaction = connection.BeginTransaction())
    using (var stream = File.OpenRead(path))
    {
       var rows = stream.Query();
       foreach (var row in rows)
             connection.Execute(&quot;insert into T (A,B) values (@A,@B)&quot;, new { row.A, row.B }, transaction: transaction);
       transaction.Commit();
    }
}
</code></pre>
<p>عملکرد:
<img src="https://user-images.githubusercontent.com/12729184/111072579-2dda7b80-8516-11eb-9843-c01a1edc88ec.png" alt="image" /></p>
<h4>2. نمونه‌ای از دانلود/آپلود فایل اکسل Xlsx در ASP.NET Core 3.1 یا MVC 5 <a href="tests/MiniExcel.Tests.AspNetCore">امتحان کنید</a></h4>
<pre><code class="language-csharp">public class ApiController : Controller
{
    public IActionResult Index()
    {
        return new ContentResult
        {
            ContentType = &quot;text/html&quot;,
            StatusCode = (int)HttpStatusCode.OK,
            Content = @&quot;&lt;html&gt;&lt;body&gt;
&lt;a href='api/DownloadExcel'&gt;DownloadExcel&lt;/a&gt;&lt;br&gt;
&lt;a href='api/DownloadExcelFromTemplatePath'&gt;DownloadExcelFromTemplatePath&lt;/a&gt;&lt;br&gt;
&lt;a href='api/DownloadExcelFromTemplateBytes'&gt;DownloadExcelFromTemplateBytes&lt;/a&gt;&lt;br&gt;
&lt;p&gt;Upload Excel&lt;/p&gt;
&lt;form method='post' enctype='multipart/form-data' action='/api/uploadexcel'&gt;
    &lt;input type='file' name='excel'&gt; &lt;br&gt;
    &lt;input type='submit' &gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;&quot;
        };
    }

    public IActionResult DownloadExcel()
    {
        var values = new[] {
            new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
            new { Column1 = &quot;Github&quot;, Column2 = 2}
        };
        var memoryStream = new MemoryStream();
        memoryStream.SaveAs(values);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
        {
            FileDownloadName = &quot;demo.xlsx&quot;
        };
    }

    public IActionResult DownloadExcelFromTemplatePath()
    {
        string templatePath = &quot;TestTemplateComplex.xlsx&quot;;

        Dictionary&lt;string, object&gt; value = new Dictionary&lt;string, object&gt;()
        {
            [&quot;title&quot;] = &quot;FooCompany&quot;,
            [&quot;managers&quot;] = new[] {
                new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
                new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
            },
            [&quot;employees&quot;] = new[] {
                new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
                new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
                new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
                new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
            }
        };

        MemoryStream memoryStream = new MemoryStream();
        memoryStream.SaveAsByTemplate(templatePath, value);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
        {
            FileDownloadName = &quot;demo.xlsx&quot;
        };
    }

    private static Dictionary&lt;string, Byte[]&gt; TemplateBytesCache = new Dictionary&lt;string, byte[]&gt;();

    static ApiController()
    {
        string templatePath = &quot;TestTemplateComplex.xlsx&quot;;
        byte[] bytes = System.IO.File.ReadAllBytes(templatePath);
        TemplateBytesCache.Add(templatePath, bytes);
    }

    public IActionResult DownloadExcelFromTemplateBytes()
    {
        byte[] bytes = TemplateBytesCache[&quot;TestTemplateComplex.xlsx&quot;];

        Dictionary&lt;string, object&gt; value = new Dictionary&lt;string, object&gt;()
        {
            [&quot;title&quot;] = &quot;FooCompany&quot;,
            [&quot;managers&quot;] = new[] {
                new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
                new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
</code></pre>
<pre><code class="language-csharp">            },
            [&quot;employees&quot;] = new[] {
                new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
                new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
                new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
                new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
            }
        };

        MemoryStream memoryStream = new MemoryStream();
        memoryStream.SaveAsByTemplate(bytes, value);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
        {
            FileDownloadName = &quot;demo.xlsx&quot;
        };
    }

    public IActionResult UploadExcel(IFormFile excel)
    {
        var stream = new MemoryStream();
        excel.CopyTo(stream);

        foreach (var item in stream.Query(true))
        {
            // منطق خود را اینجا قرار دهید و غیره.
        }

        return Ok(&quot;فایل با موفقیت آپلود شد&quot;);
    }
}
</code></pre>
<h4>۳. کوئری صفحه‌بندی شده</h4>
<pre><code class="language-csharp">void Main()
{
    var rows = MiniExcel.Query(path);

    Console.WriteLine(&quot;==== صفحه شماره 1 ====&quot;);
    Console.WriteLine(Page(rows,pageSize:3,page:1));
    Console.WriteLine(&quot;==== صفحه شماره 50 ====&quot;);
    Console.WriteLine(Page(rows,pageSize:3,page:50));
    Console.WriteLine(&quot;==== صفحه شماره 5000 ====&quot;);
    Console.WriteLine(Page(rows,pageSize:3,page:5000));
}

public static IEnumerable&lt;T&gt; Page&lt;T&gt;(IEnumerable&lt;T&gt; en, int pageSize, int page)
{
    return en.Skip(page * pageSize).Take(pageSize);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/114679083-6ef4c400-9d3e-11eb-9f78-a86daa45fe46.gif" alt="20210419" /></p>
<h4>۴. خروجی گرفتن اکسل در WebForm با استفاده از memorystream</h4>
<pre><code class="language-csharp">var fileName = &quot;Demo.xlsx&quot;;
var sheetName = &quot;Sheet1&quot;;
HttpResponse response = HttpContext.Current.Response;
response.Clear();
response.ContentType = &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;;
response.AddHeader(&quot;Content-Disposition&quot;, $&quot;attachment;filename=\&quot;{fileName}\&quot;&quot;);
var values = new[] {
    new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
    new { Column1 = &quot;Github&quot;, Column2 = 2}
};
var memoryStream = new MemoryStream();
memoryStream.SaveAs(values, sheetName: sheetName);
memoryStream.Seek(0, SeekOrigin.Begin);
memoryStream.CopyTo(Response.OutputStream);
response.End();
</code></pre>
<h4>۵. چندزبانه‌سازی پویا (i18n) و مدیریت سطح دسترسی نقش‌ها</h4>
<p>مانند مثال، یک متد ایجاد کنید تا i18n و مدیریت دسترسی را انجام دهد و از <code>yield return</code> برای بازگرداندن <code>IEnumerable&lt;Dictionary&lt;string, object&gt;&gt;</code> جهت پردازش پویا و کم‌مصرف حافظه استفاده نمایید.</p>
<pre><code class="language-csharp">void Main()
{
    var value = new Order[] {
        new Order(){OrderNo = &quot;SO01&quot;,CustomerID=&quot;C001&quot;,ProductID=&quot;P001&quot;,Qty=100,Amt=500},
        new Order(){OrderNo = &quot;SO02&quot;,CustomerID=&quot;C002&quot;,ProductID=&quot;P002&quot;,Qty=300,Amt=400},
    };

    Console.WriteLine(&quot;en-Us و نقش Sales&quot;);
    {
        var path = Path.GetTempPath() + Guid.NewGuid() + &quot;.xlsx&quot;;
        var lang = &quot;en-US&quot;;
        var role = &quot;Sales&quot;;
        MiniExcel.SaveAs(path, GetOrders(lang, role, value));
        MiniExcel.Query(path, true).Dump();
    }

    Console.WriteLine(&quot;zh-CN و نقش PMC&quot;);
    {
        var path = Path.GetTempPath() + Guid.NewGuid() + &quot;.xlsx&quot;;
        var lang = &quot;zh-CN&quot;;
        var role = &quot;PMC&quot;;
        MiniExcel.SaveAs(path, GetOrders(lang, role, value));
        MiniExcel.Query(path, true).Dump();
    }
}

private IEnumerable&lt;Dictionary&lt;string, object&gt;&gt; GetOrders(string lang, string role, Order[] orders)
{
    foreach (var order in orders)
    {
        var newOrder = new Dictionary&lt;string, object&gt;();

        if (lang == &quot;zh-CN&quot;)
        {
            newOrder.Add(&quot;客户编号&quot;, order.CustomerID);
            newOrder.Add(&quot;订单编号&quot;, order.OrderNo);
            newOrder.Add(&quot;产品编号&quot;, order.ProductID);
            newOrder.Add(&quot;数量&quot;, order.Qty);
            if (role == &quot;Sales&quot;)
                newOrder.Add(&quot;价格&quot;, order.Amt);
            yield return newOrder;
        }
        else if (lang == &quot;en-US&quot;)
        {
            newOrder.Add(&quot;Customer ID&quot;, order.CustomerID);
            newOrder.Add(&quot;Order No&quot;, order.OrderNo);
            newOrder.Add(&quot;Product ID&quot;, order.ProductID);
            newOrder.Add(&quot;Quantity&quot;, order.Qty);
            if (role == &quot;Sales&quot;)
                newOrder.Add(&quot;Amount&quot;, order.Amt);
            yield return newOrder;
        }
        else
        {
            throw new InvalidDataException($&quot;lang {lang} wrong&quot;);
        }
    }
}

public class Order
{
    public string OrderNo { get; set; }
    public string CustomerID { get; set; }
    public decimal Qty { get; set; }
    public string ProductID { get; set; }
    public decimal Amt { get; set; }
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/118939964-d24bc480-b982-11eb-88dd-f06655f6121a.png" alt="image" /></p>
<h3>سوالات متداول</h3>
<h4>سوال: عنوان ستون اکسل با نام ویژگی کلاس برابر نیست، چگونه نگاشت انجام دهم؟</h4>
<p>پاسخ: لطفاً از ویژگی ExcelColumnName استفاده کنید.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/116020475-eac50980-a678-11eb-8804-129e87200e5e.png" alt="image" /></p>
<h4>سوال: چگونه چند شیت را کوئری یا خروجی بگیرم؟</h4>
<p>پاسخ: از متد <code>GetSheetNames</code> همراه با پارامتر sheetName در Query استفاده کنید.</p>
<pre><code class="language-csharp">var sheets = MiniExcel.GetSheetNames(path);
foreach (var sheet in sheets)
{
    Console.WriteLine($&quot;نام شیت : {sheet} &quot;);
    var rows = MiniExcel.Query(path,useHeaderRow:true,sheetName:sheet);
    Console.WriteLine(rows);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/116199841-2a1f5300-a76a-11eb-90a3-6710561cf6db.png" alt="image" /></p>
<h4>سوال: چگونه اطلاعات مربوط به قابل مشاهده بودن شیت را کوئری یا خروجی بگیرم؟</h4>
<p>پاسخ: از متد <code>GetSheetInformations</code> استفاده کنید.</p>
<pre><code class="language-csharp">var sheets = MiniExcel.GetSheetInformations(path);
foreach (var sheetInfo in sheets)
{
    Console.WriteLine($&quot;اندیس شیت : {sheetInfo.Index} &quot;); // اندیس بعدی شیت - از 0 شماره گذاری می‌شود
    Console.WriteLine($&quot;نام شیت : {sheetInfo.Name} &quot;);   // نام شیت
    Console.WriteLine($&quot;وضعیت شیت : {sheetInfo.State} &quot;); // وضعیت قابل مشاهده بودن شیت - قابل مشاهده / مخفی
}
</code></pre>
<pre><code>#### سوال: آیا استفاده از Count باعث بارگذاری تمام داده‌ها در حافظه می‌شود؟

خیر، تست تصویری دارای ۱ میلیون ردیف * ۱۰ ستون داده است، حداکثر استفاده از حافظه کمتر از ۶۰ مگابایت بوده و ۱۳.۶۵ ثانیه زمان می‌برد.

![image](https://user-images.githubusercontent.com/12729184/117118518-70586000-adc3-11eb-9ce3-2ba76cf8b5e5.png)

#### سوال: کوئری چگونه از اندیس عددی استفاده می‌کند؟

اندیس پیش‌فرض Query کلید رشته‌ای است: A,B,C.... اگر می‌خواهید از اندیس عددی استفاده کنید، لطفاً متد زیر را برای تبدیل ایجاد کنید

```csharp
void Main()
{
    var path = @&quot;D:\git\MiniExcel\samples\xlsx\TestTypeMapping.xlsx&quot;;
    var rows = MiniExcel.Query(path,true);
    foreach (var r in ConvertToIntIndexRows(rows))
    {
        Console.Write($&quot;column 0 : {r[0]} ,column 1 : {r[1]}&quot;);
        Console.WriteLine();
    }
}

private IEnumerable&lt;Dictionary&lt;int, object&gt;&gt; ConvertToIntIndexRows(IEnumerable&lt;object&gt; rows)
{
    ICollection&lt;string&gt; keys = null;
    var isFirst = true;
    foreach (IDictionary&lt;string,object&gt; r in rows)
    {
        if(isFirst)
        {
            keys = r.Keys;
            isFirst = false;
        }

        var dic = new Dictionary&lt;int, object&gt;();
        var index = 0;
        foreach (var key in keys)
            dic[index++] = r[key];
        yield return dic;
    }
}
</code></pre>
<h4>سوال: چرا زمانی که مقدار خالی است، اکسل بدون عنوان تولید می‌شود؟</h4>
<p>زیرا MiniExcel از منطقی مشابه JSON.NET برای دریافت داینامیک نوع از مقادیر جهت ساده‌سازی عملیات API استفاده می‌کند، و بدون داده نمی‌توان نوع را تشخیص داد. برای درک بیشتر به <a href="https://github.com/mini-software/MiniExcel/issues/133">issue #133</a> مراجعه کنید.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/122639771-546c0c00-d12e-11eb-800c-498db27889ca.png" alt="image" /></p>
<blockquote>
<p>نوع قوی و DataTable هدر تولید می‌کنند، اما Dictionary همچنان اکسل خالی خواهد بود.</p>
</blockquote>
<h4>سوال: چگونه foreach را هنگام رسیدن به ردیف خالی متوقف کنیم؟</h4>
<p>MiniExcel را می‌توان با <code>LINQ TakeWhile</code> برای توقف تکرارگر foreach استفاده کرد.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/130209137-162621c2-f337-4479-9996-beeac65bc4d4.png" alt="Image" /></p>
<h4>سوال: چگونه ردیف‌های خالی را حذف کنیم؟</h4>
<p><img src="https://user-images.githubusercontent.com/12729184/137873865-7107d8f5-eb59-42db-903a-44e80589f1b2.png" alt="image" /></p>
<p>IEnumerable :</p>
<pre><code class="language-csharp">public static IEnumerable&lt;dynamic&gt; QueryWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
{
    var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
    foreach (IDictionary&lt;string,object&gt; row in rows)
    {
        if(row.Keys.Any(key=&gt;row[key]!=null))
            yield return row;
    }
}
</code></pre>
<p>DataTable :</p>
<pre><code class="language-csharp">public static DataTable QueryAsDataTableWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
{
    if (sheetName == null &amp;&amp; excelType != ExcelType.CSV) /*Issue #279*/
        sheetName = stream.GetSheetNames().First();

    var dt = new DataTable(sheetName);
    var first = true;
    var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
    foreach (IDictionary&lt;string, object&gt; row in rows)
    {
        if (first)
        {

            foreach (var key in row.Keys)
            {
                var column = new DataColumn(key, typeof(object)) { Caption = key };
                dt.Columns.Add(column);
            }

            dt.BeginLoadData();
            first = false;
        }

        var newRow = dt.NewRow();
        var isNull=true;
        foreach (var key in row.Keys)
        {
            var _v = row[key];
            if(_v!=null)
                isNull = false;
            newRow[key] = _v;
        }

        if(!isNull)
            dt.Rows.Add(newRow);
    }

    dt.EndLoadData();
    return dt;
}
</code></pre>
<h4>سوال: چگونه SaveAs(path,value) را برای جایگزینی فایل موجود بدون نمایش خطای &quot;The file ...xlsx already exists error&quot; استفاده کنیم؟</h4>
<p>لطفاً از کلاس Stream برای پیاده‌سازی منطق ایجاد فایل سفارشی استفاده کنید، مانند:</p>
<pre><code class="language-C#">    using (var stream = File.Create(&quot;Demo.xlsx&quot;))
        MiniExcel.SaveAs(stream,value);
</code></pre>
<p>یا، از نسخه V1.25.0، SaveAs از پارامتر overwriteFile برای فعال/غیرفعال کردن بازنویسی فایل پشتیبانی می‌کند:</p>
<pre><code class="language-csharp">    MiniExcel.SaveAs(path, value, overwriteFile: true);
</code></pre>
<h3>محدودیت‌ها و نکات</h3>
<ul>
<li>فعلاً از xls و فایل‌های رمزنگاری‌شده پشتیبانی نمی‌شود</li>
<li>xlsm فقط از Query پشتیبانی می‌کند</li>
</ul>
<h3>منابع</h3>
<p><a href="https://github.com/ExcelDataReader/ExcelDataReader">ExcelDataReader</a>  / <a href="https://github.com/ClosedXML/ClosedXML">ClosedXML</a> / <a href="https://github.com/DapperLib/Dapper">Dapper</a> / <a href="https://github.com/andersnm/ExcelNumberFormat">ExcelNumberFormat</a></p>
<h3>تشکر</h3>
<h4><a href="https://www.jetbrains.com/">Jetbrains</a></h4>
<p><img src="https://user-images.githubusercontent.com/12729184/123997015-8456c180-da02-11eb-829a-aec476fe8e94.png" alt="jetbrains-variant-2" /></p>
<p>تشکر بابت ارائه رایگان IDE تمام محصولات برای این پروژه (<a href="https://user-images.githubusercontent.com/12729184/123988233-6ab17c00-d9fa-11eb-8739-2a08c6a4a263.png">License</a>)</p>
<h3>اشتراک‌گذاری مشارکت و حمایت مالی</h3>
<p>لینک https://github.com/orgs/mini-software/discussions/754</p>
<h3>مشارکت‌کنندگان</h3>
<p><img src="https://contrib.rocks/image?repo=mini-software/MiniExcel" alt="" /></p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-08</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Statcounter and other scripts can be added here -->
</body>
</html>