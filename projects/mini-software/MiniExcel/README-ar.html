<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniExcel - mini-software/MiniExcel</title>
    <meta name="title" content="MiniExcel - mini-software/MiniExcel">
    <meta name="description" content="mini-software/MiniExcel - GitHub repository ar documentation and informationهذا المشروع جزء من مؤسسة .NET ويعمل تحت مدونة السلوك الخاصة بهم. English | 简体中文 | 繁體中文 نجمتك Star و تبرعك يمكن أن تجعل MiniExcel أفضل المقدمة MiniExcel هو أداة .NET لمعالجة ملفات Excel بشكل بسيط وفعال لتجنب مشاكل نفاد الذاكرة (OOM). في الوقت الحالي، معظم الأطر الشائعة تحتاج إلى تحميل جميع البيانات في الذاكرة لتسهيل العمليات، لكن ذلك يسبب مشاكل في استهلاك الذاكرة. يحاول MiniExcel استخدام الخوارزميات من التدفق لتقليل الاستهلاك من 1000 ميجابايت إلى عدة ميجابايت فقط لتجنب نفاد الذاكرة (OOM). الميزات استهلاك منخفض للذاكرة، وتجنب مشاكل نفاد الذاكرة (OOM) وعمليات جمع القمامة الكاملة (Full GC) يدعم العمليات الفورية لكل صف من البيانات يدعم تنفيذ LINQ المؤجل، يمكنه القيام بالتقسيم السريع، والبحث السريع، واستعلامات معقدة باستهلاك منخفض خفيف الوزن، لا يتطلب تثبيت Microsoft Office، ولا COM+، وحجم ملف DLL أقل من 400KB واجهة برمجة تطبيقات سهلة للقراءة/الكتابة/الملء في Excel ابدأ الآن استيراد/استعلام Excel تصدير/إنشاء Excel قوالب Excel اسم/فهرس/تجاهل...">
    <meta name="keywords" content="mini-software, MiniExcel, GitHub, repository, ar documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/mini-software/MiniExcel/README-ar.html">
    <meta property="og:title" content="MiniExcel - mini-software/MiniExcel">
    <meta property="og:description" content="mini-software/MiniExcel - GitHub repository ar documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/mini-software/MiniExcel" id="githubRepoLink" target="_blank">mini-software/MiniExcel</a>
<br>
<h1 style="display: none;">هذا المشروع جزء من مؤسسة .NET ويعمل تحت مدونة السلوك الخاصة بهم. English | 简体中文 | 繁體中文 نجمتك Star و تبرعك يمكن أن تجعل MiniExcel أفضل المقدمة MiniExcel هو أداة .NET لمعالجة ملفات Excel بشكل بسيط وفعال لتجنب مشاكل نفاد الذاكرة (OOM). في الوقت الحالي، معظم الأطر الشائعة تحتاج إلى تحميل جميع البيانات في الذاكرة لتسهيل العمليات، لكن ذلك يسبب مشاكل في استهلاك الذاكرة. يحاول MiniExcel استخدام الخوارزميات من التدفق لتقليل الاستهلاك من 1000 ميجابايت إلى عدة ميجابايت فقط لتجنب نفاد الذاكرة (OOM). الميزات استهلاك منخفض للذاكرة، وتجنب مشاكل نفاد الذاكرة (OOM) وعمليات جمع القمامة الكاملة (Full GC) يدعم العمليات الفورية لكل صف من البيانات يدعم تنفيذ LINQ المؤجل، يمكنه القيام بالتقسيم السريع، والبحث السريع، واستعلامات معقدة باستهلاك منخفض خفيف الوزن، لا يتطلب تثبيت Microsoft Office، ولا COM+، وحجم ملف DLL أقل من 400KB واجهة برمجة تطبيقات سهلة للقراءة/الكتابة/الملء في Excel ابدأ الآن استيراد/استعلام Excel تصدير/إنشاء Excel قوالب Excel اسم/فهرس/تجاهل...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div style="text-align: center">
<p><a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/nuget/v/MiniExcel.svg" alt="NuGet"></a>  <a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/nuget/dt/MiniExcel.svg" alt=""></a>
<a href="https://ci.appveyor.com/project/mini-software/miniexcel/branch/master"><img src="https://ci.appveyor.com/api/projects/status/b2vustrwsuqx45f4/branch/master?svg=true" alt="Build status"></a>
<a href="https://gitee.com/dotnetchina/MiniExcel"><img src="https://gitee.com/dotnetchina/MiniExcel/badge/star.svg" alt="star"></a> <a href="https://github.com/mini-software/MiniExcel" rel="nofollow"><img src="https://img.shields.io/github/stars/mini-software/MiniExcel?logo=github" alt="GitHub stars"></a>
<a href="https://www.nuget.org/packages/MiniExcel"><img src="https://img.shields.io/badge/.NET-%3E%3D%204.5-red.svg" alt="version"></a>
<a href="https://deepwiki.com/mini-software/MiniExcel"><img src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
</p>
</div>
<hr />
<p><a href="https://www.dotnetfoundation.org/"><img align="right" src="https://github.com/dotnet-foundation/swag/blob/main/logo/dotnetfoundation_v4.png?raw=true" width="100" /></a></p>
<div style="text-align: center">
<p>هذا المشروع جزء من <a href="https://www.dotnetfoundation.org/">مؤسسة .NET</a> ويعمل تحت <a href="https://www.dotnetfoundation.org/code-of-conduct">مدونة السلوك</a> الخاصة بهم. </p>
</div>
<hr />
<div style="text-align: center">
<p><strong><a href="README.md">English</a> | <a href="README.zh-CN.md">简体中文</a> | <a href="README.zh-Hant.md">繁體中文</a></strong></p>
</div>
<hr />
<div style="text-align: center">
نجمتك <a href="https://github.com/mini-software/MiniExcel">Star</a> و <a href="https://miniexcel.github.io">تبرعك</a> يمكن أن تجعل MiniExcel أفضل
</div>
<hr />
<h3>المقدمة</h3>
<p>MiniExcel هو أداة .NET لمعالجة ملفات Excel بشكل بسيط وفعال لتجنب مشاكل نفاد الذاكرة (OOM).</p>
<p>في الوقت الحالي، معظم الأطر الشائعة تحتاج إلى تحميل جميع البيانات في الذاكرة لتسهيل العمليات، لكن ذلك يسبب مشاكل في استهلاك الذاكرة. يحاول MiniExcel استخدام الخوارزميات من التدفق لتقليل الاستهلاك من 1000 ميجابايت إلى عدة ميجابايت فقط لتجنب نفاد الذاكرة (OOM).</p>
<p><img src="https://user-images.githubusercontent.com/12729184/113086657-ab8bd000-9214-11eb-9563-c970ac1ee35e.png" alt="image" /></p>
<h3>الميزات</h3>
<ul>
<li>استهلاك منخفض للذاكرة، وتجنب مشاكل نفاد الذاكرة (OOM) وعمليات جمع القمامة الكاملة (Full GC)</li>
<li>يدعم العمليات الفورية لكل صف من البيانات</li>
<li>يدعم تنفيذ LINQ المؤجل، يمكنه القيام بالتقسيم السريع، والبحث السريع، واستعلامات معقدة باستهلاك منخفض</li>
<li>خفيف الوزن، لا يتطلب تثبيت Microsoft Office، ولا COM+، وحجم ملف DLL أقل من 400KB</li>
<li>واجهة برمجة تطبيقات سهلة للقراءة/الكتابة/الملء في Excel</li>
</ul>
<h3>ابدأ الآن</h3>
<ul>
<li><p><a href="#getstart1">استيراد/استعلام Excel</a></p>
</li>
<li><p><a href="#getstart2">تصدير/إنشاء Excel</a></p>
</li>
<li><p><a href="#getstart3">قوالب Excel</a></p>
</li>
<li><p><a href="#getstart4">اسم/فهرس/تجاهل عمود Excel</a></p>
</li>
<li><p><a href="#getstart5">أمثلة</a></p>
</li>
</ul>
<h3>التثبيت</h3>
<p>يمكنك تثبيت الحزمة <a href="https://www.nuget.org/packages/MiniExcel">من NuGet</a></p>
<h3>ملاحظات الإصدار</h3>
<p>يرجى مراجعة <a href="docs">ملاحظات الإصدار</a></p>
<h3>قائمة المهام</h3>
<p>يرجى مراجعة  <a href="https://github.com/mini-software/MiniExcel/projects/1?fullscreen=true">TODO</a></p>
<h3>الأداء</h3>
<p>يمكنك إيجاد كود اختبارات الأداء في <a href="benchmarks/MiniExcel.Benchmarks/Program.cs">MiniExcel.Benchmarks</a>.</p>
<p>الملف المستخدم لاختبار الأداء هو <a href="benchmarks/MiniExcel.Benchmarks/Test1%2C000%2C000x10.xlsx"><strong>Test1,000,000x10.xlsx</strong></a>، وهو مستند بحجم 32 ميجابايت يحتوي على 1,000,000 صف × 10 أعمدة ومليء بقيم &quot;HelloWorld&quot;.</p>
<p>لتشغيل جميع اختبارات الأداء استخدم:</p>
<pre><code class="language-bash">dotnet run -project .\benchmarks\MiniExcel.Benchmarks -c Release -f net9.0 -filter * --join
</code></pre>
<p>يمكنك إيجاد نتائج اختبارات الأداء للإصدار الأخير <a href="benchmarks/results">هنا</a>.</p>
<h3>استعلام/استيراد Excel  <a name="getstart1"></a></h3>
<h4>1. تنفيذ استعلام وربط النتائج مع IEnumerable قوي النوع <a href="https://dotnetfiddle.net/w5WD1J">[جرّب ذلك]</a></h4>
<p>يوصى باستخدام Stream.Query من أجل كفاءة أفضل.</p>
<pre><code class="language-csharp">public class UserAccount
{
    public Guid ID { get; set; }
    public string Name { get; set; }
    public DateTime BoD { get; set; }
    public int Age { get; set; }
    public bool VIP { get; set; }
    public decimal Points { get; set; }
}

var rows = MiniExcel.Query&lt;UserAccount&gt;(path);

// أو

using (var stream = File.OpenRead(path))
    var rows = stream.Query&lt;UserAccount&gt;();
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/111107423-c8c46b80-8591-11eb-982f-c97a2dafb379.png" alt="image" /></p>
<h4>2. تنفيذ استعلام وربطه مع قائمة من الكائنات الديناميكية بدون رؤوس <a href="https://dotnetfiddle.net/w5WD1J">[جرّب ذلك]</a></h4>
<ul>
<li>المفتاح الديناميكي هو <code>A.B.C.D..</code></li>
</ul>
<p>| MiniExcel | 1 |
|-----------|---|
| Github    | 2 |</p>
<pre><code class="language-csharp">
var rows = MiniExcel.Query(path).ToList();

// أو
using (var stream = File.OpenRead(path))
{
    var rows = stream.Query().ToList();

    Assert.Equal(&quot;MiniExcel&quot;, rows[0].A);
    Assert.Equal(1, rows[0].B);
    Assert.Equal(&quot;Github&quot;, rows[1].A);
    Assert.Equal(2, rows[1].B);
}
</code></pre>
<h4>3. تنفيذ استعلام مع صف الرأس الأول <a href="https://dotnetfiddle.net/w5WD1J">[جرّب ذلك]</a></h4>
<p>ملاحظة: في حال تكرار اسم العمود سيتم استخدام آخر واحد.</p>
<p>ملف Excel الإدخالي:</p>
<p>| Column1   | Column2 |
|-----------|---------|
| MiniExcel | 1       |
| Github    | 2       |</p>
<pre><code class="language-csharp">
var rows = MiniExcel.Query(useHeaderRow:true).ToList();

// أو

using (var stream = File.OpenRead(path))
{
    var rows = stream.Query(useHeaderRow:true).ToList();

    Assert.Equal(&quot;MiniExcel&quot;, rows[0].Column1);
    Assert.Equal(1, rows[0].Column2);
    Assert.Equal(&quot;Github&quot;, rows[1].Column1);
    Assert.Equal(2, rows[1].Column2);
}
</code></pre>
<h4>4. الاستعلام بدعم توسيع LINQ مثل First/Take/Skip ...الخ</h4>
<p>الاستعلام عن أول صف</p>
<pre><code class="language-csharp">var row = MiniExcel.Query(path).First();
Assert.Equal(&quot;HelloWorld&quot;, row.A);

// أو

using (var stream = File.OpenRead(path))
{
    var row = stream.Query().First();
    Assert.Equal(&quot;HelloWorld&quot;, row.A);
}
</code></pre>
<p>الأداء بين MiniExcel/ExcelDataReader/ClosedXML/EPPlus
<img src="https://user-images.githubusercontent.com/12729184/111072392-6037a900-8515-11eb-9693-5ce2dad1e460.gif" alt="queryfirst" /></p>
<h4>5. الاستعلام باسم الورقة</h4>
<pre><code class="language-csharp">MiniExcel.Query(path, sheetName: &quot;SheetName&quot;);
//أو
stream.Query(sheetName: &quot;SheetName&quot;);
</code></pre>
<h4>6. الاستعلام عن جميع أسماء الأوراق والصفوف</h4>
<pre><code class="language-csharp">var sheetNames = MiniExcel.GetSheetNames(path);
foreach (var sheetName in sheetNames)
{
    var rows = MiniExcel.Query(path, sheetName: sheetName);
}
</code></pre>
<h4>7. الحصول على الأعمدة</h4>
<pre><code class="language-csharp">var columns = MiniExcel.GetColumns(path); // مثال للنتيجة: [&quot;A&quot;,&quot;B&quot;...]

var cnt = columns.Count;  // الحصول على عدد الأعمدة
</code></pre>
<h4>8. الاستعلام الديناميكي وتحويل الصف إلى <code>IDictionary&lt;string,object&gt;</code></h4>
<pre><code class="language-csharp">foreach(IDictionary&lt;string,object&gt; row in MiniExcel.Query(path))
{
    //..
}

// أو
var rows = MiniExcel.Query(path).Cast&lt;IDictionary&lt;string,object&gt;&gt;();
// أو استعلام نطاقات محددة (بحروف كبيرة)
// A2 تمثل الصف الثاني من العمود A، و C3 تمثل الصف الثالث من العمود C
// إذا لم ترغب في تقييد الصفوف، فقط لا تضع أرقام
var rows = MiniExcel.QueryRange(path, startCell: &quot;A2&quot;, endCell: &quot;C3&quot;).Cast&lt;IDictionary&lt;string, object&gt;&gt;();
</code></pre>
<h4>9. استعلام الإكسل وإرجاع DataTable</h4>
<p>غير موصى به، لأن DataTable سيقوم بتحميل جميع البيانات إلى الذاكرة ويفقد ميزة MiniExcel في استهلاك الذاكرة المنخفض.</p>
<pre><code class="language-C#">var table = MiniExcel.QueryAsDataTable(path, useHeaderRow: true);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/116673475-07917200-a9d6-11eb-947e-a6f68cce58df.png" alt="image" /></p>
<h4>10. تحديد الخلية لبدء قراءة البيانات</h4>
<pre><code class="language-csharp">MiniExcel.Query(path,useHeaderRow:true,startCell:&quot;B3&quot;)
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/117260316-8593c400-ae81-11eb-9877-c087b7ac2b01.png" alt="image" /></p>
<h4>11. تعبئة الخلايا المدمجة</h4>
<p>ملاحظة: الكفاءة أقل مقارنةً بـ <code>عدم استخدام تعبئة الدمج</code></p>
<p>السبب: معيار OpenXml يضع mergeCells في أسفل الملف، مما يؤدي إلى الحاجة لتكرار قراءة sheetxml مرتين</p>
<pre><code class="language-csharp">    var config = new OpenXmlConfiguration()
    {
        FillMergedCells = true
    };
    var rows = MiniExcel.Query(path, configuration: config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/117973630-3527d500-b35f-11eb-95c3-bde255f8114e.png" alt="image" /></p>
<p>يدعم التعبئة متعددة الصفوف والأعمدة بطول وعرض متغير</p>
<p><img src="https://user-images.githubusercontent.com/12729184/117973820-6d2f1800-b35f-11eb-88d8-555063938108.png" alt="image" /></p>
<h4>12. قراءة ملف كبير باستخدام تخزين مؤقت على القرص (Disk-Base Cache - SharedString)</h4>
<p>إذا تجاوز حجم SharedStrings 5 ميجابايت، فإن MiniExcel بشكل افتراضي سيستخدم تخزين مؤقت محلي على القرص، مثل <a href="https://github.com/MiniExcel/MiniExcel/files/8403819/NotDuplicateSharedStrings_10x100000.xlsx">10x100000.xlsx</a> (مليون صف من البيانات)، عند تعطيل التخزين المؤقت على القرص يكون أقصى استخدام للذاكرة 195 ميجابايت، لكن عند تفعيل التخزين المؤقت على القرص يحتاج فقط إلى 65 ميجابايت. ملاحظة، هذا التحسين يحتاج إلى بعض التكاليف من ناحية الكفاءة، لذا سيزيد وقت القراءة من 7.4 ثوان إلى 27.2 ثانية، إذا لم تكن بحاجة إليه يمكنك تعطيل التخزين المؤقت كما يلي:</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration { EnableSharedStringCache = false };
MiniExcel.Query(path,configuration: config)
</code></pre>
<p>يمكنك استخدام <code>SharedStringCacheSize</code> لتغيير حجم sharedString الذي يتجاوز الحجم المحدد للتخزين على القرص</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration { SharedStringCacheSize=500*1024*1024 };
MiniExcel.Query(path, configuration: config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/161411851-1c3f72a7-33b3-4944-84dc-ffc1d16747dd.png" alt="image" /></p>
<p><img src="https://user-images.githubusercontent.com/12729184/161411825-17f53ec7-bef4-4b16-b234-e24799ea41b0.png" alt="image" /></p>
<h3>إنشاء/تصدير إكسل  <a name="getstart2"></a></h3>
<ol>
<li><p>يجب أن يكون النوع غير مجرد وله مُنشئ بدون معاملات عام.</p>
</li>
<li><p>يدعم MiniExcel التنفيذ المؤجل لـ IEnumerable، إذا أردت استخدام أقل قدر من الذاكرة، يرجى عدم استدعاء دوال مثل ToList</p>
</li>
</ol>
<p>مثال: الفرق بين ToList أو عدمه في استخدام الذاكرة
<img src="https://user-images.githubusercontent.com/12729184/112587389-752b0b00-8e38-11eb-8a52-cfb76c57e5eb.png" alt="image" /></p>
<h4>1. نوع مجهول أو قوي <a href="https://dotnetfiddle.net/w5WD1J">[جربه]</a></h4>
<pre><code class="language-csharp">var path = Path.Combine(Path.GetTempPath(), $&quot;{Guid.NewGuid()}.xlsx&quot;);
MiniExcel.SaveAs(path, new[] {
    new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
    new { Column1 = &quot;Github&quot;, Column2 = 2}
});
</code></pre>
<h4>2. <code>IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;</code></h4>
<pre><code class="language-csharp">var values = new List&lt;Dictionary&lt;string, object&gt;&gt;()
{
    new Dictionary&lt;string,object&gt;{{ &quot;Column1&quot;, &quot;MiniExcel&quot; }, { &quot;Column2&quot;, 1 } },
    new Dictionary&lt;string,object&gt;{{ &quot;Column1&quot;, &quot;Github&quot; }, { &quot;Column2&quot;, 2 } }
};
MiniExcel.SaveAs(path, values);
</code></pre>
<p>نتيجة إنشاء الملف:</p>
<p>| Column1   | Column2 |
|-----------|---------|
| MiniExcel | 1       |
| Github    | 2       |</p>
<h4>3.  IDataReader</h4>
<ul>
<li><code>موصى به</code>، لأنه يمكن تجنب تحميل جميع البيانات إلى الذاكرة</li>
</ul>
<pre><code class="language-csharp">MiniExcel.SaveAs(path, reader);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/121275378-149a5e80-c8bc-11eb-85fe-5453552134f0.png" alt="image" /></p>
<p>تصدير DataReader لعدة أوراق (موصى به باستخدام Dapper ExecuteReader)</p>
<pre><code class="language-csharp">using (var cnn = Connection)
{
    cnn.Open();
    var sheets = new Dictionary&lt;string,object&gt;();
    sheets.Add(&quot;sheet1&quot;, cnn.ExecuteReader(&quot;select 1 id&quot;));
    sheets.Add(&quot;sheet2&quot;, cnn.ExecuteReader(&quot;select 2 id&quot;));
    MiniExcel.SaveAs(&quot;Demo.xlsx&quot;, sheets);
}
</code></pre>
<h4>4. Datatable</h4>
<ul>
<li><p><code>غير موصى به</code>، لأنه سيقوم بتحميل كل البيانات إلى الذاكرة</p>
</li>
<li><p>DataTable تستخدم Caption كاسم العمود أولاً، ثم تستخدم اسم العمود</p>
</li>
</ul>
<pre><code class="language-csharp">var path = Path.Combine(Path.GetTempPath(), $&quot;{Guid.NewGuid()}.xlsx&quot;);
var table = new DataTable();
{
    table.Columns.Add(&quot;Column1&quot;, typeof(string));
    table.Columns.Add(&quot;Column2&quot;, typeof(decimal));
    table.Rows.Add(&quot;MiniExcel&quot;, 1);
    table.Rows.Add(&quot;Github&quot;, 2);
}

MiniExcel.SaveAs(path, table);
</code></pre>
<h4>5. استعلام Dapper</h4>
<p>شكرًا لـ @shaofing #552 ، يرجى استخدام <code>CommandDefinition + CommandFlags.NoCache</code></p>
<pre><code class="language-csharp">using (var connection = GetConnection(connectionString))
{
    var rows = connection.Query(
        new CommandDefinition(
            @&quot;select 'MiniExcel' as Column1,1 as Column2 union all select 'Github',2&quot;
            , flags: CommandFlags.NoCache)
        );
    // ملاحظة: QueryAsync سيرمي استثناء إغلاق الاتصال
    MiniExcel.SaveAs(path, rows);
</code></pre>
<p>}</p>
<pre><code>
سيقوم الكود أدناه بتحميل جميع البيانات إلى الذاكرة

```csharp
using (var connection = GetConnection(connectionString))
{
    var rows = connection.Query(@&quot;select 'MiniExcel' as Column1,1 as Column2 union all select 'Github',2&quot;);
    MiniExcel.SaveAs(path, rows);
}
</code></pre>
<h4>6. الحفظ إلى MemoryStream  <a href="https://dotnetfiddle.net/JOen0e">[جرّبها]</a></h4>
<pre><code class="language-csharp">using (var stream = new MemoryStream()) //يدعم FileStream, MemoryStream إلخ.
{
    stream.SaveAs(values);
}
</code></pre>
<p>مثال : api لتصدير Excel</p>
<pre><code class="language-csharp">public IActionResult DownloadExcel()
{
    var values = new[] {
        new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
        new { Column1 = &quot;Github&quot;, Column2 = 2}
    };

    var memoryStream = new MemoryStream();
    memoryStream.SaveAs(values);
    memoryStream.Seek(0, SeekOrigin.Begin);
    return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
    {
        FileDownloadName = &quot;demo.xlsx&quot;
    };
}
</code></pre>
<h4>7. إنشاء أوراق عمل متعددة</h4>
<pre><code class="language-csharp">// 1. Dictionary&lt;string,object&gt;
var users = new[] { new { Name = &quot;Jack&quot;, Age = 25 }, new { Name = &quot;Mike&quot;, Age = 44 } };
var department = new[] { new { ID = &quot;01&quot;, Name = &quot;HR&quot; }, new { ID = &quot;02&quot;, Name = &quot;IT&quot; } };
var sheets = new Dictionary&lt;string, object&gt;
{
    [&quot;users&quot;] = users,
    [&quot;department&quot;] = department
};
MiniExcel.SaveAs(path, sheets);

// 2. DataSet
var sheets = new DataSet();
sheets.Add(UsersDataTable);
sheets.Add(DepartmentDataTable);
//..
MiniExcel.SaveAs(path, sheets);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/118130875-6e7c4580-b430-11eb-9b82-22f02716bd63.png" alt="image" /></p>
<h4>8. خيارات TableStyles</h4>
<p>النمط الافتراضي</p>
<p><img src="https://user-images.githubusercontent.com/12729184/138234373-cfa97109-b71f-4711-b7f5-0eaaa4a0a3a6.png" alt="image" /></p>
<p>بدون ضبط الأنماط</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration()
{
     TableStyles = TableStyles.None
};
MiniExcel.SaveAs(path, value,configuration:config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/118784917-f3e57700-b8c2-11eb-8718-8d955b1bc197.png" alt="image" /></p>
<h4>9. التصفية التلقائية AutoFilter</h4>
<p>منذ الإصدار v0.19.0، يمكن لـ <code>OpenXmlConfiguration.AutoFilter</code> تمكين أو تعطيل التصفية التلقائية، والقيمة الافتراضية هي <code>true</code>. وضبط التصفية التلقائية كالتالي:</p>
<pre><code class="language-csharp">MiniExcel.SaveAs(path, value, configuration: new OpenXmlConfiguration() { AutoFilter = false });
</code></pre>
<h4>10. إنشاء صورة</h4>
<pre><code class="language-csharp">var value = new[] {
    new { Name=&quot;github&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/github_logo.png&quot;))},
    new { Name=&quot;google&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/google_logo.png&quot;))},
    new { Name=&quot;microsoft&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/microsoft_logo.png&quot;))},
    new { Name=&quot;reddit&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/reddit_logo.png&quot;))},
    new { Name=&quot;statck_overflow&quot;,Image=File.ReadAllBytes(PathHelper.GetFile(&quot;images/statck_overflow_logo.png&quot;))},
};
MiniExcel.SaveAs(path, value);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/150462383-ad9931b3-ed8d-4221-a1d6-66f799743433.png" alt="image" /></p>
<h4>11. تصدير ملفات كمصفوفة بايت Byte Array</h4>
<p>منذ الإصدار 1.22.0، عندما يكون نوع القيمة هو <code>byte[]</code> سيقوم النظام بحفظ مسار الملف في الخلية افتراضيًا، وعند الاستيراد يمكن تحويلها إلى <code>byte[]</code>. وإذا لم ترغب في استخدام ذلك، يمكنك ضبط <code>OpenXmlConfiguration.EnableConvertByteArray</code> إلى <code>false</code> لتحسين كفاءة النظام.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/153702334-c3b834f4-6ae4-4ddf-bd4e-e5005d5d8c6a.png" alt="image" /></p>
<p>منذ الإصدار 1.22.0، عندما يكون نوع القيمة هو <code>byte[]</code> سيقوم النظام بحفظ مسار الملف في الخلية افتراضيًا، وعند الاستيراد يمكن تحويلها إلى <code>byte[]</code>. وإذا لم ترغب في استخدام ذلك، يمكنك ضبط <code>OpenXmlConfiguration.EnableConvertByteArray</code> إلى <code>false</code> لتحسين كفاءة النظام.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/153702334-c3b834f4-6ae4-4ddf-bd4e-e5005d5d8c6a.png" alt="image" /></p>
<h4>12. دمج الخلايا المتشابهة عموديًا</h4>
<p>هذه الوظيفة مدعومة فقط في صيغة <code>xlsx</code> وتقوم بدمج الخلايا عموديًا بين علامتي @merge و @endmerge.
يمكنك استخدام @mergelimit لتحديد حدود دمج الخلايا عموديًا.</p>
<pre><code class="language-csharp">var mergedFilePath = Path.Combine(Path.GetTempPath(), $&quot;{Guid.NewGuid().ToString()}.xlsx&quot;);

var path = @&quot;../../../../../samples/xlsx/TestMergeWithTag.xlsx&quot;;

MiniExcel.MergeSameCells(mergedFilePath, path);
</code></pre>
<pre><code class="language-csharp">var memoryStream = new MemoryStream();

var path = @&quot;../../../../../samples/xlsx/TestMergeWithTag.xlsx&quot;;

memoryStream.MergeSameCells(path);
</code></pre>
<p>محتوى الملف قبل وبعد الدمج:</p>
<p>بدون حد للدمج:</p>
<img width="318" alt="Screenshot 2023-08-07 at 11 59 24" src="https://github.com/mini-software/MiniExcel/assets/38832863/49cc96b9-6c35-4bf3-8d43-a9752a15b22e">
<img width="318" alt="Screenshot 2023-08-07 at 11 59 57" src="https://github.com/mini-software/MiniExcel/assets/38832863/3fbd529b-3ae6-4bbe-b4d8-2793a5a58010">
<p>مع حد للدمج:</p>
<img width="346" alt="Screenshot 2023-08-08 at 18 21 00" src="https://github.com/mini-software/MiniExcel/assets/38832863/04049d28-84d5-4c2a-bcff-5847547df5e1">
<img width="346" alt="Screenshot 2023-08-08 at 18 21 40" src="https://github.com/mini-software/MiniExcel/assets/38832863/f5cf8957-b0b0-4831-b8fc-8556299235c2">
<h4>13. تخطي القيم الفارغة (null)</h4>
<p>خيار صريح جديد لكتابة خلايا فارغة للقيم null:</p>
<pre><code class="language-csharp">DataTable dt = new DataTable();

/* ... */

DataRow dr = dt.NewRow();

dr[&quot;Name1&quot;] = &quot;Somebody once&quot;;
dr[&quot;Name2&quot;] = null;
dr[&quot;Name3&quot;] = &quot;told me.&quot;;

dt.Rows.Add(dr);

OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
     EnableWriteNullValueCell = true // القيمة الافتراضية.
};

MiniExcel.SaveAs(@&quot;C:\temp\Book1.xlsx&quot;, dt, configuration: configuration);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/31481586/241419455-3c0aec8a-4e5f-4d83-b7ec-6572124c165d.png" alt="image" /></p>
<pre><code class="language-xml">&lt;x:row r=&quot;2&quot;&gt;
    &lt;x:c r=&quot;A2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;Somebody once&lt;/x:v&gt;
    &lt;/x:c&gt;
    &lt;x:c r=&quot;B2&quot; s=&quot;2&quot;&gt;&lt;/x:c&gt;
    &lt;x:c r=&quot;C2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;told me.&lt;/x:v&gt;
    &lt;/x:c&gt;
&lt;/x:row&gt;
</code></pre>
<p>السلوك السابق:</p>
<pre><code class="language-csharp">/* ... */

OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
     EnableWriteNullValueCell = false // القيمة الافتراضية هي true.
};

MiniExcel.SaveAs(@&quot;C:\temp\Book1.xlsx&quot;, dt, configuration: configuration);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/31481586/241419441-c4f27e8f-3f87-46db-a10f-08665864c874.png" alt="image" /></p>
<pre><code class="language-xml">&lt;x:row r=&quot;2&quot;&gt;
    &lt;x:c r=&quot;A2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;Somebody once&lt;/x:v&gt;
    &lt;/x:c&gt;
    &lt;x:c r=&quot;B2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;&lt;/x:v&gt;
    &lt;/x:c&gt;
    &lt;x:c r=&quot;C2&quot; t =&quot;str&quot; s=&quot;2&quot;&gt;
        &lt;x:v&gt;told me.&lt;/x:v&gt;
    &lt;/x:c&gt;
&lt;/x:row&gt;
</code></pre>
<p>يعمل للقيم null و DBNull.</p>
<h4>14. تثبيت الأجزاء (Freeze Panes)</h4>
<pre><code class="language-csharp">/* ... */

OpenXmlConfiguration configuration = new OpenXmlConfiguration()
{
    FreezeRowCount = 1,     // الافتراضي هو 1
    FreezeColumnCount = 2   // الافتراضي هو 0
};

MiniExcel.SaveAs(@&quot;C:\temp\Book1.xlsx&quot;, dt, configuration: configuration);
</code></pre>
<p><img src="https://raw.githubusercontent.com/mini-software/MiniExcel/master/docs/images/freeze-pane-1.png" alt="image" /></p>
<h3>تعبئة البيانات في قالب إكسل <a name="getstart3"></a></h3>
<ul>
<li>الإعلان مشابه لقالب Vue مثل <code>{{اسم المتغير}}</code>، أو عرض المجموعات <code>{{اسم المجموعة.اسم الحقل}}</code></li>
<li>دعم عرض المجموعات IEnumerable/DataTable/DapperRow</li>
</ul>
<h4>1. تعبئة أساسية</h4>
<p>القالب:
<img src="https://user-images.githubusercontent.com/12729184/114537556-ed8d2b00-9c84-11eb-8303-a69f62c41e5b.png" alt="image" /></p>
<p>النتيجة:
<img src="https://user-images.githubusercontent.com/12729184/114537490-d8180100-9c84-11eb-8c69-db58692f3a85.png" alt="image" /></p>
<p>الكود:</p>
<pre><code class="language-csharp">// 1. بواسطة POCO
var value = new
{
    Name = &quot;Jack&quot;,
    CreateDate = new DateTime(2021, 01, 01),
    VIP = true,
    Points = 123
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);


// 2. بواسطة Dictionary
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;Name&quot;] = &quot;Jack&quot;,
    [&quot;CreateDate&quot;] = new DateTime(2021, 01, 01),
    [&quot;VIP&quot;] = true,
    [&quot;Points&quot;] = 123
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>2. تعبئة بيانات IEnumerable</h4>
<blockquote>
<p>ملاحظة1: استخدم أول IEnumerable من نفس العمود كأساس لتعبئة القائمة</p>
</blockquote>
<p>القالب:
<img src="https://user-images.githubusercontent.com/12729184/114564652-14f2f080-9ca3-11eb-831f-09e3fedbc5fc.png" alt="image" /></p>
<p>النتيجة:
<img src="https://user-images.githubusercontent.com/12729184/114564204-b2015980-9ca2-11eb-900d-e21249f93f7c.png" alt="image" /></p>
<p>الكود:</p>
<pre><code class="language-csharp">//1. بواسطة POCO
var value = new
{
    employees = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Lisa&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;HR&quot;},
        new {name=&quot;Mike&quot;,department=&quot;IT&quot;},
        new {name=&quot;Neo&quot;,department=&quot;IT&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);

//2. بواسطة Dictionary
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;employees&quot;] = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Lisa&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;HR&quot;},
        new {name=&quot;Mike&quot;,department=&quot;IT&quot;},
        new {name=&quot;Neo&quot;,department=&quot;IT&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>3. تعبئة بيانات معقدة</h4>
<blockquote>
<p>ملاحظة: يدعم أوراق عمل متعددة واستخدام نفس المتغير</p>
</blockquote>
<p>القالب:</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114565255-acf0da00-9ca3-11eb-8a7f-8131b2265ae8.png" alt="image" /></p>
<p>النتيجة:</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114565329-bf6b1380-9ca3-11eb-85e3-3969e8bf6378.png" alt="image" /></p>
<pre><code class="language-csharp">// 1. بواسطة POCO
var value = new
{
    title = &quot;FooCompany&quot;,
    managers = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    },
    employees = new[] {
        new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
        new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
        new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
        new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);

// 2. بواسطة Dictionary
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;title&quot;] = &quot;FooCompany&quot;,
    [&quot;managers&quot;] = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    },
    [&quot;employees&quot;] = new[] {
        new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
        new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
        new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
        new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>4. أداء تعبئة البيانات الضخمة</h4>
<blockquote>
<p>ملاحظة: استخدام IEnumerable مع التنفيذ المؤجل وليس ToList يمكن أن يوفر أقصى استهلاك للذاكرة في MiniExcel</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/12729184/114577091-5046ec80-9cae-11eb-924b-087c7becf8da.png" alt="image" /></p>
<h4>5. التعيين التلقائي لنوع قيمة الخلية</h4>
<p>القالب</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114802504-64830a80-9dd0-11eb-8d56-8e8c401b3ace.png" alt="image" /></p>
<p>النتيجة</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114802419-43221e80-9dd0-11eb-9ffe-a2ce34fe7076.png" alt="image" /></p>
<p>الفئة</p>
<pre><code class="language-csharp">public class Poco
{
    public string @string { get; set; }
    public int? @int { get; set; }
</code></pre>
<pre><code class="language-csharp">public decimal? @decimal { get; set; }
public double? @double { get; set; }
public DateTime? datetime { get; set; }
public bool? @bool { get; set; }
public Guid? Guid { get; set; }
}
</code></pre>
<p>الكود</p>
<pre><code class="language-csharp">var poco = new TestIEnumerableTypePoco { @string = &quot;string&quot;, @int = 123, @decimal = decimal.Parse(&quot;123.45&quot;), @double = (double)123.33, @datetime = new DateTime(2021, 4, 1), @bool = true, @Guid = Guid.NewGuid() };
var value = new
{
    Ts = new[] {
        poco,
        new TestIEnumerableTypePoco{},
        null,
        poco
    }
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>6. مثال : قائمة مشاريع Github</h4>
<p>القالب</p>
<p><img src="https://user-images.githubusercontent.com/12729184/115068623-12073280-9f25-11eb-9124-f4b3efcdb2a7.png" alt="image" /></p>
<p>النتيجة</p>
<p><img src="https://user-images.githubusercontent.com/12729184/115068639-1a5f6d80-9f25-11eb-9f45-27c434d19a78.png" alt="image" /></p>
<p>الكود</p>
<pre><code class="language-csharp">var projects = new[]
{
    new {Name = &quot;MiniExcel&quot;,Link=&quot;https://github.com/mini-software/MiniExcel&quot;,Star=146, CreateTime=new DateTime(2021,03,01)},
    new {Name = &quot;HtmlTableHelper&quot;,Link=&quot;https://github.com/mini-software/HtmlTableHelper&quot;,Star=16, CreateTime=new DateTime(2020,02,01)},
    new {Name = &quot;PocoClassGenerator&quot;,Link=&quot;https://github.com/mini-software/PocoClassGenerator&quot;,Star=16, CreateTime=new DateTime(2019,03,17)}
};
var value = new
{
    User = &quot;ITWeiHan&quot;,
    Projects = projects,
    TotalStar = projects.Sum(s =&gt; s.Star)
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>7. تعبئة البيانات المجمعة</h4>
<pre><code class="language-csharp">var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;employees&quot;] = new[] {
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;HR&quot;},
        new {name=&quot;John&quot;,department=&quot;IT&quot;},
        new {name=&quot;Neo&quot;,department=&quot;IT&quot;},
        new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
    }
};
await MiniExcel.SaveAsByTemplateAsync(path, templatePath, value);
</code></pre>
<h5>1. مع وسم <code>@group</code> ومع وسم <code>@header</code></h5>
<p>قبل</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646717-21b9d57a-2be2-4e9a-801b-ae212231d2b4.PNG" alt="before_with_header" /></p>
<p>بعد</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646721-58a7a340-7004-4bc2-af24-cffcb2c20737.PNG" alt="after_with_header" /></p>
<h5>2. مع وسم @group وبدون وسم @header</h5>
<p>قبل</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646873-b12417fa-801b-4890-8e96-669ed3b43902.PNG" alt="before_without_header" /></p>
<p>بعد</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646872-622461ba-342e-49ee-834f-b91ad9c2dac3.PNG" alt="after_without_header" /></p>
<h5>3. بدون وسم @group</h5>
<p>قبل</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646975-f52a68eb-e031-43b5-abaa-03b67c052d1a.PNG" alt="without_group" /></p>
<p>بعد</p>
<p><img src="https://user-images.githubusercontent.com/38832863/218646974-4a3c0e07-7c66-4088-ad07-b4ad3695b7e1.PNG" alt="without_group_after" /></p>
<h4>8. عبارات If/ElseIf/Else داخل الخلية</h4>
<p>القواعد:</p>
<ol>
<li>يدعم DateTime, Double, Int مع العمليات ==, !=, &gt;, &gt;=, &lt;, &lt;=.</li>
<li>يدعم String مع العمليات ==, !=.</li>
<li>يجب أن تكون كل عبارة في سطر جديد.</li>
<li>يجب إضافة مسافة واحدة قبل وبعد العمليات.</li>
<li>يجب ألا يكون هناك سطر جديد داخل العبارات.</li>
<li>يجب أن تكون الخلية في نفس التنسيق تمامًا كما هو موضح أدناه.</li>
</ol>
<pre><code class="language-csharp">@if(name == Jack)
{{employees.name}}
@elseif(name == Neo)
Test {{employees.name}}
@else
{{employees.department}}
@endif
</code></pre>
<p>قبل</p>
<p><img src="https://user-images.githubusercontent.com/38832863/235360606-ca654769-ff55-4f5b-98d2-d2ec0edb8173.PNG" alt="if_before" /></p>
<p>بعد</p>
<p><img src="https://user-images.githubusercontent.com/38832863/235360609-869bb960-d63d-45ae-8d64-9e8b0d0ab658.PNG" alt="if_after" /></p>
<h4>9. DataTable كمعامل</h4>
<pre><code class="language-csharp">var managers = new DataTable();
{
    managers.Columns.Add(&quot;name&quot;);
    managers.Columns.Add(&quot;department&quot;);
    managers.Rows.Add(&quot;Jack&quot;, &quot;HR&quot;);
    managers.Rows.Add(&quot;Loan&quot;, &quot;IT&quot;);
}
var value = new Dictionary&lt;string, object&gt;()
{
    [&quot;title&quot;] = &quot;FooCompany&quot;,
    [&quot;managers&quot;] = managers,
};
MiniExcel.SaveAsByTemplate(path, templatePath, value);
</code></pre>
<h4>10. الصيغ</h4>
<h5>1. مثال</h5>
<p>أضف بادئة <code>$</code> إلى الصيغة الخاصة بك واستخدم <code>$enumrowstart</code> و <code>$enumrowend</code> لتحديد بداية ونهاية الصفوف المرجعية:</p>
<p><img src="docs/images/template-formulas-1.png" alt="image" /></p>
<p>عند عرض القالب، ستتم إزالة البادئة <code>$</code> وسيتم استبدال <code>$enumrowstart</code> و <code>$enumrowend</code> بأرقام الصفوف الفعلية للبداية والنهاية:</p>
<p><img src="docs/images/template-formulas-2.png" alt="image" /></p>
<h5>2. أمثلة أخرى للصيغ:</h5>
<p>|              |                                                                                           |
|--------------|-------------------------------------------------------------------------------------------|
| Sum          | <code>$=SUM(C{{$enumrowstart}}:C{{$enumrowend}})</code>                                              |
| Alt. Average | <code>$=SUM(C{{$enumrowstart}}:C{{$enumrowend}}) / COUNT(C{{$enumrowstart}}:C{{$enumrowend}})</code> |
| Range        | <code>$=MAX(C{{$enumrowstart}}:C{{$enumrowend}}) - MIN(C{{$enumrowstart}}:C{{$enumrowend}})</code>   |</p>
<h4>11. أخرى</h4>
<h5>1. التحقق من مفتاح معامل القالب</h5>
<p>منذ الإصدار V1.24.0 ، يتم تجاهل مفتاح المعامل المفقود افتراضيًا في القالب واستبداله بسلسلة فارغة، ويمكن لـ <code>IgnoreTemplateParameterMissing</code> التحكم في إلقاء الاستثناء أم لا.</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration()
{
    IgnoreTemplateParameterMissing = false,
};
MiniExcel.SaveAsByTemplate(path, templatePath, value, config)
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/157464332-e316f829-54aa-4c84-a5aa-9aef337b668d.png" alt="image" /></p>
<h3>اسم العمود/الفهرس/خاصية التجاهل في Excel <a name="getstart4"></a></h3>
<h4>1. تحديد اسم العمود، رقم العمود، التجاهل</h4>
<p>مثال Excel</p>
<p><img src="https://user-images.githubusercontent.com/12729184/114230869-3e163700-99ac-11eb-9a90-2039d4b4b313.png" alt="image" /></p>
<p>الكود</p>
<pre><code class="language-csharp">public class ExcelAttributeDemo
{
    [ExcelColumnName(&quot;Column1&quot;)]
</code></pre>
<pre><code class="language-csharp">public string Test1 { get; set; }
[ExcelColumnName(&quot;Column2&quot;)]
public string Test2 { get; set; }
[ExcelIgnore]
public string Test3 { get; set; }
[ExcelColumnIndex(&quot;I&quot;)] // سيقوم النظام بتحويل &quot;I&quot; إلى الفهرس 8
public string Test4 { get; set; }
public string Test5 { get; } // بدون set سيتم تجاهلها
public string Test6 { get; private set; } // set غير عامة سيتم تجاهلها
[ExcelColumnIndex(3)] // يبدأ من 0
public string Test7 { get; set; }
}

var rows = MiniExcel.Query&lt;ExcelAttributeDemo&gt;(path).ToList();
Assert.Equal(&quot;Column1&quot;, rows[0].Test1);
Assert.Equal(&quot;Column2&quot;, rows[0].Test2);
Assert.Null(rows[0].Test3);
Assert.Equal(&quot;Test7&quot;, rows[0].Test4);
Assert.Null(rows[0].Test5);
Assert.Null(rows[0].Test6);
Assert.Equal(&quot;Test4&quot;, rows[0].Test7);
</code></pre>
<h4>2. تنسيق مخصص (ExcelFormatAttribute)</h4>
<p>منذ الإصدار V0.21.0، يدعم الفئة التي تحتوي على طريقة <code>ToString(string content)</code> للتنسيق</p>
<p>الفئة</p>
<pre><code class="language-csharp">public class Dto
{
    public string Name { get; set; }

    [ExcelFormat(&quot;MMMM dd, yyyy&quot;)]
    public DateTime InDate { get; set; }
}
</code></pre>
<p>الكود</p>
<pre><code class="language-csharp">var value = new Dto[] {
    new Issue241Dto{ Name=&quot;Jack&quot;,InDate=new DateTime(2021,01,04)},
    new Issue241Dto{ Name=&quot;Henry&quot;,InDate=new DateTime(2020,04,05)},
};
MiniExcel.SaveAs(path, value);
</code></pre>
<p>النتيجة</p>
<p><img src="https://user-images.githubusercontent.com/12729184/118910788-ab2bcd80-b957-11eb-8d42-bfce36621b1b.png" alt="image" /></p>
<p>استعلام يدعم تحويل التنسيقات المخصصة</p>
<p><img src="https://user-images.githubusercontent.com/12729184/118911286-87b55280-b958-11eb-9a88-c8ff403d240a.png" alt="image" /></p>
<h4>3. تعيين عرض العمود (ExcelColumnWidthAttribute)</h4>
<pre><code class="language-csharp">public class Dto
{
    [ExcelColumnWidth(20)]
    public int ID { get; set; }
    [ExcelColumnWidth(15.50)]
    public string Name { get; set; }
}
</code></pre>
<h4>4. تعيين عدة أسماء أعمدة لنفس الخاصية.</h4>
<pre><code class="language-csharp">public class Dto
{
    [ExcelColumnName(excelColumnName:&quot;EmployeeNo&quot;,aliases:new[] { &quot;EmpNo&quot;,&quot;No&quot; })]
    public string Empno { get; set; }
    public string Name { get; set; }
}
</code></pre>
<h4>5. System.ComponentModel.DisplayNameAttribute = ExcelColumnName.excelColumnNameAttribute</h4>
<p>منذ الإصدار 1.24.0، النظام يدعم System.ComponentModel.DisplayNameAttribute = ExcelColumnName.excelColumnNameAttribute</p>
<pre><code class="language-C#">public class TestIssueI4TXGTDto
{
    public int ID { get; set; }
    public string Name { get; set; }
    [DisplayName(&quot;Specification&quot;)]
    public string Spc { get; set; }
    [DisplayName(&quot;Unit Price&quot;)]
    public decimal Up { get; set; }
}
</code></pre>
<h4>6. ExcelColumnAttribute</h4>
<p>منذ الإصدار V1.26.0، يمكن تبسيط تعيين عدة سمات كما يلي:</p>
<pre><code class="language-csharp">        public class TestIssueI4ZYUUDto
        {
            [ExcelColumn(Name = &quot;ID&quot;,Index =0)]
            public string MyProperty { get; set; }
            [ExcelColumn(Name = &quot;CreateDate&quot;, Index = 1,Format =&quot;yyyy-MM&quot;,Width =100)]
            public DateTime MyProperty2 { get; set; }
        }
</code></pre>
<h4>7. DynamicColumnAttribute</h4>
<p>منذ الإصدار V1.26.0، يمكننا تعيين سمات العمود ديناميكياً</p>
<pre><code class="language-csharp">            var config = new OpenXmlConfiguration
            {
                DynamicColumns = new DynamicExcelColumn[] {
                    new DynamicExcelColumn(&quot;id&quot;){Ignore=true},
                    new DynamicExcelColumn(&quot;name&quot;){Index=1,Width=10},
                    new DynamicExcelColumn(&quot;createdate&quot;){Index=0,Format=&quot;yyyy-MM-dd&quot;,Width=15},
                    new DynamicExcelColumn(&quot;point&quot;){Index=2,Name=&quot;Account Point&quot;},
                }
            };
            var path = PathHelper.GetTempPath();
            var value = new[] { new { id = 1, name = &quot;Jack&quot;, createdate = new DateTime(2022, 04, 12) ,point = 123.456} };
            MiniExcel.SaveAs(path, value, configuration: config);
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/164510353-5aecbc4e-c3ce-41e8-b6cf-afd55eb23b68.png" alt="image" /></p>
<h4>8. DynamicSheetAttribute</h4>
<p>منذ الإصدار V1.31.4 يمكننا تعيين سمات الورقة ديناميكياً. يمكننا تعيين اسم الورقة وحالتها (الرؤية).</p>
<pre><code class="language-csharp">            var configuration = new OpenXmlConfiguration
            {
                DynamicSheets = new DynamicExcelSheet[] {
                    new DynamicExcelSheet(&quot;usersSheet&quot;) { Name = &quot;Users&quot;, State = SheetState.Visible },
                    new DynamicExcelSheet(&quot;departmentSheet&quot;) { Name = &quot;Departments&quot;, State = SheetState.Hidden }
                }
            };

            var users = new[] { new { Name = &quot;Jack&quot;, Age = 25 }, new { Name = &quot;Mike&quot;, Age = 44 } };
            var department = new[] { new { ID = &quot;01&quot;, Name = &quot;HR&quot; }, new { ID = &quot;02&quot;, Name = &quot;IT&quot; } };
            var sheets = new Dictionary&lt;string, object&gt;
            {
                [&quot;usersSheet&quot;] = users,
                [&quot;departmentSheet&quot;] = department
            };

            var path = PathHelper.GetTempPath();
            MiniExcel.SaveAs(path, sheets, configuration: configuration);
</code></pre>
<p>يمكننا أيضاً استخدام السمة الجديدة ExcelSheetAttribute:</p>
<pre><code class="language-C#">   [ExcelSheet(Name = &quot;Departments&quot;, State = SheetState.Hidden)]
   private class DepartmentDto
   {
      [ExcelColumn(Name = &quot;ID&quot;,Index = 0)]
      public string ID { get; set; }
      [ExcelColumn(Name = &quot;Name&quot;,Index = 1)]
      public string Name { get; set; }
   }
</code></pre>
<h3>إضافة، حذف، تحديث</h3>
<h4>إضافة</h4>
<p>الإصدار v1.28.0 يدعم إدراج بيانات N صفوف بعد آخر صف في CSV</p>
<pre><code class="language-csharp">// الأصل
{
    var value = new[] {
          new { ID=1,Name =&quot;Jack&quot;,InDate=new DateTime(2021,01,03)},
          new { ID=2,Name =&quot;Henry&quot;,InDate=new DateTime(2020,05,03)},
    };
    MiniExcel.SaveAs(path, value);
}
// إدراج صف واحد بعد الأخير
{
    var value = new { ID=3,Name = &quot;Mike&quot;, InDate = new DateTime(2021, 04, 23) };
    MiniExcel.Insert(path, value);
}
// إدراج N صفوف بعد الأخير
{
    var value = new[] {
          new { ID=4,Name =&quot;Frank&quot;,InDate=new DateTime(2021,06,07)},
          new { ID=5,Name =&quot;Gloria&quot;,InDate=new DateTime(2022,05,03)},
</code></pre>
<pre><code class="language-csharp">};
MiniExcel.Insert(path, value);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/191023733-1e2fa732-db5c-4a3a-9722-b891fe5aa069.png" alt="image" /></p>
<p>v1.37.0 يدعم إدراج ورقة جديدة في ملف Excel موجود</p>
<pre><code class="language-csharp">// ملف excel الأصلي
{
    var value = new[] {
          new { ID=1,Name =&quot;Jack&quot;,InDate=new DateTime(2021,01,03)},
          new { ID=2,Name =&quot;Henry&quot;,InDate=new DateTime(2020,05,03)},
    };
    MiniExcel.SaveAs(path, value, sheetName: &quot;Sheet1&quot;);
}
// إدراج ورقة جديدة
{
    var value = new { ID=3,Name = &quot;Mike&quot;, InDate = new DateTime(2021, 04, 23) };
    MiniExcel.Insert(path, table, sheetName: &quot;Sheet2&quot;);
}
</code></pre>
<h4>الحذف (بانتظار)</h4>
<h4>التحديث (بانتظار)</h4>
<h3>الكشف التلقائي عن نوع ملف Excel <a name="getstart5"></a></h3>
<ul>
<li>يقوم MiniExcel بالتحقق مما إذا كان الملف xlsx أو csv بناءً على <code>امتداد الملف</code> بشكل افتراضي، لكن قد يكون هناك عدم دقة، يرجى تحديد النوع يدوياً.</li>
<li>لا يمكن معرفة النوع من Stream مباشرة، لذا يرجى تحديده يدوياً.</li>
</ul>
<pre><code class="language-csharp">stream.SaveAs(excelType:ExcelType.CSV);
// أو
stream.SaveAs(excelType:ExcelType.XLSX);
// أو
stream.Query(excelType:ExcelType.CSV);
// أو
stream.Query(excelType:ExcelType.XLSX);
</code></pre>
<h3>CSV</h3>
<h4>ملاحظة</h4>
<ul>
<li>النوع الافتراضي للعودة هو <code>string</code>، ولن يتم تحويل القيمة إلى أرقام أو تاريخ ووقت، ما لم يتم تعريف النوع باستخدام generic قوي النوعية.</li>
</ul>
<h4>فاصل مخصص</h4>
<p>الافتراضي هو <code>,</code> كفاصل، يمكنك تعديل خاصية <code>Seperator</code> للتخصيص</p>
<pre><code class="language-csharp">var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    Seperator=';'
};
MiniExcel.SaveAs(path, values,configuration: config);
</code></pre>
<p>منذ الإصدار V1.30.1 يدعم وظيفة فاصل مخصص (شكرًا لـ @hyzx86)</p>
<pre><code class="language-csharp">var config = new CsvConfiguration()
{
    SplitFn = (row) =&gt; Regex.Split(row, $&quot;[\t,](?=(?:[^\&quot;]|\&quot;[^\&quot;]*\&quot;)*$)&quot;)
        .Select(s =&gt; Regex.Replace(s.Replace(&quot;\&quot;\&quot;&quot;, &quot;\&quot;&quot;), &quot;^\&quot;|\&quot;$&quot;, &quot;&quot;)).ToArray()
};
var rows = MiniExcel.Query(path, configuration: config).ToList();
</code></pre>
<h4>فاصل أسطر مخصص</h4>
<p>الافتراضي هو <code>\r\n</code> كحرف نهاية السطر، يمكنك تعديل خاصية <code>NewLine</code> للتخصيص</p>
<pre><code class="language-csharp">var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    NewLine='\n'
};
MiniExcel.SaveAs(path, values,configuration: config);
</code></pre>
<h4>ترميز مخصص</h4>
<ul>
<li>الترميز الافتراضي هو &quot;Detect Encoding From Byte Order Marks&quot;  (detectEncodingFromByteOrderMarks: true)</li>
<li>إذا كان لديك متطلبات ترميز مخصصة، يرجى تعديل خاصية StreamReaderFunc / StreamWriterFunc</li>
</ul>
<pre><code class="language-csharp">// قراءة
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    StreamReaderFunc = (stream) =&gt; new StreamReader(stream,Encoding.GetEncoding(&quot;gb2312&quot;))
};
var rows = MiniExcel.Query(path, true,excelType:ExcelType.CSV,configuration: config);

// كتابة
var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
    StreamWriterFunc = (stream) =&gt; new StreamWriter(stream, Encoding.GetEncoding(&quot;gb2312&quot;))
};
MiniExcel.SaveAs(path, value,excelType:ExcelType.CSV, configuration: config);
</code></pre>
<h4>قراءة السلاسل الفارغة كـ null</h4>
<p>افتراضيًا، يتم تحويل القيم الفارغة إلى string.Empty. يمكنك تعديل هذا السلوك</p>
<pre><code class="language-csharp">var config = new MiniExcelLibs.Csv.CsvConfiguration()
{
   ReadEmptyStringAsNull = true
};
</code></pre>
<h3>DataReader</h3>
<h4>1. GetReader</h4>
<p>منذ الإصدار 1.23.0، يمكنك استخدام GetDataReader</p>
<pre><code class="language-csharp">    using (var reader = MiniExcel.GetReader(path,true))
    {
        while (reader.Read())
        {
            for (int i = 0; i &lt; reader.FieldCount; i++)
            {
                var value = reader.GetValue(i);
            }
        }
    }
</code></pre>
<h3>Async</h3>
<ul>
<li>v0.17.0 يدعم Async (شكرًا isdaniel ( SHIH,BING-SIOU)](https://github.com/isdaniel))</li>
</ul>
<pre><code class="language-csharp">public static Task SaveAsAsync(string path, object value, bool printHeader = true, string sheetName = &quot;Sheet1&quot;, ExcelType excelType = ExcelType.UNKNOWN, IConfiguration configuration = null)
public static Task SaveAsAsync(this Stream stream, object value, bool printHeader = true, string sheetName = &quot;Sheet1&quot;, ExcelType excelType = ExcelType.XLSX, IConfiguration configuration = null)
public static Task&lt;IEnumerable&lt;dynamic&gt;&gt; QueryAsync(string path, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null)
public static Task&lt;IEnumerable&lt;T&gt;&gt; QueryAsync&lt;T&gt;(this Stream stream, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null) where T : class, new()
public static Task&lt;IEnumerable&lt;T&gt;&gt; QueryAsync&lt;T&gt;(string path, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null) where T : class, new()
public static Task&lt;IEnumerable&lt;IDictionary&lt;string, object&gt;&gt;&gt; QueryAsync(this Stream stream, bool useHeaderRow = false, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null)
public static Task SaveAsByTemplateAsync(this Stream stream, string templatePath, object value)
public static Task SaveAsByTemplateAsync(this Stream stream, byte[] templateBytes, object value)
public static Task SaveAsByTemplateAsync(string path, string templatePath, object value)
public static Task SaveAsByTemplateAsync(string path, byte[] templateBytes, object value)
public static Task&lt;DataTable&gt; QueryAsDataTableAsync(string path, bool useHeaderRow = true, string sheetName = null, ExcelType excelType = ExcelType.UNKNOWN, string startCell = &quot;A1&quot;, IConfiguration configuration = null)
</code></pre>
<ul>
<li>v1.25.0 يدعم <code>cancellationToken</code>。</li>
</ul>
<h3>أخرى</h3>
<h4>1. Enum</h4>
<p>تأكد أن اسم العمود في Excel واسم الخاصية متطابقان، سيتم تعيينهما تلقائيًا (غير حساس لحالة الأحرف)</p>
<p><img src="https://user-images.githubusercontent.com/12729184/116210595-9784b100-a775-11eb-936f-8e7a8b435961.png" alt="image" /></p>
<p>منذ الإصدار V0.18.0 يدعم Enum Description</p>
<pre><code class="language-csharp">public class Dto
{
    public string Name { get; set; }
    public I49RYZUserType UserType { get; set; }
}

public enum Type
{
    [Description(&quot;General User&quot;)]
    V1,
    [Description(&quot;General Administrator&quot;)]
    V2,
    [Description(&quot;Super Administrator&quot;)]
    V3
}
</code></pre>
<pre><code>
![image](https://user-images.githubusercontent.com/12729184/133116630-27cc7161-099a-48b8-9784-cd1e443af3d1.png)

منذ الإصدار 1.30.0 تم دعم الوصف الخاص بـ Excel إلى Enum، شكرًا @KaneLeung

#### 2. تحويل CSV إلى XLSX أو تحويل XLSX إلى CSV

```csharp
MiniExcel.ConvertXlsxToCsv(xlsxPath, csvPath);
MiniExcel.ConvertXlsxToCsv(xlsxStream, csvStream);
MiniExcel.ConvertCsvToXlsx(csvPath, xlsxPath);
MiniExcel.ConvertCsvToXlsx(csvStream, xlsxStream);
</code></pre>
<pre><code class="language-csharp">using (var excelStream = new FileStream(path: filePath, FileMode.Open, FileAccess.Read))
using (var csvStream = new MemoryStream())
{
   MiniExcel.ConvertXlsxToCsv(excelStream, csvStream);
}
</code></pre>
<h4>3. تخصيص CultureInfo</h4>
<p>منذ الإصدار 1.22.0، يمكنك تخصيص CultureInfo كما يلي، القيمة الافتراضية للنظام <code>CultureInfo.InvariantCulture</code>.</p>
<pre><code class="language-csharp">var config = new CsvConfiguration()
{
    Culture = new CultureInfo(&quot;fr-FR&quot;),
};
MiniExcel.SaveAs(path, value, configuration: config);

// أو
MiniExcel.Query(path, configuration: config);
</code></pre>
<h4>4. تخصيص حجم البافر (Buffer Size)</h4>
<pre><code class="language-csharp">    public abstract class Configuration : IConfiguration
    {
        public int BufferSize { get; set; } = 1024 * 512;
    }
</code></pre>
<h4>5. الوضع السريع (FastMode)</h4>
<p>النظام لن يتحكم في الذاكرة، ولكن يمكنك الحصول على سرعة حفظ أعلى.</p>
<pre><code class="language-csharp">var config = new OpenXmlConfiguration() { FastMode = true };
MiniExcel.SaveAs(path, reader,configuration:config);
</code></pre>
<h4>6. إضافة صورة بشكل دفعي (MiniExcel.AddPicture)</h4>
<pre><code class="language-csharp">var images = new[]
{
    new MiniExcelPicture
    {
        ImageBytes = File.ReadAllBytes(PathHelper.GetFile(&quot;images/github_logo.png&quot;)),
        SheetName = null, // الافتراضي null هو الورقة الأولى
        CellAddress = &quot;C3&quot;, // مطلوب
    },
    new MiniExcelPicture
    {
        ImageBytes = File.ReadAllBytes(PathHelper.GetFile(&quot;images/google_logo.png&quot;)),
        PictureType = &quot;image/png&quot;, // الافتراضي PictureType = image/png
        SheetName = &quot;Demo&quot;,
        CellAddress = &quot;C9&quot;, // مطلوب
        WidthPx = 100,
        HeightPx = 100,
    },
};
MiniExcel.AddPicture(path, images);
</code></pre>
<p><img src="https://github.com/user-attachments/assets/19c4d241-9753-4ede-96c8-f810c1a22247" alt="Image" /></p>
<h4>7. الحصول على أبعاد الورقة (Get Sheets Dimension)</h4>
<pre><code class="language-csharp">var dim = MiniExcel.GetSheetDimensions(path);
</code></pre>
<h3>أمثلة:</h3>
<h4>1. SQLite &amp; Dapper إدخال بيانات ملفات ضخمة عبر SQL وتجنب نفاد الذاكرة (OOM)</h4>
<p>ملاحظة: يرجى عدم استدعاء دوال ToList/ToArray بعد Query، لأنها ستحمل جميع البيانات في الذاكرة.</p>
<pre><code class="language-csharp">using (var connection = new SQLiteConnection(connectionString))
{
    connection.Open();
    using (var transaction = connection.BeginTransaction())
    using (var stream = File.OpenRead(path))
    {
       var rows = stream.Query();
       foreach (var row in rows)
             connection.Execute(&quot;insert into T (A,B) values (@A,@B)&quot;, new { row.A, row.B }, transaction: transaction);
       transaction.Commit();
    }
}
</code></pre>
<p>الأداء:
<img src="https://user-images.githubusercontent.com/12729184/111072579-2dda7b80-8516-11eb-9843-c01a1edc88ec.png" alt="image" /></p>
<h4>2. مثال API تحميل/رفع ملف إكسل Xlsx في ASP.NET Core 3.1 أو MVC 5 <a href="tests/MiniExcel.Tests.AspNetCore">جربه</a></h4>
<pre><code class="language-csharp">public class ApiController : Controller
{
    public IActionResult Index()
    {
        return new ContentResult
        {
            ContentType = &quot;text/html&quot;,
            StatusCode = (int)HttpStatusCode.OK,
            Content = @&quot;&lt;html&gt;&lt;body&gt;
&lt;a href='api/DownloadExcel'&gt;DownloadExcel&lt;/a&gt;&lt;br&gt;
&lt;a href='api/DownloadExcelFromTemplatePath'&gt;DownloadExcelFromTemplatePath&lt;/a&gt;&lt;br&gt;
&lt;a href='api/DownloadExcelFromTemplateBytes'&gt;DownloadExcelFromTemplateBytes&lt;/a&gt;&lt;br&gt;
&lt;p&gt;Upload Excel&lt;/p&gt;
&lt;form method='post' enctype='multipart/form-data' action='/api/uploadexcel'&gt;
    &lt;input type='file' name='excel'&gt; &lt;br&gt;
    &lt;input type='submit' &gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;&quot;
        };
    }

    public IActionResult DownloadExcel()
    {
        var values = new[] {
            new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
            new { Column1 = &quot;Github&quot;, Column2 = 2}
        };
        var memoryStream = new MemoryStream();
        memoryStream.SaveAs(values);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
        {
            FileDownloadName = &quot;demo.xlsx&quot;
        };
    }

    public IActionResult DownloadExcelFromTemplatePath()
    {
        string templatePath = &quot;TestTemplateComplex.xlsx&quot;;

        Dictionary&lt;string, object&gt; value = new Dictionary&lt;string, object&gt;()
        {
            [&quot;title&quot;] = &quot;FooCompany&quot;,
            [&quot;managers&quot;] = new[] {
                new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
                new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
            },
            [&quot;employees&quot;] = new[] {
                new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
                new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
                new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
                new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
            }
        };

        MemoryStream memoryStream = new MemoryStream();
        memoryStream.SaveAsByTemplate(templatePath, value);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
        {
            FileDownloadName = &quot;demo.xlsx&quot;
        };
    }

    private static Dictionary&lt;string, Byte[]&gt; TemplateBytesCache = new Dictionary&lt;string, byte[]&gt;();

    static ApiController()
    {
        string templatePath = &quot;TestTemplateComplex.xlsx&quot;;
        byte[] bytes = System.IO.File.ReadAllBytes(templatePath);
        TemplateBytesCache.Add(templatePath, bytes);
    }

    public IActionResult DownloadExcelFromTemplateBytes()
    {
        byte[] bytes = TemplateBytesCache[&quot;TestTemplateComplex.xlsx&quot;];

        Dictionary&lt;string, object&gt; value = new Dictionary&lt;string, object&gt;()
        {
            [&quot;title&quot;] = &quot;FooCompany&quot;,
            [&quot;managers&quot;] = new[] {
                new {name=&quot;Jack&quot;,department=&quot;HR&quot;},
                new {name=&quot;Loan&quot;,department=&quot;IT&quot;}
</code></pre>
<pre><code class="language-csharp">            },
            [&quot;employees&quot;] = new[] {
                new {name=&quot;Wade&quot;,department=&quot;HR&quot;},
                new {name=&quot;Felix&quot;,department=&quot;HR&quot;},
                new {name=&quot;Eric&quot;,department=&quot;IT&quot;},
                new {name=&quot;Keaton&quot;,department=&quot;IT&quot;}
            }
        };

        MemoryStream memoryStream = new MemoryStream();
        memoryStream.SaveAsByTemplate(bytes, value);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return new FileStreamResult(memoryStream, &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;)
        {
            FileDownloadName = &quot;demo.xlsx&quot;
        };
    }

    public IActionResult UploadExcel(IFormFile excel)
    {
        var stream = new MemoryStream();
        excel.CopyTo(stream);

        foreach (var item in stream.Query(true))
        {
            // نفذ منطقك هنا وما إلى ذلك.
        }

        return Ok(&quot;تم رفع الملف بنجاح&quot;);
    }
}
</code></pre>
<h4>3. استعلام مع ترقيم الصفحات</h4>
<pre><code class="language-csharp">void Main()
{
    var rows = MiniExcel.Query(path);

    Console.WriteLine(&quot;==== الصفحة رقم 1 ====&quot;);
    Console.WriteLine(Page(rows,pageSize:3,page:1));
    Console.WriteLine(&quot;==== الصفحة رقم 50 ====&quot;);
    Console.WriteLine(Page(rows,pageSize:3,page:50));
    Console.WriteLine(&quot;==== الصفحة رقم 5000 ====&quot;);
    Console.WriteLine(Page(rows,pageSize:3,page:5000));
}

public static IEnumerable&lt;T&gt; Page&lt;T&gt;(IEnumerable&lt;T&gt; en, int pageSize, int page)
{
    return en.Skip(page * pageSize).Take(pageSize);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/114679083-6ef4c400-9d3e-11eb-9f78-a86daa45fe46.gif" alt="20210419" /></p>
<h4>4. تصدير Excel في WebForm عبر MemoryStream</h4>
<pre><code class="language-csharp">var fileName = &quot;Demo.xlsx&quot;;
var sheetName = &quot;Sheet1&quot;;
HttpResponse response = HttpContext.Current.Response;
response.Clear();
response.ContentType = &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;;
response.AddHeader(&quot;Content-Disposition&quot;, $&quot;attachment;filename=\&quot;{fileName}\&quot;&quot;);
var values = new[] {
    new { Column1 = &quot;MiniExcel&quot;, Column2 = 1 },
    new { Column1 = &quot;Github&quot;, Column2 = 2}
};
var memoryStream = new MemoryStream();
memoryStream.SaveAs(values, sheetName: sheetName);
memoryStream.Seek(0, SeekOrigin.Begin);
memoryStream.CopyTo(Response.OutputStream);
response.End();
</code></pre>
<h4>5. إدارة ديناميكية للغات المتعددة (i18n) وصلاحيات الأدوار</h4>
<p>مثل المثال، قم بإنشاء دالة للتعامل مع التعدد اللغوي وإدارة الصلاحيات، واستخدم <code>yield return</code> لإرجاع <code>IEnumerable&lt;Dictionary&lt;string, object&gt;&gt;</code> لتحقيق معالجة ديناميكية وفعالية في استهلاك الذاكرة.</p>
<pre><code class="language-csharp">void Main()
{
    var value = new Order[] {
        new Order(){OrderNo = &quot;SO01&quot;,CustomerID=&quot;C001&quot;,ProductID=&quot;P001&quot;,Qty=100,Amt=500},
        new Order(){OrderNo = &quot;SO02&quot;,CustomerID=&quot;C002&quot;,ProductID=&quot;P002&quot;,Qty=300,Amt=400},
    };

    Console.WriteLine(&quot;en-Us ودور المبيعات&quot;);
    {
        var path = Path.GetTempPath() + Guid.NewGuid() + &quot;.xlsx&quot;;
        var lang = &quot;en-US&quot;;
        var role = &quot;Sales&quot;;
        MiniExcel.SaveAs(path, GetOrders(lang, role, value));
        MiniExcel.Query(path, true).Dump();
    }

    Console.WriteLine(&quot;zh-CN ودور PMC&quot;);
    {
        var path = Path.GetTempPath() + Guid.NewGuid() + &quot;.xlsx&quot;;
        var lang = &quot;zh-CN&quot;;
        var role = &quot;PMC&quot;;
        MiniExcel.SaveAs(path, GetOrders(lang, role, value));
        MiniExcel.Query(path, true).Dump();
    }
}

private IEnumerable&lt;Dictionary&lt;string, object&gt;&gt; GetOrders(string lang, string role, Order[] orders)
{
    foreach (var order in orders)
    {
        var newOrder = new Dictionary&lt;string, object&gt;();

        if (lang == &quot;zh-CN&quot;)
        {
            newOrder.Add(&quot;客户编号&quot;, order.CustomerID);
            newOrder.Add(&quot;订单编号&quot;, order.OrderNo);
            newOrder.Add(&quot;产品编号&quot;, order.ProductID);
            newOrder.Add(&quot;数量&quot;, order.Qty);
            if (role == &quot;Sales&quot;)
                newOrder.Add(&quot;价格&quot;, order.Amt);
            yield return newOrder;
        }
        else if (lang == &quot;en-US&quot;)
        {
            newOrder.Add(&quot;Customer ID&quot;, order.CustomerID);
            newOrder.Add(&quot;Order No&quot;, order.OrderNo);
            newOrder.Add(&quot;Product ID&quot;, order.ProductID);
            newOrder.Add(&quot;Quantity&quot;, order.Qty);
            if (role == &quot;Sales&quot;)
                newOrder.Add(&quot;Amount&quot;, order.Amt);
            yield return newOrder;
        }
        else
        {
            throw new InvalidDataException($&quot;lang {lang} wrong&quot;);
        }
    }
}

public class Order
{
    public string OrderNo { get; set; }
    public string CustomerID { get; set; }
    public decimal Qty { get; set; }
    public string ProductID { get; set; }
    public decimal Amt { get; set; }
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/118939964-d24bc480-b982-11eb-88dd-f06655f6121a.png" alt="image" /></p>
<h3>الأسئلة الشائعة</h3>
<h4>س: عنوان رأس الجدول في Excel لا يساوي اسم خاصية الكلاس، كيف يمكن إجراء الربط؟</h4>
<p>ج: الرجاء استخدام الخاصية ExcelColumnName</p>
<p><img src="https://user-images.githubusercontent.com/12729184/116020475-eac50980-a678-11eb-8804-129e87200e5e.png" alt="image" /></p>
<h4>س. كيف يمكن الاستعلام أو تصدير عدة أوراق عمل؟</h4>
<p>ج. استخدم دالة <code>GetSheetNames</code> مع معامل اسم الورقة في الاستعلام.</p>
<pre><code class="language-csharp">var sheets = MiniExcel.GetSheetNames(path);
foreach (var sheet in sheets)
{
    Console.WriteLine($&quot;اسم الورقة : {sheet} &quot;);
    var rows = MiniExcel.Query(path,useHeaderRow:true,sheetName:sheet);
    Console.WriteLine(rows);
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/12729184/116199841-2a1f5300-a76a-11eb-90a3-6710561cf6db.png" alt="image" /></p>
<h4>س. كيف يمكن الاستعلام أو تصدير معلومات عن حالة ظهور الورقة؟</h4>
<p>ج. استخدم دالة <code>GetSheetInformations</code>.</p>
<pre><code class="language-csharp">var sheets = MiniExcel.GetSheetInformations(path);
foreach (var sheetInfo in sheets)
{
    Console.WriteLine($&quot;فهرس الورقة : {sheetInfo.Index} &quot;); // رقم فهرس الورقة - يبدأ من 0
    Console.WriteLine($&quot;اسم الورقة : {sheetInfo.Name} &quot;);   // اسم الورقة
    Console.WriteLine($&quot;حالة الورقة : {sheetInfo.State} &quot;); // حالة ظهور الورقة - ظاهر / مخفي
}
</code></pre>
<pre><code>#### س. هل استخدام Count سيحمّل جميع البيانات في الذاكرة؟

لا، اختبار الصورة يحتوي على مليون صف × 10 أعمدة من البيانات، وأقصى استخدام للذاكرة هو أقل من 60 ميجابايت، ويستغرق 13.65 ثانية

![image](https://user-images.githubusercontent.com/12729184/117118518-70586000-adc3-11eb-9ce3-2ba76cf8b5e5.png)

#### س. كيف يستخدم Query الفهارس الرقمية؟

الفهرس الافتراضي لـ Query هو مفتاح نصي: A,B,C.... إذا كنت تريد التغيير إلى فهرس رقمي، يرجى إنشاء الطريقة التالية للتحويل

```csharp
void Main()
{
    var path = @&quot;D:\git\MiniExcel\samples\xlsx\TestTypeMapping.xlsx&quot;;
    var rows = MiniExcel.Query(path,true);
    foreach (var r in ConvertToIntIndexRows(rows))
    {
        Console.Write($&quot;column 0 : {r[0]} ,column 1 : {r[1]}&quot;);
        Console.WriteLine();
    }
}

private IEnumerable&lt;Dictionary&lt;int, object&gt;&gt; ConvertToIntIndexRows(IEnumerable&lt;object&gt; rows)
{
    ICollection&lt;string&gt; keys = null;
    var isFirst = true;
    foreach (IDictionary&lt;string,object&gt; r in rows)
    {
        if(isFirst)
        {
            keys = r.Keys;
            isFirst = false;
        }

        var dic = new Dictionary&lt;int, object&gt;();
        var index = 0;
        foreach (var key in keys)
            dic[index++] = r[key];
        yield return dic;
    }
}
</code></pre>
<h4>س. لا يتم توليد ملف إكسل بدون عنوان عندما تكون القيم فارغة عند التصدير</h4>
<p>لأن MiniExcel يستخدم منطقًا مشابهًا لـ JSON.NET للحصول على النوع ديناميكيًا من القيم لتبسيط العمليات البرمجية، ولا يمكن معرفة النوع بدون بيانات. يمكنك مراجعة <a href="https://github.com/mini-software/MiniExcel/issues/133">المشكلة #133</a> لمزيد من الفهم.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/122639771-546c0c00-d12e-11eb-800c-498db27889ca.png" alt="image" /></p>
<blockquote>
<p>النوع القوي وDataTable سيولدان رؤوس أعمدة، لكن Dictionary ستبقى إكسل فارغ</p>
</blockquote>
<h4>س. كيف يتم إيقاف التكرار foreach عند الصف الفارغ؟</h4>
<p>يمكن استخدام MiniExcel مع <code>LINQ TakeWhile</code> لإيقاف التكرار عند الصف الفارغ.</p>
<p><img src="https://user-images.githubusercontent.com/12729184/130209137-162621c2-f337-4479-9996-beeac65bc4d4.png" alt="Image" /></p>
<h4>س. كيف يمكن حذف الصفوف الفارغة؟</h4>
<p><img src="https://user-images.githubusercontent.com/12729184/137873865-7107d8f5-eb59-42db-903a-44e80589f1b2.png" alt="image" /></p>
<p>IEnumerable :</p>
<pre><code class="language-csharp">public static IEnumerable&lt;dynamic&gt; QueryWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
{
    var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
    foreach (IDictionary&lt;string,object&gt; row in rows)
    {
        if(row.Keys.Any(key=&gt;row[key]!=null))
            yield return row;
    }
}
</code></pre>
<p>DataTable :</p>
<pre><code class="language-csharp">public static DataTable QueryAsDataTableWithoutEmptyRow(Stream stream, bool useHeaderRow, string sheetName, ExcelType excelType, string startCell, IConfiguration configuration)
{
    if (sheetName == null &amp;&amp; excelType != ExcelType.CSV) /*Issue #279*/
        sheetName = stream.GetSheetNames().First();

    var dt = new DataTable(sheetName);
    var first = true;
    var rows = stream.Query(useHeaderRow,sheetName,excelType,startCell,configuration);
    foreach (IDictionary&lt;string, object&gt; row in rows)
    {
        if (first)
        {

            foreach (var key in row.Keys)
            {
                var column = new DataColumn(key, typeof(object)) { Caption = key };
                dt.Columns.Add(column);
            }

            dt.BeginLoadData();
            first = false;
        }

        var newRow = dt.NewRow();
        var isNull=true;
        foreach (var key in row.Keys)
        {
            var _v = row[key];
            if(_v!=null)
                isNull = false;
            newRow[key] = _v;
        }

        if(!isNull)
            dt.Rows.Add(newRow);
    }

    dt.EndLoadData();
    return dt;
}
</code></pre>
<h4>س. كيف يمكن استخدام SaveAs(path,value) لاستبدال الملف الموجود دون ظهور خطأ &quot;The file ...xlsx already exists error&quot;</h4>
<p>يرجى استخدام فئة Stream لتخصيص منطق إنشاء الملف، مثل:</p>
<pre><code class="language-C#">    using (var stream = File.Create(&quot;Demo.xlsx&quot;))
        MiniExcel.SaveAs(stream,value);
</code></pre>
<p>أو، منذ الإصدار V1.25.0، تدعم SaveAs معامل overwriteFile لتمكين/تعطيل استبدال الملف الموجود</p>
<pre><code class="language-csharp">    MiniExcel.SaveAs(path, value, overwriteFile: true);
</code></pre>
<h3>القيود والتنبيهات</h3>
<ul>
<li>لا يدعم xls والملفات المشفرة حاليًا</li>
<li>xlsm يدعم فقط Query</li>
</ul>
<h3>المراجع</h3>
<p><a href="https://github.com/ExcelDataReader/ExcelDataReader">ExcelDataReader</a>  / <a href="https://github.com/ClosedXML/ClosedXML">ClosedXML</a> / <a href="https://github.com/DapperLib/Dapper">Dapper</a> / <a href="https://github.com/andersnm/ExcelNumberFormat">ExcelNumberFormat</a></p>
<h3>الشكر</h3>
<h4><a href="https://www.jetbrains.com/">Jetbrains</a></h4>
<p><img src="https://user-images.githubusercontent.com/12729184/123997015-8456c180-da02-11eb-829a-aec476fe8e94.png" alt="jetbrains-variant-2" /></p>
<p>شكرًا لتوفير رخصة مجانية لجميع منتجات IDE لهذا المشروع (<a href="https://user-images.githubusercontent.com/12729184/123988233-6ab17c00-d9fa-11eb-8739-2a08c6a4a263.png">License</a>)</p>
<h3>مشاركة التبرعات والمساهمة</h3>
<p>الرابط https://github.com/orgs/mini-software/discussions/754</p>
<h3>المساهمون</h3>
<p><img src="https://contrib.rocks/image?repo=mini-software/MiniExcel" alt="" /></p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-08</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Statcounter and other scripts can be added here -->
</body>
</html>