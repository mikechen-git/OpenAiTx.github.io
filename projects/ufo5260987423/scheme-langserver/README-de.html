<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scheme-langserver - ufo5260987423/scheme-langserver de</title>
    <meta name="title" content="scheme-langserver - ufo5260987423/scheme-langserver de | Scheme-langserver Sie können mein Paper lesen und wie folgt zitieren: WANG, Z. (2025, 12. Mai). Scheme-langserver: Treat Scheme Code Editing as the First-Class ...">
    <meta name="description" content="ufo5260987423/scheme-langserver - GitHub repository de documentation and information | Scheme-langserver Sie können mein Paper lesen und wie folgt zitieren: WANG, Z. (2025, 12. Mai). Scheme-langserver: Treat Scheme Code Editing as the First-Class ...">
    <meta name="keywords" content="ufo5260987423, scheme-langserver, GitHub, repository, de documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/ufo5260987423/scheme-langserver/README-de.html">
    <meta property="og:title" content="scheme-langserver - ufo5260987423/scheme-langserver de | Scheme-langserver Sie können mein Paper lesen und wie folgt zitieren: WANG, Z. (2025, 12. Mai). Scheme-langserver: Treat Scheme Code Editing as the First-Class ...">
    <meta property="og:description" content="ufo5260987423/scheme-langserver - GitHub repository de documentation and information | Scheme-langserver Sie können mein Paper lesen und wie folgt zitieren: WANG, Z. (2025, 12. Mai). Scheme-langserver: Treat Scheme Code Editing as the First-Class ...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/ufo5260987423/scheme-langserver" id="githubRepoLink" target="_blank">ufo5260987423/scheme-langserver</a>
<h1 style="display: none;">Scheme-langserver Sie können mein Paper lesen und wie folgt zitieren: WANG, Z. (2025, 12. Mai). Scheme-langserver: Treat Scheme Code Editing as the First-Class ...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <p><img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png" alt="" /></p>
<h1>Scheme-langserver</h1>
<p><a href="https://deepwiki.com/ufo5260987423/scheme-langserver"><img src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki" /></a></p>
<p>Sie können mein <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf">Paper</a> lesen und wie folgt zitieren:</p>
<blockquote>
<p>WANG, Z. (2025, 12. Mai). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zürich. https://doi.org/10.5281/zenodo.15384882</p>
</blockquote>
<p>Da GitHub möglicherweise chinesische IP-Adressen blockiert, musste ich dieses Repository <a href="https://codeberg.org/ufo5260987423/scheme-langserver">hierhin</a> und <a href="https://gitee.com/ufo5260987423/scheme-langserver">hierhin</a> kopieren. Ich werde alle Repositories weiterhin aktualisieren, aber ich kann es nicht garantieren. Ich arbeite jetzt auch mit <a href="https://github.com/XmacsLabs">XmacsLabs</a> zusammen, Sie können auch einen Fork <a href="https://github.com/XmacsLabs/scheme-langserver">hier</a> finden.</p>
<p><video src="https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb" controls="controls" width="500" height="300"></video></p>
<p><strong>Jetzt kann VSCode scheme-langserver verwenden!</strong> Bitte beachten Sie <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md">HIER</a>.</p>
<blockquote>
<p>HINWEIS: Es gibt viele, viele Bugs im scheme-langserver. Ich bin dabei, sie zu beheben und bitte die Community um Hilfe. Bitte haben Sie Geduld.</p>
</blockquote>
<blockquote>
<p>HINWEIS: Die automatisch generierten Typinformationen finden Sie <a href="https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result">hier</a>. Sie werden derzeit hauptsächlich für die Weiterentwicklung (vielleicht inkl. AKKU) und zum Debuggen verwendet.</p>
</blockquote>
<p>Das Implementieren von Funktionen wie Autovervollständigung, Gehe-zu-Definition oder Dokumentation beim Hover ist ein erheblicher Aufwand beim Programmieren. Im Vergleich zu anderen Sprachen wie Java, Python, JavaScript und C werden Implementierungen des Language Server Protocols für Lisp-Sprachen jedoch quasi im Vakuum entwickelt. <a href="https://gitlab.com/emacs-geiser">Geiser</a>, <a href="https://github.com/jeapostrophe/racket-langserver">racket langserver</a> und <a href="https://github.com/becls/swish-lint">swish-lint</a> basieren alle auf <code>repl</code> (Read-Eval-Print Loop) oder einem Keyword-Tokenizer statt echter Programmierung. Zum Beispiel: Wenn ein Programmierer an einem noch unfertigen Projekt arbeitet, in dem der Code nicht vollständig lauffähig ist, würden <a href="https://gitlab.com/emacs-geiser">Geiser</a> oder andere nur Top-Level-Bindungsbezeichner auflisten, die durch die Prozedur <code>environment-symbols</code> (für <a href="https://cisco.github.io/ChezScheme/">Chez</a>) bereitgestellt werden, oder sie vervollständigen Symbole anstelle von Bezeichnern. Das heißt, für lokale Bindungen und unfertige Codes, obwohl die Unterstützung beim Programmieren eigentlich am wichtigsten wäre, helfen <a href="https://gitlab.com/emacs-geiser">Geiser</a> und ähnliche Tools nicht bei der Erkennung des gültigen Gültigkeitsbereichs eines Bezeichners. Ähnliche Probleme treten bei Gehe-zu-Definition und vielen anderen Funktionen auf.</p>
<p>Ein Hauptgrund ist, dass für Scheme und andere Lisp-Dialekte die umfangreichen Datensätze und flexiblen Kontrollstrukturen die Programmanalyse zu einer großen Herausforderung machen. Insbesondere das Makro: Es scheint, als wäre Scheme hauptsächlich für Genies und Meta-/Makroprogrammierung gedacht. Aber ich sage nein. Scheme kann viele interessante Dinge ermöglichen, wenn eine bessere Programmierumgebung bereitgestellt wird. Und jetzt können Sie <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md"><strong>HIER STARTEN</strong></a>.</p>
<p>Dieses Paket ist eine Implementierung des Language Server Protocol, die das Programmieren mit Scheme unterstützt. Es bietet Vervollständigung, Definition und Typinferenz. Diese Funktionen basieren auf statischer Codeanalyse mit dem <a href="http://www.r6rs.org/">r6rs Standard</a> und einigen offensichtlichen Regeln für unfertige Codes. Dieses Paket selbst und zugehörige Bibliotheken sind veröffentlicht oder werden veröffentlicht mit <a href="https://akkuscm.org/">Akku</a>, einem Paketmanager für Scheme.</p>
<p>Dieses Paket wurde auch mit <a href="https://cisco.github.io/ChezScheme/">Chez Scheme</a> in den Versionen 9.4 und 9.5 getestet. Ein detaillierter Test für Version 10.0.0 wird nach dem Upgrade meines Laptop-Betriebssystems auf eine neuere Version durchgeführt.</p>
<p>Ich mache diese Open-Source-Arbeit nur in meiner Freizeit und kann viele großartige Ideen zur Community beitragen, wie z. B. die Einbettung einer Data-Flow-Analyse in scheme-langserver oder vieles mehr. Und ich bitte kontinuierlich um mehr Spenden oder Förderung. Sie können über <a href="https://www.patreon.com/PoorProgrammer/membership">diese Patreon-Seite</a> oder <a href="https://afdian.com/a/ufo5260987423">爱发电</a> spenden.</p>
<h2>Kompilierung, Installation &amp; Konfiguration finden Sie <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md">HIER</a></h2>
<h2>Aktueller Status</h2>
<p>Ich werde weiterhin Bugs beheben, den Code profilieren und Informationen für mein großes Buch über selbstgemachte Typinferenzsysteme sammeln. Das wird etwa 1 Jahr dauern. Weitere Entwicklungen beinhalten ein <a href="https://code.visualstudio.com/">VScode</a> Plugin und Data-Flow-Analyse. Tatsächlich ist diese Open-Source-Arbeit derzeit ein Nebenjob für mich, und ich kann keinen Zeitplan garantieren.</p>
<h2>Release</h2>
<p>1.2.9 Jetzt: Viel Spaß mit der Typinferenz!</p>
<p>Frühere Releases finden Sie in <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md">dieser Datei</a>.</p>
<h3>Funktionen</h3>
<ol>
<li>Top-Level- und lokale Bezeichner-Vervollständigung.
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png" alt="Top-level and local identifiers binding" title="Top-level and local identifiers binding" /></li>
<li>Gehe-zu-Definition.
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png" alt="Goto definition with telescope.nvim" title="Goto Definition with telescope.nvim" /></li>
<li>Kompatibel mit Paketmanager: Akku.</li>
<li>Synchronisierung von Dateiänderungen und entsprechende Indexanpassung.</li>
<li>Hover.</li>
<li>Referenzen und Dokumenthervorhebung (dokumentenbezogene Referenzen).
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png" alt="Find references with telescope.nvim" title="Find references with telescope.nvim" /></li>
<li>Dokumentsymbol.
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png" alt="Find document symbols with telescope.nvim" title="find document symbols with telescope.nvim" /></li>
<li>Erkennung von *-Syntax (define-syntax, let-syntax, etc.) für lokale Bezeichnerbindungen.</li>
<li>Plattformübergreifendes paralleles Indexieren.</li>
<li>Eigener Quellcode-Annotator zur Kompatibilität mit .sps-Dateien.</li>
<li>Peephole-Optimierung für API-Anfragen mit aussetzbaren Aufgaben.</li>
<li>Typinferenz mit einem selbst entwickelten DSL-Interpreter (darauf bin ich sehr stolz!). Sie ist nun auch in die Autovervollständigung integriert. Wie in der folgenden Abbildung zu sehen ist, stehen die &quot;length-b&quot; und &quot;length-a&quot; mit &quot;integer?&quot; Typ vor den anderen empfohlenen Optionen, da sie zum geforderten Parametertyp von &quot;&lt;=&quot; passen.
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png" alt="Autocompletion with type inference" title="Autocompletion with type inference" />
Ein Test kann dies belegen, einfach <code>scheme --script tests/protocol/apis/test-completion.sps</code> ausführen und die Logdatei <code>scheme-langserver.log</code> enthält dann Ergebnisse wie:</li>
</ol>
<pre><code class="language-bash">send-message
2023 11 21 11 26 41 967266866
{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:&quot;3&quot;,&quot;result&quot;:[{&quot;label&quot;:&quot;length-a&quot;},{&quot;label&quot;:&quot;length-b&quot;},{&quot;label&quot;:&quot;lambda&quot;},{&quot;label&quot;:&quot;latin-1-codec&quot;},{&quot;label&quot;:&quot;lcm&quot;},{&quot;label&quot;:&quot;least-fixnum&quot;},{&quot;label&quot;:&quot;length&quot;},{&quot;label&quot;:&quot;let&quot;},{&quot;label&quot;:&quot;let*&quot;},{&quot;label&quot;:&quot;let*-values&quot;},{&quot;label&quot;:&quot;let-syntax&quot;},{&quot;label&quot;:&quot;let-values&quot;},{&quot;label&quot;:&quot;letrec&quot;},{&quot;label&quot;:&quot;letrec*&quot;},{&quot;label&quot;:&quot;letrec-syntax&quot;},{&quot;label&quot;:&quot;lexical-violation?&quot;},{&quot;label&quot;:&quot;list&quot;},{&quot;label&quot;:&quot;list-&gt;string&quot;},{&quot;label&quot;:&quot;list-&gt;vector&quot;},{&quot;label&quot;:&quot;list-ref&quot;},{&quot;label&quot;:&quot;list-sort&quot;},{&quot;label&quot;:&quot;list-tail&quot;},{&quot;label&quot;:&quot;list?&quot;},{&quot;label&quot;:&quot;log&quot;},{&quot;label&quot;:&quot;lookahead-char&quot;},{&quot;label&quot;:&quot;lookahead-u8&quot;}]}
</code></pre>
<ol start="13">
<li>Abstrakter Interpreter zum Erkennen von Bezeichnern zwischen verschiedenen Dateiendungen wie scm, ss, sps, sls und sld.</li>
</ol>
<h3>TODOs</h3>
<ol start="14">
<li>Umbenennung.</li>
<li>Vollständige Kompatibilität mit dem <a href="http://www.r6rs.org/">r6rs Standard</a>.</li>
<li>Schrittweiser Makro-Expander: Eigentlich habe ich einen implementiert und wollte ihn als Schlüsselschritt zur Erkennung von Bezeichnerbindungen in selbst definierten Makros nutzen. Jetzt merke ich, dass diese Erkennung viel schwieriger ist als gedacht, und ich weiß nicht, wo der Expander nützlich sein könnte.</li>
<li>Code-Auswertung.</li>
<li>Code-Diagnose.</li>
<li>Hinzufügen von semantischer Unterstützung für andere Sprachen. Könnten Java, C, Python und viele andere Sprachen mit einem AST-Transformer unterstützt werden?</li>
<li>Extrahieren von Ausdrücken/Statements in eine Prozedur.</li>
</ol>
<h2>TODO:Beitragen</h2>
<h2>Debug</h2>
<h3>Wie debuggt man</h3>
<p>https://www.scheme.com/debug/debug.html#g1</p>
<h3>Ausgabelog</h3>
<p>Nach den Hinweisen im Abschnitt <a href="#building">Building</a>, <a href="#installation-for-lunarvim">Installation für Lunar Vim</a> und <a href="#todo-installation-for-vscode">Installation für VScode</a>, falls jemand entwickeln und etwas loggen möchte, ist es praktisch, <code>path-to-log-file</code> hinzuzufügen und die Datei <code>~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua</code> wie folgt umzuschreiben:</p>
<pre><code class="language-lua">local util = require 'lspconfig.util'
local bin_name = '{path-to-run}'
local cmd = { bin_name ,&quot;path-to-log-file&quot;}

return {
  default_config = {
    cmd = cmd,
    filetypes = { 'scheme' },
    root_dir = util.find_git_ancestor,
    single_file_support = true,
  },
  docs = {
    description = [[
https://github.com/ufo5260987423/scheme-langserver
`scheme-langserver`, eine Implementierung des Language Server Protocol für Scheme
]]   ,
  },
</code></pre>
<h3>Wiederkehrende Fehleranalyse mit Log</h3>
<p>Mit dem oben genannten <a href="#output-log">Ausgabe-Log</a> können Sie mithilfe von <code>tests/log-debug.sps</code> wiederkehrende Fehler untersuchen:</p>
<ol>
<li>Benennen Sie <code>{path-to-log}</code> (in der Regel <code>~/scheme-langserver.log</code>) um in <code>~/ready-for-analyse.log</code>;</li>
<li>Führen Sie <code>scheme --script tests/log-debug.sps</code> aus. Wenn Sie die Multi-Thread-Umgebung reproduzieren möchten, können Sie ebenfalls <code>scheme --script tests/log-debug.sps</code> ausführen.</li>
</ol>
<h2>Test</h2>
<p>Fast alle wichtigen Prozeduren und APIs sind getestet. Meine Arbeit ist zwar grob, aber nützlich. Vielleicht möchten Sie herausfinden, was ich im Verzeichnis <code>tests</code> gemacht habe, oder einfach den folgenden Befehl im <code>{scheme-langserver-root-directory}</code> ausführen:</p>
<pre><code class="language-bash">bash test.sh
</code></pre>
<blockquote>
<p>HINWEIS
Es ist schwierig, Tests in einer Multi-Thread-Umgebung durchzuführen. Daher konzentrieren sich die aktuellen Tests auf den Single-Thread-Betrieb.</p>
</blockquote>
<h2>Scheme-langserver für andere Zwecke verwenden</h2>
<h3>Script-Fu in GIMP</h3>
<p>Script-Fu basiert auf einer interpretierten Sprache namens Scheme und funktioniert, indem es mit Funktionen arbeitet, die mit den internen Funktionen von GIMP interagieren. Am Beispiel des <a href="https://dalelane.co.uk/blog/?p=628">Skripts auf dieser Seite</a> können Sie scheme-langserver mit Skriptdateien mit der Erweiterung &quot;SCM&quot; verwenden.</p>
<h3>Sonstiges</h3>
<p>Ich interessiere mich auch für <a href="https://opusmodus.com/">OMN (Opusmodus Notation)</a> und AutoLisp. Aber ich habe noch viele andere Dinge zu erledigen.</p>
<h2>Code-Zeilen zählen</h2>
<pre><code class="language-bash">find . -name &quot;*.sls&quot; ! -path &quot;./.akku/*&quot; |xargs wc -l
</code></pre>
<h2>Ausführliche Dokumentation</h2>
<ol>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf">Scheme-langserver: Scheme-Code-Bearbeitung als zentrales Anliegen behandeln</a>.</li>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/analysis/identifier.md">Auffinden von Identifier-Bindungen</a></li>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/util/synchronize.md">Synchronisierung</a></li>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/analysis/type-inference.md">Typinferenz</a>,~~<a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/analysis/type-inference.cn.md">类型推断</a>~~(Veraltet, und ich schreibe derzeit ein chinesisches Buch darüber)</li>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/protocol/analysis.md">API Analyse</a></li>
<li><a href="https://deepwiki.com/ufo5260987423/scheme-langserver">Deepwiki</a></li>
</ol>
<h2>Star-Verlauf</h2>
<p><a href="https://star-history.com/#ufo5260987423/scheme-langserver"><img src="https://api.star-history.com/svg?repos=ufo5260987423/scheme-langserver&amp;type=Date" alt="Star History Chart" /></a></p>
<h2>Mitwirkende</h2>
<p><img src="https://contrib.rocks/image?repo=ufo5260987423/scheme-langserver" alt="Contributors" /></p>
<pre><code>

---


Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-07-01


---
</code></pre>

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>