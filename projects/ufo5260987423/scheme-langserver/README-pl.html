<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scheme-langserver - ufo5260987423/scheme-langserver pl</title>
    <meta name="title" content="scheme-langserver - ufo5260987423/scheme-langserver pl | Scheme-langserver Możesz przeczytać mój artykuł i zacytować go w ten sposób: WANG, Z. (2025, 12 maja). Scheme-langserver: Treat Scheme Code Editing as the First...">
    <meta name="description" content="ufo5260987423/scheme-langserver - GitHub repository pl documentation and information | Scheme-langserver Możesz przeczytać mój artykuł i zacytować go w ten sposób: WANG, Z. (2025, 12 maja). Scheme-langserver: Treat Scheme Code Editing as the First...">
    <meta name="keywords" content="ufo5260987423, scheme-langserver, GitHub, repository, pl documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/ufo5260987423/scheme-langserver/README-pl.html">
    <meta property="og:title" content="scheme-langserver - ufo5260987423/scheme-langserver pl | Scheme-langserver Możesz przeczytać mój artykuł i zacytować go w ten sposób: WANG, Z. (2025, 12 maja). Scheme-langserver: Treat Scheme Code Editing as the First...">
    <meta property="og:description" content="ufo5260987423/scheme-langserver - GitHub repository pl documentation and information | Scheme-langserver Możesz przeczytać mój artykuł i zacytować go w ten sposób: WANG, Z. (2025, 12 maja). Scheme-langserver: Treat Scheme Code Editing as the First...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/ufo5260987423/scheme-langserver" id="githubRepoLink" target="_blank">ufo5260987423/scheme-langserver</a>
<h1 style="display: none;">Scheme-langserver Możesz przeczytać mój artykuł i zacytować go w ten sposób: WANG, Z. (2025, 12 maja). Scheme-langserver: Treat Scheme Code Editing as the First...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <p><img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/logo-no-background.png" alt="" /></p>
<h1>Scheme-langserver</h1>
<p><a href="https://deepwiki.com/ufo5260987423/scheme-langserver"><img src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki" /></a></p>
<p>Możesz przeczytać mój <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf">artykuł</a> i zacytować go w ten sposób:</p>
<blockquote>
<p>WANG, Z. (2025, 12 maja). Scheme-langserver: Treat Scheme Code Editing as the First-Class Concern. The 18th European Lisp Symposium (ELS`25), Zurich. https://doi.org/10.5281/zenodo.15384882</p>
</blockquote>
<p>Ponieważ GitHub może blokować adresy IP z Chin, musiałem skopiować to repozytorium <a href="https://codeberg.org/ufo5260987423/scheme-langserver">tutaj</a> oraz <a href="https://gitee.com/ufo5260987423/scheme-langserver">tutaj</a>. Będę stale aktualizować wszystkie repozytoria, ale nie mogę tego zagwarantować. Obecnie współpracuję również z <a href="https://github.com/XmacsLabs">XmacsLabs</a>, można znaleźć fork <a href="https://github.com/XmacsLabs/scheme-langserver">tutaj</a>.</p>
<p><video src="https://github.com/user-attachments/assets/893bba98-6709-4fac-a4d3-dc7b6aab46fb" controls="controls" width="500" height="300"></video></p>
<p><strong>Teraz VSCode może korzystać ze scheme-langserver!</strong> Proszę sprawdź <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md">TUTAJ</a>.</p>
<blockquote>
<p>UWAGA: Scheme-langserver posiada bardzo dużo błędów. Wciąż je naprawiam i proszę społeczność o pomoc. Proszę o cierpliwość.</p>
</blockquote>
<blockquote>
<p>UWAGA: automatycznie generowane informacje o typach można znaleźć <a href="https://ufo5260987423.github.io/scheme-langserver/doc/analysis/type-inference-result">tutaj</a>. Obecnie są one wykorzystywane głównie do dalszego rozwoju (może z AKKU) i debugowania.</p>
</blockquote>
<p>Implementacja wsparcia dla takich funkcji jak autouzupełnianie, przejście do definicji czy dokumentacja po najechaniu myszką to poważne wyzwanie programistyczne. Jednak w porównaniu z innymi językami jak java, python, javascript czy c, implementacje language server protocol dla języków lispowych powstają w próżni. <a href="https://gitlab.com/emacs-geiser">Geiser</a>, <a href="https://github.com/jeapostrophe/racket-langserver">racket langserver</a> oraz <a href="https://github.com/becls/swish-lint">swish-lint</a> itp. opierają się na <code>repl</code> (Read-Eval-Print Loop) lub tokenizatorze słów kluczowych, a nie na analizie kodu. Na przykład, jeśli programista pracuje nad niedokończonym projektem, w którym kod nie jest w pełni wykonalny, <a href="https://gitlab.com/emacs-geiser">Geiser</a> i inne narzędzia ukończą tylko identyfikatory wiązań na najwyższym poziomie, wymienione przez procedurę <code>environment-symbols</code> (dla <a href="https://cisco.github.io/ChezScheme/">Chez</a>), lub uzupełnią symbole zamiast identyfikatorów. Oznacza to, że dla lokalnych wiązań i niedokończonego kodu – choć praca nad programowaniem powinna być priorytetem – <a href="https://gitlab.com/emacs-geiser">Geiser</a> i jego odpowiedniki nie pomagają w rozpoznawaniu poprawnego zakresu identyfikatorów. Podobne problemy pojawiają się przy przejściu do definicji i innych funkcjach.</p>
<p>Główną przyczyną jest to, że w scheme i innych dialektach lispowych bogactwo struktur danych i elastyczność kontroli przepływu sprawiają, że analiza programu jest dużym wyzwaniem. Szczególnie makra – wydaje się, że scheme jest przeznaczony głównie dla geniuszy i programowania meta/makro. Ja jednak twierdzę, że nie. Scheme może być wykorzystywany do wielu ciekawych rzeczy, jeśli zapewni się lepsze środowisko programistyczne. Teraz możesz <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md"><strong>ZACZĄĆ TUTAJ</strong></a>.</p>
<p>Ten pakiet to implementacja language server protocol wspierająca programowanie w scheme. Udostępnia uzupełnianie kodu, przechodzenie do definicji i inferencję typów. Funkcje te oparte są na statycznej analizie kodu zgodnie ze <a href="http://www.r6rs.org/">standardem r6rs</a> oraz oczywistymi regułami dla niedokończonego kodu. Sam pakiet i powiązane biblioteki są publikowane lub będą publikowane z <a href="https://akkuscm.org/">Akku</a>, czyli menedżerem pakietów dla Scheme.</p>
<p>Pakiet był także testowany z <a href="https://cisco.github.io/ChezScheme/">Chez Scheme</a> w wersjach 9.4 i 9.5. Szczegółowe testy dla wersji 10.0.0 będą wykonane po aktualizacji mojego systemu operacyjnego.</p>
<p>Pracuję nad tym projektem open source w wolnym czasie i mogę wnieść do społeczności wiele świetnych pomysłów, takich jak wbudowanie analizy przepływu danych w scheme-langserver lub wiele innych rzeczy. Stale proszę również o wsparcie finansowe lub darowizny. Możesz przekazać datek poprzez <a href="https://www.patreon.com/PoorProgrammer/membership">tę stronę patreona</a> lub <a href="https://afdian.com/a/ufo5260987423">爱发电</a>.</p>
<h2>Kompilacja, instalacja i konfiguracja są opisane <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/startup.md">TUTAJ</a></h2>
<h2>Aktualny stan</h2>
<p>Będę nadal naprawiać błędy, profilować kod i zbierać materiały do mojej wielkiej książki o systemie inferencji typów własnej roboty. Zajmie mi to około roku. Kolejne plany rozwoju obejmują wtyczkę do <a href="https://code.visualstudio.com/">VScode</a> oraz analizę przepływu danych. W praktyce jednak traktuję ten projekt open source jako pracę dorywczą i nie mogę zagwarantować żadnego harmonogramu.</p>
<h2>Wydanie</h2>
<p>1.2.9 Teraz można korzystać z inferencji typów!</p>
<p>Poprzednie wydania znajdziesz w <a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/release-log.md">tym pliku</a>.</p>
<h3>Funkcjonalności</h3>
<ol>
<li>Uzupełnianie wiązań identyfikatorów na najwyższym i lokalnym poziomie.
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion.png" alt="Top-level and local identifiers binding" title="Top-level and local identifiers binding" /></li>
<li>Przechodzenie do definicji.
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/definition.png" alt="Goto definition with telescope.nvim" title="Goto Definition with telescope.nvim" /></li>
<li>Kompatybilność z menedżerem pakietów: Akku.</li>
<li>Synchronizacja zmian plików i odpowiednia aktualizacja indeksu.</li>
<li>Wyświetlanie dokumentacji po najechaniu (hover).</li>
<li>Wyszukiwanie referencji i podświetlanie dokumentów (referencje w zakresie dokumentu).
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/find-references.png" alt="Find references with telescope.nvim" title="Find references with telescope.nvim" /></li>
<li>Symbole dokumentu.
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/document-symbol.png" alt="Find document symbols with telescope.nvim" title="find document symbols with telescope.nvim" /></li>
<li>Wychwytywanie wiązań lokalnych identyfikatorów bazujące na *-syntax (define-syntax, let-syntax itd.).</li>
<li>Wieloplatformowe, równoległe indeksowanie.</li>
<li>Własnoręczny adnotator kodu źródłowego, kompatybilny z plikami .sps.</li>
<li>Optymalizacja „peephole” dla żądań API z zadaniami wstrzymywanymi.</li>
<li>Inferencja typów z użyciem własnego interpretera DSL (jestem z tego bardzo dumny!). Teraz została ona zintegrowana z autouzupełnianiem. Jak pokazano na poniższym obrazku, „length-b” i „length-a” mające typ „integer?” są wyświetlane na początku proponowanych opcji, ponieważ pasują do typu parametru wymaganego przez „&lt;=”.
<img src="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/figure/auto-completion-with-type-inference.png" alt="Autocompletion with type inference" title="Autocompletion with type inference" />
Test może to potwierdzić – wystarczy uruchomić <code>scheme --script tests/protocol/apis/test-completion.sps</code>, a plik logu <code>scheme-langserver.log</code> będzie zawierał wyniki takie jak:</li>
</ol>
<pre><code class="language-bash">send-message
2023 11 21 11 26 41 967266866
{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:&quot;3&quot;,&quot;result&quot;:[{&quot;label&quot;:&quot;length-a&quot;},{&quot;label&quot;:&quot;length-b&quot;},{&quot;label&quot;:&quot;lambda&quot;},{&quot;label&quot;:&quot;latin-1-codec&quot;},{&quot;label&quot;:&quot;lcm&quot;},{&quot;label&quot;:&quot;least-fixnum&quot;},{&quot;label&quot;:&quot;length&quot;},{&quot;label&quot;:&quot;let&quot;},{&quot;label&quot;:&quot;let*&quot;},{&quot;label&quot;:&quot;let*-values&quot;},{&quot;label&quot;:&quot;let-syntax&quot;},{&quot;label&quot;:&quot;let-values&quot;},{&quot;label&quot;:&quot;letrec&quot;},{&quot;label&quot;:&quot;letrec*&quot;},{&quot;label&quot;:&quot;letrec-syntax&quot;},{&quot;label&quot;:&quot;lexical-violation?&quot;},{&quot;label&quot;:&quot;list&quot;},{&quot;label&quot;:&quot;list-&gt;string&quot;},{&quot;label&quot;:&quot;list-&gt;vector&quot;},{&quot;label&quot;:&quot;list-ref&quot;},{&quot;label&quot;:&quot;list-sort&quot;},{&quot;label&quot;:&quot;list-tail&quot;},{&quot;label&quot;:&quot;list?&quot;},{&quot;label&quot;:&quot;log&quot;},{&quot;label&quot;:&quot;lookahead-char&quot;},{&quot;label&quot;:&quot;lookahead-u8&quot;}]}
</code></pre>
<ol start="13">
<li>Abstrakcyjny interpreter do wychwytywania identyfikatorów pomiędzy różnymi rozszerzeniami plików, jak scm, ss, sps, sls oraz sld.</li>
</ol>
<h3>TODO</h3>
<ol start="14">
<li>Zmiana nazw (renaming).</li>
<li>Pełna zgodność ze <a href="http://www.r6rs.org/">standardem r6rs</a>.</li>
<li>Krokowy ekspander makr: w zasadzie już go zaimplementowałem i chciałem, żeby był kluczowym elementem do wychwytywania wiązań identyfikatorów w makrach własnej definicji. Teraz jednak widzę, że to zadanie jest dużo trudniejsze niż sądziłem, a ekspander nie wiem, gdzie mógłby być wykorzystany.</li>
<li>Wykonywanie kodu (eval).</li>
<li>Diagnostyka kodu.</li>
<li>Dodanie wsparcia semantyki międzyjęzykowej. Czy java, c, python i inne języki mogłyby być obsłużone przez transformator AST?</li>
<li>Ekstrakcja wyrażeń/instrukcji do procedury.</li>
</ol>
<h2>TODO: Współtworzenie</h2>
<h2>Debugowanie</h2>
<h3>Jak debugować</h3>
<p>https://www.scheme.com/debug/debug.html#g1</p>
<h3>Log wyjściowy</h3>
<p>Postępując zgodnie z instrukcjami z <a href="#building">Budowania</a>, <a href="#installation-for-lunarvim">Instalacji dla Lunar Vim</a> oraz <a href="#todo-installation-for-vscode">Instalacji dla VScode</a>, jeśli ktoś chce rozwijać projekt i rejestrować logi, wystarczy dodać <code>path-to-log-file</code> i nadpisać plik <code>~/.local/share/lunarvim/site/pack/packer/start/nvim-lspconfig/lua/lspconfig/server_configurations/scheme_langserver.lua</code> następująco:</p>
<pre><code class="language-lua">local util = require 'lspconfig.util'
local bin_name = '{path-to-run}'
local cmd = { bin_name ,&quot;path-to-log-file&quot;}

return {
  default_config = {
    cmd = cmd,
    filetypes = { 'scheme' },
    root_dir = util.find_git_ancestor,
    single_file_support = true,
  },
  docs = {
    description = [[
https://github.com/ufo5260987423/scheme-langserver
`scheme-langserver`, a language server protocol implementation for scheme
]]   ,
  },
}
</code></pre>
<h3>Powtarzanie z logiem</h3>
<p>Korzystając z powyższego <a href="#output-log">logu wyjściowego</a>, możesz użyć <code>tests/log-debug.sps</code> do powtarzania błędów:</p>
<ol>
<li>Zmień nazwę pliku <code>{path-to-log}</code> (zazwyczaj <code>~/scheme-langserver.log</code>) na <code>~/ready-for-analyse.log</code>;</li>
<li>Uruchom <code>scheme --script tests/log-debug.sps</code>. Jeśli chcesz odtworzyć środowisko wielowątkowe, możesz również uruchomić <code>scheme --script tests/log-debug.sps</code>.</li>
</ol>
<h2>Test</h2>
<p>Prawie wszystkie kluczowe procedury i API są testowane. Moja praca jest dość surowa, ale użyteczna, może znajdziesz to, co zrobiłem w katalogu <code>tests</code> lub po prostu uruchom poniższe polecenie w <code>{scheme-langserver-root-directory}</code></p>
<pre><code class="language-bash">bash test.sh
</code></pre>
<blockquote>
<p>UWAGA
Trudno jest testować w środowisku wielowątkowym. Dlatego obecne testy skupiają się na jednym wątku.</p>
</blockquote>
<h2>Użycie Scheme-langserver do innych celów</h2>
<h3>Script-Fu w GIMP</h3>
<p>Script-Fu opiera się na interpretowanym języku Scheme i działa poprzez używanie funkcji, które współpracują z wewnętrznymi funkcjami GIMP-a. Na przykładzie skryptu z <a href="https://dalelane.co.uk/blog/?p=628">tej strony</a>, możesz użyć scheme-langserver z plikiem skryptu o rozszerzeniu &quot;SCM&quot;.</p>
<h3>Inne</h3>
<p>Ciekawi mnie także <a href="https://opusmodus.com/">OMN (Opusmodus Notation)</a> i AutoLisp. Ale mam jeszcze wiele do zrobienia.</p>
<h2>Liczenie kodu</h2>
<pre><code class="language-bash">find . -name &quot;*.sls&quot; ! -path &quot;./.akku/*&quot; |xargs wc -l
</code></pre>
<h2>Szczegółowa dokumentacja</h2>
<ol>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/paper.pdf">Scheme-langserver: Traktowanie edycji kodu Scheme jako priorytetu</a>.</li>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/analysis/identifier.md">Wychwytywanie powiązań identyfikatorów</a></li>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/util/synchronize.md">Synchronizacja</a></li>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/analysis/type-inference.md">Wnioskowanie typów</a>,~~<a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/analysis/type-inference.cn.md">类型推断</a>~~(Przestarzałe, pracuję nad książką po chińsku na ten temat)</li>
<li><a href="https://raw.githubusercontent.com/ufo5260987423/scheme-langserver/main/./doc/protocol/analysis.md">Analiza API</a></li>
<li><a href="https://deepwiki.com/ufo5260987423/scheme-langserver">Deepwiki</a></li>
</ol>
<h2>Historia gwiazdek</h2>
<p><a href="https://star-history.com/#ufo5260987423/scheme-langserver"><img src="https://api.star-history.com/svg?repos=ufo5260987423/scheme-langserver&amp;type=Date" alt="Star History Chart" /></a></p>
<h2>Współtwórcy</h2>
<p><img src="https://contrib.rocks/image?repo=ufo5260987423/scheme-langserver" alt="Contributors" /></p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-07-01</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>