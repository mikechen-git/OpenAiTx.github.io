<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>proposal-signals - tc39/proposal-signals pt</title>
    <meta name="title" content="proposal-signals - tc39/proposal-signals pt | 🚦 Proposta padrão de Signals em JavaScript 🚦 Stage 1 (explicação) Proponentes da proposta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, K...">
    <meta name="description" content="tc39/proposal-signals - GitHub repository pt documentation and information | 🚦 Proposta padrão de Signals em JavaScript 🚦 Stage 1 (explicação) Proponentes da proposta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, K...">
    <meta name="keywords" content="tc39, proposal-signals, GitHub, repository, pt documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/tc39/proposal-signals/README-pt.html">
    <meta property="og:title" content="proposal-signals - tc39/proposal-signals pt | 🚦 Proposta padrão de Signals em JavaScript 🚦 Stage 1 (explicação) Proponentes da proposta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, K...">
    <meta property="og:description" content="tc39/proposal-signals - GitHub repository pt documentation and information | 🚦 Proposta padrão de Signals em JavaScript 🚦 Stage 1 (explicação) Proponentes da proposta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, K...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/tc39/proposal-signals" id="githubRepoLink" target="_blank">tc39/proposal-signals</a>
<h1 style="display: none;">🚦 Proposta padrão de Signals em JavaScript 🚦 Stage 1 (explicação) Proponentes da proposta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, K...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>🚦 Proposta padrão de Signals em JavaScript 🚦</h1>
<img align=right src="https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg" alt="Signals logo" width=100>
<p>Stage 1 (<a href="https://tc39.es/process-document/">explicação</a>)</p>
<p>Proponentes da proposta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg</p>
<p>Autores originais: Rob Eisenberg e Daniel Ehrenberg</p>
<p>Este documento descreve uma direção inicial comum para signals em JavaScript, similar ao esforço Promises/A+ que precedeu as Promises padronizadas pelo TC39 no ES2015. Experimente você mesmo, usando <a href="https://github.com/proposal-signals/signal-polyfill">um polyfill</a>.</p>
<p>De forma semelhante ao Promises/A+, este esforço foca em alinhar o ecossistema JavaScript. Se esse alinhamento for bem-sucedido, então um padrão poderá surgir, baseado nessa experiência. Diversos autores de frameworks estão colaborando aqui em um modelo comum que pode dar suporte ao núcleo de reatividade deles. O rascunho atual é baseado no design e contribuições de autores/maintainers do <a href="https://angular.io/">Angular</a>, <a href="https://bubble.io/">Bubble</a>, <a href="https://emberjs.com/">Ember</a>, <a href="https://www.fast.design/">FAST</a>, <a href="https://mobx.js.org/">MobX</a>, <a href="https://preactjs.com/">Preact</a>, <a href="https://qwik.dev/">Qwik</a>, <a href="https://rxjs.dev/">RxJS</a>, <a href="https://www.solidjs.com/">Solid</a>, <a href="https://www.starbeamjs.com/">Starbeam</a>, <a href="https://svelte.dev/">Svelte</a>, <a href="https://vuejs.org/">Vue</a>, <a href="https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a">Wiz</a>, e mais…</p>
<p>Diferente do Promises/A+, não estamos tentando resolver uma API comum voltada para desenvolvedores, mas sim as semânticas centrais precisas do grafo de signals subjacente. Esta proposta inclui uma API totalmente concreta, mas a API não é direcionada à maioria dos desenvolvedores de aplicações. Em vez disso, a API de signals aqui apresentada é mais adequada para que frameworks construam sobre ela, proporcionando interoperabilidade por meio de um grafo de signals comum e mecanismo de rastreamento automático.</p>
<p>O plano para esta proposta é realizar prototipação inicial significativa, incluindo integração em vários frameworks, antes de avançar além do Stage 1. Só estamos interessados em padronizar Signals se eles forem adequados para uso prático em múltiplos frameworks e proporcionarem benefícios reais em relação aos signals fornecidos pelos frameworks. Esperamos que uma prototipação inicial significativa nos forneça essas informações. Veja &quot;Status e plano de desenvolvimento&quot; abaixo para mais detalhes.</p>
<h2>Contexto: Por que Signals?</h2>
<p>Para desenvolver uma interface de usuário (UI) complicada, desenvolvedores de aplicações JavaScript precisam armazenar, calcular, invalidar, sincronizar e enviar estado para a camada de visualização da aplicação de maneira eficiente. UIs normalmente envolvem mais do que apenas gerenciar valores simples, frequentemente incluindo a renderização de estado computado que depende de uma árvore complexa de outros valores ou estados que também são computados. O objetivo dos Signals é fornecer infraestrutura para gerenciar tal estado de aplicação, permitindo que desenvolvedores foquem na lógica de negócio ao invés desses detalhes repetitivos.</p>
<p>Construtos semelhantes a signals têm sido considerados úteis de forma independente também em contextos não relacionados a UI, especialmente em sistemas de build para evitar rebuilds desnecessários.</p>
<p>Signals são usados em programação reativa para eliminar a necessidade de gerenciar atualizações em aplicações.</p>
<blockquote>
<p>Um modelo de programação declarativo para atualização com base em mudanças de estado.</p>
</blockquote>
<p>de <em><a href="https://www.pzuraq.com/blog/what-is-reactivity">What is Reactivity?</a></em>.</p>
<h4>Exemplo - Um Contador em VanillaJS</h4>
<p>Dado uma variável, <code>counter</code>, você deseja renderizar no DOM se o contador é par ou ímpar. Sempre que o <code>counter</code> muda, você quer atualizar o DOM com a última paridade. Em Vanilla JS, você poderia ter algo assim:</p>
<pre><code class="language-js">let counter = 0;
const setCounter = (value) =&gt; {
  counter = value;
  render();
};

const isEven = () =&gt; (counter &amp; 1) == 0;
const parity = () =&gt; isEven() ? &quot;even&quot; : &quot;odd&quot;;
const render = () =&gt; element.innerText = parity();

// Simular atualizações externas ao counter...
setInterval(() =&gt; setCounter(counter + 1), 1000);
</code></pre>
<blockquote>
<p>[!NOTE]<br />
Globais são usados aqui apenas para fins de demonstração. O gerenciamento adequado de estado possui muitas soluções, e os exemplos nesta proposta têm a intenção de ser o mais mínimos possível. Esta proposta não incentiva o uso de variáveis globais.</p>
</blockquote>
<p>Isto possui vários problemas...</p>
<ul>
<li>A configuração do <code>counter</code> é barulhenta e cheia de boilerplate.</li>
<li>O estado de <code>counter</code> está fortemente acoplado ao sistema de renderização.</li>
<li>Se o <code>counter</code> muda, mas <code>parity</code> não (por exemplo, o contador vai de 2 para 4), então fazemos uma computação de paridade desnecessária e renderização desnecessária.</li>
<li>E se outra parte da nossa UI quiser apenas renderizar quando o <code>counter</code> for atualizado?</li>
<li>E se outra parte da nossa UI depender apenas de <code>isEven</code> ou <code>parity</code>?</li>
</ul>
<p>Mesmo neste cenário relativamente simples, diversos problemas surgem rapidamente. Poderíamos tentar contornar isso introduzindo pub/sub para o <code>counter</code>. Isso permitiria que consumidores adicionais do <code>counter</code> pudessem se inscrever para adicionar suas próprias reações às mudanças de estado.</p>
<p>No entanto, ainda estamos presos aos seguintes problemas:</p>
<ul>
<li>A função de renderização, que depende apenas de <code>parity</code>, deve &quot;saber&quot; que, na verdade, precisa se inscrever no <code>counter</code>.</li>
<li>Não é possível atualizar a UI com base apenas em <code>isEven</code> ou <code>parity</code>, sem interagir diretamente com <code>counter</code>.</li>
<li>Aumentamos nosso boilerplate. Sempre que você está usando algo, não é apenas uma questão de chamar uma função ou ler uma variável, mas sim de se inscrever e fazer atualizações ali. Gerenciar a desinscrição também é especialmente complicado.</li>
</ul>
<p>Agora, poderíamos resolver alguns problemas adicionando pub/sub não apenas ao <code>counter</code>, mas também ao <code>isEven</code> e ao <code>parity</code>. Teríamos então que inscrever <code>isEven</code> no <code>counter</code>, <code>parity</code> em <code>isEven</code>, e <code>render</code> em <code>parity</code>. Infelizmente, não apenas nosso código boilerplate aumentou muito, mas também estamos presos a uma tonelada de gerenciamento de inscrições, e um potencial desastre de vazamento de memória se não limpamos tudo corretamente. Portanto, resolvemos alguns problemas, mas criamos toda uma nova categoria de problemas e muito código. Para piorar, temos que passar por todo esse processo para cada pedaço de estado em nosso sistema.</p>
<h3>Apresentando Signals</h3>
<p>Abstrações de data binding em UIs para o modelo e a visualização há muito tempo são centrais para frameworks de UI em diversas linguagens de programação, apesar da ausência de qualquer mecanismo desse tipo embutido no JS ou na plataforma web. Dentro de frameworks e bibliotecas JS, houve muita experimentação em diferentes maneiras de representar esse binding, e a experiência mostrou o poder do fluxo de dados unidirecional em conjunto com um tipo de dado de primeira classe representando uma célula de estado ou computação derivada de outros dados, agora frequentemente chamado de &quot;Signals&quot;.
Essa abordagem de valor reativo de primeira classe parece ter feito sua primeira aparição popular em frameworks web JavaScript de código aberto com o <a href="https://knockoutjs.com/">Knockout</a> <a href="https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/">em 2010</a>. Nos anos seguintes, muitas variações e implementações foram criadas. Nos últimos 3-4 anos, o primitivo Signal e abordagens relacionadas ganharam ainda mais força, com praticamente todas as bibliotecas ou frameworks modernos de JavaScript tendo algo similar, sob um nome ou outro.</p>
<p>Para entender Signals, vejamos o exemplo acima, reimaginado com uma API de Signal mais detalhada abaixo.</p>
<h4>Exemplo - Um Contador com Signals</h4>
<pre><code class="language-js">const counter = new Signal.State(0);
const isEven = new Signal.Computed(() =&gt; (counter.get() &amp; 1) == 0);
const parity = new Signal.Computed(() =&gt; isEven.get() ? &quot;even&quot; : &quot;odd&quot;);

// Uma biblioteca ou framework define efeitos com base em outros primitives de Signal
declare function effect(cb: () =&gt; void): (() =&gt; void);

effect(() =&gt; element.innerText = parity.get());

// Simular atualizações externas ao counter...
setInterval(() =&gt; counter.set(counter.get() + 1), 1000);
</code></pre>
<p>Há algumas coisas que podemos perceber imediatamente:</p>
<ul>
<li>Eliminamos o boilerplate barulhento em torno da variável <code>counter</code> do nosso exemplo anterior.</li>
<li>Existe uma API unificada para lidar com valores, computações e efeitos colaterais.</li>
<li>Não há problema de referência circular ou dependências invertidas entre <code>counter</code> e <code>render</code>.</li>
<li>Não há inscrições manuais, nem necessidade de gerenciamento.</li>
<li>Existe um meio de controlar o tempo/agendamento de efeitos colaterais.</li>
</ul>
<p>Signals nos oferecem muito mais do que pode ser visto superficialmente na API:</p>
<ul>
<li><strong>Rastreamento Automático de Dependências</strong> - Um Signal computado descobre automaticamente quaisquer outros Signals dos quais depende, sejam esses Signals valores simples ou outros cálculos.</li>
<li><strong>Avaliação Preguiçosa (Lazy Evaluation)</strong> - Os cálculos não são avaliados de forma ávida quando são declarados, nem são imediatamente avaliados quando suas dependências mudam. Eles só são avaliados quando seu valor é explicitamente solicitado.</li>
<li><strong>Memoização</strong> - Signals computados armazenam em cache seu último valor para que cálculos cujas dependências não mudaram não precisem ser reavaliados, não importa quantas vezes sejam acessados.</li>
</ul>
<h2>Motivação para padronizar Signals</h2>
<h4>Interoperabilidade</h4>
<p>Cada implementação de Signal tem seu próprio mecanismo de rastreamento automático, para acompanhar as fontes encontradas ao avaliar um Signal computado. Isso dificulta o compartilhamento de modelos, componentes e bibliotecas entre diferentes frameworks--eles tendem a vir com um falso acoplamento ao seu mecanismo de visualização (visto que Signals geralmente são implementados como parte de frameworks JS).</p>
<p>Um objetivo desta proposta é desacoplar totalmente o modelo reativo da visualização de renderização, permitindo que desenvolvedores migrem para novas tecnologias de renderização sem reescrever seu código não relacionado à interface, ou desenvolvam modelos reativos compartilhados em JS para serem implantados em diferentes contextos. Infelizmente, devido a versionamento e duplicidade, revelou-se impraticável alcançar um forte nível de compartilhamento via bibliotecas em JS--os built-ins oferecem uma garantia de compartilhamento mais forte.</p>
<h4>Desempenho/Uso de memória</h4>
<p>Sempre há um pequeno potencial de ganho de desempenho ao embarcar menos código devido a bibliotecas comumente usadas serem internas, mas as implementações de Signals geralmente são bastante pequenas, então não esperamos que esse efeito seja muito grande.</p>
<p>Suspeitamos que implementações nativas em C++ das estruturas de dados e algoritmos relacionados a Signal possam ser ligeiramente mais eficientes do que o que é possível em JS, por um fator constante. No entanto, não são antecipadas mudanças algorítmicas em relação ao que estaria presente em um polyfill; não se espera que os engines sejam mágicos aqui, e os próprios algoritmos de reatividade serão bem definidos e inequívocos.</p>
<p>O grupo responsável espera desenvolver várias implementações de Signals e usá-las para investigar essas possibilidades de desempenho.</p>
<h4>DevTools</h4>
<p>Com as bibliotecas de Signal existentes em JS, pode ser difícil rastrear coisas como:</p>
<ul>
<li>A stack de chamadas através de uma cadeia de Signals computados, mostrando a cadeia causal para um erro</li>
<li>O grafo de referências entre Signals, quando um depende de outro -- importante ao depurar uso de memória</li>
</ul>
<p>Signals embutidos permitem que runtimes JS e DevTools tenham potencialmente um suporte aprimorado para inspecionar Signals, particularmente para depuração ou análise de desempenho, seja isso integrado aos navegadores ou por meio de uma extensão compartilhada. Ferramentas existentes como o inspetor de elementos, snapshot de desempenho e analisadores de memória poderiam ser atualizados para destacar especificamente Signals em sua apresentação de informações.</p>
<h4>Benefícios secundários</h4>
<h5>Benefícios de uma biblioteca padrão</h5>
<p>Em geral, o JavaScript tem uma biblioteca padrão relativamente mínima, mas uma tendência no TC39 tem sido tornar o JS uma linguagem mais &quot;baterias incluídas&quot;, com um conjunto de funcionalidades internas e de alta qualidade disponível. Por exemplo, Temporal está substituindo o moment.js, e vários recursos pequenos, como <code>Array.prototype.flat</code> e <code>Object.groupBy</code>, estão substituindo muitos casos de uso do lodash. Os benefícios incluem tamanhos de bundle menores, maior estabilidade e qualidade, menos para aprender ao entrar em um novo projeto, e um vocabulário geralmente comum entre desenvolvedores JS.</p>
<h5>Integração HTML/DOM (possibilidade futura)</h5>
<p>Trabalhos atuais no W3C e por implementadores de navegadores buscam trazer templating nativo para HTML (<a href="https://github.com/WICG/webcomponents/pull/1023">DOM Parts</a> e <a href="https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md">Template Instantiation</a>). Além disso, o W3C Web Components CG está explorando a possibilidade de estender Web Components para oferecer uma API HTML totalmente declarativa. Para alcançar ambos os objetivos, eventualmente será necessário um primitivo reativo no HTML. Além disso, muitas melhorias ergonômicas no DOM por meio da integração de Signals podem ser imaginadas e já foram solicitadas pela comunidade.</p>
<blockquote>
<p>Nota: essa integração seria um esforço separado para o futuro, não faz parte desta proposta em si.</p>
</blockquote>
<h5>Troca de informações no ecossistema (<em>não</em> é motivo para embarcar)</h5>
<p>Esforços de padronização às vezes podem ser úteis apenas no nível da &quot;comunidade&quot;, mesmo sem mudanças nos navegadores. O esforço dos Signals está reunindo muitos autores de frameworks diferentes para uma discussão profunda sobre a natureza da reatividade, algoritmos e interoperabilidade. Isso já tem sido útil, mas não justifica a inclusão em engines JS e navegadores; Signals só devem ser adicionados ao padrão JavaScript se houver benefícios significativos <em>além</em> da troca de informações do ecossistema viabilizada.</p>
<h2>Objetivos de design para Signals</h2>
<p>Acontece que as bibliotecas de Signal existentes não são tão diferentes umas das outras, em sua essência. Esta proposta visa se apoiar em seu sucesso, implementando as qualidades importantes de muitas dessas bibliotecas.</p>
<h3>Funcionalidades principais</h3>
<ul>
<li>Um tipo Signal que representa estado, ou seja, Signal gravável. Este é um valor que outros podem ler.</li>
<li>Um tipo Signal computado/memo/derivado, que depende de outros e é calculado de forma preguiçosa e armazenado em cache.
<ul>
<li>O cálculo é preguiçoso, ou seja, Signals computados não são calculados novamente por padrão quando uma de suas dependências muda, mas apenas executados se alguém realmente os ler.</li>
<li>O cálculo é &quot;<a href="https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_reativa#Glitches">livre de glitches</a>&quot;, ou seja, nenhum cálculo desnecessário é realizado. Isso implica que, quando uma aplicação lê um Signal computado, há uma ordenação topológica das partes potencialmente sujas do grafo a serem executadas, para eliminar duplicatas.</li>
<li>O cálculo é armazenado em cache, ou seja, se, após a última vez que uma dependência mudou, nenhuma dependência mudou, então o Signal computado <em>não</em> é recalculado ao ser acessado.</li>
<li>Comparações personalizadas são possíveis tanto para Signals computados quanto para Signals de estado, para indicar quando outros Signals computados que dependem deles devem ser atualizados.</li>
</ul>
</li>
<li>Reações à condição em que um Signal computado tem uma de suas dependências (ou dependências aninhadas) tornando-se &quot;suja&quot; e mudando, significando que o valor do Signal pode estar desatualizado.
<ul>
<li>Esta reação serve para agendar trabalhos mais significativos a serem realizados posteriormente.</li>
<li>Efeitos são implementados em termos dessas reações, mais agendamento em nível de framework.</li>
<li>Signals computados precisam da capacidade de reagir a serem registrados como uma dependência (aninhada) de uma dessas reações.</li>
</ul>
</li>
<li>Permitir que frameworks JS façam seu próprio agendamento. Nenhum agendamento embutido obrigatório no estilo Promise.
<ul>
<li>Reações síncronas são necessárias para permitir o agendamento de trabalho posterior com base na lógica do framework.</li>
<li>Escritas são síncronas e têm efeito imediato (um framework que faz batch das escritas pode implementar isso por cima).</li>
<li>É possível separar a verificação se um efeito pode estar &quot;sujo&quot; de realmente rodar o efeito (permitindo um agendador de efeitos em dois estágios).</li>
</ul>
</li>
<li>Capacidade de ler Signals <em>sem</em> acionar o registro de dependências (<code>untrack</code>)</li>
<li>Possibilitar a composição de diferentes bases de código que usam Signals/reatividade, por exemplo,
<ul>
<li>Usar múltiplos frameworks juntos no que diz respeito ao rastreamento/reatividade em si (com ressalvas, veja abaixo)</li>
<li>Estruturas de dados reativas independentes de framework (por exemplo, proxy de store recursivamente reativo, Map e Set e Array reativos, etc.)</li>
</ul>
</li>
</ul>
<h3>Solidez</h3>
<ul>
<li>Desencorajar/proibir o uso ingênuo de reações síncronas.
<ul>
<li>Risco de solidez: pode expor &quot;<a href="https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_reativa#Glitches">glitches</a>&quot; se usado de forma inadequada: Se a renderização for feita imediatamente quando um Signal é definido, pode expor um estado de aplicação incompleto para o usuário final. Portanto, esse recurso deve ser usado apenas para agendar trabalho de forma inteligente para depois que a lógica da aplicação estiver concluída.</li>
<li>Solução: Proibir leitura e escrita de qualquer Signal de dentro de um callback de reação síncrona.</li>
</ul>
</li>
<li>Desencorajar <code>untrack</code> e marcar sua natureza não sólida
<ul>
<li>Risco de solidez: permite a criação de Signals computados cujo valor depende de outros Signals, mas que não são atualizados quando esses Signals mudam. Deve ser usado quando os acessos não rastreados não mudam o resultado do cálculo.</li>
<li>Solução: A API é marcada como &quot;unsafe&quot; no nome.</li>
</ul>
</li>
<li>Nota: Esta proposta permite que signals sejam lidos e escritos tanto de signals computados quanto de efeito, sem restringir escritas que venham após leituras, apesar do risco para a solidez. Essa decisão foi tomada para preservar flexibilidade e compatibilidade na integração com frameworks.</li>
</ul>
<h3>API de superfície</h3>
<ul>
<li>Deve ser uma base sólida para múltiplos frameworks implementarem seus mecanismos de Signals/reatividade.
<ul>
<li>Deve ser uma boa base para proxies de store recursivos, reatividade baseada em decoradores em campos de classe, e APIs tanto no estilo <code>.value</code> quanto <code>[state, setState]</code>.</li>
<li>A semântica é capaz de expressar os padrões válidos habilitados por diferentes frameworks. Por exemplo, deve ser possível que esses Signals sejam a base de escritas refletidas imediatamente ou escritas que são agrupadas e aplicadas posteriormente.</li>
</ul>
</li>
<li>Seria interessante se essa API fosse utilizável diretamente por desenvolvedores JavaScript.
<ul>
<li>Se um recurso se alinha com um conceito do ecossistema, usar o vocabulário comum é bom.
<ul>
<li>Contudo, é importante não literalmente copiar exatamente os mesmos nomes!</li>
</ul>
</li>
<li>Tensão entre &quot;usabilidade por devs JS&quot; e &quot;oferecer todos os ganchos para frameworks&quot;
<ul>
<li>Ideia: Oferecer todos os ganchos, mas incluir erros quando usados de forma inadequada, se possível.</li>
<li>Ideia: Colocar APIs sutis em um namespace <code>subtle</code>, semelhante ao <a href="https://developer.mozilla.org/pt-BR/docs/Web/API/Crypto/subtle"><code>crypto.subtle</code></a>, para marcar a linha entre APIs necessárias para uso avançado como implementação de frameworks ou ferramentas de dev versus uso cotidiano como instanciar signals para uso com um framework.</li>
</ul>
</li>
</ul>
</li>
<li>Ser implementável e utilizável com bom desempenho -- a API de superfície não causa overhead excessivo
<ul>
<li>Permitir subclassificação, para que frameworks possam adicionar seus próprios métodos e campos, incluindo campos privados. Isso é importante para evitar a necessidade de alocações adicionais no nível do framework. Veja &quot;Gerenciamento de memória&quot; abaixo.</li>
</ul>
</li>
</ul>
<h3>Gerenciamento de memória</h3>
<ul>
<li>Se possível: Um Signal computado deve ser coletável pelo garbage collector se nada vivo estiver referenciando-o para leituras futuras possíveis, mesmo que ele esteja ligado em um grafo mais amplo que permaneça vivo (por exemplo, lendo um estado que permanece vivo).</li>
<li>Observe que a maioria dos frameworks atualmente exige o descarte explícito de Signals computados se eles tiverem qualquer referência para ou de outro grafo de Signal que permaneça ativo.</li>
<li>Isso acaba não sendo tão ruim quando sua vida útil está atrelada à vida útil de um componente de UI, e efeitos precisam ser descartados de qualquer forma.</li>
<li>Se for muito caro executar com essa semântica, então devemos adicionar descarte explícito (ou &quot;desvinculação&quot;) de Signals computados à API abaixo, que atualmente não possui isso.</li>
<li>Um objetivo relacionado separado: Minimizar o número de alocações, por exemplo,
<ul>
<li>para criar um Signal gravável (evitar dois closures separados + array)</li>
<li>para implementar efeitos (evitar um closure para cada reação individual)</li>
<li>Na API para observar mudanças de Signal, evitar a criação de estruturas de dados temporárias adicionais</li>
<li>Solução: API baseada em classes permitindo o reuso de métodos e campos definidos em subclasses</li>
</ul>
</li>
</ul>
<h2>Esboço da API</h2>
<p>Uma ideia inicial de uma API de Signal está abaixo. Observe que este é apenas um rascunho inicial e antecipamos mudanças ao longo do tempo. Vamos começar com o <code>.d.ts</code> completo para ter uma ideia do formato geral e, em seguida, discutiremos os detalhes do que tudo isso significa.</p>
<pre><code class="language-ts">interface Signal&lt;T&gt; {
    // Obtém o valor do signal
    get(): T;
}

namespace Signal {
    // Um Signal de leitura e escrita
    class State&lt;T&gt; implements Signal&lt;T&gt; {
        // Cria um Signal de estado iniciando com o valor t
        constructor(t: T, options?: SignalOptions&lt;T&gt;);

        // Obtém o valor do signal
        get(): T;

        // Define o valor do Signal de estado para t
        set(t: T): void;
    }

    // Um Signal que é uma fórmula baseada em outros Signals
    class Computed&lt;T = unknown&gt; implements Signal&lt;T&gt; {
        // Cria um Signal que avalia para o valor retornado pelo callback.
        // O callback é chamado com este signal como valor de this.
        constructor(cb: (this: Computed&lt;T&gt;) =&gt; T, options?: SignalOptions&lt;T&gt;);

        // Obtém o valor do signal
        get(): T;
    }

    // Este namespace inclui recursos &quot;avançados&quot; que são melhores
    // deixar para autores de frameworks ao invés de desenvolvedores de aplicações.
    // Análogo a `crypto.subtle`
    namespace subtle {
        // Executa um callback com todo rastreamento desabilitado
        function untrack&lt;T&gt;(cb: () =&gt; T): T;

        // Obtém o signal computado atual que está rastreando leituras de qualquer signal, se houver
        function currentComputed(): Computed | null;

        // Retorna a lista ordenada de todos os signals que este referenciou
        // durante a última vez em que foi avaliado.
        // Para um Watcher, lista o conjunto de signals que ele está observando.
        function introspectSources(s: Computed | Watcher): (State | Computed)[];

        // Retorna os Watchers nos quais este signal está contido, além de quaisquer
        // Signals Computed que leram este signal da última vez em que foram avaliados,
        // se esse signal computed está (recursivamente) sendo observado.
        function introspectSinks(s: State | Computed): (Computed | Watcher)[];

        // Verdadeiro se este signal está &quot;ativo&quot;, ou seja, está sendo observado por um Watcher,
        // ou é lido por um signal Computed que está (recursivamente) ativo.
        function hasSinks(s: State | Computed): boolean;

        // Verdadeiro se este elemento é &quot;reativo&quot;, ou seja, depende
        // de algum outro signal. Um Computed onde hasSources é falso
        // sempre retornará a mesma constante.
        function hasSources(s: Computed | Watcher): boolean;

        class Watcher {
            // Quando uma fonte (recursiva) do Watcher é escrita, chama este callback,
            // se ainda não foi chamado desde a última chamada de `watch`.
            // Nenhum signal pode ser lido ou escrito durante o notify.
            constructor(notify: (this: Watcher) =&gt; void);

            // Adiciona estes signals ao conjunto do Watcher e define o watcher para executar seu
            // callback notify na próxima vez que qualquer signal do conjunto (ou um de seus dependentes) mudar.
            // Pode ser chamado sem argumentos apenas para redefinir o estado &quot;notificado&quot;, para que
            // o callback notify seja invocado novamente.
            watch(...s: Signal[]): void;

            // Remove estes signals do conjunto observado (ex.: para um efeito que foi descartado)
            unwatch(...s: Signal[]): void;

            // Retorna o conjunto de fontes no conjunto do Watcher que ainda estão sujas, ou é um signal computed
            // com uma fonte que está suja ou pendente e ainda não foi reavaliada
            getPending(): Signal[];
        }

        // Hooks para observar quando está sendo observado ou deixou de ser observado
        var watched: Symbol;
        var unwatched: Symbol;
    }

    interface SignalOptions&lt;T&gt; {
        // Função de comparação personalizada entre o valor antigo e o novo. Padrão: Object.is.
        // O signal é passado como valor de this para contexto.
        equals?: (this: Signal&lt;T&gt;, t: T, t2: T) =&gt; boolean;
```ts
// Callback chamado quando isWatched se torna verdadeiro, se anteriormente era falso
[Signal.subtle.watched]?: (this: Signal&lt;T&gt;) =&gt; void;

// Callback chamado sempre que isWatched se torna falso, se anteriormente era verdadeiro
[Signal.subtle.unwatched]?: (this: Signal&lt;T&gt;) =&gt; void;
}
}
</code></pre>
<h3>Como funcionam os Signals</h3>
<p>Um Signal representa uma célula de dados que pode mudar ao longo do tempo. Signals podem ser do tipo &quot;state&quot; (apenas um valor definido manualmente) ou &quot;computed&quot; (uma fórmula baseada em outros Signals).</p>
<p>Signals computados funcionam rastreando automaticamente quais outros Signals são lidos durante sua avaliação. Quando um computed é lido, ele verifica se alguma de suas dependências registradas anteriormente mudou e se reavalia se for o caso. Quando múltiplos Signals computados são aninhados, toda a atribuição do rastreamento vai para o mais interno deles.</p>
<p>Signals computados são lazy, ou seja, baseados em pull: eles só são reavaliados quando são acessados, mesmo que uma de suas dependências tenha mudado antes.</p>
<p>O callback passado para Signals computados geralmente deve ser &quot;puro&quot;, no sentido de ser uma função determinística e sem efeitos colaterais dos outros Signals que acessa. Ao mesmo tempo, o momento em que o callback é chamado é determinístico, permitindo que efeitos colaterais sejam usados com cuidado.</p>
<p>Signals possuem cache/memoização proeminente: tanto Signals de state quanto computados lembram seu valor atual, e só disparam recálculo de Signals computados que os referenciam se eles realmente mudarem. Uma comparação repetida entre valores antigos e novos nem é necessária—a comparação é feita uma vez quando o Signal fonte é redefinido/reavaliado, e o mecanismo do Signal mantém o controle de quais entidades que referenciam aquele Signal ainda não atualizaram com base no novo valor. Internamente, isso geralmente é representado por &quot;graph coloring&quot;, como descrito no <a href="https://raw.githubusercontent.com/tc39/proposal-signals/main/Milo%27s%20blog%20post">post do blog do Milo</a>.</p>
<p>Signals computados rastreiam suas dependências dinamicamente—cada vez que são executados, podem acabar dependendo de coisas diferentes, e esse conjunto de dependências preciso é mantido atualizado no grafo de Signals. Isso significa que, se você tem uma dependência necessária em apenas um ramo, e o cálculo anterior tomou o outro ramo, então uma mudança nesse valor temporariamente não usado não fará com que o Signal computado seja recalculado, mesmo quando acessado.</p>
<p>Diferente de Promises do JavaScript, tudo em Signals é executado de forma síncrona:</p>
<ul>
<li>Definir um Signal para um novo valor é síncrono, e isso é refletido imediatamente ao ler qualquer Signal computado que dependa dele em seguida. Não há agrupamento/batching embutido nessa mutação.</li>
<li>Ler Signals computados é síncrono—seu valor está sempre disponível.</li>
<li>O callback <code>notify</code> em Watchers, como explicado abaixo, roda de forma síncrona, durante a chamada <code>.set()</code> que o disparou (mas após a coloração do grafo estar completa).</li>
</ul>
<p>Como as Promises, Signals podem representar um estado de erro: se o callback de um Signal computado lançar uma exceção, esse erro é armazenado em cache como qualquer outro valor, e relançado toda vez que o Signal é lido.</p>
<h3>Entendendo a classe Signal</h3>
<p>Uma instância de <code>Signal</code> representa a capacidade de ler um valor que muda dinamicamente e cujas atualizações são rastreadas ao longo do tempo. Ela também implicitamente inclui a capacidade de se inscrever no Signal, implicitamente por meio de um acesso rastreado de outro Signal computado.</p>
<p>A API aqui foi desenhada para corresponder ao consenso da comunidade entre grande parte das bibliotecas de Signal no uso de nomes como &quot;signal&quot;, &quot;computed&quot; e &quot;state&quot;. Entretanto, o acesso a Signals Computados e de State é feito por meio do método <code>.get()</code>, o que difere de todas as APIs populares de Signal, que usam um acessor <code>.value</code> ou sintaxe de chamada <code>signal()</code>.</p>
<p>A API é projetada para reduzir o número de alocações, tornando Signals adequados para serem incorporados em frameworks JavaScript, alcançando desempenho igual ou melhor que Signals personalizados de frameworks existentes. Isso implica:</p>
<ul>
<li>Signals de State são um único objeto gravável, que pode ser tanto acessado quanto definido a partir da mesma referência. (Veja implicações abaixo na seção &quot;Separação de capacidades&quot;.)</li>
<li>Tanto Signals de State quanto Computados são projetados para serem subclassificados, facilitando que frameworks adicionem propriedades adicionais por meio de campos de classe públicos e privados (bem como métodos para usar esse estado).</li>
<li>Vários callbacks (por exemplo, <code>equals</code>, o callback de computed) são chamados com o Signal relevante como valor de <code>this</code> para contexto, de modo que não é necessário criar um novo closure por Signal. Em vez disso, o contexto pode ser salvo em propriedades extras do próprio Signal.</li>
</ul>
<p>Algumas condições de erro aplicadas por esta API:</p>
<ul>
<li>É um erro ler um computed recursivamente.</li>
<li>O callback <code>notify</code> de um Watcher não pode ler nem escrever nenhum signal.</li>
<li>Se o callback de um Signal computado lançar uma exceção, acessos subsequentes ao Signal relançam esse erro armazenado em cache, até que uma das dependências mude e ele seja recalculado.</li>
</ul>
<p>Algumas condições que <em>não</em> são aplicadas:</p>
<ul>
<li>Signals Computados podem escrever em outros Signals, de forma síncrona dentro do seu callback.</li>
<li>Trabalhos enfileirados pelo callback <code>notify</code> de um Watcher podem ler ou escrever signals, tornando possível replicar <a href="https://react.dev/learn/you-might-not-need-an-effect">antipadrões clássicos do React</a> em termos de Signals!</li>
</ul>
<h3>Implementando efeitos</h3>
<p>A interface <code>Watcher</code> definida acima dá a base para implementar APIs JS típicas para efeitos: callbacks que são executados novamente quando outros Signals mudam, apenas por seu efeito colateral. A função <code>effect</code> usada acima no exemplo inicial pode ser definida da seguinte forma:</p>
<pre><code class="language-ts">// Esta função normalmente viveria em uma biblioteca/framework, não no código da aplicação
// NOTA: Esta lógica de agendamento é básica demais para ser útil. Não copie/cole.
let pending = false;

let w = new Signal.subtle.Watcher(() =&gt; {
    if (!pending) {
        pending = true;
        queueMicrotask(() =&gt; {
            pending = false;
            for (let s of w.getPending()) s.get();
            w.watch();
        });
    }
});

// Um Signal effect que avalia cb, que agenda uma leitura de
// si mesmo na fila de microtarefas sempre que uma de suas dependências pode mudar
export function effect(cb) {
    let destructor;
    let c = new Signal.Computed(() =&gt; { destructor?.(); destructor = cb(); });
    w.watch(c);
    c.get();
    return () =&gt; { destructor?.(); w.unwatch(c) };
}
</code></pre>
<p>A API do Signal não inclui nenhuma função embutida como <code>effect</code>. Isso ocorre porque o agendamento de efeitos é sutil e frequentemente se integra aos ciclos de renderização do framework e a outros estados ou estratégias específicas de frameworks de alto nível aos quais o JS não tem acesso.</p>
<p>Percorrendo as diferentes operações usadas aqui: o callback <code>notify</code> passado ao construtor de <code>Watcher</code> é a função chamada quando o Signal vai de um estado &quot;clean&quot; (onde sabemos que o cache está inicializado e válido) para um estado &quot;checked&quot; ou &quot;dirty&quot; (onde o cache pode ou não ser válido porque pelo menos um dos estados dos quais depende recursivamente foi alterado).</p>
<p>Chamadas a <code>notify</code> são, em última instância, disparadas por uma chamada a <code>.set()</code> em algum Signal de state. Essa chamada é síncrona: acontece antes de <code>.set</code> retornar. Mas não há necessidade de se preocupar com esse callback observando o grafo de Signal em um estado parcialmente processado, porque durante um callback <code>notify</code>, nenhum Signal pode ser lido ou escrito, mesmo em uma chamada <code>untrack</code>. Como <code>notify</code> é chamado durante <code>.set()</code>, ele interrompe outro fluxo de lógica, que pode não estar completo. Para ler ou escrever Signals a partir de <code>notify</code>, agende o trabalho para rodar depois, por exemplo, escrevendo o Signal em uma lista para ser acessado posteriormente, ou com <code>queueMicrotask</code> como acima.</p>
<p>Note que é perfeitamente possível usar Signals de maneira eficaz sem <code>Signal.subtle.Watcher</code> ao agendar polling de Signals computados, como faz o Glimmer. Entretanto, muitos frameworks descobriram que é frequentemente útil ter essa lógica de agendamento rodando de forma síncrona, então a API de Signals inclui isso.</p>
<p>Tanto Signals computados quanto de state são coletados pelo garbage collector como qualquer valor JS. Mas Watchers têm uma maneira especial de manter as coisas vivas: qualquer Signal observado por um Watcher será mantido vivo enquanto qualquer um dos estados subjacentes for acessível, pois estes podem disparar uma futura chamada <code>notify</code> (e então uma futura <code>.get()</code>). Por essa razão, lembre-se de chamar <code>Watcher.prototype.unwatch</code> para limpar efeitos.</p>
<h3>Um escape hatch não seguro</h3>
<p><code>Signal.subtle.untrack</code> é um escape hatch que permite ler Signals <em>sem</em> rastrear essas leituras. Essa capacidade é insegura porque permite a criação de Signals computados cujo valor depende de outros Signals, mas que não são atualizados quando esses Signals mudam. Deve ser usado quando os acessos não rastreados não irão alterar o resultado do cálculo.</p>
<!--
TODO: Mostrar exemplo onde faz sentido usar untrack

### Usando watched/unwatched
TODO: Mostrar exemplo de conversão de um Observable para um sinal computado, inscrito apenas quando usado por um efeito

TODO: Mostrar exemplo de um sinal computado que representa o resultado de um fetch direcionado a um estado, que é cancelado

### Introspecção para SSR

TODO: Mostrar como funciona a serialização do grafo de sinais

TODO: Mostrar como você pode "hidratar" um sinal de estado para computado depois, usando alguns sinais.
-->
<h3>Omitido por enquanto</h3>
<p>Esses recursos podem ser adicionados posteriormente, mas não estão incluídos no rascunho atual. Sua omissão se deve à falta de consenso estabelecido no espaço de design entre frameworks, bem como à capacidade demonstrada de contornar sua ausência com mecanismos baseados na noção de Sinais descrita neste documento. No entanto, infelizmente, a omissão limita o potencial de interoperabilidade entre frameworks. À medida que protótipos de Sinais, conforme descrito neste documento, forem produzidos, haverá um esforço para reexaminar se essas omissões foram a decisão adequada.</p>
<ul>
<li><strong>Assíncrono</strong>: Os sinais estão sempre disponíveis para avaliação de forma síncrona, neste modelo. No entanto, é frequentemente útil ter certos processos assíncronos que levam a um sinal ser definido, e entender quando um sinal ainda está &quot;carregando&quot;. Uma maneira simples de modelar o estado de carregamento é com exceções, e o comportamento de cache de exceções dos sinais computados compõe razoavelmente com essa técnica. Técnicas aprimoradas são discutidas na <a href="https://github.com/proposal-signals/proposal-signals/issues/30">Issue #30</a>.</li>
<li><strong>Transações</strong>: Para transições entre visualizações, muitas vezes é útil manter um estado ativo tanto para o estado &quot;de&quot; quanto para o &quot;para&quot;. O estado &quot;para&quot; é renderizado em segundo plano, até que esteja pronto para a troca (cometendo a transação), enquanto o estado &quot;de&quot; permanece interativo. Manter ambos os estados ao mesmo tempo requer &quot;forkar&quot; o estado do grafo de sinais, e pode até ser útil suportar múltiplas transições pendentes ao mesmo tempo. Discussão em <a href="https://github.com/proposal-signals/proposal-signals/issues/73">Issue #73</a>.</li>
</ul>
<p>Alguns possíveis <a href="https://github.com/proposal-signals/proposal-signals/issues/32">métodos de conveniência</a> também foram omitidos.</p>
<h2>Status e plano de desenvolvimento</h2>
<p>Esta proposta está na agenda do TC39 de abril de 2024 para o Estágio 1. Atualmente, pode ser considerada como &quot;Estágio 0&quot;.</p>
<p><a href="https://github.com/proposal-signals/signal-polyfill">Um polyfill</a> para esta proposta está disponível, com alguns testes básicos. Alguns autores de frameworks começaram a experimentar a substituição desta implementação de sinal, mas esse uso está em estágio inicial.</p>
<p>Os colaboradores da proposta de Sinais querem ser especialmente <strong>conservadores</strong> em como avançam com esta proposta, para evitar cair na armadilha de aprovar algo que acabaremos nos arrependendo e não usando de fato. Nosso plano é realizar as seguintes tarefas extras, não exigidas pelo processo do TC39, para garantir que esta proposta está no caminho certo:</p>
<p>Antes de propor para o Estágio 2, planejamos:</p>
<ul>
<li>Desenvolver múltiplas implementações de polyfill de nível de produção que sejam sólidas, bem testadas (por exemplo, passando testes de vários frameworks, bem como testes do estilo test262) e competitivas em termos de desempenho (como verificado com um conjunto abrangente de benchmarks de sinais/frameworks).</li>
<li>Integrar a API de Sinais proposta em um grande número de frameworks JS que consideramos representativos, e fazer com que algumas aplicações grandes funcionem com essa base. Testar se ela funciona de forma eficiente e correta nesses contextos.</li>
<li>Ter uma compreensão sólida do espaço de possíveis extensões da API, e concluir quais (se houver) devem ser adicionadas a esta proposta.</li>
</ul>
<h2>Algoritmos de Sinal</h2>
<p>Esta seção descreve cada uma das APIs expostas ao JavaScript, em termos dos algoritmos que implementam. Isso pode ser considerado como uma proto-especificação, e está incluído neste ponto inicial para definir um possível conjunto de semânticas, estando muito aberto a mudanças.</p>
<p>Alguns aspectos do algoritmo:</p>
<ul>
<li>A ordem de leitura dos Sinais dentro de um computado é significativa e é observável na ordem em que certos callbacks (quando <code>Watcher</code> é invocado, <code>equals</code>, o primeiro parâmetro para <code>new Signal.Computed</code> e os callbacks <code>watched</code>/<code>unwatched</code>) são executados. Isso significa que as fontes de um Sinal computado devem ser armazenadas ordenadas.</li>
<li>Esses quatro callbacks podem lançar exceções, e essas exceções são propagadas de maneira previsível para o código JS chamador. As exceções <em>não</em> interrompem a execução deste algoritmo nem deixam o grafo em um estado parcialmente processado. Para erros lançados no callback <code>notify</code> de um Watcher, essa exceção é enviada para a chamada <code>.set()</code> que a acionou, usando um AggregateError se várias exceções forem lançadas. As outras (incluindo <code>watched</code>/<code>unwatched</code>?) são armazenadas no valor do Sinal, para serem relançadas quando lidas, e tal Sinal relançado pode ser marcado como <code>~clean~</code> assim como qualquer outro com um valor normal.</li>
<li>Cuidados são tomados para evitar circularidades em casos de sinais computados que não são &quot;observados&quot; (sendo observados por algum Watcher), para que possam ser coletados pelo garbage collector de forma independente de outras partes do grafo de sinais. Internamente, isso pode ser implementado com um sistema de números de geração que são sempre coletados; observe que implementações otimizadas também podem incluir números de geração locais por nó, ou evitar rastrear alguns números em sinais observados.</li>
</ul>
<h3>Estado global oculto</h3>
<p>Os algoritmos de Sinal precisam referenciar certos estados globais. Esse estado é global para toda a thread, ou &quot;agente&quot;.</p>
<ul>
<li><code>computing</code>: O Sinal computado ou de efeito mais interno atualmente sendo reavaliado devido a uma chamada <code>.get</code> ou <code>.run</code>, ou <code>null</code>. Inicialmente <code>null</code>.</li>
<li><code>frozen</code>: Booleano que denota se há um callback atualmente em execução que exige que o grafo não seja modificado. Inicialmente <code>false</code>.</li>
<li><code>generation</code>: Um inteiro incremental, começando em 0, usado para rastrear quão atual é um valor enquanto evita circularidades.</li>
</ul>
<h3>O namespace <code>Signal</code></h3>
<p><code>Signal</code> é um objeto comum que serve como um namespace para classes e funções relacionadas a Sinais.</p>
<p><code>Signal.subtle</code> é um objeto de namespace interno semelhante.</p>
<h3>A classe <code>Signal.State</code></h3>
<h4>Slots internos de <code>Signal.State</code></h4>
<ul>
<li><code>value</code>: O valor atual do sinal de estado</li>
<li><code>equals</code>: A função de comparação usada ao alterar valores</li>
<li><code>watched</code>: O callback chamado quando o sinal passa a ser observado por um efeito</li>
<li><code>unwatched</code>: O callback chamado quando o sinal deixa de ser observado por um efeito</li>
<li><code>sinks</code>: Conjunto de sinais observados que dependem deste</li>
</ul>
<h4>Construtor: <code>Signal.State(initialValue, options)</code></h4>
<ol>
<li>Defina o <code>value</code> deste Sinal como <code>initialValue</code>.</li>
<li>Defina o <code>equals</code> deste Sinal como options?.equals</li>
<li>Defina o <code>watched</code> deste Sinal como options?.[Signal.subtle.watched]</li>
<li>Defina o <code>unwatched</code> deste Sinal como options?.[Signal.subtle.unwatched]</li>
<li>Defina o <code>sinks</code> deste Sinal como o conjunto vazio</li>
</ol>
<h4>Método: <code>Signal.State.prototype.get()</code></h4>
<ol>
<li>Se <code>frozen</code> for true, lance uma exceção.</li>
<li>Se <code>computing</code> não for <code>undefined</code>, adicione este Sinal ao conjunto <code>sources</code> de <code>computing</code>.</li>
<li>NOTA: Não adicionamos <code>computing</code> ao conjunto <code>sinks</code> deste Sinal até que ele seja observado por um Watcher.</li>
<li>Retorne o <code>value</code> deste Sinal.</li>
</ol>
<h4>Método: <code>Signal.State.prototype.set(newValue)</code></h4>
<ol>
<li>Se o contexto de execução atual for <code>frozen</code>, lance uma exceção.</li>
<li>Execute o algoritmo &quot;definir valor do Sinal&quot; com este Sinal e o primeiro parâmetro para o valor.</li>
<li>Se esse algoritmo retornar <code>~clean~</code>, então retorne undefined.</li>
<li>Defina o <code>state</code> de todos os <code>sinks</code> deste Sinal como (se for um Sinal Computado) <code>~dirty~</code> se estavam previamente clean, ou (se for um Watcher) <code>~pending~</code> se estava previamente <code>~watching~</code>.</li>
<li>Defina o <code>state</code> de todas as dependências de Sinal Computado dos sinks (recursivamente) como <code>~checked~</code> se estavam previamente <code>~clean~</code> (ou seja, mantenha as marcações de dirty), ou para Watchers, <code>~pending~</code> se previamente <code>~watching~</code>.</li>
<li>Para cada Watcher previamente <code>~watching~</code> encontrado nessa busca recursiva, em ordem de profundidade,
<ol>
<li>Defina <code>frozen</code> como true.</li>
<li>Chame seu callback <code>notify</code> (salvando separadamente qualquer exceção lançada, mas ignorando o valor de retorno de <code>notify</code>).</li>
<li>Restaure <code>frozen</code> para false.</li>
<li>Defina o <code>state</code> do Watcher para <code>~waiting~</code>.</li>
</ol>
</li>
<li>Se alguma exceção foi lançada dos callbacks <code>notify</code>, propague-a para o chamador após todos os callbacks <code>notify</code> terem sido executados. Se houver múltiplas exceções, agrupe-as em um AggregateError e lance-o.</li>
<li>Retorne undefined.</li>
</ol>
<h3>A classe <code>Signal.Computed</code></h3>
<h4>Máquina de estados de <code>Signal.Computed</code></h4>
<p>O <code>state</code> de um Computed Signal pode ser um dos seguintes:</p>
<ul>
<li><code>~clean~</code>: O valor do Signal está presente e sabe-se que não está desatualizado.</li>
<li><code>~checked~</code>: Uma fonte (indireta) deste Signal foi alterada; este Signal tem um valor, mas ele <em>pode</em> estar desatualizado. Só será possível saber se está desatualizado quando todas as fontes imediatas forem avaliadas.</li>
<li><code>~computing~</code>: O callback deste Signal está sendo executado atualmente como efeito colateral de uma chamada <code>.get()</code>.</li>
<li><code>~dirty~</code>: Ou este Signal tem um valor que se sabe estar desatualizado, ou nunca foi avaliado.</li>
</ul>
<p>O grafo de transição é o seguinte:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; dirty
    dirty --&gt; computing: [4]
    computing --&gt; clean: [5]
    clean --&gt; dirty: [2]
    clean --&gt; checked: [3]
    checked --&gt; clean: [6]
    checked --&gt; dirty: [1]
</code></pre>
<p>As transições são:
| Número | De | Para | Condição | Algoritmo |
| ------ | ---- | -- | --------- | --------- |
| 1 | <code>~checked~</code> | <code>~dirty~</code> | Uma fonte imediata deste signal, que é um computed signal, foi avaliada e seu valor foi alterado. | Algoritmo: recalcular Signal computado dirty |
| 2 | <code>~clean~</code> | <code>~dirty~</code> | Uma fonte imediata deste signal, que é um State, foi definida com um valor diferente do anterior. | Método: <code>Signal.State.prototype.set(newValue)</code> |
| 3 | <code>~clean~</code> | <code>~checked~</code> | Uma fonte recursiva, mas não imediata, deste signal, que é um State, foi definida com um valor diferente do anterior. | Método: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~dirty~</code> | <code>~computing~</code> | Estamos prestes a executar o <code>callback</code>. | Algoritmo: recalcular Signal computado dirty |
| 5 | <code>~computing~</code> | <code>~clean~</code> | O <code>callback</code> terminou de ser avaliado e retornou um valor ou lançou uma exceção. | Algoritmo: recalcular Signal computado dirty |
| 6 | <code>~checked~</code> | <code>~clean~</code> | Todas as fontes imediatas deste signal foram avaliadas e todas permaneceram inalteradas, então agora sabemos que não está desatualizado. | Algoritmo: recalcular Signal computado dirty |</p>
<h4>Slots internos de <code>Signal.Computed</code></h4>
<ul>
<li><code>value</code>: O valor em cache anterior do Signal, ou <code>~uninitialized~</code> para um Signal computado nunca lido. O valor pode ser uma exceção que é relançada quando o valor é lido. Sempre <code>undefined</code> para effect signals.</li>
<li><code>state</code>: Pode ser <code>~clean~</code>, <code>~checked~</code>, <code>~computing~</code> ou <code>~dirty~</code>.</li>
<li><code>sources</code>: Um conjunto ordenado de Signals dos quais este Signal depende.</li>
<li><code>sinks</code>: Um conjunto ordenado de Signals que dependem deste Signal.</li>
<li><code>equals</code>: O método equals fornecido nas opções.</li>
<li><code>callback</code>: O callback chamado para obter o valor do Signal computado. Definido como o primeiro parâmetro passado ao construtor.</li>
</ul>
<h4>Construtor de <code>Signal.Computed</code></h4>
<p>O construtor define</p>
<ul>
<li><code>callback</code> como seu primeiro parâmetro</li>
<li><code>equals</code> com base nas opções, padrão para <code>Object.is</code> se ausente</li>
<li><code>state</code> para <code>~dirty~</code></li>
<li><code>value</code> para <code>~uninitialized~</code></li>
</ul>
<p>Com <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a>, o callback passado para <code>new Signal.Computed</code> fecha sobre o snapshot do momento em que o construtor foi chamado, e restaura esse snapshot durante sua execução.</p>
<h4>Método: <code>Signal.Computed.prototype.get</code></h4>
<ol>
<li>Se o contexto de execução atual está <code>frozen</code> ou se este Signal está no estado <code>~computing~</code>, ou se este signal é um Watcher e está <code>computing</code> um Signal computado, lance uma exceção.</li>
<li>Se <code>computing</code> não for <code>null</code>, adicione este Signal ao conjunto <code>sources</code> de <code>computing</code>.</li>
<li>NOTA: Não adicionamos <code>computing</code> ao conjunto <code>sinks</code> deste Signal até que ele seja observado por um Watcher.</li>
<li>Se o estado deste Signal for <code>~dirty~</code> ou <code>~checked~</code>: Repita os passos a seguir até que este Signal esteja <code>~clean~</code>:
<ol>
<li>Recursivamente, suba via <code>sources</code> para encontrar a fonte recursiva mais profunda e à esquerda (ou seja, a primeira observada) que seja um Computed Signal marcado como <code>~dirty~</code> (interrompendo a busca ao encontrar um Computed Signal <code>~clean~</code> e incluindo este Computed Signal como o último a ser buscado).</li>
<li>Execute o algoritmo &quot;recalcular Signal computado dirty&quot; naquele Signal.</li>
</ol>
</li>
<li>Neste ponto, o estado deste Signal será <code>~clean~</code> e nenhuma fonte recursiva estará <code>~dirty~</code> ou <code>~checked~</code>. Retorne o <code>value</code> do Signal. Se o valor for uma exceção, relance essa exceção.</li>
</ol>
<h3>A classe <code>Signal.subtle.Watcher</code></h3>
<h4>Máquina de estados de <code>Signal.subtle.Watcher</code></h4>
<p>O <code>state</code> de um Watcher pode ser um dos seguintes:</p>
<ul>
<li><code>~waiting~</code>: O callback <code>notify</code> foi executado, ou o Watcher é novo, mas não está observando ativamente nenhum signal.</li>
<li><code>~watching~</code>: O Watcher está observando ativamente signals, mas nenhuma alteração ocorreu que necessite de um callback <code>notify</code>.</li>
<li><code>~pending~</code>: Uma dependência do Watcher foi alterada, mas o callback <code>notify</code> ainda não foi executado.</li>
</ul>
<p>O grafo de transição é o seguinte:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; waiting
    waiting --&gt; watching: [1]
    watching --&gt; waiting: [2]
    watching --&gt; pending: [3]
    pending --&gt; waiting: [4]
</code></pre>
<p>As transições são:
| Número | De | Para | Condição | Algoritmo |
| ------ | ---- | -- | --------- | --------- |
| 1 | <code>~waiting~</code> | <code>~watching~</code> | O método <code>watch</code> do Watcher foi chamado. | Método: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code> |
| 2 | <code>~watching~</code> | <code>~waiting~</code> | O método <code>unwatch</code> do Watcher foi chamado e o último signal observado foi removido. | Método: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code> |
| 3 | <code>~watching~</code> | <code>~pending~</code> | Um signal observado pode ter tido seu valor alterado. | Método: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~pending~</code> | <code>~waiting~</code> | O callback <code>notify</code> foi executado. | Método: <code>Signal.State.prototype.set(newValue)</code> |</p>
<h4>Slots internos de <code>Signal.subtle.Watcher</code></h4>
<ul>
<li><code>state</code>: Pode ser <code>~watching~</code>, <code>~pending~</code> ou <code>~waiting~</code></li>
<li><code>signals</code>: Um conjunto ordenado de Signals que este Watcher está observando</li>
<li><code>notifyCallback</code>: O callback chamado quando algo muda. Definido como o primeiro parâmetro passado ao construtor.</li>
</ul>
<h4>Construtor: <code>new Signal.subtle.Watcher(callback)</code></h4>
<ol>
<li><code>state</code> é definido como <code>~waiting~</code>.</li>
<li>Inicialize <code>signals</code> como um conjunto vazio.</li>
<li><code>notifyCallback</code> é definido como o parâmetro callback.
Com <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a>, o callback passado para <code>new Signal.subtle.Watcher</code> <em>não</em> encerra o snapshot do momento em que o construtor foi chamado, para que informações contextuais ao redor da gravação fiquem visíveis.</li>
</ol>
<h4>Método: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code></h4>
<ol>
<li>Se <code>frozen</code> for true, lance uma exceção.</li>
<li>Se algum dos argumentos não for um sinal, lance uma exceção.</li>
<li>Adicione todos os argumentos ao final do <code>signals</code> deste objeto.</li>
<li>Para cada sinal recém-observado, da esquerda para a direita,
<ol>
<li>Adicione este watcher como um <code>sink</code> para esse sinal.</li>
<li>Se este foi o primeiro sink, então faça a recursão até as sources para adicionar esse sinal como sink.</li>
<li>Defina <code>frozen</code> como true.</li>
<li>Chame o callback <code>watched</code> se existir.</li>
<li>Restaure <code>frozen</code> para false.</li>
</ol>
</li>
<li>Se o <code>state</code> do Signal for <code>~waiting~</code>, então defina como <code>~watching~</code>.</li>
</ol>
<h4>Método: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code></h4>
<ol>
<li>Se <code>frozen</code> for true, lance uma exceção.</li>
<li>Se algum dos argumentos não for um sinal, ou não estiver sendo observado por este watcher, lance uma exceção.</li>
<li>Para cada sinal nos argumentos, da esquerda para a direita,
<ol>
<li>Remova esse sinal do conjunto <code>signals</code> deste Watcher.</li>
<li>Remova este Watcher do conjunto <code>sink</code> deste Signal.</li>
<li>Se o conjunto <code>sink</code> desse Signal ficou vazio, remova esse Signal como sink de cada uma de suas sources.</li>
<li>Defina <code>frozen</code> como true.</li>
<li>Chame o callback <code>unwatched</code> se existir.</li>
<li>Restaure <code>frozen</code> para false.</li>
</ol>
</li>
<li>Se o watcher agora não tiver <code>signals</code> e seu <code>state</code> for <code>~watching~</code>, então defina como <code>~waiting~</code>.</li>
</ol>
<h4>Método: <code>Signal.subtle.Watcher.prototype.getPending()</code></h4>
<ol>
<li>Retorne um Array contendo o subconjunto de <code>signals</code> que são Computed Signals nos estados <code>~dirty~</code> ou <code>~pending~</code>.</li>
</ol>
<h3>Método: <code>Signal.subtle.untrack(cb)</code></h3>
<ol>
<li>Deixe <code>c</code> ser o estado atual de <code>computing</code> do contexto de execução.</li>
<li>Defina <code>computing</code> como null.</li>
<li>Chame <code>cb</code>.</li>
<li>Restaure <code>computing</code> para <code>c</code> (mesmo se <code>cb</code> lançar uma exceção).</li>
<li>Retorne o valor de retorno de <code>cb</code> (relançando qualquer exceção).</li>
</ol>
<p>Nota: untrack não tira você do estado <code>frozen</code>, que é mantido estritamente.</p>
<h3>Método: <code>Signal.subtle.currentComputed()</code></h3>
<ol>
<li>Retorne o valor atual de <code>computing</code>.</li>
</ol>
<h3>Algoritmos comuns</h3>
<h5>Algoritmo: recalcular um Signal computed dirty</h5>
<ol>
<li>Limpe o conjunto <code>sources</code> deste Signal e remova-o dos conjuntos <code>sinks</code> dessas sources.</li>
<li>Salve o valor anterior de <code>computing</code> e defina <code>computing</code> como este Signal.</li>
<li>Defina o estado deste Signal como <code>~computing~</code>.</li>
<li>Execute o callback deste computed Signal, usando este Signal como valor de this. Salve o valor de retorno e, se o callback lançar uma exceção, armazene-a para relançar.</li>
<li>Restaure o valor anterior de <code>computing</code>.</li>
<li>Aplique o algoritmo &quot;set Signal value&quot; ao valor de retorno do callback.</li>
<li>Defina o estado deste Signal como <code>~clean~</code>.</li>
<li>Se esse algoritmo retornou <code>~dirty~</code>: marque todos os sinks deste Signal como <code>~dirty~</code> (anteriormente, os sinks poderiam estar misturados entre checked e dirty). (Ou, se este não estiver sendo observado, então adote um novo número de geração para indicar dirty, ou algo assim.)</li>
<li>Caso contrário, se o algoritmo retornou <code>~clean~</code>: nesse caso, para cada sink <code>~checked~</code> deste Signal, se todas as sources desse Signal agora estiverem limpas, então marque esse Signal como <code>~clean~</code> também. Aplique essa etapa de limpeza recursivamente para sinks adicionais, para quaisquer Signals recém-limpos que tenham sinks checked. (Ou, se este não estiver sendo observado, indique o mesmo de alguma forma, para que a limpeza possa ser feita de forma preguiçosa.)</li>
</ol>
<h5>Algoritmo de atribuição de valor do Signal</h5>
<ol>
<li>Se este algoritmo recebeu um valor (ao contrário de uma exceção para ser relançada, do algoritmo de recalcular computed Signal dirty):
<ol>
<li>Chame a função <code>equals</code> deste Signal, passando como parâmetros o valor atual, o novo valor e este Signal. Se uma exceção for lançada, salve essa exceção (para relançar quando lido) como o valor do Signal e continue como se o callback tivesse retornado false.</li>
<li>Se essa função retornar true, retorne <code>~clean~</code>.</li>
</ol>
</li>
<li>Defina o <code>value</code> deste Signal como o parâmetro.</li>
<li>Retorne <code>~dirty~</code></li>
</ol>
<h2>FAQ</h2>
<p><strong>P</strong>: Não é um pouco cedo para padronizar algo relacionado a Signals, quando eles acabaram de se tornar populares em 2022? Não deveríamos dar mais tempo para evoluírem e se estabilizarem?</p>
<p><strong>R</strong>: O estado atual dos Signals em frameworks web é resultado de mais de 10 anos de desenvolvimento contínuo. À medida que o investimento aumentou, como tem acontecido nos últimos anos, quase todos os frameworks web estão convergindo para um modelo central muito semelhante de Signals. Esta proposta é resultado de um exercício de design compartilhado entre um grande número de líderes atuais em frameworks web, e não avançará para padronização sem a validação desse grupo de especialistas em diferentes contextos.</p>
<h4>Como os Signals são usados?</h4>
<p><strong>P</strong>: Signals nativos podem ser usados por frameworks, considerando sua integração estreita com renderização e propriedade?</p>
<p><strong>R</strong>: As partes mais específicas de frameworks tendem a estar na área de efeitos, agendamento e propriedade/eliminação, que esta proposta não tenta resolver. Nossa prioridade inicial ao prototipar Signals no padrão é validar que eles podem funcionar &quot;por baixo&quot; dos frameworks existentes de forma compatível e com bom desempenho.</p>
<p><strong>P</strong>: A API de Signal foi projetada para ser usada diretamente por desenvolvedores de aplicações, ou envolvida por frameworks?</p>
<p><strong>R</strong>: Embora esta API possa ser usada diretamente por desenvolvedores de aplicações (pelo menos a parte que não está no namespace <code>Signal.subtle</code>), ela não foi projetada para ser especialmente ergonômica. Em vez disso, as necessidades de autores de bibliotecas/frameworks são prioridade. Espera-se que a maioria dos frameworks envolva até mesmo as APIs básicas de <code>Signal.State</code> e <code>Signal.Computed</code> com algo que expresse sua abordagem ergonômica. Na prática, normalmente é melhor usar Signals por meio de um framework, que gerencia recursos mais complexos (por exemplo, Watcher, <code>untrack</code>), bem como gerenciamento de propriedade e eliminação (por exemplo, decidir quando os signals devem ser adicionados e removidos de watchers) e agendamento de renderização para o DOM — esta proposta não tenta resolver esses problemas.</p>
<p><strong>P</strong>: Preciso desmontar Signals relacionados a um widget quando esse widget é destruído? Qual é a API para isso?</p>
<p><strong>R</strong>: A operação de desmontagem relevante aqui é <code>Signal.subtle.Watcher.prototype.unwatch</code>. Apenas Signals observados precisam ser limpos (desobservados), enquanto Signals não observados podem ser coletados automaticamente pelo garbage collector.</p>
<p><strong>P</strong>: Signals funcionam com VDOM ou diretamente com o DOM HTML subjacente?</p>
<p><strong>R</strong>: Sim! Signals são independentes da tecnologia de renderização. Frameworks JavaScript existentes que usam construções semelhantes a Signals integram-se com VDOM (por exemplo, Preact), DOM nativo (por exemplo, Solid) e uma combinação (por exemplo, Vue). O mesmo será possível com Signals nativos.</p>
<p><strong>P</strong>: Será ergonômico usar Signals no contexto de frameworks baseados em classes como Angular e Lit? E quanto a frameworks baseados em compilador, como Svelte?</p>
<p><strong>R</strong>: Campos de classe podem ser baseados em Signal com um simples decorator de acessor, como mostrado no <a href="https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators">readme do polyfill de Signal</a>. Signals estão muito alinhados com as Runes do Svelte 5 — é simples para um compilador transformar runes na API de Signal definida aqui, e de fato é isso que o Svelte 5 faz internamente (mas com sua própria biblioteca de Signals).</p>
<p><strong>P</strong>: Signals funcionam com SSR? Hidratação? Resumibilidade?</p>
<p><strong>R</strong>: Sim. Qwik usa Signals com bons resultados em ambas as propriedades, e outros frameworks têm abordagens bem desenvolvidas para hidratação com Signals e diferentes trade-offs. Achamos que é possível modelar os Signals resumíveis do Qwik usando um State e um Computed signal conectados, e planejamos provar isso em código.
<strong>Q</strong>: Os Signals funcionam com fluxo de dados unidirecional, como o React?</p>
<p><strong>A</strong>: Sim, Signals são um mecanismo para fluxo de dados unidirecional. Frameworks de UI baseados em Signals permitem que você expresse sua visualização como uma função do modelo (onde o modelo incorpora Signals). Um grafo de estado e Signals computados é acíclico por construção. Também é possível recriar antipadrões do React dentro dos Signals (!), por exemplo, o equivalente ao <code>setState</code> dentro do <code>useEffect</code> é usar um Watcher para agendar uma escrita em um Signal de estado.</p>
<p><strong>Q</strong>: Como os signals se relacionam com sistemas de gerenciamento de estado como Redux? Signals incentivam estado não estruturado?</p>
<p><strong>A</strong>: Signals podem formar uma base eficiente para abstrações de gerenciamento de estado semelhantes a stores. Um padrão comum encontrado em vários frameworks é um objeto baseado em Proxy que internamente representa propriedades usando Signals, por exemplo, <a href="https://vuejs.org/api/reactivity-core.html#reactive">Vue <code>reactive()</code></a>, ou <a href="https://docs.solidjs.com/concepts/stores">Solid stores</a>. Esses sistemas permitem o agrupamento flexível do estado no nível certo de abstração para a aplicação em questão.</p>
<p><strong>Q</strong>: O que os Signals oferecem que o <code>Proxy</code> atualmente não lida?</p>
<p><strong>A</strong>: Proxies e Signals são complementares e funcionam bem juntos. Proxies permitem interceptar operações superficiais de objeto e signals coordenam um grafo de dependências (de células). Usar um Proxy respaldado por Signals é uma ótima maneira de criar uma estrutura reativa aninhada com excelente ergonomia.</p>
<p>Neste exemplo, podemos usar um proxy para fazer com que o signal tenha uma propriedade getter e setter em vez de usar os métodos <code>get</code> e <code>set</code>:</p>
<pre><code class="language-js">const a = new Signal.State(0);
const b = new Proxy(a, {
  get(target, property, receiver) {
    if (property === 'value') {
      return target.get():
    }
  }
  set(target, property, value, receiver) {
    if (property === 'value') {
      target.set(value)!
    }
  }
});

// uso em um contexto reativo hipotético:
&lt;template&gt;
  {b.value}

  &lt;button onclick={() =&gt; {
    b.value++;
  }}&gt;change&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>ao usar um renderizador que é otimizado para reatividade de grão fino, clicar no botão fará com que a célula <code>b.value</code> seja atualizada.</p>
<p>Veja:</p>
<ul>
<li>exemplos de estruturas reativas aninhadas criadas com Signals e Proxies: <a href="https://github.com/NullVoxPopuli/signal-utils/tree/main/src">signal-utils</a></li>
<li>exemplo de implementações anteriores mostrando a relação entre dados reativos e proxies: <a href="https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private">tracked-built-ins</a></li>
<li><a href="https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574">discussão</a>.</li>
</ul>
<h4>Como os Signals funcionam?</h4>
<p><strong>Q</strong>: Signals são baseados em push ou pull?</p>
<p><strong>A</strong>: A avaliação de Signals computados é baseada em pull: Signals computados só são avaliados quando <code>.get()</code> é chamado, mesmo que o estado subjacente tenha mudado muito antes. Ao mesmo tempo, mudar um Signal de estado pode imediatamente acionar o callback de um Watcher, &quot;empurrando&quot; a notificação. Portanto, Signals podem ser considerados uma construção &quot;push-pull&quot;.</p>
<p><strong>Q</strong>: Signals introduzem não determinismo na execução do JavaScript?</p>
<p><strong>A</strong>: Não. Para começar, todas as operações de Signal têm semânticas e ordenações bem definidas, e não diferirão entre implementações compatíveis. Em um nível mais alto, Signals seguem um certo conjunto de invariantes, em relação aos quais são &quot;corretos&quot;. Um Signal computado sempre observa o grafo de Signals em um estado consistente, e sua execução não é interrompida por outro código que muta Signals (exceto pelas chamadas dele próprio). Veja a descrição acima.</p>
<p><strong>Q</strong>: Quando escrevo em um Signal de estado, quando a atualização do Signal computado é agendada?</p>
<p><strong>A</strong>: Não é agendada! O Signal computado irá se recalcular na próxima vez que alguém o ler. Síncronamente, o callback <code>notify</code> de um Watcher pode ser chamado, permitindo que frameworks agendem uma leitura no momento que acharem apropriado.</p>
<p><strong>Q</strong>: Quando as escritas em Signals de estado têm efeito? Imediatamente ou são agrupadas?</p>
<p><strong>A</strong>: Escritas em Signals de estado são refletidas imediatamente — na próxima vez que um Signal computado que depende do Signal de estado for lido, ele se recalculará se necessário, mesmo que seja na linha de código imediatamente seguinte. No entanto, a preguiça inerente a esse mecanismo (de que Signals computados só são calculados quando lidos) significa que, na prática, os cálculos podem ocorrer de forma agrupada.</p>
<p><strong>Q</strong>: O que significa Signals possibilitarem execução &quot;livre de glitches&quot;?</p>
<p><strong>A</strong>: Modelos anteriores baseados em push para reatividade enfrentaram o problema de computação redundante: se uma atualização em um Signal de estado faz com que o Signal computado execute imediatamente, isso pode acabar forçando uma atualização na UI. Mas essa escrita na UI pode ser prematura, se houver outra mudança no Signal de estado original antes do próximo frame. Às vezes, valores intermediários imprecisos eram até mostrados aos usuários finais devido a esses <a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">glitches</a>. Signals evitam essa dinâmica por serem baseados em pull, e não em push: no momento em que o framework agenda o render da UI, ele irá buscar as atualizações apropriadas, evitando trabalho desperdiçado tanto na computação quanto na escrita no DOM.</p>
<p><strong>Q</strong>: O que significa Signals serem &quot;lossy&quot; (com perda)?</p>
<p><strong>A</strong>: Esse é o outro lado da execução livre de glitches: Signals representam uma célula de dados — apenas o valor atual imediato (que pode mudar), não um fluxo de dados ao longo do tempo. Então, se você escrever duas vezes seguidas em um Signal de estado, sem fazer mais nada, a primeira escrita é &quot;perdida&quot; e nunca será vista por qualquer Signal computado ou efeito. Isso é entendido como uma funcionalidade e não um bug — outros construtos (por exemplo, iteráveis assíncronos, observables) são mais apropriados para fluxos.</p>
<p><strong>Q</strong>: Signals nativos serão mais rápidos do que implementações JS de Signals já existentes?</p>
<p><strong>A</strong>: Esperamos que sim (por um pequeno fator constante), mas isso ainda precisa ser comprovado em código. Engines JS não são mágicas, e no final precisarão implementar o mesmo tipo de algoritmos das implementações JS de Signals. Veja a seção acima sobre performance.</p>
<h4>Por que os Signals são projetados desse jeito?</h4>
<p><strong>Q</strong>: Por que esta proposta não inclui uma função <code>effect()</code>, se efeitos são necessários para qualquer uso prático de Signals?</p>
<p><strong>A</strong>: Efeitos estão inerentemente ligados a agendamento e descarte, que são gerenciados por frameworks e estão fora do escopo desta proposta. Em vez disso, esta proposta inclui a base para implementação de efeitos através da API de mais baixo nível <code>Signal.subtle.Watcher</code>.</p>
<p><strong>Q</strong>: Por que as assinaturas são automáticas ao invés de fornecer uma interface manual?</p>
<p><strong>A</strong>: A experiência mostrou que interfaces de assinatura manual para reatividade são pouco ergonômicas e propensas a erros. O rastreamento automático é mais composicional e é uma funcionalidade central dos Signals.</p>
<p><strong>Q</strong>: Por que o callback do <code>Watcher</code> roda de forma síncrona, e não agendada em uma microtask?</p>
<p><strong>A</strong>: Porque o callback não pode ler ou escrever em Signals, não há inconsistências causadas por chamá-lo de forma síncrona. Um callback típico irá adicionar um Signal a um Array para ser lido depois, ou marcar um bit em algum lugar. Não é necessário e seria impraticavelmente caro criar uma microtask separada para todas essas ações.</p>
<p><strong>Q</strong>: Está faltando nesta API algumas coisas legais que meu framework favorito fornece, e que facilitam programar com Signals. Isso pode ser adicionado ao padrão também?</p>
<p><strong>A</strong>: Talvez. Várias extensões ainda estão em consideração. Por favor, abra uma issue para discutir qualquer funcionalidade que achar importante e que esteja faltando.</p>
<p><strong>Q</strong>: Esta API pode ser reduzida em tamanho ou complexidade?</p>
<p><strong>A</strong>: Definitivamente é um objetivo manter esta API mínima, e tentamos fazer isso com o que foi apresentado acima. Se você tiver ideias de mais coisas que podem ser removidas, por favor, abra uma issue para discutir.</p>
<h4>Como os Signals estão sendo padronizados?</h4>
<p><strong>Q</strong>: Não deveríamos começar o trabalho de padronização nesta área com um conceito mais primitivo, como observables?
<strong>A</strong>: Observables podem ser uma boa ideia para algumas situações, mas não resolvem os problemas que os Signals buscam solucionar. Conforme descrito acima, observables ou outros mecanismos de publicação/assinatura não são uma solução completa para muitos tipos de programação de UI, devido à necessidade de configuração propensa a erros pelos desenvolvedores e trabalho desperdiçado devido à falta de preguiça (laziness), entre outros problemas.</p>
<p><strong>Q</strong>: Por que os Signals estão sendo propostos no TC39 em vez do DOM, já que a maioria de suas aplicações é baseada na web?</p>
<p><strong>A</strong>: Alguns coautores desta proposta têm interesse em ambientes de UI fora da web como objetivo, mas atualmente, ambos os ambientes podem ser adequados para isso, já que APIs web estão sendo implementadas cada vez mais fora da web. Em última análise, Signals não precisam depender de nenhuma API do DOM, então qualquer caminho funciona. Se alguém tiver um motivo forte para este grupo mudar, por favor, nos informe em uma issue. Por enquanto, todos os colaboradores assinaram os acordos de propriedade intelectual do TC39, e o plano é apresentar isso ao TC39.</p>
<p><strong>Q</strong>: Quanto tempo vai levar até que eu possa usar Signals padronizados?</p>
<p><strong>A</strong>: Já existe um polyfill disponível, mas é melhor não depender de sua estabilidade, pois esta API evolui durante o processo de revisão. Em alguns meses ou em um ano, um polyfill estável, de alta qualidade e alto desempenho deve estar utilizável, mas ainda estará sujeito a revisões do comitê e não será padrão ainda. Seguindo a trajetória típica de uma proposta do TC39, espera-se que leve pelo menos 2-3 anos, no mínimo, para que os Signals estejam disponíveis nativamente em todos os navegadores, mesmo em versões anteriores, de modo que polyfills não sejam mais necessários.</p>
<p><strong>Q</strong>: Como vamos evitar padronizar o tipo errado de Signals muito cedo, assim como {{JS/web feature that you don't like}}?</p>
<p><strong>A</strong>: Os autores desta proposta planejam ir além com prototipagem e validação antes de solicitar o avanço de estágio no TC39. Veja &quot;Status and development plan&quot; acima. Se você identificar lacunas nesse plano ou oportunidades de melhoria, por favor, abra uma issue explicando.</p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-28</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>