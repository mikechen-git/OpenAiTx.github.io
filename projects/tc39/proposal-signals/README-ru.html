<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>proposal-signals - tc39/proposal-signals ru</title>
    <meta name="title" content="proposal-signals - tc39/proposal-signals ru | 🚦 Стандартное предложение по Signals в JavaScript 🚦 Стадия 1 (объяснение) Чемпионы предложения TC39: Даниэль Эренберг, Йехуда Кац, Джатин Раманатан, Шей Льюис...">
    <meta name="description" content="tc39/proposal-signals - GitHub repository ru documentation and information | 🚦 Стандартное предложение по Signals в JavaScript 🚦 Стадия 1 (объяснение) Чемпионы предложения TC39: Даниэль Эренберг, Йехуда Кац, Джатин Раманатан, Шей Льюис...">
    <meta name="keywords" content="tc39, proposal-signals, GitHub, repository, ru documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/tc39/proposal-signals/README-ru.html">
    <meta property="og:title" content="proposal-signals - tc39/proposal-signals ru | 🚦 Стандартное предложение по Signals в JavaScript 🚦 Стадия 1 (объяснение) Чемпионы предложения TC39: Даниэль Эренберг, Йехуда Кац, Джатин Раманатан, Шей Льюис...">
    <meta property="og:description" content="tc39/proposal-signals - GitHub repository ru documentation and information | 🚦 Стандартное предложение по Signals в JavaScript 🚦 Стадия 1 (объяснение) Чемпионы предложения TC39: Даниэль Эренберг, Йехуда Кац, Джатин Раманатан, Шей Льюис...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/tc39/proposal-signals" id="githubRepoLink" target="_blank">tc39/proposal-signals</a>
<h1 style="display: none;">🚦 Стандартное предложение по Signals в JavaScript 🚦 Стадия 1 (объяснение) Чемпионы предложения TC39: Даниэль Эренберг, Йехуда Кац, Джатин Раманатан, Шей Льюис...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>🚦 Стандартное предложение по Signals в JavaScript 🚦</h1>
<img align=right src="https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg" alt="Signals logo" width=100>
<p>Стадия 1 (<a href="https://tc39.es/process-document/">объяснение</a>)</p>
<p>Чемпионы предложения TC39: Даниэль Эренберг, Йехуда Кац, Джатин Раманатан, Шей Льюис, Кристен Хьюэлл Гарретт, Доминик Ганнауэй, Престон Сего, Милло М, Роб Айзенберг</p>
<p>Оригинальные авторы: Роб Айзенберг и Даниэль Эренберг</p>
<p>Этот документ описывает раннее общее направление для signals в JavaScript, аналогично инициативе Promises/A+, которая предшествовала стандартизации Promises комитетом TC39 в ES2015. Попробуйте сами, используя <a href="https://github.com/proposal-signals/signal-polyfill">polyfill</a>.</p>
<p>Подобно Promises/A+, это усилие направлено на согласование экосистемы JavaScript. Если эта согласованность будет успешной, на основе этого опыта может появиться стандарт. Несколько авторов фреймворков сотрудничают здесь над общей моделью, которая может лежать в основе их реактивного ядра. Текущий черновик основан на дизайнерских предложениях авторов и мейнтейнеров <a href="https://angular.io/">Angular</a>, <a href="https://bubble.io/">Bubble</a>, <a href="https://emberjs.com/">Ember</a>, <a href="https://www.fast.design/">FAST</a>, <a href="https://mobx.js.org/">MobX</a>, <a href="https://preactjs.com/">Preact</a>, <a href="https://qwik.dev/">Qwik</a>, <a href="https://rxjs.dev/">RxJS</a>, <a href="https://www.solidjs.com/">Solid</a>, <a href="https://www.starbeamjs.com/">Starbeam</a>, <a href="https://svelte.dev/">Svelte</a>, <a href="https://vuejs.org/">Vue</a>, <a href="https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a">Wiz</a> и других...</p>
<p>В отличие от Promises/A+, мы не пытаемся решить задачу единого API для разработчиков, а сосредоточены на точных базовых семантиках графа сигналов. Это предложение действительно включает полностью конкретный API, но он не предназначен для большинства прикладных разработчиков. Вместо этого API сигналов здесь больше подходит для фреймворков, чтобы строить на его основе, обеспечивая совместимость через общий граф сигналов и механизм авто-трекинга.</p>
<p>План по этому предложению — провести значительное раннее прототипирование, включая интеграцию в несколько фреймворков, прежде чем переходить дальше стадии 1. Нас интересует стандартизация Signals только если они пригодны к использованию на практике в нескольких фреймворках и дают реальные преимущества по сравнению с сигналами, предоставляемыми фреймворками. Мы надеемся, что значительное раннее прототипирование даст нам эту информацию. Подробнее см. раздел &quot;Статус и план развития&quot; ниже.</p>
<h2>Предпосылки: Зачем нужны Signals?</h2>
<p>Для разработки сложного пользовательского интерфейса (UI) разработчикам JavaScript-приложений необходимо хранить, вычислять, инвалидировать, синхронизировать и эффективно передавать состояние на уровень отображения приложения. UI обычно включает не только управление простыми значениями, но и рендеринг вычисленного состояния, которое зависит от сложного дерева других значений или состояния, вычисляемого динамически. Цель Signals — предоставить инфраструктуру для управления таким состоянием приложения, чтобы разработчики могли сосредоточиться на бизнес-логике, а не на этих рутинных деталях.</p>
<p>Похожие на сигналы конструкции были независимо признаны полезными и вне UI, в частности в системах сборки для предотвращения ненужных пересборок.</p>
<p>Signals используются в реактивном программировании для устранения необходимости ручного управления обновлениями в приложениях.</p>
<blockquote>
<p>Декларативная модель программирования для обновления на основе изменений состояния.</p>
</blockquote>
<p>из <em><a href="https://www.pzuraq.com/blog/what-is-reactivity">What is Reactivity?</a></em>.</p>
<h4>Пример — VanillaJS-счётчик</h4>
<p>Пусть есть переменная <code>counter</code>, которую нужно отобразить в DOM в зависимости от того, чётное или нечётное её значение. Каждый раз при изменении <code>counter</code> нужно обновлять DOM с актуальным признаком чётности. На чистом JS это может выглядеть так:</p>
<pre><code class="language-js">let counter = 0;
const setCounter = (value) =&gt; {
  counter = value;
  render();
};

const isEven = () =&gt; (counter &amp; 1) == 0;
const parity = () =&gt; isEven() ? &quot;even&quot; : &quot;odd&quot;;
const render = () =&gt; element.innerText = parity();

// Симуляция внешних обновлений counter...
setInterval(() =&gt; setCounter(counter + 1), 1000);
</code></pre>
<blockquote>
<p>[!NOTE]<br />
Глобальные переменные здесь используются только для демонстрации. Для корректного управления состоянием существует множество решений, а примеры в этом предложении максимально минималистичны. Это предложение не поощряет использование глобальных переменных.</p>
</blockquote>
<p>У этого подхода есть ряд проблем...</p>
<ul>
<li>Инициализация <code>counter</code> громоздкая и наполнена шаблонным кодом.</li>
<li>Состояние <code>counter</code> жёстко связано с системой рендеринга.</li>
<li>Если <code>counter</code> изменяется, но <code>parity</code> нет (например, счётчик с 2 на 4), мы выполняем ненужное вычисление и рендеринг.</li>
<li>Что если другая часть UI хочет реагировать только на обновления <code>counter</code>?</li>
<li>Что если другая часть UI зависит только от <code>isEven</code> или <code>parity</code>?</li>
</ul>
<p>Даже в этом относительно простом сценарии быстро возникают проблемы. Можно попытаться их обойти, введя pub/sub для <code>counter</code>. Это позволит другим потребителям подписываться и реагировать на изменения состояния.</p>
<p>Однако остаются следующие проблемы:</p>
<ul>
<li>Функция рендеринга, зависящая только от <code>parity</code>, вынуждена &quot;знать&quot;, что ей нужно подписываться на <code>counter</code>.</li>
<li>Нельзя обновить UI только при изменении <code>isEven</code> или <code>parity</code>, не взаимодействуя с <code>counter</code> напрямую.</li>
<li>Мы увеличили количество шаблонного кода. Использование чего-либо теперь требует не просто вызова функции или чтения переменной, а подписки и обработки обновлений. Управление отписками становится особенно сложным.</li>
</ul>
<p>Теперь можно попытаться решить часть проблем, введя pub/sub не только для <code>counter</code>, но и для <code>isEven</code> и <code>parity</code>. Тогда придётся подписать <code>isEven</code> на <code>counter</code>, <code>parity</code> на <code>isEven</code>, а <code>render</code> на <code>parity</code>. К сожалению, в результате шаблонный код разрастается, увеличивается количество подписок и возрастает риск утечек памяти, если не правильно чистить ресурсы. Таким образом, часть проблем решена, но появляется новая категория сложностей и лишнего кода. Более того, этот процесс придётся повторять для каждого состояния в системе.</p>
<h3>Введение Signals</h3>
<p>Абстракции data binding для модели и представления давно стали ядром UI-фреймворков во многих языках программирования, несмотря на отсутствие такой механики в самом JS или веб-платформе. Внутри JS-фреймворков и библиотек было много экспериментов с разными способами представления этих связей, и опыт показал эффективность однонаправленного потока данных в сочетании с полноценным типом данных, представляющим ячейку состояния или вычисления на основе других данных, который сейчас часто называют &quot;Signals&quot;.
Похоже, что такой подход впервые стал популярен в open-source JavaScript веб-фреймворках с <a href="https://knockoutjs.com/">Knockout</a> <a href="https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/">в 2010 году</a>. С тех пор появилось много вариаций и реализаций. За последние 3–4 года примитив Signal и связанные подходы получили ещё большее распространение — практически в каждой современной JS-библиотеке или фреймворке есть что-то подобное под разными именами.</p>
<p>Чтобы понять Signals, рассмотрим пример выше, переосмысленный с использованием API Signals, который будет подробно описан далее.</p>
<h4>Пример — Signals-счётчик</h4>
<pre><code class="language-js">const counter = new Signal.State(0);
const isEven = new Signal.Computed(() =&gt; (counter.get() &amp; 1) == 0);
const parity = new Signal.Computed(() =&gt; isEven.get() ? &quot;even&quot; : &quot;odd&quot;);

// Библиотека или фреймворк определяет эффекты на основе других примитивов Signal
declare function effect(cb: () =&gt; void): (() =&gt; void);

effect(() =&gt; element.innerText = parity.get());

// Симуляция внешних обновлений counter...
setInterval(() =&gt; counter.set(counter.get() + 1), 1000);
</code></pre>
<p>Сразу видно несколько вещей:</p>
<ul>
<li>Мы избавились от лишнего шаблонного кода вокруг переменной <code>counter</code> из предыдущего примера.</li>
<li>Есть унифицированный API для работы со значениями, вычислениями и побочными эффектами.</li>
<li>Нет проблемы циклических зависимостей между <code>counter</code> и <code>render</code>.</li>
<li>Нет ручных подписок и необходимости вести учёт.</li>
<li>Есть механизм управления временем/планированием побочных эффектов.</li>
</ul>
<p>Signals дают нам гораздо больше, чем видно на поверхности API:</p>
<ul>
<li><strong>Автоматическое отслеживание зависимостей</strong> — вычисляемый сигнал автоматически обнаруживает все другие сигналы, от которых он зависит, будь то простые значения или другие вычисления.</li>
<li><strong>Ленивая (отложенная) оценка</strong> — вычисления не выполняются немедленно при их объявлении, и также не вычисляются сразу при изменении их зависимостей. Они выполняются только тогда, когда их значение явно запрошено.</li>
<li><strong>Мемоизация</strong> — вычисляемые сигналы кэшируют своё последнее значение, чтобы вычисления с неизменившимися зависимостями не пересчитывались заново, независимо от количества обращений к ним.</li>
</ul>
<h2>Мотивация стандартизации сигналов</h2>
<h4>Взаимная совместимость</h4>
<p>Каждая реализация сигналов использует свой собственный механизм автотрекинга для отслеживания источников, встреченных при вычислении вычисляемого сигнала. Это затрудняет обмен моделями, компонентами и библиотеками между различными фреймворками — они, как правило, оказываются ложным образом связаны со своим движком представления (так как сигналы обычно реализуются как часть JS-фреймворков).</p>
<p>Цель этого предложения — полностью отделить реактивную модель от рендеринга, позволяя разработчикам переходить на новые технологии рендеринга без переписывания не-UI кода или разрабатывать общие реактивные модели на JS для использования в разных контекстах. К сожалению, из-за версионирования и дублирования оказалось непрактично достичь высокого уровня совместного использования через библиотеки на уровне JS — встроенные средства обеспечивают более сильную гарантию совместимости.</p>
<h4>Производительность/использование памяти</h4>
<p>Всегда есть небольшой потенциальный прирост производительности за счёт уменьшения количества доставляемого кода, если часто используемые библиотеки становятся встроенными, но реализации сигналов обычно довольно малы, поэтому этот эффект не ожидается как значительный.</p>
<p>Мы предполагаем, что нативные реализации на C++ структур данных и алгоритмов, связанных с сигналами, могут быть немного эффективнее, чем то, что можно реализовать на JS, за счёт постоянного множителя. Однако никаких алгоритмических изменений по сравнению с полифиллом не предполагается; не ожидается, что движки будут &quot;магическими&quot;, а сами алгоритмы реактивности будут чётко определены и однозначны.</p>
<p>Группа авторов предложения планирует разработать различные реализации сигналов и использовать их для исследования возможностей по производительности.</p>
<h4>DevTools</h4>
<p>Существующие JS-библиотеки сигналов затрудняют трассировку таких вещей, как:</p>
<ul>
<li>Стек вызовов по цепочке вычисляемых сигналов, показывающий причинно-следственную цепочку для ошибки</li>
<li>Граф ссылок между сигналами, когда один зависит от другого — это важно при отладке использования памяти</li>
</ul>
<p>Встроенные сигналы позволяют JS-движкам и DevTools потенциально улучшить поддержку инспекции сигналов, особенно при отладке или анализе производительности — будь то встроено в браузеры или реализовано через общее расширение. Существующие инструменты, такие как инспектор элементов, снимки производительности и профилировщики памяти, можно обновить, чтобы они специально выделяли сигналы в своей информации.</p>
<h4>Вторичные преимущества</h4>
<h5>Преимущества стандартной библиотеки</h5>
<p>В целом, стандартная библиотека JavaScript была довольно минималистичной, но в TC39 наблюдается тенденция делать JS языком &quot;с батарейками&quot;, с качественным, встроенным набором функциональности. Например, Temporal заменяет moment.js, а ряд небольших возможностей, например, <code>Array.prototype.flat</code> и <code>Object.groupBy</code> заменяют многие случаи использования lodash. Преимущества: меньший размер бандлов, повышенная стабильность и качество, меньше нового для изучения при переходе на проект, и общий словарь среди JS-разработчиков.</p>
<h5>Интеграция с HTML/DOM (возможность на будущее)</h5>
<p>В настоящее время в W3C и у разработчиков браузеров ведётся работа по внедрению нативного шаблонирования в HTML (<a href="https://github.com/WICG/webcomponents/pull/1023">DOM Parts</a> и <a href="https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md">Template Instantiation</a>). Кроме того, W3C Web Components CG исследует возможность расширения Web Components для предоставления полностью декларативного HTML API. Для достижения обеих целей HTML в итоге понадобится реактивный примитив. Также можно представить себе множество эргономичных улучшений DOM за счёт интеграции сигналов, и сообщество уже выражало такой запрос.</p>
<blockquote>
<p>Примечание: эта интеграция будет отдельным проектом в будущем, не частью текущего предложения.</p>
</blockquote>
<h5>Обмен информацией в экосистеме (<em>не</em> причина для внедрения)</h5>
<p>Стандартизация может быть полезна и на уровне &quot;сообщества&quot;, даже без изменений в браузерах. Работа над сигналами объединяет авторов многих разных фреймворков для глубокого обсуждения природы реактивности, алгоритмов и совместимости. Это уже оказалось полезным, но не оправдывает включение в JS-движки и браузеры; сигналы должны добавляться в стандарт JavaScript только при наличии значительных преимуществ <em>помимо</em> обмена знаниями в экосистеме.</p>
<h2>Цели проектирования сигналов</h2>
<p>Оказалось, что существующие библиотеки сигналов в своей основе не так уж сильно отличаются друг от друга. Это предложение нацелено на развитие их успеха за счёт реализации важных качеств многих из них.</p>
<h3>Основные возможности</h3>
<ul>
<li>Тип &quot;сигнал&quot;, представляющий состояние, то есть записываемый сигнал. Это значение, которое могут читать другие.</li>
<li>Тип вычисляемого/мемо/производного сигнала, который зависит от других и вычисляется лениво и кэшируется.
<ul>
<li>Вычисление ленивое, то есть вычисляемые сигналы по умолчанию не пересчитываются при изменении одной из зависимостей, а только если кто-то их реально читает.</li>
<li>Вычисление &quot;без <a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">глюков</a>&quot;, то есть никогда не выполняются ненужные вычисления. Это подразумевает, что при чтении вычисляемого сигнала приложение производит топологическую сортировку потенциально &quot;грязных&quot; частей графа для устранения дубликатов.</li>
<li>Вычисление кэшируется: если после последнего изменения зависимости ни одна из них не изменилась, то вычисляемый сигнал <em>не</em> пересчитывается при доступе.</li>
<li>Для вычисляемых сигналов, как и для сигнала-состояния, возможны пользовательские сравнения, чтобы определять, должны ли обновляться дальнейшие вычисляемые сигналы, зависящие от них.</li>
</ul>
</li>
<li>Реакции на ситуацию, когда у вычисляемого сигнала одна из зависимостей (или вложенных зависимостей) становится &quot;грязной&quot; и меняется, что может означать устаревшее значение сигнала.
<ul>
<li>Такая реакция предназначена для планирования более значительной работы в будущем.</li>
<li>Эффекты реализуются на основе этих реакций плюс планирования на уровне фреймворка.</li>
<li>Вычисляемым сигналам нужна возможность реагировать на регистрацию в качестве (вложенной) зависимости одной из этих реакций.</li>
</ul>
</li>
<li>Позволить JS-фреймворкам выполнять собственное планирование. Не должно быть навязанного Promise-стиля планирования.
<ul>
<li>Синхронные реакции нужны, чтобы планировать дальнейшую работу на основе логики фреймворка.</li>
<li>Записи происходят синхронно и вступают в силу сразу (фреймворк, который делает батчинг, может реализовать это поверх).</li>
<li>Возможно отделить проверку &quot;грязности&quot; эффекта от его фактического выполнения (что позволяет реализовать двухэтапный планировщик эффектов).</li>
</ul>
</li>
<li>Возможность читать сигналы <em>без</em> записи зависимостей (<code>untrack</code>)</li>
<li>Возможность композирования различных кодовых баз, использующих сигналы/реактивность, например,
<ul>
<li>Использование нескольких фреймворков вместе (в части отслеживания/реактивности; с оговорками, см. ниже)</li>
<li>Независимые от фреймворка реактивные структуры данных (например, рекурсивно реактивный стор proxy, реактивные Map, Set и Array и т. д.)</li>
</ul>
</li>
</ul>
<h3>Корректность (Soundness)</h3>
<ul>
<li>Предотвращать/запрещать наивное неправильное использование синхронных реакций.
<ul>
<li>Риск для корректности: это может привести к появлению &quot;<a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">глюков</a>&quot;, если использовать некорректно: если рендеринг происходит сразу при установке сигнала, это может привести к отображению неполного состояния приложения для пользователя. Поэтому эта функция должна использоваться только для грамотного планирования работы после завершения логики приложения.</li>
<li>Решение: Запретить чтение и запись любого сигнала из синхронного колбэка реакции</li>
</ul>
</li>
<li>Предостеречь от использования <code>untrack</code> и отметить его некорректность
<ul>
<li>Риск для корректности: позволяет создавать вычисляемые сигналы, чьё значение зависит от других сигналов, но которые не обновляются при изменении этих сигналов. Следует использовать, только если неотслеживаемые обращения не влияют на результат вычисления.</li>
<li>Решение: API помечен как &quot;unsafe&quot; в имени.</li>
</ul>
</li>
<li>Примечание: это предложение разрешает чтение и запись сигналов из вычисляемых и эффектовых сигналов без ограничения на записи, следующие за чтением, несмотря на риск для корректности. Это решение принято для сохранения гибкости и совместимости при интеграции с фреймворками.</li>
</ul>
<h3>Поверхностный API</h3>
<ul>
<li>Должен быть надёжной основой для различных фреймворков, реализующих свои механизмы сигналов/реактивности.
<ul>
<li>Должен быть хорошей базой для рекурсивных proxy-хранилищ, реактивности полей класса на основе декораторов, а также для API в стиле <code>.value</code> и <code>[state, setState]</code>.</li>
<li>Семантика должна позволять реализовать валидные паттерны, используемые разными фреймворками. Например, сигналы могут быть основой как немедленно отражаемых изменений, так и изменений, которые применяются позже батчингом.</li>
</ul>
</li>
<li>Было бы хорошо, если бы этот API был пригоден для непосредственного использования разработчиками JavaScript.
<ul>
<li>Если функция совпадает с концепцией из экосистемы, использование общего словаря — это хорошо.
<ul>
<li>Однако важно не повторять буквально одни и те же имена!</li>
</ul>
</li>
<li>Напряжённость между &quot;удобством для JS-разработчиков&quot; и &quot;предоставлением всех хуков для фреймворков&quot;
<ul>
<li>Идея: предоставить все хуки, но по возможности выдавать ошибки при неправильном использовании.</li>
<li>Идея: вынести тонкие API в пространство имён <code>subtle</code>, аналогично <a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle"><code>crypto.subtle</code></a>, чтобы отметить грань между API, необходимыми для более продвинутого использования (реализация фреймворка, разработка devtools), и более повседневной разработкой приложений (создание сигналов для использования с фреймворком).</li>
</ul>
</li>
</ul>
</li>
<li>Должен быть реализуемым и эффективным — поверхностный API не должен вносить значительных накладных расходов
<ul>
<li>Должна быть возможность наследования, чтобы фреймворки могли добавлять свои методы и поля, включая приватные поля. Это важно для предотвращения дополнительных аллокаций на уровне фреймворка. См. &quot;Управление памятью&quot; ниже.</li>
</ul>
</li>
</ul>
<h3>Управление памятью</h3>
<ul>
<li>Если возможно: вычисляемый сигнал должен быть удаляемым сборщиком мусора, если на него нет живых ссылок для возможных будущих чтений, даже если он связан с более широким графом, который остаётся живым (например, путём чтения состояния, которое остаётся живым).</li>
<li>Обратите внимание, что большинство современных фреймворков требует явного уничтожения вычисляемых сигналов, если они имеют какую-либо ссылку на другой граф сигналов, который остаётся живым.</li>
<li>Это оказывается не такой уж большой проблемой, когда их время жизни связано со временем жизни UI-компонента, и эффекты всё равно нужно уничтожать.</li>
<li>Если выполнение с такой семантикой оказывается слишком затратным, то следует добавить явное уничтожение (или «отвязку») вычисляемых сигналов в API ниже, где этого сейчас нет.</li>
<li>Отдельная сопутствующая цель: минимизировать количество аллокаций, например,
<ul>
<li>чтобы сделать записываемый сигнал (избежать двух отдельных замыканий + массива)</li>
<li>чтобы реализовать эффекты (избежать замыкания для каждой отдельной реакции)</li>
<li>в API для отслеживания изменений сигналов избегать создания дополнительных временных структур данных</li>
<li>Решение: API на основе классов, позволяющий переиспользовать методы и поля, определённые в подклассах</li>
</ul>
</li>
</ul>
<h2>Эскиз API</h2>
<p>Ниже приведена начальная идея API сигналов. Обратите внимание, что это всего лишь ранний черновик, и мы ожидаем изменений со временем. Давайте начнём с полного <code>.d.ts</code>, чтобы получить представление о структуре, а затем обсудим детали.</p>
<pre><code class="language-ts">interface Signal&lt;T&gt; {
    // Получить значение сигнала
    get(): T;
}

namespace Signal {
    // Сигнал с возможностью чтения и записи
    class State&lt;T&gt; implements Signal&lt;T&gt; {
        // Создать сигнал состояния с начальным значением t
        constructor(t: T, options?: SignalOptions&lt;T&gt;);

        // Получить значение сигнала
        get(): T;

        // Установить значение сигнала состояния в t
        set(t: T): void;
    }

    // Сигнал, являющийся формулой на основе других сигналов
    class Computed&lt;T = unknown&gt; implements Signal&lt;T&gt; {
        // Создать сигнал, который вычисляется как результат обратного вызова.
        // Обратный вызов вызывается с этим сигналом в качестве this.
        constructor(cb: (this: Computed&lt;T&gt;) =&gt; T, options?: SignalOptions&lt;T&gt;);

        // Получить значение сигнала
        get(): T;
    }

    // Это пространство имён включает «продвинутые» возможности, которые лучше
    // оставить авторам фреймворков, а не разработчикам приложений.
    // Аналогично `crypto.subtle`
    namespace subtle {
        // Выполнить обратный вызов с отключённым трекингом
        function untrack&lt;T&gt;(cb: () =&gt; T): T;

        // Получить текущий вычисляемый сигнал, который отслеживает чтения сигналов, если есть такой
        function currentComputed(): Computed | null;

        // Возвращает упорядоченный список всех сигналов, к которым этот обращался
        // во время последнего вычисления.
        // Для Watcher возвращает набор сигналов, за которыми он следит.
        function introspectSources(s: Computed | Watcher): (State | Computed)[];

        // Возвращает Watcher'ы, в которые входит этот сигнал, а также все
        // вычисляемые сигналы, которые читали этот сигнал при последнем вычислении,
        // если этот вычисляемый сигнал (рекурсивно) наблюдается.
        function introspectSinks(s: State | Computed): (Computed | Watcher)[];

        // Истинно, если сигнал «живой», то есть за ним следит Watcher,
        // или его читает вычисляемый сигнал, который (рекурсивно) жив.
        function hasSinks(s: State | Computed): boolean;

        // Истинно, если элемент «реактивный», то есть зависит
        // от какого-либо другого сигнала. Computed с hasSources == false
        // всегда будет возвращать одну и ту же константу.
        function hasSources(s: Computed | Watcher): boolean;

        class Watcher {
            // Когда (рекурсивный) источник Watcher изменяется, вызывается этот обратный вызов,
            // если он ещё не был вызван с момента последнего вызова `watch`.
            // Во время notify нельзя читать или писать сигналы.
            constructor(notify: (this: Watcher) =&gt; void);

            // Добавить эти сигналы в набор Watcher и установить Watcher для выполнения
            // notify при следующем изменении любого сигнала в наборе (или его зависимостей).
            // Можно вызвать без аргументов, чтобы просто сбросить состояние «уведомлено»,
            // чтобы notify был вызван снова.
            watch(...s: Signal[]): void;

            // Удалить эти сигналы из набора (например, для эффекта, который уничтожается)
            unwatch(...s: Signal[]): void;

            // Возвращает набор источников в наборе Watcher, которые всё ещё «грязные», либо вычисляемый сигнал,
            // у которого источник грязный или ожидает и ещё не был пересчитан
            getPending(): Signal[];
        }

        // Хуки для отслеживания момента, когда за сигналом начинают или перестают следить
        var watched: Symbol;
        var unwatched: Symbol;
    }

    interface SignalOptions&lt;T&gt; {
        // Пользовательская функция сравнения между старым и новым значением. По умолчанию: Object.is.
        // Сигнал передаётся как this для контекста.
        equals?: (this: Signal&lt;T&gt;, t: T, t2: T) =&gt; boolean;
```ts
// Callback вызывается, когда isWatched становится true, если ранее было false
[Signal.subtle.watched]?: (this: Signal&lt;T&gt;) =&gt; void;

// Callback вызывается каждый раз, когда isWatched становится false, если ранее было true
[Signal.subtle.unwatched]?: (this: Signal&lt;T&gt;) =&gt; void;
}
}
</code></pre>
<h3>Как работают сигналы</h3>
<p>Сигнал представляет собой ячейку данных, которые могут изменяться со временем. Сигналы могут быть либо &quot;состоянием&quot; (просто значение, устанавливаемое вручную), либо &quot;вычисляемым&quot; (формула на основе других сигналов).</p>
<p>Вычисляемые сигналы работают путем автоматического отслеживания, какие другие сигналы были прочитаны во время их вычисления. Когда происходит чтение вычисляемого сигнала, он проверяет, изменились ли какие-либо из его ранее зафиксированных зависимостей, и, если да — переоценивает себя. Когда несколько вычисляемых сигналов вложены друг в друга, вся атрибуция отслеживания уходит к самому внутреннему.</p>
<p>Вычисляемые сигналы являются ленивыми, то есть работают по принципу &quot;pull&quot;: они пересчитываются только тогда, когда к ним обращаются, даже если одна из их зависимостей изменилась ранее.</p>
<p>Callback, передаваемый в вычисляемые сигналы, должен быть, как правило, &quot;чистым&quot; в смысле детерминированной, не имеющей побочных эффектов функции от других сигналов, к которым осуществляется доступ. В то же время, момент вызова callback является детерминированным, что позволяет использовать побочные эффекты с осторожностью.</p>
<p>Сигналы имеют заметное кеширование/мемоизацию: как состояние, так и вычисляемые сигналы запоминают свое текущее значение и инициируют пересчет только тех вычисляемых сигналов, которые на них ссылаются, если они действительно изменились. Повторное сравнение старых и новых значений даже не требуется — сравнение производится один раз при сбросе/переоценке исходного сигнала, и механизм сигналов отслеживает, какие элементы, ссылающиеся на этот сигнал, еще не обновились на основе нового значения. Внутренне это, как правило, реализуется с помощью &quot;раскраски графа&quot;, как описано в (блоге Milo).</p>
<p>Вычисляемые сигналы динамически отслеживают свои зависимости — каждый раз при запуске они могут зависеть от разных элементов, и этот точный набор зависимостей поддерживается в актуальном состоянии в графе сигналов. Это означает, что если у вас есть зависимость, необходимая только на одной ветке, а предыдущее вычисление шло по другой ветке, то изменение этой временно неиспользуемой переменной не вызовет пересчета вычисляемого сигнала, даже если будет обращение к нему.</p>
<p>В отличие от JavaScript Promise, все в сигналах выполняется синхронно:</p>
<ul>
<li>Установка нового значения сигнала происходит синхронно, и это немедленно отражается при чтении любого вычисляемого сигнала, который от него зависит. Встроенной пакетной обработки изменений нет.</li>
<li>Чтение вычисляемых сигналов синхронно — их значение всегда доступно.</li>
<li>Callback <code>notify</code> в Watchers, как объяснено ниже, выполняется синхронно во время вызова <code>.set()</code>, который его вызвал (но после завершения раскраски графа).</li>
</ul>
<p>Как и Promises, сигналы могут представлять состояние ошибки: если callback вычисляемого сигнала выбрасывает исключение, то эта ошибка кешируется как обычное значение и будет выбрасываться снова при каждом чтении сигнала.</p>
<h3>Понимание класса Signal</h3>
<p>Экземпляр <code>Signal</code> представляет возможность читать динамически изменяющееся значение, обновления которого отслеживаются во времени. Он также неявно включает возможность подписки на сигнал через отслеживаемый доступ из другого вычисляемого сигнала.</p>
<p>Данный API разработан, чтобы соответствовать приблизительному консенсусу в экосистеме сигналов относительно использования таких названий, как &quot;signal&quot;, &quot;computed&quot; и &quot;state&quot;. Однако доступ к вычисляемым и состояниям сигналам осуществляется через метод <code>.get()</code>, что расходится со всеми популярными API сигналов, которые используют либо аксессор <code>.value</code>, либо синтаксис вызова <code>signal()</code>.</p>
<p>API спроектирован для уменьшения числа выделений памяти, чтобы сделать сигналы пригодными для внедрения в JavaScript-фреймворки с производительностью, не уступающей или превосходящей существующие специализированные сигналы. Это означает:</p>
<ul>
<li>Сигналы состояния — это один изменяемый объект, к которому можно обращаться и который можно изменять из одной и той же ссылки. (См. последствия ниже в разделе &quot;Разделение возможностей&quot;.)</li>
<li>Как сигналы состояния, так и вычисляемые сигналы спроектированы так, чтобы их можно было наследовать, облегчая фреймворкам добавление дополнительных свойств через публичные и приватные поля класса (а также методы для работы с этим состоянием).</li>
<li>Различные callback (например, <code>equals</code>, callback вычисляемого сигнала) вызываются с соответствующим сигналом в качестве значения <code>this</code> для контекста, чтобы не создавать новую замыкание для каждого сигнала. Вместо этого контекст можно хранить в дополнительных свойствах самого сигнала.</li>
</ul>
<p>Некоторые условия ошибок, обеспечиваемые этим API:</p>
<ul>
<li>Ошибка — рекурсивное чтение вычисляемого сигнала.</li>
<li>Callback <code>notify</code> у Watcher не может читать или записывать любые сигналы.</li>
<li>Если callback вычисляемого сигнала выбрасывает исключение, то все последующие обращения к сигналу будут выбрасывать сохраненную ошибку, пока одна из зависимостей не изменится и не произойдет пересчет.</li>
</ul>
<p>Некоторые условия, которые <em>не</em> контролируются:</p>
<ul>
<li>Вычисляемые сигналы могут записывать в другие сигналы синхронно в своем callback.</li>
<li>Работа, поставленная в очередь callback-ом <code>notify</code> Watcher, может читать или записывать сигналы, что позволяет воспроизвести <a href="https://react.dev/learn/you-might-not-need-an-effect">классические антипаттерны React</a> в терминах сигналов!</li>
</ul>
<h3>Реализация эффектов</h3>
<p>Интерфейс <code>Watcher</code>, определенный выше, служит основой для реализации типичных JS-API для эффектов: callback-ов, которые повторно выполняются при изменении других сигналов, исключительно ради побочных эффектов. Функция <code>effect</code>, используемая выше в исходном примере, может быть определена следующим образом:</p>
<pre><code class="language-ts">// Эта функция обычно живет в библиотеке/фреймворке, а не в прикладном коде
// ПРИМЕЧАНИЕ: Эта логика планирования слишком проста для реального использования. Не копируйте.
let pending = false;

let w = new Signal.subtle.Watcher(() =&gt; {
    if (!pending) {
        pending = true;
        queueMicrotask(() =&gt; {
            pending = false;
            for (let s of w.getPending()) s.get();
            w.watch();
        });
    }
});

// Эффектный сигнал, который вычисляется до cb и планирует чтение себя в микротаске,
// всякий раз, когда одна из его зависимостей может измениться
export function effect(cb) {
    let destructor;
    let c = new Signal.Computed(() =&gt; { destructor?.(); destructor = cb(); });
    w.watch(c);
    c.get();
    return () =&gt; { destructor?.(); w.unwatch(c) };
}
</code></pre>
<p>В API сигналов не включена никакая встроенная функция вроде <code>effect</code>. Это связано с тем, что планирование эффектов тонко и часто связано с циклами рендеринга фреймворков и другим специфическим для фреймворков состоянием или стратегиями, к которым JS не имеет доступа.</p>
<p>Разберем различные операции, используемые здесь: Callback <code>notify</code>, переданный в конструктор <code>Watcher</code>, — это функция, вызываемая, когда сигнал переходит из &quot;чистого&quot; состояния (когда мы знаем, что кеш инициализирован и валиден) в &quot;проверенное&quot; или &quot;грязное&quot; состояние (когда кеш может быть или не быть валидным, потому что хотя бы одно из состояний, от которых он рекурсивно зависит, изменено).</p>
<p>Вызовы <code>notify</code> в конечном итоге инициируются вызовом <code>.set()</code> на каком-либо сигнале состояния. Этот вызов синхронный: происходит до возврата из <code>.set</code>. Но не нужно беспокоиться о том, что этот callback увидит граф сигналов в полупереработанном состоянии, потому что во время callback-а <code>notify</code> никакой сигнал не может быть прочитан или записан, даже в вызове <code>untrack</code>. Поскольку <code>notify</code> вызывается в процессе <code>.set()</code>, это прерывает другой поток логики, который может быть еще не завершен. Чтобы читать или записывать сигналы из <code>notify</code>, планируйте работу на потом, например, записав сигнал в список для последующего доступа или с помощью <code>queueMicrotask</code>, как показано выше.</p>
<p>Обратите внимание, что вполне возможно эффективно использовать сигналы без <code>Signal.subtle.Watcher</code>, планируя опрос вычисляемых сигналов, как это делает Glimmer. Однако многие фреймворки обнаружили, что часто бывает полезно выполнять такую логику синхронно, поэтому API сигналов ее включает.</p>
<p>Как вычисляемые, так и сигналы состояния собираются сборщиком мусора как любые значения JS. Но Watcher имеют особый способ удержания объектов: любые сигналы, отслеживаемые Watcher, будут удерживаться в памяти до тех пор, пока какие-либо из нижележащих состояний достижимы, так как они могут инициировать будущий вызов <code>notify</code> (и затем будущий вызов <code>.get()</code>). Поэтому не забывайте вызывать <code>Watcher.prototype.unwatch</code> для очистки эффектов.</p>
<h3>Небезопасный escape hatch</h3>
<p><code>Signal.subtle.untrack</code> — это лазейка, позволяющая читать сигналы <em>без</em> отслеживания этих чтений. Эта возможность небезопасна, потому что позволяет создавать вычисляемые сигналы, чье значение зависит от других сигналов, но которые не обновляются при изменении этих сигналов. Ее следует использовать только тогда, когда неотслеживаемые обращения не повлияют на результат вычисления.</p>
<!--
TODO: Привести пример, где имеет смысл использовать untrack

### Использование watched/unwatched
TODO: Показать пример преобразования Observable в вычисляемый сигнал, на который подписываются только при использовании эффектом

TODO: Показать пример вычисляемого сигнала, который представляет результат fetch, направленного на состояние, который отменяется

### Интроспекция для SSR

TODO: Показать, как работает сериализация графа сигналов

TODO: Показать, как можно «гидратировать» сигнал от состояния к вычисляемому позже, используя несколько сигналов.
-->
<h3>Пока опущено</h3>
<p>Эти возможности могут быть добавлены позже, но в текущем черновике они отсутствуют. Их опущение связано с отсутствием устоявшегося консенсуса в области проектирования между фреймворками, а также с продемонстрированной способностью обходиться без них с помощью механизмов, построенных поверх концепции Signals, описанной в этом документе. Однако, к сожалению, их отсутствие ограничивает потенциал для взаимодействия между фреймворками. По мере создания прототипов Signals, описанных в этом документе, будет предпринята попытка пересмотреть, было ли это опущение правильным решением.</p>
<ul>
<li><strong>Асинхронность</strong>: В этой модели сигналы всегда доступны для синхронной оценки. Однако часто бывает полезно иметь определённые асинхронные процессы, которые приводят к установке сигнала, и понимать, когда сигнал всё ещё «загружается». Один из простых способов смоделировать состояние загрузки — использовать исключения, и поведение кэширования исключений в вычисляемых сигналах довольно разумно сочетается с этим приёмом. Улучшенные техники обсуждаются в <a href="https://github.com/proposal-signals/proposal-signals/issues/30">Issue #30</a>.</li>
<li><strong>Транзакции</strong>: Для переходов между представлениями часто бывает полезно поддерживать активное состояние как для состояния «откуда», так и «куда». Состояние «куда» отображается в фоновом режиме, пока не будет готово к переключению (коммиту транзакции), а состояние «откуда» остаётся интерактивным. Для одновременного поддержания обоих состояний требуется «форкать» состояние графа сигналов, и может даже быть полезно поддерживать несколько ожидающих переходов одновременно. Обсуждение в <a href="https://github.com/proposal-signals/proposal-signals/issues/73">Issue #73</a>.</li>
</ul>
<p>Также опущены некоторые возможные <a href="https://github.com/proposal-signals/proposal-signals/issues/32">вспомогательные методы</a>.</p>
<h2>Статус и план разработки</h2>
<p>Это предложение включено в повестку дня TC39 на апрель 2024 года для Stage 1. В настоящее время его можно рассматривать как «Stage 0».</p>
<p><a href="https://github.com/proposal-signals/signal-polyfill">Полифил</a> для этого предложения доступен с некоторыми базовыми тестами. Некоторые авторы фреймворков начали экспериментировать с заменой своей реализации сигналов на эту, но это использование пока находится на ранней стадии.</p>
<p>Участники работы над предложением Signal хотят быть особенно <strong>консервативными</strong> в продвижении этого предложения, чтобы не попасть в ловушку, когда что-то внедряется, а затем оказывается бесполезным. Наш план — выполнить следующие дополнительные задачи, не требуемые процессом TC39, чтобы убедиться, что предложение находится на правильном пути:</p>
<p>Перед переходом на Stage 2 мы планируем:</p>
<ul>
<li>Разработать несколько полифильных реализаций промышленного уровня, которые будут надёжными, хорошо протестированными (например, проходят тесты различных фреймворков, а также тесты в стиле test262), и конкурентоспособными по производительности (что подтверждено тщательным набором бенчмарков сигналов/фреймворков).</li>
<li>Интегрировать предлагаемое API Signal в большое количество JS-фреймворков, которые мы считаем в какой-то степени репрезентативными, а также чтобы некоторые крупные приложения работали на этой основе. Протестировать, что оно работает эффективно и корректно в этих контекстах.</li>
<li>Иметь чёткое понимание пространства возможных расширений API и прийти к выводу, какие из них (если вообще какие-то) стоит включить в это предложение.</li>
</ul>
<h2>Алгоритмы сигналов</h2>
<p>В этом разделе описывается каждый из API, доступных для JavaScript, с точки зрения реализуемых ими алгоритмов. Это можно рассматривать как протоспецификацию и включено на этом раннем этапе, чтобы закрепить возможный набор семантики, при этом оставляя пространство для изменений.</p>
<p>Некоторые особенности алгоритма:</p>
<ul>
<li>Порядок чтения сигналов внутри вычисления имеет значение и наблюдаем в порядке выполнения определённых обратных вызовов (вызывается <code>Watcher</code>, <code>equals</code>, первый параметр в <code>new Signal.Computed</code> и обратные вызовы <code>watched</code>/<code>unwatched</code>). Это значит, что источники вычисляемого сигнала должны храниться в определённом порядке.</li>
<li>Все эти четыре обратных вызова могут выбрасывать исключения, и эти исключения передаются вызывающему JS-коду предсказуемым образом. Исключения <em>не</em> останавливают выполнение этого алгоритма и не оставляют граф в полуобработанном состоянии. Для ошибок, возникших в обратном вызове <code>notify</code> у Watcher, это исключение передаётся в вызов <code>.set()</code>, который его вызвал, используя AggregateError, если исключений было несколько. Остальные (включая <code>watched</code>/<code>unwatched</code>?) сохраняются в значении сигнала, чтобы быть повторно выброшенными при чтении, и такой повторно выбрасываемый сигнал может быть помечен как <code>~clean~</code> так же, как и любой другой с обычным значением.</li>
<li>Предусмотрены меры по предотвращению циклических зависимостей в случаях вычисляемых сигналов, которые не «наблюдаются» (не отслеживаются никаким Watcher), чтобы их можно было собрать сборщиком мусора независимо от других частей графа сигналов. Внутренне это можно реализовать с помощью системы номеров поколений, которые всегда собираются; обратите внимание, что оптимизированные реализации могут также включать локальные номера поколений для отдельных узлов или не отслеживать некоторые номера для наблюдаемых сигналов.</li>
</ul>
<h3>Скрытое глобальное состояние</h3>
<p>Алгоритмы Signal должны обращаться к определённому глобальному состоянию. Это состояние глобально для всего потока или «агента».</p>
<ul>
<li><code>computing</code>: Самый внутренний вычисляемый или эффектный сигнал, который в данный момент пересчитывается из-за вызова <code>.get</code> или <code>.run</code>, либо <code>null</code>. Изначально <code>null</code>.</li>
<li><code>frozen</code>: Булево значение, обозначающее, выполняется ли в данный момент обратный вызов, который требует, чтобы граф не изменялся. Изначально <code>false</code>.</li>
<li><code>generation</code>: Инкрементируемое целое число, начинающееся с 0, используется для отслеживания актуальности значения и предотвращения циклических зависимостей.</li>
</ul>
<h3>Пространство имён <code>Signal</code></h3>
<p><code>Signal</code> — это обычный объект, который служит пространством имён для классов и функций, связанных с Signal.</p>
<p><code>Signal.subtle</code> — подобный внутренний объект-пространство имён.</p>
<h3>Класс <code>Signal.State</code></h3>
<h4>Внутренние слоты <code>Signal.State</code></h4>
<ul>
<li><code>value</code>: Текущее значение сигнала состояния</li>
<li><code>equals</code>: Функция сравнения, используемая при изменении значений</li>
<li><code>watched</code>: Обратный вызов, вызываемый, когда сигнал становится отслеживаемым эффектом</li>
<li><code>unwatched</code>: Обратный вызов, вызываемый, когда сигнал больше не отслеживается эффектом</li>
<li><code>sinks</code>: Множество отслеживаемых сигналов, зависящих от этого</li>
</ul>
<h4>Конструктор: <code>Signal.State(initialValue, options)</code></h4>
<ol>
<li>Установить <code>value</code> этого сигнала в <code>initialValue</code>.</li>
<li>Установить <code>equals</code> этого сигнала в options?.equals</li>
<li>Установить <code>watched</code> этого сигнала в options?.[Signal.subtle.watched]</li>
<li>Установить <code>unwatched</code> этого сигнала в options?.[Signal.subtle.unwatched]</li>
<li>Установить <code>sinks</code> этого сигнала в пустое множество</li>
</ol>
<h4>Метод: <code>Signal.State.prototype.get()</code></h4>
<ol>
<li>Если <code>frozen</code> истинно, выбросить исключение.</li>
<li>Если <code>computing</code> не <code>undefined</code>, добавить этот сигнал в множество <code>sources</code> у <code>computing</code>.</li>
<li>ПРИМЕЧАНИЕ: Мы не добавляем <code>computing</code> в множество <code>sinks</code> этого сигнала, пока на него не подпишется Watcher.</li>
<li>Вернуть значение этого сигнала.</li>
</ol>
<h4>Метод: <code>Signal.State.prototype.set(newValue)</code></h4>
<ol>
<li>Если текущий контекст выполнения находится в состоянии <code>frozen</code>, выбросить исключение.</li>
<li>Выполнить алгоритм «установки значения сигнала» с этим сигналом и первым параметром в качестве значения.</li>
<li>Если этот алгоритм вернул <code>~clean~</code>, вернуть undefined.</li>
<li>Установить состояние всех <code>sinks</code> этого сигнала в (если это вычисляемый сигнал) <code>~dirty~</code>, если они были ранее чистыми, или (если это Watcher) <code>~pending~</code>, если ранее были в состоянии <code>~watching~</code>.</li>
<li>Рекурсивно установить состояние всех зависимостей вычисляемых сигналов sinks в <code>~checked~</code>, если они были ранее <code>~clean~</code> (оставляя грязные метки на месте), или для Watchers — <code>~pending~</code>, если ранее были <code>~watching~</code>.</li>
<li>Для каждого ранее <code>~watching~</code> Watcher, найденного при этом рекурсивном поиске, затем в порядке обхода в глубину:
<ol>
<li>Установить <code>frozen</code> в true.</li>
<li>Вызвать их обратный вызов <code>notify</code> (сохраняя любое выброшенное исключение, но игнорируя возвращаемое значение <code>notify</code>).</li>
<li>Восстановить <code>frozen</code> в false.</li>
<li>Установить состояние Watcher в <code>~waiting~</code>.</li>
</ol>
</li>
<li>Если какой-либо обратный вызов <code>notify</code> выбросил исключение, передать его вызывающему после завершения всех <code>notify</code>. Если исключений несколько, собрать их в AggregateError и выбросить его.</li>
<li>Вернуть undefined.</li>
</ol>
<h3>Класс <code>Signal.Computed</code></h3>
<h4>Состояния автомата <code>Signal.Computed</code></h4>
<p>Состояние (<code>state</code>) вычисляемого сигнала (Computed Signal) может быть одним из следующих:</p>
<ul>
<li><code>~clean~</code>: Значение сигнала присутствует и гарантированно не устарело.</li>
<li><code>~checked~</code>: (Косвенный) источник этого сигнала изменился; у сигнала есть значение, но оно <em>может</em> быть устаревшим. Является ли оно устаревшим, станет известно только после оценки всех непосредственных источников.</li>
<li><code>~computing~</code>: В данный момент выполняется обратный вызов (callback) этого сигнала как побочный эффект вызова <code>.get()</code>.</li>
<li><code>~dirty~</code>: Либо у этого сигнала есть значение, которое гарантированно устарело, либо он никогда не вычислялся.</li>
</ul>
<p>Граф переходов выглядит следующим образом:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; dirty
    dirty --&gt; computing: [4]
    computing --&gt; clean: [5]
    clean --&gt; dirty: [2]
    clean --&gt; checked: [3]
    checked --&gt; clean: [6]
    checked --&gt; dirty: [1]
</code></pre>
<p>Переходы:
| Номер | Откуда | Куда | Условие | Алгоритм |
| ----- | ------ | ---- | ------- | -------- |
| 1 | <code>~checked~</code> | <code>~dirty~</code> | Был оценен непосредственный источник этого сигнала, который сам является вычисляемым сигналом, и его значение изменилось. | Алгоритм: пересчитать устаревший вычисляемый сигнал |
| 2 | <code>~clean~</code> | <code>~dirty~</code> | Был установлен непосредственный источник этого сигнала, который является состоянием (State), с новым значением, не равным предыдущему. | Метод: <code>Signal.State.prototype.set(newValue)</code> |
| 3 | <code>~clean~</code> | <code>~checked~</code> | Рекурсивный, но не непосредственный, источник этого сигнала, который является состоянием (State), был установлен с новым значением, не равным предыдущему. | Метод: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~dirty~</code> | <code>~computing~</code> | Сейчас будет выполнен <code>callback</code>. | Алгоритм: пересчитать устаревший вычисляемый сигнал |
| 5 | <code>~computing~</code> | <code>~clean~</code> | <code>callback</code> завершил вычисление и вернул значение либо сгенерировал исключение. | Алгоритм: пересчитать устаревший вычисляемый сигнал |
| 6 | <code>~checked~</code> | <code>~clean~</code> | Все непосредственные источники этого сигнала были оценены, и все остались неизменными, значит, сигнал гарантированно не устарел. | Алгоритм: пересчитать устаревший вычисляемый сигнал |</p>
<h4>Внутренние слоты <code>Signal.Computed</code></h4>
<ul>
<li><code>value</code>: Предыдущее кэшированное значение сигнала или <code>~uninitialized~</code> для вычисляемого сигнала, который ни разу не читался. Значением может быть исключение, которое будет выброшено при чтении значения. Для сигналов-эффектов всегда <code>undefined</code>.</li>
<li><code>state</code>: Может быть <code>~clean~</code>, <code>~checked~</code>, <code>~computing~</code> или <code>~dirty~</code>.</li>
<li><code>sources</code>: Упорядоченное множество сигналов, от которых зависит этот сигнал.</li>
<li><code>sinks</code>: Упорядоченное множество сигналов, которые зависят от этого сигнала.</li>
<li><code>equals</code>: Метод сравнения, переданный в опциях.</li>
<li><code>callback</code>: Функция обратного вызова, вызываемая для получения значения вычисляемого сигнала. Устанавливается первым параметром конструктора.</li>
</ul>
<h4>Конструктор <code>Signal.Computed</code></h4>
<p>Конструктор устанавливает:</p>
<ul>
<li><code>callback</code> в значение первого параметра</li>
<li><code>equals</code> согласно опциям, по умолчанию <code>Object.is</code>, если не указано</li>
<li><code>state</code> в <code>~dirty~</code></li>
<li><code>value</code> в <code>~uninitialized~</code></li>
</ul>
<p>С использованием <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a>, callback, переданный в <code>new Signal.Computed</code>, замыкает снимок состояния (snapshot) на момент вызова конструктора и восстанавливает его во время выполнения.</p>
<h4>Метод: <code>Signal.Computed.prototype.get</code></h4>
<ol>
<li>Если текущий контекст выполнения <code>frozen</code> или если у этого сигнала состояние <code>~computing~</code>, или если этот сигнал является Watcher и происходит вычисление вычисляемого сигнала, выбросить исключение.</li>
<li>Если <code>computing</code> не <code>null</code>, добавить этот сигнал в множество <code>sources</code> сигнала <code>computing</code>.</li>
<li>ПРИМЕЧАНИЕ: Мы не добавляем <code>computing</code> в множество <code>sinks</code> этого сигнала до тех пор, пока он не будет отслежен (watched) Watcher'ом.</li>
<li>Если состояние этого сигнала <code>~dirty~</code> или <code>~checked~</code>: Повторять следующие шаги, пока состояние этого сигнала не станет <code>~clean~</code>:
<ol>
<li>Рекурсивно пройти вверх по <code>sources</code>, чтобы найти самый глубокий, левый (то есть самый ранее обнаруженный) рекурсивный источник, который является вычисляемым сигналом в состоянии <code>~dirty~</code> (прервать поиск при встрече <code>~clean~</code> вычисляемого сигнала; включить этот вычисляемый сигнал как последний элемент поиска).</li>
<li>Выполнить алгоритм &quot;пересчитать устаревший вычисляемый сигнал&quot; для этого сигнала.</li>
</ol>
</li>
<li>На этом этапе состояние сигнала будет <code>~clean~</code>, и ни один рекурсивный источник не будет <code>~dirty~</code> или <code>~checked~</code>. Вернуть значение сигнала (<code>value</code>). Если значение — это исключение, выбросить это исключение.</li>
</ol>
<h3>Класс <code>Signal.subtle.Watcher</code></h3>
<h4>Состояния <code>Signal.subtle.Watcher</code></h4>
<p>Состояние (<code>state</code>) Watcher может быть одним из следующих:</p>
<ul>
<li><code>~waiting~</code>: Колбэк <code>notify</code> был вызван, или Watcher только что создан, но в данный момент не отслеживает ни одного сигнала.</li>
<li><code>~watching~</code>: Watcher активно отслеживает сигналы, но пока не произошло изменений, требующих вызова <code>notify</code>.</li>
<li><code>~pending~</code>: Зависимость Watcher изменилась, но колбэк <code>notify</code> еще не был вызван.</li>
</ul>
<p>Граф переходов выглядит следующим образом:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; waiting
    waiting --&gt; watching: [1]
    watching --&gt; waiting: [2]
    watching --&gt; pending: [3]
    pending --&gt; waiting: [4]
</code></pre>
<p>Переходы:
| Номер | Откуда | Куда | Условие | Алгоритм |
| ----- | ------ | ---- | ------- | -------- |
| 1 | <code>~waiting~</code> | <code>~watching~</code> | Был вызван метод <code>watch</code> Watcher'а. | Метод: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code> |
| 2 | <code>~watching~</code> | <code>~waiting~</code> | Был вызван метод <code>unwatch</code> Watcher'а и последний отслеживаемый сигнал был удален. | Метод: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code> |
| 3 | <code>~watching~</code> | <code>~pending~</code> | Отслеживаемый сигнал мог изменить значение. | Метод: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~pending~</code> | <code>~waiting~</code> | Был вызван колбэк <code>notify</code>. | Метод: <code>Signal.State.prototype.set(newValue)</code> |</p>
<h4>Внутренние слоты <code>Signal.subtle.Watcher</code></h4>
<ul>
<li><code>state</code>: Может быть <code>~watching~</code>, <code>~pending~</code> или <code>~waiting~</code></li>
<li><code>signals</code>: Упорядоченное множество сигналов, которые отслеживает этот Watcher</li>
<li><code>notifyCallback</code>: Колбэк, вызываемый при изменении чего-либо. Устанавливается первым параметром конструктора.</li>
</ul>
<h4>Конструктор: <code>new Signal.subtle.Watcher(callback)</code></h4>
<ol>
<li><code>state</code> устанавливается в <code>~waiting~</code>.</li>
<li><code>signals</code> инициализируется как пустое множество.</li>
<li><code>notifyCallback</code> устанавливается равным параметру callback.
С <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a> обратный вызов, переданный в <code>new Signal.subtle.Watcher</code>, <em>не</em> замыкается на снимке состояния в момент вызова конструктора, чтобы контекстная информация вокруг записи оставалась видимой.</li>
</ol>
<h4>Метод: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code></h4>
<ol>
<li>Если <code>frozen</code> истинно, выбросить исключение.</li>
<li>Если какой-либо из аргументов не является сигналом, выбросить исключение.</li>
<li>Добавить все аргументы в конец массива <code>signals</code> этого объекта.</li>
<li>Для каждого нового отслеживаемого сигнала, слева направо:
<ol>
<li>Добавить этот watcher как <code>sink</code> к этому сигналу.</li>
<li>Если это был первый sink, то рекурсивно пройтись по источникам, чтобы добавить этот сигнал как sink.</li>
<li>Установить <code>frozen</code> в true.</li>
<li>Вызвать обратный вызов <code>watched</code>, если он существует.</li>
<li>Восстановить <code>frozen</code> в false.</li>
</ol>
</li>
<li>Если <code>state</code> сигнала — <code>~waiting~</code>, то установить его в <code>~watching~</code>.</li>
</ol>
<h4>Метод: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code></h4>
<ol>
<li>Если <code>frozen</code> истинно, выбросить исключение.</li>
<li>Если какой-либо из аргументов не является сигналом или не отслеживается этим watcher, выбросить исключение.</li>
<li>Для каждого сигнала из аргументов, слева направо:
<ol>
<li>Удалить этот сигнал из множества <code>signals</code> этого Watcher.</li>
<li>Удалить этот Watcher из множества <code>sink</code> этого сигнала.</li>
<li>Если множество <code>sink</code> этого сигнала стало пустым, удалить этот сигнал как sink из каждого его источника.</li>
<li>Установить <code>frozen</code> в true.</li>
<li>Вызвать обратный вызов <code>unwatched</code>, если он существует.</li>
<li>Восстановить <code>frozen</code> в false.</li>
</ol>
</li>
<li>Если у watcher больше нет сигналов в <code>signals</code>, и его <code>state</code> — <code>~watching~</code>, установить его в <code>~waiting~</code>.</li>
</ol>
<h4>Метод: <code>Signal.subtle.Watcher.prototype.getPending()</code></h4>
<ol>
<li>Вернуть массив, содержащий подмножество сигналов из <code>signals</code>, которые являются вычисляемыми сигналами в состояниях <code>~dirty~</code> или <code>~pending~</code>.</li>
</ol>
<h3>Метод: <code>Signal.subtle.untrack(cb)</code></h3>
<ol>
<li>Пусть <code>c</code> — текущее значение <code>computing</code> в контексте исполнения.</li>
<li>Установить <code>computing</code> в null.</li>
<li>Вызвать <code>cb</code>.</li>
<li>Восстановить <code>computing</code> в <code>c</code> (даже если <code>cb</code> выбросил исключение).</li>
<li>Вернуть результат выполнения <code>cb</code> (или пробросить исключение).</li>
</ol>
<p>Примечание: untrack не выводит из состояния <code>frozen</code>, которое поддерживается строго.</p>
<h3>Метод: <code>Signal.subtle.currentComputed()</code></h3>
<ol>
<li>Вернуть текущее значение <code>computing</code>.</li>
</ol>
<h3>Общие алгоритмы</h3>
<h5>Алгоритм: пересчитать грязный вычисляемый сигнал</h5>
<ol>
<li>Очистить множество <code>sources</code> этого сигнала и удалить его из множеств <code>sinks</code> этих источников.</li>
<li>Сохранить предыдущее значение <code>computing</code> и установить <code>computing</code> в этот сигнал.</li>
<li>Установить состояние сигнала в <code>~computing~</code>.</li>
<li>Выполнить обратный вызов вычисляемого сигнала, используя этот сигнал как this. Сохранить возвращаемое значение и, если обратный вызов выбросил исключение, сохранить его для повторного выбрасывания.</li>
<li>Восстановить предыдущее значение <code>computing</code>.</li>
<li>Применить алгоритм &quot;установки значения сигнала&quot; к возвращаемому значению обратного вызова.</li>
<li>Установить состояние сигнала в <code>~clean~</code>.</li>
<li>Если алгоритм вернул <code>~dirty~</code>: пометить все sinks этого сигнала как <code>~dirty~</code> (ранее sinks могли быть смесью checked и dirty). (Или, если сигнал не отслеживается, принять новое поколение для указания &quot;грязности&quot; или что-то подобное.)</li>
<li>Иначе, если алгоритм вернул <code>~clean~</code>: для каждого sink этого сигнала в состоянии <code>~checked~</code>, если все его источники теперь чисты, то пометить этот сигнал как <code>~clean~</code> также. Применить этот шаг очистки к последующим sinks рекурсивно, для всех новых чистых сигналов, имеющих checked sinks. (Или, если сигнал не отслеживается, как-то обозначить это, чтобы очистка могла производиться лениво.)</li>
</ol>
<h5>Алгоритм установки значения сигнала</h5>
<ol>
<li>Если алгоритму передано значение (в отличие от исключения для повторного выбрасывания из алгоритма пересчёта грязного вычисляемого сигнала):
<ol>
<li>Вызвать функцию <code>equals</code> этого сигнала, передав текущий <code>value</code>, новое значение и сам сигнал. Если выброшено исключение, сохранить его (для повторного выбрасывания при чтении) как значение сигнала и продолжить, как если бы функция вернула false.</li>
<li>Если функция вернула true, вернуть <code>~clean~</code>.</li>
</ol>
</li>
<li>Установить <code>value</code> этого сигнала в переданное значение.</li>
<li>Вернуть <code>~dirty~</code></li>
</ol>
<h2>FAQ</h2>
<p><strong>В:</strong> Не слишком ли рано стандартизировать что-то, связанное с сигналами, когда они только начали набирать популярность в 2022 году? Не стоит ли дать им больше времени на развитие и стабилизацию?</p>
<p><strong>О:</strong> Текущее состояние сигналов во фреймворках для веба — результат более чем 10-летнего непрерывного развития. По мере того как инвестиции растут, как это было в последние годы, почти все фреймворки приходят к очень похожей основной модели сигналов. Это предложение — результат совместного проектирования между большим количеством лидеров современных веб-фреймворков, и оно не будет продвигаться к стандартизации без валидации этой группы экспертов в разных контекстах.</p>
<h4>Как используются сигналы?</h4>
<p><strong>В:</strong> Могут ли встроенные сигналы вообще использоваться фреймворками, учитывая их тесную интеграцию с рендерингом и владением?</p>
<p><strong>О:</strong> Части, которые больше зависят от фреймворков, обычно касаются эффектов, планирования и владения/освобождения ресурсов, и это предложение не пытается их решать. Наш главный приоритет при прототипировании сигналов для стандартизации — убедиться, что они могут &quot;лежать в основе&quot; существующих фреймворков совместимо и с хорошей производительностью.</p>
<p><strong>В:</strong> Предполагается ли, что API Signal будет использоваться напрямую разработчиками приложений или он предназначен для обёртывания фреймворками?</p>
<p><strong>О:</strong> Хотя этот API может использоваться напрямую разработчиками приложений (по крайней мере, та его часть, что не находится в пространстве имён <code>Signal.subtle</code>), он не рассчитан на особую эргономику. Вместо этого приоритеты отданы авторам библиотек/фреймворков. Ожидается, что большинство фреймворков обернут даже базовые API <code>Signal.State</code> и <code>Signal.Computed</code> в что-то более удобное. На практике обычно лучше использовать сигналы через фреймворк, который управляет сложными функциями (например, Watcher, <code>untrack</code>), а также владением и освобождением ресурсов (например, определяет, когда сигналы должны быть добавлены в watcher и удалены из них), и планированием рендеринга в DOM — это предложение не пытается решать эти задачи.</p>
<p><strong>В:</strong> Нужно ли явно уничтожать сигналы, связанные с виджетом, когда этот виджет уничтожается? Какой API для этого существует?</p>
<p><strong>О:</strong> Соответствующая операция уничтожения здесь — <code>Signal.subtle.Watcher.prototype.unwatch</code>. Только отслеживаемые сигналы нужно очищать (путём unwatch), а неотслеживаемые сигналы могут быть автоматически собраны сборщиком мусора.</p>
<p><strong>В:</strong> Работают ли сигналы с VDOM или напрямую с HTML DOM?</p>
<p><strong>О:</strong> Да! Сигналы независимы от технологии рендеринга. Существующие фреймворки на JavaScript, использующие конструкции, подобные сигналам, интегрируются с VDOM (например, Preact), нативным DOM (например, Solid) и их комбинациями (например, Vue). То же самое будет возможно и со встроенными сигналами.</p>
<p><strong>В:</strong> Будет ли удобно использовать сигналы во фреймворках, основанных на классах, таких как Angular и Lit? А как насчёт фреймворков на основе компилятора, таких как Svelte?</p>
<p><strong>О:</strong> Поля классов могут быть основаны на сигналах с помощью простого декоратора-аксессора, как показано в <a href="https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators">readme Signal polyfill</a>. Сигналы очень тесно связаны с рунами Svelte 5 — компилятору легко преобразовать руны в API сигналов, определённый здесь, и на самом деле именно так и поступает Svelte 5 (но со своей собственной библиотекой сигналов).</p>
<p><strong>В:</strong> Работают ли сигналы с SSR? Гидрацией? Восстанавливаемостью?</p>
<p><strong>О:</strong> Да. Qwik эффективно использует сигналы и для этих свойств, а другие фреймворки имеют хорошо проработанные подходы к гидрации с сигналами с разными компромиссами. Мы считаем, что можно смоделировать восстанавливаемые сигналы Qwik, используя связку State и Computed сигнала, и планируем доказать это на практике в коде.
<strong>В</strong>: Работают ли сигналы с однонаправленным потоком данных, как это делает React?</p>
<p><strong>О</strong>: Да, сигналы являются механизмом для однонаправленного потока данных. UI-фреймворки на основе сигналов позволяют выразить представление как функцию от модели (где модель включает сигналы). Граф состояний и вычисляемых сигналов по определению ацикличен. Также возможно воспроизвести анти-паттерны React в рамках сигналов (!), например, эквивалент сигнала для <code>setState</code> внутри <code>useEffect</code> — это использование Watcher для планирования записи в сигнальный State.</p>
<p><strong>В</strong>: Как сигналы соотносятся с системами управления состоянием, такими как Redux? Поощряют ли сигналы неструктурированное состояние?</p>
<p><strong>О</strong>: Сигналы могут стать эффективной основой для абстракций управления состоянием, подобных хранилищу. Распространённый паттерн во многих фреймворках — это объект на основе Proxy, который внутренне представляет свойства с помощью сигналов, например, <a href="https://vuejs.org/api/reactivity-core.html#reactive">Vue <code>reactive()</code></a> или <a href="https://docs.solidjs.com/concepts/stores">Solid stores</a>. Эти системы позволяют гибко группировать состояние на нужном уровне абстракции для конкретного приложения.</p>
<p><strong>В</strong>: Что предлагают сигналы такого, чего не умеет <code>Proxy</code>?</p>
<p><strong>О</strong>: Proxy и сигналы дополняют друг друга и хорошо работают вместе. Proxy позволяет перехватывать поверхностные операции с объектами, а сигналы координируют граф зависимостей (ячеек). Использовать сигналы в качестве основы для Proxy — отличный способ создать вложенную реактивную структуру с хорошей эргономикой.</p>
<p>В этом примере мы можем использовать proxy для создания геттера и сеттера у сигнала вместо методов <code>get</code> и <code>set</code>:</p>
<pre><code class="language-js">const a = new Signal.State(0);
const b = new Proxy(a, {
  get(target, property, receiver) {
    if (property === 'value') {
      return target.get():
    }
  }
  set(target, property, value, receiver) {
    if (property === 'value') {
      target.set(value)!
    }
  }
});

// использование в гипотетическом реактивном контексте:
&lt;template&gt;
  {b.value}

  &lt;button onclick={() =&gt; {
    b.value++;
  }}&gt;change&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>при использовании рендера, оптимизированного для мелкозернистой реактивности, клик по кнопке вызовет обновление ячейки <code>b.value</code>.</p>
<p>См.:</p>
<ul>
<li>примеры вложенных реактивных структур, созданных с помощью сигналов и Proxy: <a href="https://github.com/NullVoxPopuli/signal-utils/tree/main/src">signal-utils</a></li>
<li>пример предыдущих реализаций, показывающих связь между реактивными данными и прокси: <a href="https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private">tracked-built-ins</a></li>
<li><a href="https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574">обсуждение</a>.</li>
</ul>
<h4>Как работают сигналы?</h4>
<p><strong>В</strong>: Сигналы основаны на push- или pull-модели?</p>
<p><strong>О</strong>: Вычисление вычисляемых сигналов основано на pull-модели: вычисляемые сигналы пересчитываются только при вызове <code>.get()</code>, даже если базовое состояние изменилось намного раньше. В то же время, изменение State-сигнала может немедленно вызвать callback Watcher'а, &quot;проталкивая&quot; уведомление. Таким образом, сигналы можно рассматривать как конструкцию &quot;push-pull&quot;.</p>
<p><strong>В</strong>: Вносят ли сигналы недетерминизм в выполнение JavaScript?</p>
<p><strong>О</strong>: Нет. Во-первых, все операции с сигналами имеют чётко определённую семантику и порядок, и не будут отличаться между корректными реализациями. На более высоком уровне сигналы следуют определённому набору инвариантов, относительно которых они &quot;корректны&quot;. Вычисляемый сигнал всегда наблюдает граф сигналов в согласованном состоянии, и его выполнение не прерывается другим кодом, изменяющим сигналы (за исключением вызовов самого себя). См. описание выше.</p>
<p><strong>В</strong>: Когда я записываю в State-сигнал, когда обновление вычисляемого сигнала планируется?</p>
<p><strong>О</strong>: Оно не планируется! Вычисляемый сигнал пересчитает себя в следующий раз, когда его кто-то прочитает. Синхронно может быть вызван callback Watcher'а, что позволяет фреймворкам запланировать чтение в подходящий для них момент.</p>
<p><strong>В</strong>: Когда записи в State-сигналы вступают в силу? Немедленно или пакетно?</p>
<p><strong>О</strong>: Записи в State-сигналы отражаются немедленно — при следующем чтении вычисляемого сигнала, который зависит от State-сигнала, он пересчитает себя при необходимости, даже если это происходит в следующей строке кода. Однако, присущая механизму ленивость (вычисляемые сигналы вычисляются только при чтении) на практике приводит к тому, что вычисления могут происходить пакетно.</p>
<p><strong>В</strong>: Что означает, что сигналы обеспечивают &quot;безглитчевое&quot; выполнение?</p>
<p><strong>О</strong>: Более ранние push-модели реактивности сталкивались с проблемой избыточных вычислений: если изменение State-сигнала вызывает немедленный запуск вычисляемого сигнала, в итоге это может привести к обновлению UI. Однако это обновление может быть преждевременным, если до следующего кадра произойдет ещё одно изменение исходного State-сигнала. Иногда из-за таких <a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">глитчей</a> конечным пользователям даже показывались неверные промежуточные значения. Сигналы избегают этой проблемы, будучи основанными на pull-модели, а не push: в момент, когда фреймворк планирует рендеринг UI, он &quot;вытягивает&quot; актуальные обновления, избегая напрасной работы как при вычислениях, так и при записи в DOM.</p>
<p><strong>В</strong>: Что значит, что сигналы &quot;теряют&quot; значения (&quot;lossy&quot;)?</p>
<p><strong>О</strong>: Это обратная сторона безглитчевого выполнения: сигналы представляют собой ячейку данных — только текущее значение (которое может измениться), а не поток данных во времени. Поэтому, если вы дважды подряд запишете в State-сигнал, не делая больше ничего, первая запись &quot;теряется&quot; и не видна ни одному вычисляемому сигналу или эффекту. Это считается достоинством, а не ошибкой — для потоков данных больше подходят другие конструкции (например, асинхронные итераторы, observables).</p>
<p><strong>В</strong>: Будут ли нативные сигналы быстрее существующих JS-реализаций сигналов?</p>
<p><strong>О</strong>: Мы надеемся на это (за счёт небольшого постоянного множителя), но это ещё предстоит доказать на практике. JS-движки — не магия, и им в конечном итоге придётся реализовать те же алгоритмы, что и JS-реализации сигналов. См. раздел выше о производительности.</p>
<h4>Почему сигналы устроены так?</h4>
<p><strong>В</strong>: Почему в этом предложении не включена функция <code>effect()</code>, если эффекты необходимы для практического использования сигналов?</p>
<p><strong>О</strong>: Эффекты по своей природе связаны с планированием и удалением (disposal), которые управляются фреймворками и выходят за рамки этого предложения. Вместо этого в предложении есть основа для реализации эффектов через низкоуровневый API <code>Signal.subtle.Watcher</code>.</p>
<p><strong>В</strong>: Почему подписки происходят автоматически, а не с помощью ручного интерфейса?</p>
<p><strong>О</strong>: Опыт показал, что ручные интерфейсы подписки для реактивности неудобны и склонны к ошибкам. Автоматическое отслеживание более компонуемо и является ключевой особенностью сигналов.</p>
<p><strong>В</strong>: Почему callback Watcher'а вызывается синхронно, а не планируется в микротаск?</p>
<p><strong>О</strong>: Поскольку callback не может читать или писать сигналы, синхронный вызов не нарушает корректность. Типичный callback просто добавляет сигнал в массив для последующего чтения или выставляет где-то бит. Создавать отдельный микротаск для каждого такого действия не только излишне, но и непрактично дорого.</p>
<p><strong>В</strong>: В этом API не хватает некоторых удобных функций, которые есть в моём любимом фреймворке и которые упрощают работу с сигналами. Можно ли добавить их в стандарт?</p>
<p><strong>О</strong>: Возможно. Различные расширения всё ещё находятся на рассмотрении. Пожалуйста, заведите issue для обсуждения любой отсутствующей, по вашему мнению, важной функции.</p>
<p><strong>В</strong>: Можно ли уменьшить размер или сложность этого API?</p>
<p><strong>О</strong>: Это определённо цель — сделать API минимальным, и мы старались этого добиться в приведённом выше описании. Если у вас есть идеи, что ещё можно убрать, пожалуйста, создайте issue для обсуждения.</p>
<h4>Как проходит стандартизация сигналов?</h4>
<p><strong>В</strong>: Разве не стоило бы начать работу по стандартизации с более примитивной концепции, такой как observables?
<strong>В</strong>: Наблюдаемые объекты (Observables) могут быть хорошей идеей для некоторых задач, но они не решают те проблемы, которые призваны решать Сигналы (Signals). Как описано выше, наблюдаемые объекты или другие механизмы публикации/подписки не являются полноценным решением для многих типов UI-программирования из-за чрезмерно трудоемкой и подверженной ошибкам настройки для разработчиков, а также из-за потерь производительности по причине отсутствия ленивости и других проблем.</p>
<p><strong>Вопрос</strong>: Почему Сигналы предлагаются в TC39, а не в DOM, учитывая, что большинство их применений связано с вебом?</p>
<p><strong>Ответ</strong>: Некоторые соавторы этого предложения заинтересованы в не-вебовых UI-средах как в одной из целей, однако сегодня обе площадки вполне подходят, поскольку веб-API всё чаще реализуются вне веба. В конечном итоге, Сигналы не зависят от каких-либо DOM-API, поэтому оба варианта возможны. Если у кого-то есть веская причина для смены рабочей группы, пожалуйста, сообщите об этом в issue. На данный момент все участники подписали соглашения об интеллектуальной собственности TC39, и планируется представить предложение в TC39.</p>
<p><strong>Вопрос</strong>: Сколько времени потребуется, чтобы я мог использовать стандартные Сигналы?</p>
<p><strong>Ответ</strong>: Полифил уже доступен, но лучше не полагаться на его стабильность, поскольку этот API будет меняться в процессе рассмотрения. Через несколько месяцев или год можно ожидать появления качественного, высокопроизводительного и стабильного полифила, однако он всё равно будет подвержен изменениям со стороны комитета и пока не станет стандартом. Следуя типичному пути рассмотрения предложений в TC39, можно ожидать, что пройдет минимум 2-3 года до того момента, когда Сигналы будут нативно поддерживаться всеми браузерами (с поддержкой нескольких предыдущих версий), и необходимость в полифилах отпадет.</p>
<p><strong>Вопрос</strong>: Как мы предотвратим слишком раннюю стандартизацию неправильного типа Сигналов, как это было с {{JS/web feature that you don't like}}?</p>
<p><strong>Ответ</strong>: Авторы данного предложения планируют приложить дополнительные усилия по созданию прототипов и проверке решений до подачи запроса на повышение стадии в TC39. См. раздел &quot;Статус и план разработки&quot; выше. Если вы видите пробелы в этом плане или возможности для улучшения, пожалуйста, создайте issue с пояснением.</p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-28</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>