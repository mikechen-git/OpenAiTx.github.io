<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>proposal-signals - tc39/proposal-signals es</title>
    <meta name="title" content="proposal-signals - tc39/proposal-signals es | 🚦 Propuesta de estándar de Signals en JavaScript 🚦 Etapa 1 (explicación) Champions de la propuesta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay...">
    <meta name="description" content="tc39/proposal-signals - GitHub repository es documentation and information | 🚦 Propuesta de estándar de Signals en JavaScript 🚦 Etapa 1 (explicación) Champions de la propuesta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay...">
    <meta name="keywords" content="tc39, proposal-signals, GitHub, repository, es documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/tc39/proposal-signals/README-es.html">
    <meta property="og:title" content="proposal-signals - tc39/proposal-signals es | 🚦 Propuesta de estándar de Signals en JavaScript 🚦 Etapa 1 (explicación) Champions de la propuesta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay...">
    <meta property="og:description" content="tc39/proposal-signals - GitHub repository es documentation and information | 🚦 Propuesta de estándar de Signals en JavaScript 🚦 Etapa 1 (explicación) Champions de la propuesta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/tc39/proposal-signals" id="githubRepoLink" target="_blank">tc39/proposal-signals</a>
<h1 style="display: none;">🚦 Propuesta de estándar de Signals en JavaScript 🚦 Etapa 1 (explicación) Champions de la propuesta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>🚦 Propuesta de estándar de Signals en JavaScript 🚦</h1>
<img align=right src="https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg" alt="Signals logo" width=100>
<p>Etapa 1 (<a href="https://tc39.es/process-document/">explicación</a>)</p>
<p>Champions de la propuesta TC39: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg</p>
<p>Autores originales: Rob Eisenberg y Daniel Ehrenberg</p>
<p>Este documento describe una dirección común temprana para los signals en JavaScript, similar al esfuerzo Promises/A+ que precedió a las Promises estandarizadas por TC39 en ES2015. Pruébalo tú mismo, usando <a href="https://github.com/proposal-signals/signal-polyfill">un polyfill</a>.</p>
<p>De manera similar a Promises/A+, este esfuerzo se enfoca en alinear el ecosistema de JavaScript. Si esta alineación tiene éxito, entonces podría surgir un estándar, basado en esa experiencia. Varios autores de frameworks están colaborando aquí en un modelo común que podría respaldar el núcleo de reactividad de sus frameworks. El borrador actual se basa en aportes de diseño de los autores/mantenedores de <a href="https://angular.io/">Angular</a>, <a href="https://bubble.io/">Bubble</a>, <a href="https://emberjs.com/">Ember</a>, <a href="https://www.fast.design/">FAST</a>, <a href="https://mobx.js.org/">MobX</a>, <a href="https://preactjs.com/">Preact</a>, <a href="https://qwik.dev/">Qwik</a>, <a href="https://rxjs.dev/">RxJS</a>, <a href="https://www.solidjs.com/">Solid</a>, <a href="https://www.starbeamjs.com/">Starbeam</a>, <a href="https://svelte.dev/">Svelte</a>, <a href="https://vuejs.org/">Vue</a>, <a href="https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a">Wiz</a>, y más…</p>
<p>A diferencia de Promises/A+, no estamos tratando de resolver una API común orientada al desarrollador, sino más bien las semánticas precisas del núcleo del grafo de signals subyacente. Esta propuesta sí incluye una API completamente concreta, pero la API no está dirigida a la mayoría de los desarrolladores de aplicaciones. En cambio, la API de signals aquí es más adecuada para que los frameworks construyan sobre ella, proporcionando interoperabilidad a través de un grafo de signals común y un mecanismo de auto-seguimiento.</p>
<p>El plan para esta propuesta es realizar prototipos tempranos significativos, incluida la integración en varios frameworks, antes de avanzar más allá de la Etapa 1. Solo estamos interesados en estandarizar Signals si son adecuados para su uso práctico en múltiples frameworks y proporcionan beneficios reales sobre los signals provistos por los frameworks. Esperamos que una fase de prototipado temprano nos brinde esta información. Consulta &quot;Estado y plan de desarrollo&quot; más abajo para más detalles.</p>
<h2>Antecedentes: ¿Por qué Signals?</h2>
<p>Para desarrollar una interfaz de usuario (UI) complicada, los desarrolladores de aplicaciones JavaScript necesitan almacenar, computar, invalidar, sincronizar y enviar el estado a la capa de vista de la aplicación de manera eficiente. Las UI comúnmente implican mucho más que simplemente gestionar valores simples, a menudo implican renderizar un estado computado que depende de un árbol complejo de otros valores o estados que también son computados. El objetivo de los Signals es proporcionar infraestructura para gestionar este estado de aplicación, de modo que los desarrolladores puedan enfocarse en la lógica de negocio en lugar de estos detalles repetitivos.</p>
<p>Se ha descubierto que los constructos tipo signal son útiles de manera independiente también en contextos no relacionados con UI, particularmente en sistemas de build para evitar reconstrucciones innecesarias.</p>
<p>Los signals se utilizan en la programación reactiva para eliminar la necesidad de gestionar actualizaciones en las aplicaciones.</p>
<blockquote>
<p>Un modelo de programación declarativo para actualizar en función de cambios en el estado.</p>
</blockquote>
<p>de <em><a href="https://www.pzuraq.com/blog/what-is-reactivity">¿Qué es la reactividad?</a></em>.</p>
<h4>Ejemplo - Un contador en VanillaJS</h4>
<p>Dada una variable, <code>counter</code>, quieres renderizar en el DOM si el contador es par o impar. Cada vez que <code>counter</code> cambie, quieres actualizar el DOM con la última paridad. En Vanilla JS, podrías tener algo así:</p>
<pre><code class="language-js">let counter = 0;
const setCounter = (value) =&gt; {
  counter = value;
  render();
};

const isEven = () =&gt; (counter &amp; 1) == 0;
const parity = () =&gt; isEven() ? &quot;even&quot; : &quot;odd&quot;;
const render = () =&gt; element.innerText = parity();

// Simula actualizaciones externas a counter...
setInterval(() =&gt; setCounter(counter + 1), 1000);
</code></pre>
<blockquote>
<p>[!NOTA]<br />
Se usan variables globales aquí solo para propósitos de demostración. La gestión adecuada de estado tiene muchas soluciones, y los ejemplos en esta propuesta buscan ser lo más minimalistas posible. Esta propuesta no fomenta el uso de variables globales.</p>
</blockquote>
<p>Esto tiene varios problemas...</p>
<ul>
<li>La configuración de <code>counter</code> es ruidosa y con mucho código repetitivo.</li>
<li>El estado de <code>counter</code> está fuertemente acoplado al sistema de renderizado.</li>
<li>Si <code>counter</code> cambia pero <code>parity</code> no (por ejemplo, counter pasa de 2 a 4), entonces hacemos un cálculo innecesario de la paridad y un renderizado innecesario.</li>
<li>¿Qué pasa si otra parte de nuestra UI solo quiere renderizar cuando <code>counter</code> se actualiza?</li>
<li>¿Qué pasa si otra parte de nuestra UI depende solo de <code>isEven</code> o <code>parity</code>?</li>
</ul>
<p>Incluso en este escenario relativamente simple, aparecen varios problemas rápidamente. Podríamos intentar solucionar esto introduciendo pub/sub para <code>counter</code>. Esto permitiría que consumidores adicionales de <code>counter</code> puedan suscribirse para añadir sus propias reacciones a los cambios de estado.</p>
<p>Sin embargo, aún estamos atascados con los siguientes problemas:</p>
<ul>
<li>La función de renderizado, que solo depende de <code>parity</code>, en su lugar debe &quot;saber&quot; que en realidad necesita suscribirse a <code>counter</code>.</li>
<li>No es posible actualizar la UI en función solo de <code>isEven</code> o <code>parity</code>, sin interactuar directamente con <code>counter</code>.</li>
<li>Hemos incrementado nuestro código repetitivo. Cada vez que usas algo, no es solo cuestión de llamar una función o leer una variable, sino de suscribirse y hacer actualizaciones allí. Gestionar la desuscripción también es especialmente complicado.</li>
</ul>
<p>Ahora, podríamos resolver algunos problemas añadiendo pub/sub no solo a <code>counter</code> sino también a <code>isEven</code> y <code>parity</code>. Entonces tendríamos que suscribir <code>isEven</code> a <code>counter</code>, <code>parity</code> a <code>isEven</code>, y <code>render</code> a <code>parity</code>. Desafortunadamente, no solo nuestro código repetitivo ha explotado, sino que estamos atrapados con un montón de gestión de suscripciones, y un posible desastre de fugas de memoria si no limpiamos todo correctamente. Así que, hemos resuelto algunos problemas pero creado toda una nueva categoría de problemas y mucho código. Para empeorar las cosas, tenemos que pasar por este proceso para cada pieza de estado en nuestro sistema.</p>
<h3>Introducción a Signals</h3>
<p>Las abstracciones de data binding en las UI para el modelo y la vista han sido durante mucho tiempo fundamentales en los frameworks de UI en múltiples lenguajes de programación, a pesar de la ausencia de tal mecanismo en JS o en la plataforma web. Dentro de los frameworks y librerías JS, ha habido mucha experimentación sobre diferentes formas de representar este binding, y la experiencia ha demostrado el poder del flujo de datos unidireccional en conjunto con un tipo de dato de primera clase que representa una celda de estado o un cálculo derivado de otros datos, ahora llamados a menudo &quot;Signals&quot;.
Este enfoque de valor reactivo de primera clase parece haber hecho su primera aparición popular en frameworks web de JavaScript de código abierto con <a href="https://knockoutjs.com/">Knockout</a> <a href="https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/">en 2010</a>. En los años siguientes, se han creado muchas variaciones e implementaciones. En los últimos 3-4 años, el primitivo Signal y enfoques relacionados han ganado aún más tracción, con casi todas las librerías o frameworks modernos de JavaScript teniendo algo similar, bajo uno u otro nombre.</p>
<p>Para entender Signals, echemos un vistazo al ejemplo anterior, reimaginado con una API de Signal más detallada a continuación.</p>
<h4>Ejemplo - Un contador con Signals</h4>
<pre><code class="language-js">const counter = new Signal.State(0);
const isEven = new Signal.Computed(() =&gt; (counter.get() &amp; 1) == 0);
const parity = new Signal.Computed(() =&gt; isEven.get() ? &quot;even&quot; : &quot;odd&quot;);

// Una librería o framework define efectos en función de otros primitivos Signal
declare function effect(cb: () =&gt; void): (() =&gt; void);

effect(() =&gt; element.innerText = parity.get());

// Simula actualizaciones externas a counter...
setInterval(() =&gt; counter.set(counter.get() + 1), 1000);
</code></pre>
<p>Hay algunas cosas que podemos notar de inmediato:</p>
<ul>
<li>Hemos eliminado el código repetitivo y ruidoso alrededor de la variable <code>counter</code> de nuestro ejemplo anterior.</li>
<li>Hay una API unificada para manejar valores, cálculos y efectos secundarios.</li>
<li>No hay problema de referencias circulares ni dependencias invertidas entre <code>counter</code> y <code>render</code>.</li>
<li>No hay suscripciones manuales, ni necesidad de gestión de registros.</li>
<li>Hay una forma de controlar el momento/la programación de los efectos secundarios.</li>
</ul>
<p>Sin embargo, los Signals nos brindan mucho más que lo que se puede ver en la superficie de la API:</p>
<ul>
<li><strong>Seguimiento Automático de Dependencias</strong> - Una Signal computada descubre automáticamente cualquier otra Signal de la que dependa, ya sean estos valores simples u otros cálculos.</li>
<li><strong>Evaluación Perezosa</strong> - Los cálculos no se evalúan anticipadamente cuando se declaran, ni se evalúan inmediatamente cuando cambian sus dependencias. Solo se evalúan cuando su valor es solicitado explícitamente.</li>
<li><strong>Memoización</strong> - Las Signals computadas almacenan en caché su último valor, de modo que los cálculos cuyas dependencias no hayan cambiado no necesitan ser reevaluados, sin importar cuántas veces sean accedidos.</li>
</ul>
<h2>Motivación para estandarizar Signals</h2>
<h4>Interoperabilidad</h4>
<p>Cada implementación de Signal tiene su propio mecanismo de seguimiento automático, para llevar el control de las fuentes encontradas al evaluar una Signal computada. Esto dificulta compartir modelos, componentes y librerías entre diferentes frameworks—tienden a venir con un acoplamiento falso a su motor de vista (dado que las Signals suelen implementarse como parte de frameworks de JS).</p>
<p>Uno de los objetivos de esta propuesta es desacoplar completamente el modelo reactivo del renderizado de la vista, permitiendo a los desarrolladores migrar a nuevas tecnologías de renderizado sin reescribir su código no relacionado a UI, o desarrollar modelos reactivos compartidos en JS para desplegar en diferentes contextos. Desafortunadamente, debido a versiones y duplicación, ha resultado impráctico lograr un alto nivel de compartición mediante librerías a nivel de JS—las funcionalidades integradas ofrecen una garantía de compartición más fuerte.</p>
<h4>Rendimiento/Uso de memoria</h4>
<p>Siempre existe un pequeño potencial de mejora en el rendimiento al enviar menos código gracias a que librerías comúnmente usadas vienen integradas, pero las implementaciones de Signals suelen ser bastante pequeñas, por lo que no esperamos que este efecto sea muy grande.</p>
<p>Sospechamos que las implementaciones nativas en C++ de las estructuras de datos y algoritmos relacionados con Signals pueden ser ligeramente más eficientes que lo que se puede lograr en JS, por un factor constante. Sin embargo, no se anticipan cambios algorítmicos frente a lo que estaría presente en un polyfill; no se espera que los motores hagan magia aquí, y los algoritmos de reactividad estarán bien definidos y serán inequívocos.</p>
<p>El grupo promotor espera desarrollar varias implementaciones de Signals y usar estas para investigar estas posibilidades de rendimiento.</p>
<h4>DevTools</h4>
<p>Con las librerías de Signals existentes en lenguaje JS, puede ser difícil rastrear cosas como:</p>
<ul>
<li>La pila de llamadas a través de una cadena de Signals computadas, mostrando la cadena causal de un error</li>
<li>El grafo de referencias entre Signals, cuando una depende de otra—importante cuando se depura el uso de memoria</li>
</ul>
<p>Las Signals integradas permiten que los entornos de ejecución de JS y DevTools puedan tener un soporte mejorado para inspeccionar Signals, particularmente para depuración o análisis de rendimiento, ya sea integrado en los navegadores o a través de una extensión compartida. Herramientas existentes como el inspector de elementos, la captura de rendimiento y los perfiladores de memoria podrían actualizarse para resaltar específicamente las Signals en su presentación de información.</p>
<h4>Beneficios secundarios</h4>
<h5>Beneficios de una librería estándar</h5>
<p>En general, JavaScript ha tenido una librería estándar bastante mínima, pero una tendencia en TC39 ha sido hacer de JS un lenguaje más &quot;con pilas incluidas&quot;, con un conjunto de funcionalidades integradas y de alta calidad disponible. Por ejemplo, Temporal está reemplazando moment.js, y varias pequeñas funciones, por ejemplo, <code>Array.prototype.flat</code> y <code>Object.groupBy</code> están reemplazando muchos casos de uso de lodash. Los beneficios incluyen tamaños de bundle más pequeños, mayor estabilidad y calidad, menos cosas que aprender al unirse a un nuevo proyecto, y un vocabulario común entre desarrolladores de JS.</p>
<h5>Integración HTML/DOM (una posibilidad futura)</h5>
<p>El trabajo actual en el W3C y por parte de los implementadores de navegadores busca llevar la plantillas nativas a HTML (<a href="https://github.com/WICG/webcomponents/pull/1023">DOM Parts</a> y <a href="https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md">Template Instantiation</a>). Además, el W3C Web Components CG está explorando la posibilidad de extender los Web Components para ofrecer una API HTML totalmente declarativa. Para lograr ambos objetivos, eventualmente HTML necesitará una primitiva reactiva. Además, se pueden imaginar muchas mejoras ergonómicas al DOM mediante la integración de Signals, las cuales han sido solicitadas por la comunidad.</p>
<blockquote>
<p>Nota, esta integración sería un esfuerzo separado para el futuro, no parte de esta propuesta en sí.</p>
</blockquote>
<h5>Intercambio de información en el ecosistema (<em>no</em> es una razón para incluirlo)</h5>
<p>Los esfuerzos de estandarización a veces pueden ser útiles solo a nivel &quot;comunidad&quot;, incluso sin cambios en los navegadores. El esfuerzo de Signals está reuniendo a muchos autores de frameworks diferentes para una discusión profunda sobre la naturaleza de la reactividad, los algoritmos y la interoperabilidad. Esto ya ha sido útil, y no justifica la inclusión en los motores JS y navegadores; las Signals solo deberían agregarse al estándar de JavaScript si existen beneficios significativos <em>más allá</em> del intercambio de información del ecosistema que permite.</p>
<h2>Objetivos de diseño para Signals</h2>
<p>Resulta que las librerías de Signals existentes no son tan diferentes entre sí, en su núcleo. Esta propuesta busca aprovechar su éxito implementando las cualidades importantes de muchas de esas librerías.</p>
<h3>Funcionalidades principales</h3>
<ul>
<li>Un tipo Signal que representa estado, es decir, Signal escribible. Este es un valor que otros pueden leer.</li>
<li>Un tipo Signal computada/memo/derivada, que depende de otras y se calcula y almacena en caché de manera perezosa.
<ul>
<li>El cálculo es perezoso, lo que significa que las Signals computadas no se recalculan por defecto cuando cambia una de sus dependencias, sino que solo se ejecutan si alguien realmente las lee.</li>
<li>El cálculo es &quot;<a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_reactiva#Glitches">libre de glitches</a>&quot;, es decir, nunca se realizan cálculos innecesarios. Esto implica que, cuando una aplicación lee una Signal computada, hay un ordenamiento topológico de las partes potencialmente sucias del grafo para ejecutar, eliminando duplicados.</li>
<li>El cálculo se almacena en caché, lo que significa que si, después de la última vez que una dependencia cambió, ninguna dependencia ha cambiado, entonces la Signal computada <em>no</em> se recalcula al accederla.</li>
<li>Es posible realizar comparaciones personalizadas para Signals computadas así como para las de estado, para determinar cuándo Signals computadas adicionales que dependen de ellas deben actualizarse.</li>
</ul>
</li>
<li>Reacciones a la condición donde una Signal computada tiene una de sus dependencias (o dependencias anidadas) marcada como &quot;sucia&quot; y cambia, lo que significa que el valor de la Signal podría estar desactualizado.
<ul>
<li>Esta reacción está pensada para programar trabajo más importante que se realizará más tarde.</li>
<li>Los efectos se implementan en términos de estas reacciones, más la programación a nivel de framework.</li>
<li>Las Signals computadas necesitan la capacidad de reaccionar a si están registradas como una dependencia (anidada) de una de estas reacciones.</li>
</ul>
</li>
<li>Permitir que los frameworks de JS realicen su propia programación. No hay una programación forzada integrada al estilo Promise.
<ul>
<li>Se necesitan reacciones síncronas para permitir programar trabajo posterior basado en la lógica del framework.</li>
<li>Las escrituras son síncronas y tienen efecto inmediato (un framework que agrupe escrituras puede hacerlo por encima).</li>
<li>Es posible separar la comprobación de si un efecto puede estar &quot;sucio&quot; de la ejecución real del efecto (permitiendo un programador de efectos en dos etapas).</li>
</ul>
</li>
<li>Capacidad de leer Signals <em>sin</em> activar el registro de dependencias (<code>untrack</code>)</li>
<li>Permitir la composición de diferentes bases de código que usen Signals/reactividad, por ejemplo,
<ul>
<li>Usar múltiples frameworks juntos en cuanto al seguimiento/reactividad en sí (salvo omisiones, ver más abajo)</li>
<li>Estructuras de datos reactivas independientes de framework (por ejemplo, proxy de almacén recursivamente reactivo, Map y Set y Array reactivos, etc.)</li>
</ul>
</li>
</ul>
<h3>Solidez</h3>
<ul>
<li>Desalentar/prohibir el uso ingenuo de reacciones síncronas.
<ul>
<li>Riesgo de solidez: puede exponer &quot;<a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_reactiva#Glitches">glitches</a>&quot; si se usa incorrectamente: Si el renderizado se realiza inmediatamente cuando se establece una Signal, puede exponer un estado de aplicación incompleto al usuario final. Por tanto, esta función solo debe usarse para programar trabajo inteligentemente para más adelante, una vez que la lógica de la aplicación haya terminado.</li>
<li>Solución: No permitir leer ni escribir ninguna Signal desde dentro de un callback de reacción síncrona.</li>
</ul>
</li>
<li>Desalentar el uso de <code>untrack</code> y marcar su naturaleza no sólida
<ul>
<li>Riesgo de solidez: permite la creación de Signals computadas cuyo valor depende de otras Signals, pero que no se actualizan cuando esas Signals cambian. Debe usarse cuando los accesos no rastreados no cambiarán el resultado del cálculo.</li>
<li>Solución: La API está marcada como &quot;insegura&quot; en el nombre.</li>
</ul>
</li>
<li>Nota: Esta propuesta sí permite que las signals sean leídas y escritas tanto desde signals computadas como de efectos, sin restringir escrituras que ocurran después de lecturas, a pesar del riesgo de solidez. Esta decisión fue tomada para preservar flexibilidad y compatibilidad en la integración con frameworks.</li>
</ul>
<h3>API superficial</h3>
<ul>
<li>Debe ser una base sólida para que múltiples frameworks implementen sus mecanismos de Signals/reactividad.
<ul>
<li>Debe ser una buena base para proxies de almacén recursivos, reactividad basada en decoradores de campos de clase, y para APIs tanto del tipo <code>.value</code> como <code>[state, setState]</code>.</li>
<li>La semántica debe ser capaz de expresar los patrones válidos habilitados por diferentes frameworks. Por ejemplo, debe ser posible que estas Signals sean la base tanto de escrituras reflejadas inmediatamente como de escrituras agrupadas y aplicadas más tarde.</li>
</ul>
</li>
<li>Sería deseable que esta API pueda ser utilizada directamente por desarrolladores JavaScript.
<ul>
<li>Si una funcionalidad coincide con un concepto del ecosistema, es bueno usar vocabulario común.
<ul>
<li>Sin embargo, es importante no usar literalmente los mismos nombres exactos.</li>
</ul>
</li>
<li>Tensión entre &quot;usabilidad para desarrolladores JS&quot; y &quot;proveer todos los ganchos para frameworks&quot;
<ul>
<li>Idea: Proveer todos los ganchos, pero incluir errores cuando se usen incorrectamente si es posible.</li>
<li>Idea: Colocar las APIs sutiles en un espacio de nombres <code>subtle</code>, similar a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle"><code>crypto.subtle</code></a>, para marcar la línea entre las APIs necesarias para usos más avanzados como implementar un framework o construir dev tools, versus el desarrollo de aplicaciones cotidiano como instanciar signals para usar con un framework.</li>
</ul>
</li>
</ul>
</li>
<li>Ser implementable y utilizable con buen rendimiento—la API superficial no debe causar demasiada sobrecarga.
<ul>
<li>Permitir subclasificación, de modo que los frameworks puedan añadir sus propios métodos y campos, incluidos los campos privados. Esto es importante para evitar la necesidad de asignaciones adicionales a nivel de framework. Ver &quot;Gestión de memoria&quot; más abajo.</li>
</ul>
</li>
</ul>
<h3>Gestión de memoria</h3>
<ul>
<li>Si es posible: Una Signal computada debe poder ser recolectada por el recolector de basura si nada vivo la está referenciando para posibles lecturas futuras, incluso si está enlazada en un grafo más grande que permanece vivo (por ejemplo, al leer un estado que permanece vivo).</li>
<li>Tenga en cuenta que la mayoría de los frameworks actuales requieren la eliminación explícita de las Signals computadas si tienen alguna referencia desde o hacia otro grafo de Signals que permanece activo.</li>
<li>Esto no resulta tan problemático cuando su ciclo de vida está vinculado al ciclo de vida de un componente de UI, y de todas formas los efectos necesitan ser eliminados.</li>
<li>Si es demasiado costoso ejecutarlo con estas semánticas, entonces deberíamos añadir la eliminación explícita (o &quot;desvinculación&quot;) de Signals computadas a la API a continuación, que actualmente carece de ello.</li>
<li>Un objetivo relacionado por separado: Minimizar el número de asignaciones, por ejemplo,
<ul>
<li>para crear una Signal editable (evitar dos closures separadas + array)</li>
<li>para implementar efectos (evitar una closure para cada reacción)</li>
<li>En la API para observar cambios en Signals, evitar la creación de estructuras de datos temporales adicionales</li>
<li>Solución: API basada en clases que permite la reutilización de métodos y campos definidos en subclases</li>
</ul>
</li>
</ul>
<h2>Boceto de la API</h2>
<p>A continuación se muestra una idea inicial de una API de Signal. Tenga en cuenta que esto es solo un borrador temprano, y anticipamos cambios con el tiempo. Comencemos con el <code>.d.ts</code> completo para hacernos una idea de la estructura general, y luego discutiremos los detalles de lo que significa todo esto.</p>
<pre><code class="language-ts">interface Signal&lt;T&gt; {
    // Obtener el valor de la signal
    get(): T;
}

namespace Signal {
    // Una Signal de lectura y escritura
    class State&lt;T&gt; implements Signal&lt;T&gt; {
        // Crear una Signal de estado comenzando con el valor t
        constructor(t: T, options?: SignalOptions&lt;T&gt;);

        // Obtener el valor de la signal
        get(): T;

        // Establecer el valor de la Signal de estado a t
        set(t: T): void;
    }

    // Una Signal que es una fórmula basada en otras Signals
    class Computed&lt;T = unknown&gt; implements Signal&lt;T&gt; {
        // Crear una Signal que se evalúa al valor retornado por el callback.
        // El callback es llamado con esta signal como el valor de this.
        constructor(cb: (this: Computed&lt;T&gt;) =&gt; T, options?: SignalOptions&lt;T&gt;);

        // Obtener el valor de la signal
        get(): T;
    }

    // Este namespace incluye características &quot;avanzadas&quot; que es mejor
    // dejar para los autores de frameworks en lugar de los desarrolladores de aplicaciones.
    // Análogo a `crypto.subtle`
    namespace subtle {
        // Ejecutar un callback con todo el seguimiento deshabilitado
        function untrack&lt;T&gt;(cb: () =&gt; T): T;

        // Obtener la signal computada actual que está rastreando cualquier lectura de signal, si existe
        function currentComputed(): Computed | null;

        // Devuelve una lista ordenada de todas las signals que esta referenció
        // durante la última vez que fue evaluada.
        // Para un Watcher, lista el conjunto de signals que está observando.
        function introspectSources(s: Computed | Watcher): (State | Computed)[];

        // Devuelve los Watchers en los que esta signal está contenida, además de cualquier
        // Signal Computed que leyó esta signal la última vez que fue evaluada,
        // si esa signal computada está (recursivamente) siendo observada.
        function introspectSinks(s: State | Computed): (Computed | Watcher)[];

        // Verdadero si esta signal está &quot;viva&quot;, es decir, está siendo observada por un Watcher,
        // o es leída por una signal Computed que (recursivamente) está viva.
        function hasSinks(s: State | Computed): boolean;

        // Verdadero si este elemento es &quot;reactivo&quot;, es decir, depende
        // de alguna otra signal. Una Computed donde hasSources es falso
        // siempre devolverá la misma constante.
        function hasSources(s: Computed | Watcher): boolean;

        class Watcher {
            // Cuando una fuente (recursiva) del Watcher es escrita, llama a este callback,
            // si aún no ha sido llamado desde la última llamada a `watch`.
            // No se pueden leer ni escribir signals durante la notificación.
            constructor(notify: (this: Watcher) =&gt; void);

            // Agrega estas signals al conjunto del Watcher y configura el watcher para ejecutar su
            // callback de notificación la próxima vez que cualquier signal en el conjunto (o una de sus dependencias) cambie.
            // Puede llamarse sin argumentos solo para restablecer el estado de &quot;notificado&quot;, de modo que
            // el callback de notificación se invoque nuevamente.
            watch(...s: Signal[]): void;

            // Elimina estas signals del conjunto observado (por ejemplo, para un efecto que se elimina)
            unwatch(...s: Signal[]): void;

            // Devuelve el conjunto de fuentes en el conjunto del Watcher que todavía están sucias, o es una signal computada
            // con una fuente que está sucia o pendiente y aún no ha sido reevaluada
            getPending(): Signal[];
        }

        // Hooks para observar cuando se comienza o se deja de observar
        var watched: Symbol;
        var unwatched: Symbol;
    }

    interface SignalOptions&lt;T&gt; {
        // Función de comparación personalizada entre el valor antiguo y el nuevo. Por defecto: Object.is.
        // La signal se pasa como el valor de this para contexto.
        equals?: (this: Signal&lt;T&gt;, t: T, t2: T) =&gt; boolean;
```ts
// Callback llamado cuando isWatched se vuelve true, si previamente era false
[Signal.subtle.watched]?: (this: Signal&lt;T&gt;) =&gt; void;

// Callback llamado cuando isWatched se vuelve false, si previamente era true
[Signal.subtle.unwatched]?: (this: Signal&lt;T&gt;) =&gt; void;
}
}
</code></pre>
<h3>Cómo funcionan los Signals</h3>
<p>Un Signal representa una celda de datos que puede cambiar con el tiempo. Los Signals pueden ser de tipo &quot;state&quot; (simplemente un valor que se establece manualmente) o &quot;computed&quot; (una fórmula basada en otros Signals).</p>
<p>Los Signals computados funcionan rastreando automáticamente qué otros Signals son leídos durante su evaluación. Cuando se lee un computed, verifica si alguna de sus dependencias registradas previamente ha cambiado y se reevalúa si es así. Cuando varios Signals computados están anidados, toda la atribución del rastreo va al más interno.</p>
<p>Los Signals computados son perezosos, es decir, basados en demanda: solo se reevalúan cuando se accede a ellos, incluso si una de sus dependencias cambió anteriormente.</p>
<p>El callback pasado a los Signals computados generalmente debe ser &quot;puro&quot; en el sentido de ser una función determinista y sin efectos secundarios de los otros Signals a los que accede. Al mismo tiempo, el momento en que se llama al callback es determinista, permitiendo que los efectos secundarios se usen con cuidado.</p>
<p>Los Signals presentan un destacado almacenamiento en caché/memoización: tanto los Signals de estado como los computados recuerdan su valor actual y solo desencadenan el recálculo de los Signals computados que los referencian si realmente cambian. Ni siquiera se necesita una comparación repetida de los valores antiguos y nuevos: la comparación se realiza una vez cuando el Signal fuente se reinicia/reevalúa, y el mecanismo de Signal lleva el seguimiento de qué cosas que referencian ese Signal aún no se han actualizado según el nuevo valor. Internamente, esto generalmente se representa mediante &quot;coloreado de grafos&quot; como se describe en (la publicación del blog de Milo).</p>
<p>Los Signals computados rastrean sus dependencias dinámicamente: cada vez que se ejecutan, pueden terminar dependiendo de cosas diferentes, y ese conjunto de dependencias preciso se mantiene actualizado en el grafo de Signals. Esto significa que si tienes una dependencia necesaria solo en una rama, y el cálculo anterior tomó la otra rama, entonces un cambio en ese valor temporalmente no utilizado no hará que el Signal computado se recalcule, incluso cuando se acceda a él.</p>
<p>A diferencia de las Promesas de JavaScript, todo en Signals se ejecuta de manera síncrona:</p>
<ul>
<li>Establecer un Signal a un nuevo valor es síncrono, y esto se refleja inmediatamente al leer cualquier Signal computado que dependa de él después. No hay ningún agrupamiento (&quot;batching&quot;) incorporado para esta mutación.</li>
<li>Leer Signals computados es síncrono: su valor está siempre disponible.</li>
<li>El callback <code>notify</code> en los Watchers, como se explica a continuación, se ejecuta de manera síncrona, durante la llamada a <code>.set()</code> que lo desencadenó (pero después de que se haya completado el coloreado del grafo).</li>
</ul>
<p>Al igual que las Promesas, los Signals pueden representar un estado de error: si el callback de un Signal computado lanza una excepción, ese error se almacena en caché como cualquier otro valor y se vuelve a lanzar cada vez que se lee el Signal.</p>
<h3>Entendiendo la clase Signal</h3>
<p>Una instancia de <code>Signal</code> representa la capacidad de leer un valor que cambia dinámicamente y cuyos cambios se rastrean con el tiempo. También incluye implícitamente la capacidad de suscribirse al Signal, de manera implícita a través de un acceso rastreado desde otro Signal computado.</p>
<p>La API aquí está diseñada para coincidir con el consenso muy general de la comunidad entre una gran fracción de las librerías de Signals en el uso de nombres como &quot;signal&quot;, &quot;computed&quot; y &quot;state&quot;. Sin embargo, el acceso a los Signals Computed y State es a través de un método <code>.get()</code>, lo cual difiere de todas las APIs populares de Signals, que usan un accesor <code>.value</code> o una sintaxis de llamada <code>signal()</code>.</p>
<p>La API está diseñada para reducir el número de asignaciones, para hacer los Signals adecuados para su integración en frameworks de JavaScript mientras se logra el mismo o mejor rendimiento que los Signals personalizados de los frameworks existentes. Esto implica:</p>
<ul>
<li>Los Signals de estado son un único objeto escribible, que puede ser accedido y modificado desde la misma referencia. (Ver implicaciones más abajo en la sección &quot;Separación de capacidades&quot;).</li>
<li>Tanto los Signals de estado como los computados están diseñados para poder ser subclaseados, para facilitar que los frameworks agreguen propiedades adicionales a través de campos de clase públicos y privados (así como métodos para usar ese estado).</li>
<li>Varios callbacks (por ejemplo, <code>equals</code>, el callback de los computados) se llaman con el Signal relevante como el valor de <code>this</code> para contexto, de modo que no se necesita una nueva closure por Signal. En su lugar, el contexto puede guardarse en propiedades extra del propio Signal.</li>
</ul>
<p>Algunas condiciones de error impuestas por esta API:</p>
<ul>
<li>Es un error leer un Signal computado recursivamente.</li>
<li>El callback <code>notify</code> de un Watcher no puede leer ni escribir ningún Signal.</li>
<li>Si el callback de un Signal computado lanza una excepción, los accesos posteriores a ese Signal vuelven a lanzar ese error almacenado, hasta que una de las dependencias cambie y se recalcule.</li>
</ul>
<p>Algunas condiciones que <em>no</em> se imponen:</p>
<ul>
<li>Los Signals computados pueden escribir en otros Signals, de forma síncrona dentro de su callback.</li>
<li>El trabajo que es puesto en cola por el callback <code>notify</code> de un Watcher puede leer o escribir signals, permitiendo replicar <a href="https://react.dev/learn/you-might-not-need-an-effect">antipatrones clásicos de React</a> en términos de Signals.</li>
</ul>
<h3>Implementando efectos</h3>
<p>La interfaz <code>Watcher</code> definida arriba da la base para implementar las típicas APIs JS para efectos: callbacks que se vuelven a ejecutar cuando otros Signals cambian, únicamente por su efecto secundario. La función <code>effect</code> usada arriba en el ejemplo inicial puede definirse así:</p>
<pre><code class="language-ts">// Esta función usualmente viviría en una librería/framework, no en código de aplicación
// NOTA: Esta lógica de programación es demasiado básica para ser útil. No copiar/pegar.
let pending = false;

let w = new Signal.subtle.Watcher(() =&gt; {
    if (!pending) {
        pending = true;
        queueMicrotask(() =&gt; {
            pending = false;
            for (let s of w.getPending()) s.get();
            w.watch();
        });
    }
});

// Un Signal de efecto que evalúa cb, que programa una lectura de
// sí mismo en la cola de microtareas cada vez que una de sus dependencias podría cambiar
export function effect(cb) {
    let destructor;
    let c = new Signal.Computed(() =&gt; { destructor?.(); destructor = cb(); });
    w.watch(c);
    c.get();
    return () =&gt; { destructor?.(); w.unwatch(c) };
}
</code></pre>
<p>La API de Signal no incluye ninguna función incorporada como <code>effect</code>. Esto se debe a que la programación de efectos es sutil y a menudo se integra con los ciclos de renderizado del framework y otros estados o estrategias específicas de alto nivel de los frameworks a los que JS no tiene acceso.</p>
<p>Repasando las diferentes operaciones utilizadas aquí: El callback <code>notify</code> pasado al constructor de <code>Watcher</code> es la función que se llama cuando el Signal pasa de un estado &quot;limpio&quot; (donde sabemos que la caché está inicializada y es válida) a un estado &quot;checked&quot; o &quot;dirty&quot; (donde la caché podría o no ser válida porque al menos uno de los estados de los que depende recursivamente ha cambiado).</p>
<p>Las llamadas a <code>notify</code> son desencadenadas en última instancia por una llamada a <code>.set()</code> en algún Signal de estado. Esta llamada es síncrona: sucede antes de que <code>.set</code> retorne. Pero no hay que preocuparse de que este callback observe el grafo de Signals en un estado a medio procesar, porque durante un callback <code>notify</code>, no se puede leer ni escribir ningún Signal, ni siquiera en una llamada a <code>untrack</code>. Como <code>notify</code> se llama durante <code>.set()</code>, está interrumpiendo otro hilo de lógica, que podría no estar completo. Para leer o escribir Signals desde <code>notify</code>, programa el trabajo para que se ejecute después, por ejemplo, escribiendo el Signal en una lista para acceder a él más tarde, o usando <code>queueMicrotask</code> como arriba.</p>
<p>Ten en cuenta que es perfectamente posible usar Signals eficazmente sin <code>Signal.subtle.Watcher</code> programando el sondeo de Signals computados, como hace Glimmer. Sin embargo, muchos frameworks han descubierto que es muy útil que esta lógica de programación se ejecute de forma síncrona, por lo que la API de Signals la incluye.</p>
<p>Tanto los Signals computados como los de estado son recolectados por el recolector de basura como cualquier valor JS. Pero los Watchers tienen una manera especial de mantener vivos los objetos: cualquier Signal observado por un Watcher se mantendrá vivo mientras cualquiera de los estados subyacentes sea accesible, ya que estos pueden desencadenar una futura llamada a <code>notify</code> (y luego a un futuro <code>.get()</code>). Por este motivo, recuerda llamar a <code>Watcher.prototype.unwatch</code> para limpiar efectos.</p>
<h3>Una vía de escape insegura</h3>
<p><code>Signal.subtle.untrack</code> es una vía de escape que permite leer Signals <em>sin</em> rastrear esas lecturas. Esta capacidad es insegura porque permite la creación de Signals computados cuyo valor depende de otros Signals, pero que no se actualizan cuando esos Signals cambian. Debe usarse cuando los accesos no rastreados no cambien el resultado del cálculo.</p>
<!--
TODO: Mostrar ejemplo donde es buena idea usar untrack

### Usando watched/unwatched
TODO: Mostrar un ejemplo de cómo convertir un Observable en una señal computada, suscrita solo cuando es utilizada por un efecto

TODO: Mostrar un ejemplo de una señal computada que representa el resultado de un fetch dirigido a un estado, que es cancelado

### Introspección para SSR

TODO: Mostrar cómo funciona la serialización del grafo de señales

TODO: Mostrar cómo se puede "hidratar" una señal de estado a computada más tarde, usando algunas señales.
-->
<h3>Omitido por ahora</h3>
<p>Estas características pueden añadirse más adelante, pero no están incluidas en el borrador actual. Su omisión se debe a la falta de consenso establecido en el espacio de diseño entre los frameworks, así como a la capacidad demostrada de solventar su ausencia mediante mecanismos adicionales sobre la noción de señales descrita en este documento. Sin embargo, desafortunadamente, la omisión limita el potencial de interoperabilidad entre frameworks. A medida que se produzcan prototipos de señales tal como se describen en este documento, se hará un esfuerzo por reexaminar si estas omisiones fueron la decisión adecuada.</p>
<ul>
<li><strong>Async</strong>: Las señales siempre están disponibles de forma síncrona para su evaluación, en este modelo. Sin embargo, es frecuentemente útil contar con ciertos procesos asíncronos que llevan a que una señal sea establecida, y poder comprender cuándo una señal aún está &quot;cargando&quot;. Una forma simple de modelar el estado de carga es mediante excepciones, y el comportamiento de almacenamiento en caché de excepciones de las señales computadas compone de manera razonable con esta técnica. Se discuten técnicas mejoradas en el <a href="https://github.com/proposal-signals/proposal-signals/issues/30">Issue #30</a>.</li>
<li><strong>Transacciones</strong>: Para transiciones entre vistas, a menudo es útil mantener un estado activo tanto para el estado &quot;de&quot; como para el estado &quot;a&quot;. El estado &quot;a&quot; se renderiza en segundo plano, hasta que esté listo para intercambiarse (comprometer la transacción), mientras que el estado &quot;de&quot; permanece interactivo. Mantener ambos estados al mismo tiempo requiere &quot;bifurcar&quot; el estado del grafo de señales, e incluso puede ser útil admitir múltiples transiciones pendientes a la vez. Discusión en el <a href="https://github.com/proposal-signals/proposal-signals/issues/73">Issue #73</a>.</li>
</ul>
<p>Algunos posibles <a href="https://github.com/proposal-signals/proposal-signals/issues/32">métodos de conveniencia</a> también han sido omitidos.</p>
<h2>Estado y plan de desarrollo</h2>
<p>Esta propuesta está en la agenda de TC39 de abril de 2024 para la Etapa 1. Actualmente puede considerarse como &quot;Etapa 0&quot;.</p>
<p><a href="https://github.com/proposal-signals/signal-polyfill">Un polyfill</a> para esta propuesta está disponible, con algunas pruebas básicas. Algunos autores de frameworks han comenzado a experimentar con sustituir esta implementación de señales, pero este uso está en una etapa inicial.</p>
<p>Los colaboradores en la propuesta de señales quieren ser especialmente <strong>conservadores</strong> en cómo impulsamos esta propuesta, para evitar caer en la trampa de aprobar algo que terminemos lamentando y no usemos realmente. Nuestro plan es realizar las siguientes tareas adicionales, no requeridas por el proceso de TC39, para asegurarnos de que esta propuesta esté en el camino correcto:</p>
<p>Antes de proponer para la Etapa 2, planeamos:</p>
<ul>
<li>Desarrollar múltiples implementaciones de polyfill de nivel de producción que sean sólidas, bien probadas (por ejemplo, pasando pruebas de varios frameworks así como pruebas estilo test262), y competitivas en términos de rendimiento (como se verifique con un conjunto exhaustivo de benchmarks de señales/frameworks).</li>
<li>Integrar la API de señales propuesta en un gran número de frameworks JS que consideremos representativos, y que algunas aplicaciones grandes funcionen con esta base. Probar que funciona de manera eficiente y correcta en estos contextos.</li>
<li>Tener una comprensión sólida sobre el espacio de posibles extensiones para la API, y haber concluido cuáles (si hay alguna) deberían añadirse a esta propuesta.</li>
</ul>
<h2>Algoritmos de señales</h2>
<p>Esta sección describe cada una de las APIs expuestas a JavaScript, en términos de los algoritmos que implementan. Esto puede considerarse como una proto-especificación, y se incluye en este punto temprano para precisar un posible conjunto de semánticas, estando muy abiertos a cambios.</p>
<p>Algunos aspectos del algoritmo:</p>
<ul>
<li>El orden de lectura de señales dentro de una computada es significativo y es observable en el orden en que se ejecutan ciertos callbacks (cuál <code>Watcher</code> es invocado, <code>equals</code>, el primer parámetro de <code>new Signal.Computed</code>, y los callbacks <code>watched</code>/<code>unwatched</code>). Esto significa que las fuentes de una señal computada deben almacenarse ordenadas.</li>
<li>Estos cuatro callbacks pueden lanzar excepciones, y estas excepciones se propagan de manera predecible al código JS que las llama. Las excepciones <em>no</em> detienen la ejecución de este algoritmo ni dejan el grafo en un estado medio procesado. Para los errores lanzados en el callback <code>notify</code> de un Watcher, esa excepción se envía a la llamada <code>.set()</code> que la disparó, usando un AggregateError si se lanzaron varias excepciones. Las demás (incluyendo <code>watched</code>/<code>unwatched</code>?) se almacenan en el valor de la señal, para ser relanzadas al leerlas, y una señal que relanza así puede marcarse como <code>~clean~</code> igual que cualquier otra con un valor normal.</li>
<li>Se tiene cuidado de evitar circularidades en los casos de señales computadas que no están &quot;observadas&quot; (siendo observadas por algún Watcher), para que puedan ser recolectadas por el recolector de basura independientemente de otras partes del grafo de señales. Internamente, esto puede implementarse con un sistema de números de generación que siempre se recolectan; cabe señalar que las implementaciones optimizadas también pueden incluir números de generación locales por nodo, o evitar el rastreo de algunos números en señales observadas.</li>
</ul>
<h3>Estado global oculto</h3>
<p>Los algoritmos de señales necesitan hacer referencia a cierto estado global. Este estado es global para todo el hilo, o &quot;agente&quot;.</p>
<ul>
<li><code>computing</code>: La señal computada o de efecto más interna que actualmente está siendo reevaluada debido a una llamada <code>.get</code> o <code>.run</code>, o <code>null</code>. Inicialmente <code>null</code>.</li>
<li><code>frozen</code>: Booleano que indica si hay un callback actualmente ejecutándose que requiere que el grafo no sea modificado. Inicialmente <code>false</code>.</li>
<li><code>generation</code>: Un entero incremental, comenzando en 0, usado para rastrear cuán actual es un valor mientras se evitan circularidades.</li>
</ul>
<h3>El espacio de nombres <code>Signal</code></h3>
<p><code>Signal</code> es un objeto ordinario que sirve como espacio de nombres para clases y funciones relacionadas con señales.</p>
<p><code>Signal.subtle</code> es un objeto de espacio de nombres interno similar.</p>
<h3>La clase <code>Signal.State</code></h3>
<h4>Slots internos de <code>Signal.State</code></h4>
<ul>
<li><code>value</code>: El valor actual de la señal de estado</li>
<li><code>equals</code>: La función de comparación usada al cambiar valores</li>
<li><code>watched</code>: El callback que se llama cuando la señal pasa a ser observada por un efecto</li>
<li><code>unwatched</code>: El callback que se llama cuando la señal deja de ser observada por un efecto</li>
<li><code>sinks</code>: Conjunto de señales observadas que dependen de esta</li>
</ul>
<h4>Constructor: <code>Signal.State(initialValue, options)</code></h4>
<ol>
<li>Establece el <code>value</code> de esta señal a <code>initialValue</code>.</li>
<li>Establece el <code>equals</code> de esta señal a options?.equals</li>
<li>Establece el <code>watched</code> de esta señal a options?.[Signal.subtle.watched]</li>
<li>Establece el <code>unwatched</code> de esta señal a options?.[Signal.subtle.unwatched]</li>
<li>Establece el <code>sinks</code> de esta señal como el conjunto vacío</li>
</ol>
<h4>Método: <code>Signal.State.prototype.get()</code></h4>
<ol>
<li>Si <code>frozen</code> es true, lanza una excepción.</li>
<li>Si <code>computing</code> no es <code>undefined</code>, agrega esta señal al conjunto <code>sources</code> de <code>computing</code>.</li>
<li>NOTA: No agregamos <code>computing</code> al conjunto <code>sinks</code> de esta señal hasta que sea observada por un Watcher.</li>
<li>Devuelve el <code>value</code> de esta señal.</li>
</ol>
<h4>Método: <code>Signal.State.prototype.set(newValue)</code></h4>
<ol>
<li>Si el contexto de ejecución actual es <code>frozen</code>, lanza una excepción.</li>
<li>Ejecuta el algoritmo &quot;establecer valor de señal&quot; con esta señal y el primer parámetro como valor.</li>
<li>Si ese algoritmo devolvió <code>~clean~</code>, entonces retorna undefined.</li>
<li>Establece el estado de todos los <code>sinks</code> de esta señal a (si es una señal Computed) <code>~dirty~</code> si estaban previamente limpios, o (si es un Watcher) <code>~pending~</code> si estaba previamente <code>~watching~</code>.</li>
<li>Establece el estado de todas las dependencias Computed Signal de los sinks (recursivamente) a <code>~checked~</code> si estaban previamente <code>~clean~</code> (es decir, deja las marcas sucias en su lugar), o para Watchers, <code>~pending~</code> si previamente <code>~watching~</code>.</li>
<li>Para cada Watcher previamente <code>~watching~</code> encontrado en esa búsqueda recursiva, luego en orden de profundidad primero,
<ol>
<li>Establece <code>frozen</code> en true.</li>
<li>Llama a su callback <code>notify</code> (guardando cualquier excepción lanzada, pero ignorando el valor de retorno de <code>notify</code>).</li>
<li>Restaura <code>frozen</code> a false.</li>
<li>Establece el estado del Watcher a <code>~waiting~</code>.</li>
</ol>
</li>
<li>Si alguna excepción fue lanzada desde los callbacks <code>notify</code>, propágala al llamador después de que todos los callbacks <code>notify</code> hayan sido ejecutados. Si hay múltiples excepciones, agrúpalas en un AggregateError y lánzalo.</li>
<li>Retorna undefined.</li>
</ol>
<h3>La clase <code>Signal.Computed</code></h3>
<h4>Máquina de estados de <code>Signal.Computed</code></h4>
<p>El <code>state</code> de una Señal Computada puede ser uno de los siguientes:</p>
<ul>
<li><code>~clean~</code>: El valor de la Señal está presente y se sabe que no está obsoleto.</li>
<li><code>~checked~</code>: Una fuente (indirecta) de esta Señal ha cambiado; esta Señal tiene un valor pero <em>puede</em> estar obsoleto. Solo se sabrá si está obsoleto cuando todas las fuentes inmediatas hayan sido evaluadas.</li>
<li><code>~computing~</code>: El callback de esta Señal se está ejecutando actualmente como efecto secundario de una llamada a <code>.get()</code>.</li>
<li><code>~dirty~</code>: O bien esta Señal tiene un valor que se sabe que está obsoleto, o nunca ha sido evaluada.</li>
</ul>
<p>El gráfico de transición es el siguiente:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; dirty
    dirty --&gt; computing: [4]
    computing --&gt; clean: [5]
    clean --&gt; dirty: [2]
    clean --&gt; checked: [3]
    checked --&gt; clean: [6]
    checked --&gt; dirty: [1]
</code></pre>
<p>Las transiciones son:
| Número | De | A | Condición | Algoritmo |
| ------ | ---- | -- | --------- | --------- |
| 1 | <code>~checked~</code> | <code>~dirty~</code> | Una fuente inmediata de esta señal, que es una señal computada, ha sido evaluada y su valor ha cambiado. | Algoritmo: recalcular señal computada dirty |
| 2 | <code>~clean~</code> | <code>~dirty~</code> | Una fuente inmediata de esta señal, que es un Estado, ha sido establecida con un valor que no es igual a su valor anterior. | Método: <code>Signal.State.prototype.set(newValue)</code> |
| 3 | <code>~clean~</code> | <code>~checked~</code> | Una fuente recursiva, pero no inmediata, de esta señal, que es un Estado, ha sido establecida con un valor que no es igual a su valor anterior. | Método: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~dirty~</code> | <code>~computing~</code> | Estamos a punto de ejecutar el <code>callback</code>. | Algoritmo: recalcular señal computada dirty |
| 5 | <code>~computing~</code> | <code>~clean~</code> | El <code>callback</code> ha terminado de evaluarse y ha retornado un valor o lanzado una excepción. | Algoritmo: recalcular señal computada dirty |
| 6 | <code>~checked~</code> | <code>~clean~</code> | Todas las fuentes inmediatas de esta señal han sido evaluadas, y todas se han descubierto sin cambios, por lo que ahora se sabe que no está obsoleta. | Algoritmo: recalcular señal computada dirty |</p>
<h4>Slots internos de <code>Signal.Computed</code></h4>
<ul>
<li><code>value</code>: El valor almacenado previamente en caché de la Señal, o <code>~uninitialized~</code> para una señal computada nunca leída. El valor puede ser una excepción que se relanza cuando se lee el valor. Siempre es <code>undefined</code> para señales de efecto.</li>
<li><code>state</code>: Puede ser <code>~clean~</code>, <code>~checked~</code>, <code>~computing~</code>, o <code>~dirty~</code>.</li>
<li><code>sources</code>: Un conjunto ordenado de Señales de las que depende esta Señal.</li>
<li><code>sinks</code>: Un conjunto ordenado de Señales que dependen de esta Señal.</li>
<li><code>equals</code>: El método equals proporcionado en las opciones.</li>
<li><code>callback</code>: El callback que se llama para obtener el valor de la señal computada. Se establece con el primer parámetro pasado al constructor.</li>
</ul>
<h4>Constructor de <code>Signal.Computed</code></h4>
<p>El constructor asigna</p>
<ul>
<li><code>callback</code> a su primer parámetro</li>
<li><code>equals</code> según las opciones, usando por defecto <code>Object.is</code> si está ausente</li>
<li><code>state</code> a <code>~dirty~</code></li>
<li><code>value</code> a <code>~uninitialized~</code></li>
</ul>
<p>Con <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a>, el callback pasado a <code>new Signal.Computed</code> se cierra sobre el snapshot del momento en que fue llamado el constructor, y restaura este snapshot durante su ejecución.</p>
<h4>Método: <code>Signal.Computed.prototype.get</code></h4>
<ol>
<li>Si el contexto de ejecución actual está <code>frozen</code> o si esta Señal tiene el estado <code>~computing~</code>, o si esta señal es un Watcher y está <code>computing</code> una señal computada, lanzar una excepción.</li>
<li>Si <code>computing</code> no es <code>null</code>, añadir esta Señal al conjunto <code>sources</code> de <code>computing</code>.</li>
<li>NOTA: No añadimos <code>computing</code> al conjunto <code>sinks</code> de esta Señal hasta que/no sea observada por un Watcher.</li>
<li>Si el estado de esta Señal es <code>~dirty~</code> o <code>~checked~</code>: Repetir los siguientes pasos hasta que esta Señal esté <code>~clean~</code>:
<ol>
<li>Recorrer hacia arriba vía <code>sources</code> para encontrar la fuente recursiva más profunda y más a la izquierda (es decir, la primera observada) que sea una Señal Computada marcada como <code>~dirty~</code> (deteniendo la búsqueda al encontrar una Señal Computada <code>~clean~</code>, e incluyendo esta Señal Computada como lo último a buscar).</li>
<li>Ejecutar el algoritmo &quot;recalcular señal computada dirty&quot; en esa Señal.</li>
</ol>
</li>
<li>En este punto, el estado de esta Señal será <code>~clean~</code>, y ninguna fuente recursiva estará <code>~dirty~</code> ni <code>~checked~</code>. Retornar el <code>value</code> de la Señal. Si el valor es una excepción, relanzar esa excepción.</li>
</ol>
<h3>La clase <code>Signal.subtle.Watcher</code></h3>
<h4>Máquina de estados de <code>Signal.subtle.Watcher</code></h4>
<p>El <code>state</code> de un Watcher puede ser uno de los siguientes:</p>
<ul>
<li><code>~waiting~</code>: El callback <code>notify</code> ha sido ejecutado, o el Watcher es nuevo, pero no está observando activamente ninguna señal.</li>
<li><code>~watching~</code>: El Watcher está observando señales activamente, pero aún no han ocurrido cambios que requieran una llamada al callback <code>notify</code>.</li>
<li><code>~pending~</code>: Una dependencia del Watcher ha cambiado, pero el callback <code>notify</code> aún no ha sido ejecutado.</li>
</ul>
<p>El gráfico de transición es el siguiente:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; waiting
    waiting --&gt; watching: [1]
    watching --&gt; waiting: [2]
    watching --&gt; pending: [3]
    pending --&gt; waiting: [4]
</code></pre>
<p>Las transiciones son:
| Número | De | A | Condición | Algoritmo |
| ------ | ---- | -- | --------- | --------- |
| 1 | <code>~waiting~</code> | <code>~watching~</code> | Se ha llamado al método <code>watch</code> del Watcher. | Método: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code> |
| 2 | <code>~watching~</code> | <code>~waiting~</code> | Se ha llamado al método <code>unwatch</code> del Watcher y se ha eliminado la última señal observada. | Método: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code> |
| 3 | <code>~watching~</code> | <code>~pending~</code> | Una señal observada puede haber cambiado de valor. | Método: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~pending~</code> | <code>~waiting~</code> | El callback <code>notify</code> ha sido ejecutado. | Método: <code>Signal.State.prototype.set(newValue)</code> |</p>
<h4>Slots internos de <code>Signal.subtle.Watcher</code></h4>
<ul>
<li><code>state</code>: Puede ser <code>~watching~</code>, <code>~pending~</code> o <code>~waiting~</code></li>
<li><code>signals</code>: Un conjunto ordenado de Señales que este Watcher está observando</li>
<li><code>notifyCallback</code>: El callback que se llama cuando algo cambia. Se establece con el primer parámetro pasado al constructor.</li>
</ul>
<h4>Constructor: <code>new Signal.subtle.Watcher(callback)</code></h4>
<ol>
<li>El <code>state</code> se establece en <code>~waiting~</code>.</li>
<li>Inicializar <code>signals</code> como un conjunto vacío.</li>
<li><code>notifyCallback</code> se establece al parámetro callback.
Con <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a>, el callback pasado a <code>new Signal.subtle.Watcher</code> <em>no</em> captura el snapshot del momento en que se llamó al constructor, de modo que la información contextual alrededor de la escritura sea visible.</li>
</ol>
<h4>Método: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code></h4>
<ol>
<li>Si <code>frozen</code> es true, lanza una excepción.</li>
<li>Si alguno de los argumentos no es una señal, lanza una excepción.</li>
<li>Añade todos los argumentos al final del array <code>signals</code> de este objeto.</li>
<li>Para cada señal recién observada, en orden de izquierda a derecha,
<ol>
<li>Añade este watcher como un <code>sink</code> a esa señal.</li>
<li>Si este fue el primer sink, entonces recursivamente sube a las fuentes para añadir esa señal como sink.</li>
<li>Establece <code>frozen</code> en true.</li>
<li>Llama al callback <code>watched</code> si existe.</li>
<li>Restaura <code>frozen</code> a false.</li>
</ol>
</li>
<li>Si el <code>state</code> de la Signal es <code>~waiting~</code>, entonces establécelo a <code>~watching~</code>.</li>
</ol>
<h4>Método: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code></h4>
<ol>
<li>Si <code>frozen</code> es true, lanza una excepción.</li>
<li>Si alguno de los argumentos no es una señal, o no está siendo observada por este watcher, lanza una excepción.</li>
<li>Para cada señal en los argumentos, en orden de izquierda a derecha,
<ol>
<li>Elimina esa señal del conjunto <code>signals</code> de este Watcher.</li>
<li>Elimina este Watcher del conjunto <code>sink</code> de esa Signal.</li>
<li>Si el conjunto <code>sink</code> de esa Signal se ha quedado vacío, elimina esa Signal como sink de cada una de sus fuentes.</li>
<li>Establece <code>frozen</code> en true.</li>
<li>Llama al callback <code>unwatched</code> si existe.</li>
<li>Restaura <code>frozen</code> a false.</li>
</ol>
</li>
<li>Si el watcher ahora no tiene <code>signals</code>, y su <code>state</code> es <code>~watching~</code>, entonces establécelo a <code>~waiting~</code>.</li>
</ol>
<h4>Método: <code>Signal.subtle.Watcher.prototype.getPending()</code></h4>
<ol>
<li>Devuelve un Array que contiene el subconjunto de <code>signals</code> que son Computed Signals en los estados <code>~dirty~</code> o <code>~pending~</code>.</li>
</ol>
<h3>Método: <code>Signal.subtle.untrack(cb)</code></h3>
<ol>
<li>Deja que <code>c</code> sea el estado <code>computing</code> actual del contexto de ejecución.</li>
<li>Establece <code>computing</code> a null.</li>
<li>Llama a <code>cb</code>.</li>
<li>Restaura <code>computing</code> a <code>c</code> (incluso si <code>cb</code> lanzó una excepción).</li>
<li>Devuelve el valor de retorno de <code>cb</code> (relanzando cualquier excepción).</li>
</ol>
<p>Nota: untrack no te saca del estado <code>frozen</code>, el cual se mantiene estrictamente.</p>
<h3>Método: <code>Signal.subtle.currentComputed()</code></h3>
<ol>
<li>Devuelve el valor actual de <code>computing</code>.</li>
</ol>
<h3>Algoritmos comunes</h3>
<h5>Algoritmo: recalcular una Signal computada dirty</h5>
<ol>
<li>Limpia el conjunto <code>sources</code> de esta Signal y elimínala de los conjuntos <code>sinks</code> de esas fuentes.</li>
<li>Guarda el valor anterior de <code>computing</code> y establece <code>computing</code> a esta Signal.</li>
<li>Establece el estado de esta Signal a <code>~computing~</code>.</li>
<li>Ejecuta el callback de esta Signal computada, usando esta Signal como valor de this. Guarda el valor de retorno y, si el callback lanzó una excepción, almacénala para relanzarla.</li>
<li>Restaura el valor anterior de <code>computing</code>.</li>
<li>Aplica el algoritmo &quot;set Signal value&quot; al valor de retorno del callback.</li>
<li>Establece el estado de esta Signal a <code>~clean~</code>.</li>
<li>Si ese algoritmo devolvió <code>~dirty~</code>: marca todos los sinks de esta Signal como <code>~dirty~</code> (anteriormente, los sinks podían estar mezclados entre checked y dirty). (O, si no está siendo observada, entonces adopta un nuevo número de generación para indicar suciedad, o algo así.)</li>
<li>De lo contrario, si el algoritmo devolvió <code>~clean~</code>: En este caso, para cada sink <code>~checked~</code> de esta Signal, si todas las fuentes de esa Signal están ahora limpias, marca también esa Signal como <code>~clean~</code>. Aplica este paso de limpieza a sinks adicionales recursivamente, a cualquier Signal recién limpia que tenga sinks marcados como checked. (O, si no está siendo observada, indica lo mismo de alguna manera, para que la limpieza pueda proceder de forma perezosa.)</li>
</ol>
<h5>Algoritmo para establecer el valor de una Signal</h5>
<ol>
<li>Si a este algoritmo se le pasó un valor (en vez de una excepción para relanzar, del algoritmo de recalcular Signal computada dirty):
<ol>
<li>Llama a la función <code>equals</code> de esta Signal, pasando como parámetros el <code>value</code> actual, el nuevo valor y esta Signal. Si se lanza una excepción, guarda esa excepción (para relanzar al leer) como el valor de la Signal y continúa como si el callback hubiese devuelto false.</li>
<li>Si esa función devolvió true, devuelve <code>~clean~</code>.</li>
</ol>
</li>
<li>Establece el <code>value</code> de esta Signal al parámetro.</li>
<li>Devuelve <code>~dirty~</code></li>
</ol>
<h2>FAQ</h2>
<p><strong>P</strong>: ¿No es un poco pronto para estandarizar algo relacionado con Signals, cuando acaban de empezar a ser lo nuevo en 2022? ¿No deberíamos darles más tiempo para evolucionar y estabilizarse?</p>
<p><strong>R</strong>: El estado actual de las Signals en los frameworks web es el resultado de más de 10 años de desarrollo continuo. A medida que aumenta la inversión, como ha ocurrido en los últimos años, casi todos los frameworks web se están acercando a un modelo central de Signals muy similar. Esta propuesta es el resultado de un ejercicio de diseño compartido entre un gran número de líderes actuales en frameworks web, y no se impulsará hacia la estandarización sin la validación de ese grupo de expertos en diversos contextos.</p>
<h4>¿Cómo se usan las Signals?</h4>
<p><strong>P</strong>: ¿Las Signals integradas pueden siquiera ser usadas por frameworks, dado su estrecha integración con el renderizado y la propiedad?</p>
<p><strong>R</strong>: Las partes que son más específicas del framework suelen estar en el área de efectos, scheduling y ownership/disposal, que esta propuesta no intenta resolver. Nuestra primera prioridad con la prototipación de Signals en proceso de estandarización es validar que puedan operar &quot;por debajo&quot; de los frameworks existentes de manera compatible y con buen rendimiento.</p>
<p><strong>P</strong>: ¿La API de Signal está pensada para ser usada directamente por desarrolladores de aplicaciones, o envuelta por frameworks?</p>
<p><strong>R</strong>: Aunque esta API podría ser utilizada directamente por desarrolladores de aplicaciones (al menos la parte que no está en el namespace <code>Signal.subtle</code>), no está diseñada para ser especialmente ergonómica. En su lugar, las necesidades de los autores de librerías/frameworks son prioritarias. Se espera que la mayoría de los frameworks envuelvan incluso las APIs básicas <code>Signal.State</code> y <code>Signal.Computed</code> con algo que exprese su propio enfoque ergonómico. En la práctica, normalmente es mejor usar Signals a través de un framework, que gestione las características más complejas (por ejemplo, Watcher, <code>untrack</code>), así como el ownership y disposal (por ejemplo, determinar cuándo las signals deben ser añadidas o eliminadas de los watchers), y programando el renderizado al DOM; esta propuesta no intenta resolver esos problemas.</p>
<p><strong>P</strong>: ¿Tengo que destruir las Signals relacionadas con un widget cuando ese widget se destruye? ¿Cuál es la API para eso?</p>
<p><strong>R</strong>: La operación de desmontaje relevante aquí es <code>Signal.subtle.Watcher.prototype.unwatch</code>. Solo las Signals observadas necesitan ser limpiadas (desobservando), mientras que las Signals no observadas pueden ser recolectadas automáticamente por el garbage collector.</p>
<p><strong>P</strong>: ¿Las Signals funcionan con VDOM o directamente con el HTML DOM subyacente?</p>
<p><strong>R</strong>: ¡Sí! Las Signals son independientes de la tecnología de renderizado. Los frameworks de JavaScript existentes que usan construcciones similares a Signals se integran con VDOM (por ejemplo, Preact), el DOM nativo (por ejemplo, Solid) y una combinación (por ejemplo, Vue). Lo mismo será posible con las Signals integradas.</p>
<p><strong>P</strong>: ¿Será ergonómico usar Signals en el contexto de frameworks basados en clases como Angular y Lit? ¿Y qué pasa con los frameworks basados en compiladores como Svelte?</p>
<p><strong>R</strong>: Los campos de clase pueden ser basados en Signal usando un simple decorador de accessors, como se muestra en <a href="https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators">el readme del polyfill de Signal</a>. Las Signals están muy alineadas con los Runes de Svelte 5—es sencillo para un compilador transformar runes a la API de Signal definida aquí, y de hecho esto es lo que hace Svelte 5 internamente (aunque con su propia librería de Signals).</p>
<p><strong>P</strong>: ¿Las Signals funcionan con SSR? ¿Con Hydration? ¿Con Resumability?</p>
<p><strong>R</strong>: Sí. Qwik utiliza Signals con buenos resultados en ambas propiedades, y otros frameworks tienen enfoques bien desarrollados para la hidratación con Signals y distintos tradeoffs. Creemos que es posible modelar las Signals resumibles de Qwik usando una señal State y una Computed conectadas, y planeamos demostrarlo en código.
<strong>P</strong>: ¿Funcionan las Signals con un flujo de datos unidireccional como lo hace React?</p>
<p><strong>R</strong>: Sí, las Signals son un mecanismo para el flujo de datos unidireccional. Los frameworks de UI basados en Signals te permiten expresar tu vista como una función del modelo (donde el modelo incorpora Signals). Un grafo de estado y Signals computadas es acíclico por construcción. También es posible recrear los anti-patrones de React dentro de Signals (!), por ejemplo, el equivalente a un <code>setState</code> dentro de <code>useEffect</code> sería usar un Watcher para programar una escritura en una Signal de estado.</p>
<p><strong>P</strong>: ¿Cómo se relacionan las signals con sistemas de gestión de estado como Redux? ¿Las signals fomentan un estado no estructurado?</p>
<p><strong>R</strong>: Las Signals pueden formar una base eficiente para abstracciones de gestión de estado similares a un store. Un patrón común en varios frameworks es un objeto basado en un Proxy que internamente representa las propiedades usando Signals, por ejemplo, <a href="https://vuejs.org/api/reactivity-core.html#reactive">Vue <code>reactive()</code></a>, o <a href="https://docs.solidjs.com/concepts/stores">Solid stores</a>. Estos sistemas permiten agrupar el estado de manera flexible al nivel de abstracción adecuado para la aplicación en particular.</p>
<p><strong>P</strong>: ¿Qué ofrecen las Signals que <code>Proxy</code> no maneja actualmente?</p>
<p><strong>R</strong>: Los Proxies y las Signals son complementarios y funcionan bien juntos. Los Proxies te permiten interceptar operaciones superficiales de objetos y las signals coordinan un grafo de dependencias (de celdas). Respaldar un Proxy con Signals es una excelente manera de crear una estructura reactiva anidada con gran ergonomía.</p>
<p>En este ejemplo, podemos usar un proxy para hacer que la signal tenga una propiedad getter y setter en lugar de usar los métodos <code>get</code> y <code>set</code>:</p>
<pre><code class="language-js">const a = new Signal.State(0);
const b = new Proxy(a, {
  get(target, property, receiver) {
    if (property === 'value') {
      return target.get():
    }
  }
  set(target, property, value, receiver) {
    if (property === 'value') {
      target.set(value)!
    }
  }
});

// uso en un contexto reactivo hipotético:
&lt;template&gt;
  {b.value}

  &lt;button onclick={() =&gt; {
    b.value++;
  }}&gt;cambiar&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>al usar un renderizador que esté optimizado para reactividad de grano fino, al hacer clic en el botón se actualizará la celda <code>b.value</code>.</p>
<p>Ver:</p>
<ul>
<li>ejemplos de estructuras reactivas anidadas creadas con Signals y Proxies: <a href="https://github.com/NullVoxPopuli/signal-utils/tree/main/src">signal-utils</a></li>
<li>ejemplo de implementaciones anteriores que muestran la relación entre datos reactivos y proxies: <a href="https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private">tracked-built-ins</a></li>
<li><a href="https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574">discusión</a>.</li>
</ul>
<h4>¿Cómo funcionan las Signals?</h4>
<p><strong>P</strong>: ¿Las Signals son basadas en push o en pull?</p>
<p><strong>R</strong>: La evaluación de las Signals computadas es basada en pull: las Signals computadas solo se evalúan cuando se llama a <code>.get()</code>, incluso si el estado subyacente cambió mucho antes. Al mismo tiempo, cambiar una Signal de estado puede activar inmediatamente el callback de un Watcher, &quot;empujando&quot; la notificación. Así que las Signals pueden considerarse como una construcción &quot;push-pull&quot;.</p>
<p><strong>P</strong>: ¿Las Signals introducen no determinismo en la ejecución de JavaScript?</p>
<p><strong>R</strong>: No. Para empezar, todas las operaciones de Signal tienen semánticas y orden bien definidos, y no variarán entre implementaciones conformes. A un nivel superior, las Signals siguen un conjunto de invariantes con respecto a los cuales son &quot;correctas&quot;. Una Signal computada siempre observa el grafo de signals en un estado consistente, y su ejecución no es interrumpida por otro código que modifique Signals (excepto por cosas que ella misma llame). Ver la descripción arriba.</p>
<p><strong>P</strong>: Cuando escribo en una Signal de estado, ¿cuándo se programa la actualización de la Signal computada?</p>
<p><strong>R</strong>: ¡No se programa! La Signal computada se recalculará la próxima vez que alguien la lea. De manera síncrona, se puede llamar al callback <code>notify</code> de un Watcher, permitiendo que los frameworks programen una lectura en el momento que consideren apropiado.</p>
<p><strong>P</strong>: ¿Cuándo surten efecto las escrituras en Signals de estado? ¿Inmediatamente o se agrupan (batched)?</p>
<p><strong>R</strong>: Las escrituras a las Signals de estado se reflejan inmediatamente: la próxima vez que se lea una Signal computada que depende de la Signal de estado, se recalculará si es necesario, incluso si es en la línea de código inmediatamente siguiente. Sin embargo, la pereza inherente en este mecanismo (que las Signals computadas solo se calculan cuando se leen) significa que, en la práctica, los cálculos pueden suceder de manera agrupada.</p>
<p><strong>P</strong>: ¿Qué significa que las Signals permitan una ejecución &quot;libre de glitches&quot;?</p>
<p><strong>R</strong>: Los modelos anteriores basados en push para la reactividad enfrentaban un problema de cálculo redundante: Si una actualización a una Signal de estado hace que la Signal computada se ejecute de inmediato, en última instancia, esto puede empujar una actualización a la UI. Pero esta escritura en la UI puede ser prematura, si iba a haber otro cambio en la Signal de estado original antes del siguiente frame. A veces, incluso se mostraban valores intermedios inexactos a los usuarios finales debido a estos <a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">glitches</a>. Las Signals evitan esta dinámica siendo pull-based en vez de push-based: en el momento en que el framework programa el renderizado de la UI, extraerá las actualizaciones apropiadas, evitando trabajo innecesario tanto en el cálculo como en la escritura al DOM.</p>
<p><strong>P</strong>: ¿Qué significa que las Signals sean &quot;lossy&quot; (con pérdida)?</p>
<p><strong>R</strong>: Este es el reverso de la ejecución libre de glitches: las Signals representan una celda de datos--solo el valor actual inmediato (que puede cambiar), no un flujo de datos en el tiempo. Por lo tanto, si escribes en una Signal de estado dos veces seguidas, sin hacer nada más, la primera escritura se &quot;pierde&quot; y nunca será vista por ninguna Signal computada o efecto. Esto se entiende como una característica y no un error; otros constructos (por ejemplo, iterables async, observables) son más apropiados para flujos de datos.</p>
<p><strong>P</strong>: ¿Las Signals nativas serán más rápidas que las implementaciones JS existentes de Signals?</p>
<p><strong>R</strong>: Esperamos que sí (por un pequeño factor constante), pero esto aún debe demostrarse en código. Los motores JS no son mágicos y, en última instancia, necesitarán implementar los mismos tipos de algoritmos que las implementaciones JS de Signals. Ver la sección anterior sobre rendimiento.</p>
<h4>¿Por qué las Signals están diseñadas de esta manera?</h4>
<p><strong>P</strong>: ¿Por qué esta propuesta no incluye una función <code>effect()</code>, si los efectos son necesarios para el uso práctico de Signals?</p>
<p><strong>R</strong>: Los efectos están inherentemente ligados a la programación y disposición, que son gestionados por los frameworks y están fuera del alcance de esta propuesta. En su lugar, esta propuesta incluye la base para implementar efectos a través de la API de bajo nivel <code>Signal.subtle.Watcher</code>.</p>
<p><strong>P</strong>: ¿Por qué las suscripciones son automáticas en lugar de proveer una interfaz manual?</p>
<p><strong>R</strong>: La experiencia ha demostrado que las interfaces de suscripción manual para la reactividad no son ergonómicas y son propensas a errores. El rastreo automático es más componible y es una característica central de las Signals.</p>
<p><strong>P</strong>: ¿Por qué el callback del <code>Watcher</code> se ejecuta de forma síncrona en vez de programarse en una microtarea?</p>
<p><strong>R</strong>: Porque el callback no puede leer ni escribir Signals, no se produce ninguna incoherencia al llamarlo de forma síncrona. Un callback típico añadirá una Signal a un Array para leerla más tarde, o marcará un bit en algún lugar. Es innecesario y poco práctico crear una microtarea separada para todas estas acciones.</p>
<p><strong>P</strong>: A esta API le faltan algunas cosas útiles que proporciona mi framework favorito, lo que hace que sea más fácil programar con Signals. ¿Eso también se puede agregar al estándar?</p>
<p><strong>R</strong>: Tal vez. Varias extensiones todavía están bajo consideración. Por favor, abre un issue para iniciar una discusión sobre cualquier característica importante que consideres que falta.</p>
<p><strong>P</strong>: ¿Se puede reducir el tamaño o la complejidad de esta API?</p>
<p><strong>R</strong>: Definitivamente es un objetivo mantener esta API mínima, y hemos intentado hacerlo con lo presentado arriba. Si tienes ideas para más cosas que se puedan eliminar, por favor abre un issue para discutirlo.</p>
<h4>¿Cómo se están estandarizando las Signals?</h4>
<p><strong>P</strong>: ¿No deberíamos comenzar el trabajo de estandarización en esta área con un concepto más primitivo, como los observables?
<strong>A</strong>: Los observables pueden ser una buena idea para algunas cosas, pero no resuelven los problemas que las Signals buscan solucionar. Como se describió anteriormente, los observables u otros mecanismos de publicación/suscripción no son una solución completa para muchos tipos de programación de interfaces de usuario, debido a la excesiva configuración propensa a errores para los desarrolladores y al trabajo desperdiciado por la falta de pereza, entre otros problemas.</p>
<p><strong>Q</strong>: ¿Por qué se están proponiendo las Signals en TC39 en lugar de en el DOM, dado que la mayoría de sus aplicaciones son basadas en la web?</p>
<p><strong>A</strong>: Algunos coautores de esta propuesta están interesados en entornos de interfaz de usuario fuera de la web como objetivo, pero hoy en día, cualquiera de los dos espacios puede ser adecuado para eso, ya que las APIs web se implementan cada vez más fuera de la web. En última instancia, las Signals no necesitan depender de ninguna API del DOM, así que cualquiera de las dos opciones funciona. Si alguien tiene una razón de peso para que este grupo cambie, por favor háganoslo saber en un issue. Por ahora, todos los colaboradores han firmado los acuerdos de propiedad intelectual de TC39, y el plan es presentar esto en TC39.</p>
<p><strong>Q</strong>: ¿Cuánto tiempo tomará hasta que pueda usar Signals estándar?</p>
<p><strong>A</strong>: Ya hay un polyfill disponible, pero es mejor no depender de su estabilidad, ya que esta API evoluciona durante su proceso de revisión. En algunos meses o un año, debería estar disponible un polyfill estable, de alta calidad y alto rendimiento, pero esto aún estará sujeto a revisiones del comité y no será estándar todavía. Siguiendo la trayectoria típica de una propuesta de TC39, se espera que tome al menos 2-3 años como mínimo absoluto para que las Signals estén disponibles de forma nativa en todos los navegadores, retrocediendo algunas versiones, de modo que los polyfills ya no sean necesarios.</p>
<p><strong>Q</strong>: ¿Cómo evitaremos estandarizar el tipo equivocado de Signals demasiado pronto, como ocurrió con {{JS/web feature que no te gusta}}?</p>
<p><strong>A</strong>: Los autores de esta propuesta planean ir más allá con la creación de prototipos y la validación antes de solicitar el avance de etapa en TC39. Véase &quot;Estado y plan de desarrollo&quot; más arriba. Si ves vacíos en este plan u oportunidades de mejora, por favor crea un issue explicándolo.</p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-28</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>