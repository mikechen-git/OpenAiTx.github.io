<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>proposal-signals - tc39/proposal-signals th</title>
    <meta name="title" content="proposal-signals - tc39/proposal-signals th | 🚦 ข้อเสนอมาตรฐาน JavaScript Signals 🚦 Stage 1 (คำอธิบาย) TC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell ...">
    <meta name="description" content="tc39/proposal-signals - GitHub repository th documentation and information | 🚦 ข้อเสนอมาตรฐาน JavaScript Signals 🚦 Stage 1 (คำอธิบาย) TC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell ...">
    <meta name="keywords" content="tc39, proposal-signals, GitHub, repository, th documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/tc39/proposal-signals/README-th.html">
    <meta property="og:title" content="proposal-signals - tc39/proposal-signals th | 🚦 ข้อเสนอมาตรฐาน JavaScript Signals 🚦 Stage 1 (คำอธิบาย) TC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell ...">
    <meta property="og:description" content="tc39/proposal-signals - GitHub repository th documentation and information | 🚦 ข้อเสนอมาตรฐาน JavaScript Signals 🚦 Stage 1 (คำอธิบาย) TC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell ...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/tc39/proposal-signals" id="githubRepoLink" target="_blank">tc39/proposal-signals</a>
<h1 style="display: none;">🚦 ข้อเสนอมาตรฐาน JavaScript Signals 🚦 Stage 1 (คำอธิบาย) TC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell ...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>🚦 ข้อเสนอมาตรฐาน JavaScript Signals 🚦</h1>
<img align=right src="https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg" alt="Signals logo" width=100>
<p>Stage 1 (<a href="https://tc39.es/process-document/">คำอธิบาย</a>)</p>
<p>TC39 proposal champions: Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg</p>
<p>ผู้เขียนต้นฉบับ: Rob Eisenberg และ Daniel Ehrenberg</p>
<p>เอกสารนี้อธิบายทิศทางร่วมเบื้องต้นสำหรับ signals ใน JavaScript คล้ายกับความพยายาม Promises/A+ ซึ่งมาก่อน Promises ที่ TC39 รับรองเป็นมาตรฐานใน ES2015 ลองใช้งานด้วยตัวเอง โดยใช้ <a href="https://github.com/proposal-signals/signal-polyfill">polyfill</a></p>
<p>เช่นเดียวกับ Promises/A+ ความพยายามนี้มุ่งเน้นการปรับแนวทางให้สอดคล้องกันใน ecosystem ของ JavaScript หากการปรับแนวทางนี้ประสบความสำเร็จ อาจมีมาตรฐานเกิดขึ้นโดยอิงจากประสบการณ์นั้น มีผู้เขียนเฟรมเวิร์กหลายรายที่ร่วมมือกันพัฒนารูปแบบร่วมที่อาจเป็นแกนหลักของระบบ reactivity ของพวกเขา ฉบับร่างปัจจุบันนี้อ้างอิงจากข้อเสนอแนะด้านการออกแบบจากผู้เขียน/ผู้ดูแลของ <a href="https://angular.io/">Angular</a>, <a href="https://bubble.io/">Bubble</a>, <a href="https://emberjs.com/">Ember</a>, <a href="https://www.fast.design/">FAST</a>, <a href="https://mobx.js.org/">MobX</a>, <a href="https://preactjs.com/">Preact</a>, <a href="https://qwik.dev/">Qwik</a>, <a href="https://rxjs.dev/">RxJS</a>, <a href="https://www.solidjs.com/">Solid</a>, <a href="https://www.starbeamjs.com/">Starbeam</a>, <a href="https://svelte.dev/">Svelte</a>, <a href="https://vuejs.org/">Vue</a>, <a href="https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a">Wiz</a> และอื่น ๆ …</p>
<p>แตกต่างจาก Promises/A+ ตรงที่เราไม่ได้พยายามแก้ปัญหาในส่วน API ที่นักพัฒนาต้องใช้งานโดยตรง แต่เป็นแก่นหลักของ semantics ที่แม่นยำของกราฟ signal ที่อยู่เบื้องหลัง ข้อเสนอนี้รวม API ที่เป็นรูปธรรมอย่างสมบูรณ์ แต่ API นี้ไม่ได้มุ่งเป้าไปที่นักพัฒนาแอปพลิเคชันส่วนใหญ่ แต่ signal API ที่นำเสนอนี้เหมาะสมกับเฟรมเวิร์กต่าง ๆ ในการนำไปต่อยอด เพื่อให้เกิดการทำงานร่วมกันผ่านกราฟ signal ร่วมและกลไกการติดตามอัตโนมัติ</p>
<p>แผนสำหรับข้อเสนอนี้คือทำการต้นแบบ (prototype) อย่างจริงจังในช่วงแรก รวมถึงการผสานเข้ากับเฟรมเวิร์กหลายตัว ก่อนจะก้าวไปไกลกว่า Stage 1 เราสนใจที่จะมาตรฐาน Signals เฉพาะในกรณีที่เหมาะสมกับการใช้งานจริงในหลายเฟรมเวิร์ก และให้ประโยชน์จริงเหนือกว่าการใช้ signals ที่แต่ละเฟรมเวิร์กจัดหาให้เอง เราหวังว่าการต้นแบบในช่วงต้นนี้จะให้ข้อมูลดังกล่าว ดู &quot;สถานะและแผนการพัฒนา&quot; ด้านล่างสำหรับรายละเอียดเพิ่มเติม</p>
<h2>พื้นหลัง: ทำไมต้อง Signals?</h2>
<p>เพื่อพัฒนาอินเทอร์เฟซผู้ใช้ (UI) ที่ซับซ้อน นักพัฒนาแอปพลิเคชัน JavaScript จำเป็นต้องจัดเก็บ คำนวณ ทำให้ข้อมูลไม่ถูกต้อง ซิงก์ และดันสถานะไปยัง view layer ของแอปพลิเคชันอย่างมีประสิทธิภาพ UI มักจะมีอะไรมากกว่าการจัดการค่าอย่างง่าย แต่มักจะต้องเรนเดอร์สถานะที่คำนวณได้ซึ่งขึ้นอยู่กับต้นไม้ที่ซับซ้อนของค่าหรือสถานะอื่น ๆ ที่ถูกคำนวณด้วย เป้าหมายของ Signals คือการจัดเตรียมโครงสร้างพื้นฐานสำหรับจัดการสถานะแอปพลิเคชันดังกล่าวเพื่อให้นักพัฒนาสามารถมุ่งเน้นที่ตรรกะของธุรกิจแทนรายละเอียดที่ต้องทำซ้ำเหล่านี้</p>
<p>constructs ที่คล้าย Signal ถูกค้นพบว่ามีประโยชน์ในบริบทที่ไม่ใช่ UI ด้วยเช่นกัน โดยเฉพาะในระบบ build เพื่อลดการ build ที่ไม่จำเป็น</p>
<p>Signals ถูกใช้ใน reactive programming เพื่อขจัดความจำเป็นในการจัดการการอัปเดตในแอปพลิเคชัน</p>
<blockquote>
<p>รูปแบบการเขียนโปรแกรมแบบ declarative สำหรับการอัปเดตตามการเปลี่ยนแปลงของ state</p>
</blockquote>
<p>จาก <em><a href="https://www.pzuraq.com/blog/what-is-reactivity">What is Reactivity?</a></em>.</p>
<h4>ตัวอย่าง - ตัวนับใน VanillaJS</h4>
<p>กำหนดตัวแปร <code>counter</code> คุณต้องการเรนเดอร์ใน DOM ว่าค่า counter เป็นเลขคู่หรือคี่ ทุกครั้งที่ <code>counter</code> เปลี่ยน คุณต้องอัปเดต DOM ด้วยค่า parity ล่าสุด ใน Vanilla JS คุณอาจมีโค้ดแบบนี้:</p>
<pre><code class="language-js">let counter = 0;
const setCounter = (value) =&gt; {
  counter = value;
  render();
};

const isEven = () =&gt; (counter &amp; 1) == 0;
const parity = () =&gt; isEven() ? &quot;even&quot; : &quot;odd&quot;;
const render = () =&gt; element.innerText = parity();

// จำลองการอัปเดต counter จากภายนอก...
setInterval(() =&gt; setCounter(counter + 1), 1000);
</code></pre>
<blockquote>
<p>[!NOTE]<br />
ตัวแปร global ถูกใช้เพื่อการสาธิตเท่านั้น การจัดการสถานะอย่างถูกต้องมีหลายวิธี และตัวอย่างในข้อเสนอนี้ถูกออกแบบให้เรียบง่ายที่สุด ข้อเสนอนี้ไม่ได้สนับสนุนให้ใช้ global variables</p>
</blockquote>
<p>สิ่งนี้มีปัญหาหลายประการ...</p>
<ul>
<li>การตั้งค่า <code>counter</code> มีความวุ่นวายและเต็มไปด้วย boilerplate</li>
<li>สถานะ <code>counter</code> ผูกติดกับระบบ rendering อย่างแน่นแฟ้น</li>
<li>หาก <code>counter</code> เปลี่ยนแต่ <code>parity</code> ไม่เปลี่ยน (เช่น counter เปลี่ยนจาก 2 เป็น 4) เราจะคำนวณ parity และ render ใหม่โดยไม่จำเป็น</li>
<li>ถ้าส่วนอื่นของ UI ต้องการ render เมื่อ <code>counter</code> อัปเดตล่ะ?</li>
<li>ถ้าส่วนอื่นของ UI ขึ้นกับ <code>isEven</code> หรือ <code>parity</code> เพียงอย่างเดียวล่ะ?</li>
</ul>
<p>แม้จะเป็นกรณีที่ค่อนข้างเรียบง่ายนี้ ก็เกิดปัญหาหลายอย่างขึ้นอย่างรวดเร็ว เราอาจพยายามแก้ปัญหาโดยเพิ่ม pub/sub ให้กับ <code>counter</code> เพื่อให้ผู้บริโภคเพิ่มเติมของ <code>counter</code> สามารถ subscribe เพื่อตอบสนองต่อการเปลี่ยนแปลง state ได้</p>
<p>แต่เรายังติดปัญหาต่อไปนี้:</p>
<ul>
<li>ฟังก์ชัน render ที่ขึ้นกับ <code>parity</code> เพียงอย่างเดียว กลับต้อง &quot;รู้&quot; ว่าจริง ๆ แล้วต้อง subscribe กับ <code>counter</code></li>
<li>ไม่สามารถอัปเดต UI จาก <code>isEven</code> หรือ <code>parity</code> โดยตรงโดยไม่ต้องยุ่งกับ <code>counter</code></li>
<li>เพิ่มความซับซ้อน boilerplate ทุกครั้งที่ใช้สิ่งใด ไม่ใช่แค่เรียกฟังก์ชันหรืออ่านค่าตัวแปร แต่ต้อง subscribe และจัดการอัปเดต รวมถึงการจัดการ unsubscription ที่ยุ่งยากเป็นพิเศษ</li>
</ul>
<p>ขณะนี้ เราอาจจะแก้ปัญหาบางส่วนได้โดยเพิ่ม pub/sub ไม่ใช่แค่กับ <code>counter</code> แต่รวมถึง <code>isEven</code> และ <code>parity</code> ด้วย เราจะต้อง subscribe <code>isEven</code> กับ <code>counter</code>, <code>parity</code> กับ <code>isEven</code> และ <code>render</code> กับ <code>parity</code> แต่น่าเสียดาย ไม่เพียงแต่โค้ด boilerplate จะระเบิดขึ้นเท่านั้น เรายังต้องจดบันทึกการ subscribe จำนวนมาก และอาจเสี่ยงต่อปัญหา memory leak หากไม่ล้างข้อมูลอย่างถูกต้อง ดังนั้น แม้จะแก้ปัญหาบางอย่างได้ ก็กลับสร้างปัญหาใหม่ขึ้นมาอีกมากและโค้ดก็ซับซ้อนขึ้น ที่แย่กว่านั้นเราต้องทำกระบวนการนี้กับ state ทุกตัวในระบบของเรา</p>
<h3>แนะนำ Signals</h3>
<p>นามธรรม data binding ใน UI สำหรับ model และ view เป็นแกนหลักของเฟรมเวิร์ก UI ในหลากหลายภาษาโปรแกรมมาอย่างยาวนาน แม้จะไม่มีกลไกดังกล่าวใน JS หรือแพลตฟอร์มเว็บ ใน JS framework และไลบรารี มีการทดลองมากมายเกี่ยวกับวิธีการแสดง binding นี้ และประสบการณ์แสดงให้เห็นถึงพลังของ one-way data flow ร่วมกับชนิดข้อมูล (data type) ชั้นหนึ่งที่แทนเซลล์ของ state หรือการคำนวณที่ได้จากข้อมูลอื่น ซึ่งปัจจุบันมักเรียกว่า &quot;Signals&quot;
แนวทาง reactive value แบบนี้ดูเหมือนจะปรากฏอย่างแพร่หลายในเฟรมเวิร์กเว็บ JavaScript open-source ครั้งแรกกับ <a href="https://knockoutjs.com/">Knockout</a> <a href="https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/">ในปี 2010</a> ตลอดหลายปีที่ผ่านมา มีการสร้าง variation และ implementation หลายแบบ ในช่วง 3-4 ปีหลัง primitive ของ Signal และแนวทางที่เกี่ยวข้องได้รับความนิยมเพิ่มขึ้นเกือบทุกไลบรารีหรือเฟรมเวิร์ก JavaScript สมัยใหม่มีสิ่งที่คล้ายกัน ไม่ว่าจะใช้ชื่อใดก็ตาม</p>
<p>เพื่อให้เข้าใจ Signals มาดูตัวอย่างด้านบนที่นำเสนอใหม่ด้วย Signal API ที่อธิบายไว้ด้านล่าง</p>
<h4>ตัวอย่าง - ตัวนับแบบ Signals</h4>
<pre><code class="language-js">const counter = new Signal.State(0);
const isEven = new Signal.Computed(() =&gt; (counter.get() &amp; 1) == 0);
const parity = new Signal.Computed(() =&gt; isEven.get() ? &quot;even&quot; : &quot;odd&quot;);

// ไลบรารีหรือเฟรมเวิร์กกำหนดเอฟเฟกต์โดยอิงกับ Signal primitives อื่น ๆ
declare function effect(cb: () =&gt; void): (() =&gt; void);

effect(() =&gt; element.innerText = parity.get());

// จำลองการอัปเดต counter จากภายนอก...
setInterval(() =&gt; counter.set(counter.get() + 1), 1000);
</code></pre>
<p>มีสิ่งที่เราสังเกตได้ทันที:</p>
<ul>
<li>เราขจัด boilerplate ที่วุ่นวายรอบตัวแปร <code>counter</code> จากตัวอย่างก่อนหน้า</li>
<li>มี API เดียวสำหรับจัดการค่า การคำนวณ และ side effect</li>
<li>ไม่มีปัญหา circular reference หรือ dependency กลับด้านระหว่าง <code>counter</code> กับ <code>render</code></li>
<li>ไม่มีการ subscribe ด้วยตนเอง หรือการจดบันทึกใด ๆ ที่ต้องทำ</li>
<li>สามารถควบคุมเวลา/การจัดตารางของ side-effect ได้</li>
</ul>
<p>Signals ให้มากกว่าสิ่งที่เห็นบนผิวของ API ดังนี้:</p>
<ul>
<li><strong>การติดตามการพึ่งพาโดยอัตโนมัติ</strong> - Signal ที่คำนวณได้จะค้นหา Signal อื่นๆ ที่มันขึ้นอยู่โดยอัตโนมัติ ไม่ว่า Signal เหล่านั้นจะเป็นค่าธรรมดาหรือการคำนวณอื่นๆ</li>
<li><strong>การประเมินค่าแบบ Lazy</strong> - การคำนวณจะไม่ถูกประเมินทันทีเมื่อถูกประกาศ และจะไม่ถูกประเมินในทันทีเมื่อการพึ่งพาของมันเปลี่ยนแปลง จะมีการประเมินค่าเมื่อมีการร้องขอค่าของมันโดยชัดเจนเท่านั้น</li>
<li><strong>การจดจำผลลัพธ์ (Memoization)</strong> - Signal ที่คำนวณได้จะเก็บค่าล่าสุดไว้ ดังนั้นการคำนวณที่ไม่มีการเปลี่ยนแปลงในการพึ่งพาจะไม่ต้องถูกประเมินซ้ำอีก ไม่ว่าจะถูกเข้าถึงกี่ครั้งก็ตาม</li>
</ul>
<h2>แรงจูงใจในการสร้างมาตรฐาน Signals</h2>
<h4>การทำงานร่วมกัน (Interoperability)</h4>
<p>แต่ละการใช้งาน Signal จะมีกลไกการติดตามอัตโนมัติของตัวเอง เพื่อใช้ติดตามแหล่งข้อมูลที่พบเจอเมื่อประเมิน Signal ที่คำนวณได้ สิ่งนี้ทำให้ยากต่อการแบ่งปันโมเดล คอมโพเนนต์ และไลบรารีระหว่างเฟรมเวิร์กต่างๆ—มักจะมีการผูกติดกับ view engine โดยไม่จำเป็น (เนื่องจาก Signal มักถูกใช้งานเป็นส่วนหนึ่งของ JS framework)</p>
<p>เป้าหมายหนึ่งของข้อเสนอนี้คือการแยกโมเดล reactive ออกจาก view rendering อย่างสมบูรณ์ เพื่อให้ผู้พัฒนาสามารถย้ายไปยังเทคโนโลยี rendering ใหม่ๆ ได้โดยไม่ต้องเขียนโค้ด non-UI ใหม่ทั้งหมด หรือสามารถพัฒนาโมเดล reactive ที่ใช้ร่วมกันใน JS เพื่อนำไปใช้งานในบริบทต่างๆ ได้ อย่างไรก็ตาม เนื่องจากปัญหาเวอร์ชันและการซ้ำซ้อน จึงไม่สามารถแบ่งปันในระดับที่เข้มแข็งผ่านไลบรารี JS ได้—built-ins จะให้หลักประกันการใช้งานร่วมกันที่แข็งแรงกว่า</p>
<h4>ประสิทธิภาพ/การใช้หน่วยความจำ</h4>
<p>โดยปกติแล้วจะมีโอกาสเพิ่มประสิทธิภาพเล็กน้อยเมื่อส่งโค้ดน้อยลง เพราะไลบรารีที่ใช้กันทั่วไปถูกรวมเป็น built-in แต่โดยทั่วไปการใช้งาน Signal มักจะมีขนาดเล็กมาก ดังนั้นเราจึงไม่คาดหวังว่าผลนี้จะมีนัยสำคัญมากนัก</p>
<p>เราคาดว่า การใช้งาน Signal และอัลกอริทึมที่เกี่ยวข้องด้วยภาษา C++ แบบ native อาจมีประสิทธิภาพมากกว่าที่ทำได้ใน JS อยู่บ้างในระดับค่าคงที่ อย่างไรก็ตาม จะไม่มีการเปลี่ยนแปลงอัลกอริทึมเมื่อเทียบกับ polyfill ที่มีอยู่ เอ็นจินไม่ได้คาดหวังว่าจะมีเวทมนตร์ และอัลกอริทึม reactivity เองจะถูกกำหนดไว้อย่างชัดเจนและไม่มีความกำกวม</p>
<p>กลุ่มผู้นำขับเคลื่อนข้อเสนอนี้คาดว่าจะพัฒนาการใช้งาน Signal แบบต่างๆ และใช้สิ่งเหล่านี้เพื่อตรวจสอบความเป็นไปได้ด้านประสิทธิภาพ</p>
<h4>DevTools</h4>
<p>สำหรับไลบรารี Signal ที่เป็นภาษา JS ในปัจจุบัน อาจยากที่จะติดตามสิ่งต่างๆ เช่น:</p>
<ul>
<li>สแต็กของการเรียกผ่านชุด chain ของ Signal ที่คำนวณได้ เพื่อแสดงสายเหตุของข้อผิดพลาด</li>
<li>กราฟอ้างอิงระหว่าง Signal เมื่อหนึ่งอันขึ้นอยู่กับอีกอัน—สำคัญมากเมื่อ debug การใช้หน่วยความจำ</li>
</ul>
<p>Signal ที่เป็น built-in จะช่วยให้ JS runtime และ DevTools มีความสามารถในการตรวจสอบ Signal ได้ดีขึ้น โดยเฉพาะสำหรับการ debug หรือวิเคราะห์ประสิทธิภาพ ไม่ว่าจะถูกสร้างไว้ในเบราว์เซอร์หรือผ่านส่วนขยายร่วมกัน เครื่องมือที่มีอยู่เช่น element inspector, performance snapshot และ memory profiler สามารถอัปเดตให้เน้น Signal โดยเฉพาะในหน้าข้อมูล</p>
<h4>ผลประโยชน์รอง</h4>
<h5>ข้อดีของไลบรารีมาตรฐาน</h5>
<p>โดยทั่วไป JavaScript มีไลบรารีมาตรฐานที่ค่อนข้างน้อย แต่แนวโน้มของ TC39 คือการทำให้ JS เป็นภาษา “มีแบตเตอรี่ให้ในตัว” ที่มีฟังก์ชันคุณภาพสูงพร้อมใช้งาน ตัวอย่างเช่น Temporal แทนที่ moment.js และฟีเจอร์ย่อยๆ หลายอย่างเช่น <code>Array.prototype.flat</code> และ <code>Object.groupBy</code> ก็มาแทนที่การใช้งาน lodash หลายกรณี ข้อดีคือ bundle ขนาดเล็กลง ความเสถียรและคุณภาพดีขึ้น เรียนรู้น้อยลงเมื่อต้องเข้าร่วมโปรเจกต์ใหม่ และมีศัพท์กลางที่ใช้ร่วมกันระหว่างนักพัฒนา JS</p>
<h5>การบูรณาการ HTML/DOM (เป็นไปได้ในอนาคต)</h5>
<p>งานปัจจุบันใน W3C และผู้พัฒนาเบราว์เซอร์กำลังพยายามนำระบบ templating แบบ native มาสู่ HTML (<a href="https://github.com/WICG/webcomponents/pull/1023">DOM Parts</a> และ <a href="https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md">Template Instantiation</a>) นอกจากนี้ W3C Web Components CG กำลังสำรวจความเป็นไปได้ในการขยาย Web Components เพื่อเสนอตัว API HTML แบบประกาศอย่างสมบูรณ์ เพื่อบรรลุเป้าหมายทั้งสองนี้ ในที่สุด HTML จะต้องมี primitive แบบ reactive นอกจากนี้ ยังมีการร้องขอจากชุมชนและสามารถจินตนาการถึงการปรับปรุง DOM ให้ใช้งานง่ายขึ้นด้วยการบูรณาการ Signal</p>
<blockquote>
<p>หมายเหตุ การบูรณาการนี้จะเป็นงานแยกออกไปในอนาคต ไม่ใช่ส่วนหนึ่งของข้อเสนอนี้</p>
</blockquote>
<h5>การแลกเปลี่ยนข้อมูลในระบบนิเวศ (<em>ไม่ใช่</em> เหตุผลที่ควรจัดส่ง)</h5>
<p>การสร้างมาตรฐานสามารถเป็นประโยชน์ในระดับ “ชุมชน” แม้จะไม่มีการเปลี่ยนแปลงในเบราว์เซอร์ ความพยายามเกี่ยวกับ Signals นี้นำผู้พัฒนา framework หลายรายมาหารือกันอย่างลึกซึ้งเกี่ยวกับธรรมชาติของ reactivity อัลกอริทึม และการทำงานร่วมกัน สิ่งนี้เป็นประโยชน์แล้ว แต่ไม่ใช่เหตุผลเพียงพอที่จะนำ Signals ไปใส่ใน JS engine หรือเบราว์เซอร์; ควรเพิ่ม Signal ในมาตรฐาน JavaScript ก็ต่อเมื่อมีประโยชน์อย่างมีนัยสำคัญ <em>เกินกว่า</em> การแลกเปลี่ยนข้อมูลในระบบนิเวศที่เกิดขึ้น</p>
<h2>เป้าหมายการออกแบบสำหรับ Signals</h2>
<p>ปรากฏว่าห้องสมุด Signal ที่มีอยู่ในปัจจุบันไม่ได้แตกต่างกันมากนักในแก่นของมัน ข้อเสนอนี้ต้องการต่อยอดจากความสำเร็จเหล่านั้นด้วยการนำคุณสมบัติสำคัญของไลบรารีเหล่านี้มาใช้</p>
<h3>คุณลักษณะหลัก</h3>
<ul>
<li>ประเภท Signal ที่เป็นสถานะ (state) หรือ Signal ที่เขียนค่าได้ เป็นค่าที่ผู้อื่นสามารถอ่านได้</li>
<li>ประเภท Signal ที่คำนวณ/จดจำ/อนุพันธ์ ซึ่งขึ้นอยู่กับ Signal อื่นและคำนวณแบบ lazy และมีการเก็บ cache
<ul>
<li>การคำนวณเป็นแบบ lazy หมายถึง Signal ที่คำนวณไม่ได้คำนวณใหม่โดยอัตโนมัติเมื่อมีการเปลี่ยนแปลงของ dependency แต่จะคำนวณเมื่อมีผู้เรียกอ่านเท่านั้น</li>
<li>การคำนวณ &quot;<a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">glitch</a>-free&quot; หมายถึงไม่มีการคำนวณที่ไม่จำเป็นเกิดขึ้นเลย สิ่งนี้หมายความว่า เมื่อแอปพลิเคชันอ่าน Signal ที่คำนวณ จะมีการเรียงลำดับ topological ส่วนที่อาจ dirty ของกราฟเพื่อรันและกำจัดข้อมูลซ้ำ</li>
<li>มี cache ในการคำนวณ หมายความว่าถ้าหลังจาก dependency เปลี่ยนครั้งล่าสุด ไม่มี dependency ใดเปลี่ยนอีก Signal ที่คำนวณจะ <em>ไม่</em> คำนวณใหม่เมื่อถูกเข้าถึง</li>
<li>สามารถเปรียบเทียบแบบกำหนดเองได้ทั้งกับ Signal ที่คำนวณและ Signal สถานะ เพื่อตรวจสอบว่า Signal ที่คำนวณอื่นที่ขึ้นอยู่กับมันควรอัปเดตหรือไม่</li>
</ul>
</li>
<li>ปฏิกิริยาต่อเงื่อนไขที่ Signal ที่คำนวณมี dependency (หรือ dependency ซ้อน) ที่กลายเป็น “dirty” และเปลี่ยนแปลง หมายความว่าค่า Signal อาจล้าสมัย
<ul>
<li>ปฏิกิริยานี้มีไว้เพื่อจัดตารางงานที่สำคัญขึ้นในภายหลัง</li>
<li>Effects จะถูกสร้างขึ้นจากปฏิกิริยาเหล่านี้ พร้อมกับการจัดตารางงานในระดับ framework</li>
<li>Signal ที่คำนวณต้องสามารถตอบสนองต่อการถูกลงทะเบียนเป็น dependency (ซ้อน) ของปฏิกิริยาเหล่านี้</li>
</ul>
</li>
<li>ให้ framework JS สามารถจัดตารางงานเองได้ ไม่มี built-in แบบ Promise ที่บังคับให้ต้องจัดตารางงาน
<ul>
<li>ต้องมีปฏิกิริยาแบบ synchronous เพื่อจัดตารางงานในภายหลังตามตรรกะของ framework</li>
<li>การเขียนเป็น synchronous และมีผลทันที (framework ที่ต้อง batch การเขียนสามารถทำเองเพิ่มเติม)</li>
<li>สามารถแยกการตรวจสอบว่า effect อาจ “dirty” ออกจากการรัน effect จริง (ทำให้สามารถสร้าง scheduler แบบ 2 ขั้นตอนได้)</li>
</ul>
</li>
<li>สามารถอ่าน Signal <em>โดยไม่</em> ทำให้เกิดการบันทึก dependency (<code>untrack</code>)</li>
<li>สามารถประกอบโค้ดที่ใช้ Signal/reactivity จากหลาย codebase ได้ เช่น
<ul>
<li>ใช้ framework หลายตัวร่วมกันในแง่ของ tracking/reactivity (ยกเว้นข้อจำกัดที่กล่าวไว้ด้านล่าง)</li>
<li>โครงสร้างข้อมูล reactive ที่ framework-independent (เช่น store proxy แบบ recursive, reactive Map, Set, Array ฯลฯ)</li>
</ul>
</li>
</ul>
<h3>ความถูกต้อง (Soundness)</h3>
<ul>
<li>ป้องกัน/ไม่สนับสนุนการใช้ synchronous reactions แบบผิดๆ
<ul>
<li>ความเสี่ยงต่อ soundness: อาจเกิด &quot;<a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">glitches</a>&quot; ถ้าใช้งานผิด หาก rendering เกิดขึ้นทันทีเมื่อ set Signal อาจทำให้ผู้ใช้เห็น state แอปที่ไม่สมบูรณ์ ดังนั้นฟีเจอร์นี้ควรใช้เพื่อจัดตารางงานอย่างชาญฉลาดภายหลัง เมื่อตรรกะแอปเสร็จสิ้นแล้วเท่านั้น</li>
<li>ทางแก้: ไม่อนุญาตให้อ่านหรือเขียน Signal ใดๆ จากใน synchronous reaction callback</li>
</ul>
</li>
<li>ไม่สนับสนุนการใช้ <code>untrack</code> และแสดงให้เห็นถึงลักษณะที่ไม่ sound
<ul>
<li>ความเสี่ยงต่อ soundness: อนุญาตให้สร้าง Signal ที่คำนวณซึ่งค่าขึ้นอยู่กับ Signal อื่น แต่จะไม่อัปเดตเมื่อ Signal เหล่านั้นเปลี่ยน ควรใช้เมื่อการเข้าถึงแบบ untracked จะไม่เปลี่ยนผลลัพธ์ของการคำนวณ</li>
<li>ทางแก้: API นี้จะถูกระบุว่า “unsafe” ในชื่อ</li>
</ul>
</li>
<li>หมายเหตุ: ข้อเสนอนี้อนุญาตให้ Signal ถูกอ่านและเขียนจาก computed และ effect signal ได้โดยไม่จำกัดการเขียนที่เกิดหลังการอ่าน แม้จะมีความเสี่ยงด้าน soundness ก็ตาม ตัดสินใจเช่นนี้เพื่อคงความยืดหยุ่นและความเข้ากันได้กับ framework</li>
</ul>
<h3>Surface API</h3>
<ul>
<li>ต้องเป็นรากฐานที่ดีสำหรับหลาย framework เพื่อนำไปใช้กับ Signal/reactivity ของตน
<ul>
<li>ควรเหมาะกับ store proxy แบบ recursive, reactivity ใน class field แบบ decorator และทั้งแบบ <code>.value</code> และ <code>[state, setState]</code>-style API</li>
<li>semantics ต้องสามารถแสดงรูปแบบที่ framework ต่างๆ ใช้งานได้ เช่น สามารถเป็นพื้นฐานสำหรับทั้งการเขียนที่สะท้อนค่าทันทีหรือการเขียนที่ batch และนำไปใช้ภายหลัง</li>
</ul>
</li>
<li>ควรใช้งานได้โดยตรงกับนักพัฒนา JavaScript
<ul>
<li>ถ้าฟีเจอร์ตรงกับแนวคิดใน ecosystem การใช้ศัพท์ที่ใช้ร่วมกันเป็นสิ่งดี
<ul>
<li>แต่สำคัญที่ไม่ควรใช้ชื่อเดียวกันกับที่มีอยู่!</li>
</ul>
</li>
<li>ความตึงเครียดระหว่าง “ใช้งานได้จริงกับ dev JS” กับ “ให้ hook ครบสำหรับ framework”
<ul>
<li>แนวคิด: ให้ hook ครบ แต่รวม error เมื่อใช้ผิด</li>
<li>แนวคิด: นำ API ที่ซับซ้อนไว้ใน namespace <code>subtle</code> คล้ายกับ <a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle"><code>crypto.subtle</code></a> เพื่อแยกเส้นระหว่าง API ที่จำเป็นสำหรับการใช้งานขั้นสูง เช่น สร้าง framework หรือ dev tools กับการใช้งานในงานประจำวัน เช่น สร้าง signal เพื่อใช้กับ framework</li>
</ul>
</li>
</ul>
</li>
<li>สามารถนำไปใช้งานและให้ประสิทธิภาพดี—Surface API ไม่เพิ่ม overhead มากเกินไป
<ul>
<li>รองรับ subclassing เพื่อให้ framework สามารถเพิ่ม method และ field ของตัวเอง (รวมถึง private field) ซึ่งสำคัญต่อการหลีกเลี่ยง allocation ส่วนเกินในระดับ framework ดูรายละเอียด “การจัดการหน่วยความจำ” ด้านล่าง</li>
</ul>
</li>
</ul>
<h3>การจัดการหน่วยความจำ</h3>
<ul>
<li>ถ้าเป็นไปได้: Signal ที่คำนวณควรสามารถถูกเก็บขยะ (garbage-collect) ได้หากไม่มีสิ่งใดอ้างอิงแบบมีชีวิตเพื่ออ่านในอนาคต แม้ว่าจะยังเชื่อมต่ออยู่ในกราฟที่ใหญ่กว่าซึ่งยังคงมีชีวิต (เช่น โดยการอ่าน state ที่ยังคงมีชีวิตอยู่)</li>
<li>โปรดทราบว่าเฟรมเวิร์กส่วนใหญ่ในปัจจุบันต้องการการกำจัด (dispose) Signal ที่คำนวณได้ (computed Signals) อย่างชัดเจน หาก Signal นั้นมีการอ้างอิงถึงหรือจากกราฟ Signal อื่นที่ยังคงมีชีวิตอยู่</li>
<li>เรื่องนี้จะไม่เป็นปัญหามากนักหากอายุการใช้งานของ Signal ผูกกับอายุการใช้งานของคอมโพเนนต์ UI และเอฟเฟ็กต์ต่าง ๆ จำเป็นต้องถูกกำจัดอยู่แล้ว</li>
<li>หากการดำเนินการด้วยลักษณะนี้มีค่าใช้จ่ายสูงเกินไป ก็ควรเพิ่มการกำจัด (dispose) หรือ &quot;unlinking&quot; ของ Signal ที่คำนวณได้เข้าไปใน API ด้านล่าง ซึ่งขณะนี้ยังไม่มี</li>
<li>เป้าหมายที่เกี่ยวข้องอีกประการหนึ่ง: ลดจำนวนการจัดสรรหน่วยความจำ เช่น
<ul>
<li>เพื่อสร้าง Signal ที่เขียนค่าได้ (writable Signal) (หลีกเลี่ยงการใช้ closure สองตัวแยกกัน + array)</li>
<li>เพื่อใช้งานเอฟเฟ็กต์ (หลีกเลี่ยงการใช้ closure สำหรับทุก ๆ การตอบสนอง)</li>
<li>ใน API สำหรับสังเกตการเปลี่ยนแปลงของ Signal ให้หลีกเลี่ยงการสร้างโครงสร้างข้อมูลชั่วคราวเพิ่มเติม</li>
<li>ทางออก: API ที่ใช้คลาส (Class-based API) ซึ่งช่วยให้สามารถนำกลับมาใช้ใหม่ได้ทั้ง methods และ fields ที่กำหนดไว้ในคลาสย่อย</li>
</ul>
</li>
</ul>
<h2>ร่าง API</h2>
<p>แนวคิดเบื้องต้นของ Signal API แสดงอยู่ด้านล่าง โปรดทราบว่านี่เป็นเพียงร่างแรกเริ่มเท่านั้น และเราคาดว่าจะมีการเปลี่ยนแปลงต่อไปในอนาคต เริ่มจากไฟล์ <code>.d.ts</code> เต็มรูปแบบเพื่อดูโครงสร้างโดยรวม จากนั้นเราจะพูดคุยรายละเอียดของแต่ละส่วน</p>
<pre><code class="language-ts">interface Signal&lt;T&gt; {
    // รับค่าของ signal
    get(): T;
}

namespace Signal {
    // Signal ที่อ่าน-เขียนค่าได้
    class State&lt;T&gt; implements Signal&lt;T&gt; {
        // สร้าง state Signal โดยเริ่มจากค่า t
        constructor(t: T, options?: SignalOptions&lt;T&gt;);

        // รับค่าของ signal
        get(): T;

        // กำหนดค่า state Signal เป็น t
        set(t: T): void;
    }

    // Signal ที่คำนวณค่าจาก Signal อื่น ๆ
    class Computed&lt;T = unknown&gt; implements Signal&lt;T&gt; {
        // สร้าง Signal ที่ประเมินผลด้วยค่าที่ callback ส่งคืน
        // Callback จะถูกเรียกโดยใช้ signal นี้เป็นค่า this
        constructor(cb: (this: Computed&lt;T&gt;) =&gt; T, options?: SignalOptions&lt;T&gt;);

        // รับค่าของ signal
        get(): T;
    }

    // เนมสเปซนี้รวมฟีเจอร์ &quot;ขั้นสูง&quot; ซึ่งเหมาะสำหรับผู้พัฒนาเฟรมเวิร์กมากกว่านักพัฒนาแอปพลิเคชัน
    // คล้ายกับ `crypto.subtle`
    namespace subtle {
        // รัน callback โดยปิดการ tracking ทั้งหมด
        function untrack&lt;T&gt;(cb: () =&gt; T): T;

        // รับ computed signal ปัจจุบันที่กำลัง track การอ่าน signal ใด ๆ ถ้ามี
        function currentComputed(): Computed | null;

        // ส่งคืนลิสต์เรียงลำดับของ signal ทั้งหมดที่ signal นี้อ้างอิงถึง
        // ในการประเมินค่าครั้งล่าสุด
        // สำหรับ Watcher จะแสดงชุดของ signal ที่กำลังเฝ้าดู
        function introspectSources(s: Computed | Watcher): (State | Computed)[];

        // ส่งคืน Watchers ที่ signal นี้อยู่ในนั้น รวมถึง
        // Computed signals ที่อ่าน signal นี้ในการประเมินค่าครั้งล่าสุด
        // หาก computed signal นั้น (แบบ recursive) ถูกเฝ้าดู
        function introspectSinks(s: State | Computed): (Computed | Watcher)[];

        // คืนค่า true หาก signal นี้ &quot;มีชีวิต&quot; คือถูกเฝ้าดูโดย Watcher,
        // หรือถูกอ่านโดย Computed signal ที่ (แบบ recursive) มีชีวิต
        function hasSinks(s: State | Computed): boolean;

        // คืนค่า true หาก element นี้เป็น &quot;reactive&quot; คือขึ้นอยู่กับ signal อื่น
        // Computed ที่ hasSources เป็น false จะคืนค่าคงที่เสมอ
        function hasSources(s: Computed | Watcher): boolean;

        class Watcher {
            // เมื่อ (recursive) source ของ Watcher ถูกเขียน จะเรียก callback นี้
            // หาก callback ยังไม่ถูกเรียกตั้งแต่ `watch` ครั้งล่าสุด
            // ห้ามอ่านหรือเขียน signal ใด ๆ ระหว่าง notify
            constructor(notify: (this: Watcher) =&gt; void);

            // เพิ่ม signals เหล่านี้เข้าในชุดของ Watcher และตั้ง watcher ให้รัน
            // notify callback เมื่อใดก็ตามที่ signal ในชุด (หรือ dependency ของมัน) มีการเปลี่ยนแปลง
            // สามารถเรียกโดยไม่มีอาร์กิวเมนต์เพื่อรีเซ็ตสถานะ &quot;notified&quot; ได้
            // เพื่อให้ notify callback ถูกเรียกอีกครั้ง
            watch(...s: Signal[]): void;

            // ลบ signals เหล่านี้ออกจากชุดที่เฝ้าดู (เช่น สำหรับ effect ที่ถูก dispose)
            unwatch(...s: Signal[]): void;

            // ส่งคืนชุดของ sources ในชุด Watcher ที่ยัง dirty หรือเป็น computed signal
            // ที่มี source เป็น dirty หรือ pending และยังไม่ได้ประเมินค่าใหม่
            getPending(): Signal[];
        }

        // ฮุคสำหรับสังเกตว่ากำลังถูกเฝ้าดูหรือไม่ถูกเฝ้าดูอีกต่อไป
        var watched: Symbol;
        var unwatched: Symbol;
    }

    interface SignalOptions&lt;T&gt; {
        // ฟังก์ชันเปรียบเทียบค่าระหว่างค่าเก่าและค่าใหม่ กำหนดค่าเริ่มต้น: Object.is
        // signal จะถูกส่งเข้าเป็นค่า this สำหรับ context
        equals?: (this: Signal&lt;T&gt;, t: T, t2: T) =&gt; boolean;
</code></pre>
<pre><code class="language-ts">        // Callback called when isWatched becomes true, if it was previously false
        [Signal.subtle.watched]?: (this: Signal&lt;T&gt;) =&gt; void;

        // Callback called whenever isWatched becomes false, if it was previously true
        [Signal.subtle.unwatched]?: (this: Signal&lt;T&gt;) =&gt; void;
    }
}
</code></pre>
<h3>วิธีการทำงานของ Signals</h3>
<p>Signal แทนข้อมูลเซลล์หนึ่งที่สามารถเปลี่ยนแปลงได้ตามกาลเวลา Signals อาจเป็นแบบ &quot;state&quot; (ค่าที่ตั้งด้วยตนเอง) หรือ &quot;computed&quot; (สูตรที่คำนวณจาก Signal อื่น ๆ)</p>
<p>Computed Signals ทำงานโดยการติดตามว่า Signal อื่น ๆ อะไรถูกอ่านระหว่างการประเมินค่า เมื่อมีการอ่าน computed มันจะตรวจสอบว่า dependencies ที่บันทึกไว้ก่อนหน้านั้นมีการเปลี่ยนแปลงหรือไม่ และจะประเมินค่าใหม่หากมีการเปลี่ยนแปลง เมื่อมีการซ้อนกันของ computed หลายชั้น การติดตามจะถูกระบุไปยังชั้นในสุด</p>
<p>Computed Signals ทำงานแบบ lazy หรือ pull-based: จะประเมินค่าใหม่ก็ต่อเมื่อถูกเข้าถึงเท่านั้น แม้ว่าหนึ่งใน dependencies จะเปลี่ยนแปลงไปก่อนหน้านี้แล้วก็ตาม</p>
<p>callback ที่ส่งเข้าไปใน computed Signals ควรเป็น &quot;pure&quot; ในแง่ที่ว่าฟังก์ชันนั้นควรเป็น deterministic และไม่มี side-effect ต่อ Signal อื่น ๆ ที่เข้าถึง ในขณะเดียวกัน เวลาที่ callback ถูกเรียกนั้นเป็นแบบ deterministic ทำให้สามารถใช้ side effect ได้อย่างระมัดระวัง</p>
<p>Signals มีการ cache/memoization เด่นชัด: ทั้ง state และ computed Signals จะจดจำค่าปัจจุบันของตนเอง และจะเรียกคำนวณใหม่เฉพาะ computed Signals ที่อ้างอิงถึงมันหากค่ามีการเปลี่ยนแปลงเท่านั้น การเปรียบเทียบค่าซ้ำ ๆ ระหว่างค่าเก่าและใหม่ไม่จำเป็นต้องทำบ่อย ๆ -- การเปรียบเทียบจะทำเพียงครั้งเดียวเมื่อ Signal ต้นทางถูกรีเซ็ตหรือประเมินใหม่ และกลไกของ Signal จะติดตามว่าอะไรที่ยังไม่ได้อัปเดตตามค่าที่เปลี่ยนแปลง ภายในจะใช้แนวคิด &quot;graph coloring&quot; ตามที่อธิบายใน (บล็อกของ Milo)</p>
<p>Computed Signals ติดตาม dependencies แบบไดนามิก—ทุกครั้งที่รันอาจขึ้นกับสิ่งที่ต่างกัน และชุด dependencies นี้จะถูกอัปเดตในกราฟ Signal เสมอ นั่นหมายความว่า ถ้าคุณมี dependency ที่จำเป็นเฉพาะบางสาขา และรอบก่อนคำนวณเป็นอีกสาขา การเปลี่ยนแปลงของค่านั้นจะไม่ทำให้ computed Signal ถูกคำนวณใหม่ แม้จะถูกดึงข้อมูลก็ตาม</p>
<p>ไม่เหมือนกับ JavaScript Promises ทุกอย่างใน Signals ทำงานแบบ synchronous:</p>
<ul>
<li>การตั้งค่า Signal เป็นค่าหรือสถานะใหม่จะเป็น synchronous และจะสะท้อนทันทีเมื่ออ่าน computed Signal อื่นที่ขึ้นกับมัน ไม่มีการ batch การเปลี่ยนแปลงนี้ในตัว</li>
<li>การอ่าน computed Signals เป็น synchronous—ค่าจะพร้อมใช้งานเสมอ</li>
<li>callback <code>notify</code> ใน Watchers ตามที่อธิบายด้านล่าง จะทำงานแบบ synchronous ระหว่างการเรียก <code>.set()</code> ที่เป็นตัวกระตุ้น (แต่หลังจากที่ graph coloring เสร็จสมบูรณ์แล้ว)</li>
</ul>
<p>คล้ายกับ Promises, Signals สามารถแสดงสถานะ error ได้: หาก callback ของ computed Signal ขว้าง exception ขึ้นมา error นั้นจะถูก cache ไว้เสมือนค่าหนึ่ง และจะถูก throw ซ้ำทุกครั้งที่ Signal นั้นถูกอ่าน</p>
<h3>ทำความเข้าใจคลาส Signal</h3>
<p>อินสแตนซ์ <code>Signal</code> แทนความสามารถในการอ่านค่าที่เปลี่ยนแปลงได้แบบไดนามิก โดยอัปเดตจะถูกติดตามตามเวลา และยังรวมถึงความสามารถในการ subscribe กับ Signal นั้นด้วย โดยเป็นการ subscribe ผ่านการเข้าถึงแบบ tracked จาก computed Signal อื่น</p>
<p>API นี้ออกแบบให้สอดคล้องกับฉันทามติของ ecosystem ในการใช้ชื่ออย่าง &quot;signal&quot;, &quot;computed&quot; และ &quot;state&quot; อย่างไรก็ตาม การเข้าถึง Computed และ State Signal ทำผ่านเมธอด <code>.get()</code> ซึ่งไม่เหมือนกับ Signal API ยอดนิยมอื่นที่ใช้ตัวเข้าถึง <code>.value</code> หรือ syntax แบบ <code>signal()</code></p>
<p>API นี้ออกแบบมาเพื่อลดการจัดสรรหน่วยความจำ (allocation) เพื่อให้ Signals เหมาะสำหรับการฝังในเฟรมเวิร์ก JavaScript และมีประสิทธิภาพเท่าหรือดีกว่า Signals ที่ปรับแต่งเฉพาะเฟรมเวิร์กเดิม ซึ่งหมายถึง:</p>
<ul>
<li>State Signals เป็นอ็อบเจ็กต์ที่เขียนได้เพียงชิ้นเดียว สามารถอ่านและตั้งค่าได้จาก reference เดียวกัน (ดูรายละเอียดในหัวข้อ &quot;Capability separation&quot; ด้านล่าง)</li>
<li>ทั้ง State และ Computed Signals ถูกออกแบบให้ subclass ได้ เพื่อให้เฟรมเวิร์กสามารถเพิ่ม property เพิ่มเติมผ่าน public/private class fields (รวมถึงเมธอดสำหรับใช้กับ state นั้น)</li>
<li>callback ต่าง ๆ (เช่น <code>equals</code>, computed callback) ถูกเรียกด้วย Signal ที่เกี่ยวข้องเป็นค่า <code>this</code> เพื่อให้ไม่ต้องสร้าง closure ใหม่สำหรับแต่ละ Signal โดย context สามารถเก็บไว้ใน property เพิ่มเติมของ signal ได้โดยตรง</li>
</ul>
<p>ข้อผิดพลาดบางกรณีที่ API นี้บังคับใช้:</p>
<ul>
<li>การอ่านค่า computed แบบ recursive ถือเป็นข้อผิดพลาด</li>
<li>callback <code>notify</code> ของ Watcher ไม่สามารถอ่านหรือเขียน signals ใด ๆ ได้</li>
<li>หาก callback ของ computed Signal ขว้าง exception ครั้งต่อไปที่เข้าถึง Signal นั้นจะ throw error ที่ cache ไว้ จนกว่า dependencies ใด ๆ จะเปลี่ยนแปลงแล้วคำนวณใหม่</li>
</ul>
<p>บางกรณีที่ <em>ไม่</em> บังคับใช้:</p>
<ul>
<li>Computed Signals สามารถเขียนค่าไปที่ Signal อื่นได้แบบ synchronous ภายใน callback ของมัน</li>
<li>งานที่ถูก queue โดย callback <code>notify</code> ของ Watcher สามารถอ่านหรือเขียน signals ได้ ทำให้สามารถเลียนแบบ <a href="https://react.dev/learn/you-might-not-need-an-effect">React antipatterns แบบคลาสสิก</a> ในเชิงของ Signals ได้!</li>
</ul>
<h3>การ implement effects</h3>
<p><code>Watcher</code> interface ที่นิยามไว้ข้างต้นเป็นรากฐานสำหรับการ implement API JS ทั่วไปสำหรับ effects: callback ที่จะรันซ้ำเมื่อ Signal อื่นเปลี่ยนแปลง เพื่อทำ side effect เท่านั้น ฟังก์ชัน <code>effect</code> ที่ใช้ในตัวอย่างตอนต้นสามารถนิยามได้ดังนี้:</p>
<pre><code class="language-ts">// ฟังก์ชันนี้โดยปกติควรอยู่ในไลบรารี/เฟรมเวิร์ก ไม่ใช่โค้ดแอปพลิเคชัน
// หมายเหตุ: กลไก scheduling นี้พื้นฐานเกินไปสำหรับใช้งานจริง ห้าม copy/paste
let pending = false;

let w = new Signal.subtle.Watcher(() =&gt; {
    if (!pending) {
        pending = true;
        queueMicrotask(() =&gt; {
            pending = false;
            for (let s of w.getPending()) s.get();
            w.watch();
        });
    }
});

// สร้าง Signal effect ที่ประเมินค่าเป็น cb และ schedule ให้อ่านตัวเองใน microtask queue
// ทุกครั้งที่ dependencies เปลี่ยนแปลง
export function effect(cb) {
    let destructor;
    let c = new Signal.Computed(() =&gt; { destructor?.(); destructor = cb(); });
    w.watch(c);
    c.get();
    return () =&gt; { destructor?.(); w.unwatch(c) };
}
</code></pre>
<p>Signal API ไม่มีฟังก์ชัน built-in แบบ <code>effect</code> เพราะการจัดคิว effect มีความซับซ้อนและมักผูกกับรอบการเรนเดอร์ของเฟรมเวิร์กหรือกลยุทธ์ภายในเฟรมเวิร์กที่ JS ไม่มี access</p>
<p>อธิบายการทำงานของแต่ละส่วน: callback <code>notify</code> ที่ส่งเข้า Watcher constructor คือฟังก์ชันที่จะถูกเรียกเมื่อ Signal เปลี่ยนจากสถานะ &quot;clean&quot; (cache ถูก initialize และ valid) ไปเป็น &quot;checked&quot; หรือ &quot;dirty&quot; (cache อาจจะ valid หรือไม่ก็ได้ เพราะ state ที่พึ่งพาเปลี่ยนแปลง)</p>
<p>การเรียก <code>notify</code> สุดท้ายจะถูกกระตุ้นโดยการเรียก <code>.set()</code> บน state Signal ใด ๆ การเรียกนี้ synchronous: จะเกิดขึ้นก่อนที่ <code>.set</code> จะ return แต่ไม่ต้องกังวลว่า callback นี้จะเห็นกราฟ Signal ในสถานะที่ประมวลผลไม่สมบูรณ์ เพราะระหว่าง callback <code>notify</code> จะไม่สามารถอ่านหรือเขียน Signal ใด ๆ ได้ แม้แต่ใน <code>untrack</code> ก็เช่นกัน เนื่องจาก <code>notify</code> ถูกเรียกระหว่าง <code>.set()</code> จึงเป็นการขัดจังหวะตรรกะอื่นที่อาจจะยังไม่สมบูรณ์ หากต้องการอ่านหรือเขียน Signal จาก <code>notify</code> ให้ schedule งานไว้รันทีหลัง เช่นจด Signal ไว้ในลิสต์แล้วไปอ่านทีหลัง หรือใช้ <code>queueMicrotask</code> ตามตัวอย่าง</p>
<p>โปรดทราบว่าสามารถใช้ Signals ได้อย่างมีประสิทธิภาพโดยไม่ต้องใช้ <code>Signal.subtle.Watcher</code> โดย schedule polling ของ computed Signals เช่นที่ Glimmer ทำ อย่างไรก็ตาม หลายเฟรมเวิร์กพบว่าการมี logic scheduling แบบ synchronous มีประโยชน์มาก จึงมีให้ใน Signals API นี้</p>
<p>ทั้ง computed และ state Signals ถูกเก็บขยะ (garbage-collected) เหมือนค่า JS ปกติ แต่ Watchers มีวิธีพิเศษในการเก็บอ็อบเจ็กต์ให้ยังมีชีวิตอยู่: Signals ที่ถูก watch โดย Watcher ใด ๆ จะถูกเก็บไว้ตราบใดที่ state ที่เกี่ยวข้องยัง reachable เพราะอาจมีการ trigger <code>notify</code> และ <code>.get()</code> ในอนาคตได้ ด้วยเหตุนี้ อย่าลืมเรียก <code>Watcher.prototype.unwatch</code> เพื่อเก็บกวาด effects</p>
<h3>ทางลัดที่ไม่ปลอดภัย</h3>
<p><code>Signal.subtle.untrack</code> เป็นช่องทาง escape ที่อนุญาตให้อ่าน Signal <em>โดยไม่</em> ติดตามการอ่านนั้น ความสามารถนี้ไม่ปลอดภัยเพราะอาจสร้าง computed Signal ที่ค่าอ้างอิง Signal อื่น แต่จะไม่อัปเดตเมื่อ Signal เหล่านั้นเปลี่ยนแปลง ควรใช้เมื่อการเข้าถึงแบบ untracked ไม่ทำให้ผลลัพธ์ของ computation เปลี่ยนแปลง</p>
<!--
TODO: Show example where it's a good idea to use untrack

### Using watched/unwatched
TODO: แสดงตัวอย่างการแปลง Observable ให้เป็น computed signal ที่มีการ subscribe เฉพาะเมื่อถูกใช้งานโดย effect

TODO: แสดงตัวอย่างของ computed signal ที่แสดงผลลัพธ์ของ fetch ซึ่งถูกสั่งให้ยกเลิกได้ตาม state

### การสืบค้นสำหรับ SSR

TODO: แสดงตัวอย่างการ serialize กราฟของ signal

TODO: แสดงตัวอย่างการ "hydrate" signal จาก state ไปสู่ computed ในภายหลัง โดยใช้ signals เพียงไม่กี่ตัว
-->
<h3>ตัดออกชั่วคราว</h3>
<p>ฟีเจอร์เหล่านี้อาจถูกเพิ่มในภายหลัง แต่ยังไม่รวมอยู่ในร่างปัจจุบัน การตัดออกนี้เกิดจากการขาดฉันทามติที่ชัดเจนในพื้นที่ออกแบบระหว่างเฟรมเวิร์กต่าง ๆ ตลอดจนความสามารถที่แสดงให้เห็นแล้วว่าสามารถแก้ปัญหาได้ด้วยกลไกเพิ่มเติมบนแนวคิด Signals ที่อธิบายไว้ในเอกสารนี้ อย่างไรก็ตาม การตัดออกนี้จำกัดศักยภาพของการทำงานร่วมกันระหว่างเฟรมเวิร์กต่าง ๆ ขณะที่ต้นแบบ Signals ที่อธิบายไว้ในเอกสารนี้ถูกสร้างขึ้น จะมีความพยายามในการกลับไปพิจารณาใหม่ว่าการตัดออกเหล่านี้เป็นการตัดสินใจที่เหมาะสมหรือไม่</p>
<ul>
<li><strong>Async</strong>: Signals จะพร้อมให้ประเมินค่าแบบ synchronous เสมอในโมเดลนี้ อย่างไรก็ตาม บ่อยครั้งที่มีประโยชน์ที่จะมี process แบบ asynchronous บางอย่างที่นำไปสู่การเซ็ตค่า signal และเข้าใจว่า signal ยังคงอยู่ในสถานะ &quot;loading&quot; วิธีที่ง่ายที่สุดในการจำลองสถานะ loading คือการใช้ exception และพฤติกรรมการ cache exception ของ computed signal ก็สามารถประกอบเข้ากับเทคนิคนี้ได้อย่างสมเหตุสมผล เทคนิคที่ปรับปรุงแล้วมีการพูดถึงใน <a href="https://github.com/proposal-signals/proposal-signals/issues/30">Issue #30</a></li>
<li><strong>Transactions</strong>: สำหรับการเปลี่ยนผ่านระหว่าง views มักเป็นประโยชน์ที่จะรักษาสถานะที่ active สำหรับ state ทั้ง &quot;จาก&quot; และ &quot;ไปยัง&quot; state โดย state &quot;ไปยัง&quot; จะ render อยู่เบื้องหลังจนกว่าจะพร้อมสลับ (commit transaction) ขณะที่ state &quot;จาก&quot; ยังคง interactive อยู่ การคงทั้งสอง state พร้อมกันต้องมีการ &quot;fork&quot; สถานะของกราฟ signal และอาจจำเป็นต้องรองรับการ transition ค้างพร้อมกันหลายรายการด้วย การอภิปรายดูได้ที่ <a href="https://github.com/proposal-signals/proposal-signals/issues/73">Issue #73</a></li>
</ul>
<p><a href="https://github.com/proposal-signals/proposal-signals/issues/32">Convenience methods</a> บางรายการก็ถูกตัดออกเช่นกัน</p>
<h2>สถานะและแผนการพัฒนา</h2>
<p>ข้อเสนอนี้อยู่ในวาระ TC39 เดือนเมษายน 2024 สำหรับ Stage 1 ในปัจจุบันนี้สามารถนับว่าเป็น &quot;Stage 0&quot;</p>
<p><a href="https://github.com/proposal-signals/signal-polyfill">Polyfill</a> สำหรับข้อเสนอนี้มีให้ใช้งานพร้อมกับชุดทดสอบพื้นฐาน ผู้เขียนเฟรมเวิร์กบางรายได้เริ่มทดลองเปลี่ยนมาใช้ signal implementation นี้แล้ว แต่การใช้งานยังอยู่ในระยะแรกเริ่ม</p>
<p>ผู้ร่วมพัฒนา Signal proposal ต้องการดำเนินการอย่าง <strong>ระมัดระวัง</strong> เป็นพิเศษในการผลักดันข้อเสนอนี้ไปข้างหน้า เพื่อหลีกเลี่ยงกับดักในการเผยแพร่สิ่งที่อาจจะทำให้เสียใจภายหลังและไม่ได้ใช้งานจริง แผนของเราคือการทำงานเพิ่มเติมดังต่อไปนี้ ซึ่งไม่ใช่ข้อกำหนดตามกระบวนการของ TC39 เพื่อให้มั่นใจว่าข้อเสนอนี้อยู่ในทิศทางที่ถูกต้อง:</p>
<p>ก่อนจะเสนอเข้าสู่ Stage 2 เรามีแผนจะ:</p>
<ul>
<li>พัฒนา polyfill ระดับ production หลายรายการที่มีความเสถียร ทดสอบอย่างดี (เช่น ผ่านการทดสอบจากเฟรมเวิร์กต่าง ๆ รวมถึง test262-style tests) และมีประสิทธิภาพในการทำงาน (พิสูจน์ด้วย signal/framework benchmark อย่างละเอียด)</li>
<li>ผสานรวม Signal API ที่เสนอเข้ากับ JS frameworks จำนวนมากที่เราพิจารณาว่าเป็นตัวแทน และแอปพลิเคชันขนาดใหญ่บางรายการนำไปใช้งาน ทดสอบว่าทำงานได้อย่างถูกต้องและมีประสิทธิภาพในบริบทเหล่านี้</li>
<li>มีความเข้าใจที่แน่ชัดในพื้นที่ของความเป็นไปได้ในการขยาย API และสรุปแล้วว่าควรเพิ่มอะไร (ถ้ามี) เข้าไปในข้อเสนอนี้</li>
</ul>
<h2>อัลกอริทึมของ Signal</h2>
<p>ส่วนนี้จะอธิบาย API แต่ละตัวที่เปิดเผยสู่ JavaScript ในแง่ของอัลกอริทึมที่มันใช้งาน สามารถนับเป็น proto-specification และถูกรวมไว้ในช่วงต้นเพื่อกำหนด semantics ชุดหนึ่งที่เป็นไปได้ ในขณะที่ยังเปิดรับการเปลี่ยนแปลงอยู่</p>
<p>ลักษณะบางประการของอัลกอริทึม:</p>
<ul>
<li>ลำดับของการอ่าน Signals ภายใน computed มีความสำคัญ และสามารถสังเกตได้จากลำดับของ callback บางตัว (ที่ <code>Watcher</code> ถูกเรียก, <code>equals</code>, พารามิเตอร์แรกของ <code>new Signal.Computed</code>, และ callback <code>watched</code>/<code>unwatched</code>) ที่ถูก execute นี่หมายความว่า sources ของ computed Signal ต้องถูกเก็บแบบมีลำดับ</li>
<li>Callback ทั้งสี่นี้อาจ throw exception ได้ทั้งหมด และ exception เหล่านี้จะถูก propagate ไปยัง JS code ที่เรียกใช้อย่างสามารถคาดการณ์ได้ Exception เหล่านี้จะ <em>ไม่</em> หยุดการทำงานของอัลกอริทึมนี้หรือปล่อยให้กราฟอยู่ในสถานะที่ประมวลผลค้างอยู่ สำหรับ error ที่ throw จาก notify callback ของ Watcher, exception นั้นจะถูกส่งไปที่ <code>.set()</code> ที่เป็นตัวเรียกใช้ โดยใช้ AggregateError หากมีหลาย exception ส่วนอื่น ๆ (รวมถึง <code>watched</code>/<code>unwatched</code>?) จะถูกเก็บในค่าของ Signal เพื่อนำไป throw ซ้ำเมื่ออ่าน และ signal ที่ throw ซ้ำนี้สามารถถูก mark ว่า <code>~clean~</code> ได้เหมือนกับ signal ที่มีค่าปกติ</li>
<li>มีการระมัดระวังเพื่อหลีกเลี่ยงวงจรในกรณีของ computed signals ที่ไม่ได้ &quot;watched&quot; (ไม่ได้ถูกสังเกตโดย Watcher ใด ๆ) เพื่อให้สามารถถูก garbage collect ได้อย่างอิสระจากส่วนอื่นของกราฟ signal ภายในอาจ implement ด้วยระบบ generation number ที่ถูกเก็บเสมอ; ทั้งนี้ implementation ที่ optimized อาจมี generation number ต่อ node ใน local หรือไม่ track บางค่าใน signal ที่ถูก watch แล้วก็ได้</li>
</ul>
<h3>สถานะ global ที่ซ่อนอยู่</h3>
<p>อัลกอริทึมของ Signal จำเป็นต้องอ้างอิงสถานะ global บางรายการ ซึ่งสถานะนี้เป็น global สำหรับทั้ง thread หรือ &quot;agent&quot;</p>
<ul>
<li><code>computing</code>: computed หรือ effect Signal ที่อยู่ลึกสุดที่กำลังถูก reevaluate จากการเรียก <code>.get</code> หรือ <code>.run</code> หรือ <code>null</code> เริ่มต้นเป็น <code>null</code></li>
<li><code>frozen</code>: Boolean แสดงว่าขณะนี้มี callback ที่กำลัง execute ที่ต้องการไม่ให้มีการเปลี่ยนแปลงกราฟหรือไม่ เริ่มต้นเป็น <code>false</code></li>
<li><code>generation</code>: เลขจำนวนเต็มที่เพิ่มขึ้นทีละ 1 เริ่มต้นที่ 0 ใช้เพื่อติดตามว่าค่าปัจจุบันใหม่แค่ไหน ในขณะที่หลีกเลี่ยงวงจร</li>
</ul>
<h3>เนมสเปซ <code>Signal</code></h3>
<p><code>Signal</code> เป็น object ปกติที่ทำหน้าที่เป็นเนมสเปซสำหรับคลาสและฟังก์ชันที่เกี่ยวข้องกับ Signal</p>
<p><code>Signal.subtle</code> เป็น object เนมสเปซย่อยคล้ายกัน</p>
<h3>คลาส <code>Signal.State</code></h3>
<h4>ช่อง internal ของ <code>Signal.State</code></h4>
<ul>
<li><code>value</code>: ค่าปัจจุบันของ state signal</li>
<li><code>equals</code>: ฟังก์ชันเปรียบเทียบที่ใช้เมื่อเปลี่ยนค่า</li>
<li><code>watched</code>: callback ที่จะถูกเรียกเมื่อ signal นี้ถูกสังเกตโดย effect</li>
<li><code>unwatched</code>: callback ที่จะถูกเรียกเมื่อ signal นี้ไม่ถูกสังเกตโดย effect อีกต่อไป</li>
<li><code>sinks</code>: เซ็ตของ watched signals ที่ขึ้นกับ signal นี้</li>
</ul>
<h4>Constructor: <code>Signal.State(initialValue, options)</code></h4>
<ol>
<li>กำหนด <code>value</code> ของ Signal นี้เป็น <code>initialValue</code></li>
<li>กำหนด <code>equals</code> ของ Signal นี้เป็น options?.equals</li>
<li>กำหนด <code>watched</code> ของ Signal นี้เป็น options?.[Signal.subtle.watched]</li>
<li>กำหนด <code>unwatched</code> ของ Signal นี้เป็น options?.[Signal.subtle.unwatched]</li>
<li>กำหนด <code>sinks</code> ของ Signal นี้เป็นเซ็ตว่าง</li>
</ol>
<h4>Method: <code>Signal.State.prototype.get()</code></h4>
<ol>
<li>ถ้า <code>frozen</code> เป็น true ให้ throw exception</li>
<li>ถ้า <code>computing</code> ไม่ใช่ <code>undefined</code> ให้เพิ่ม Signal นี้เข้าไปในเซ็ต <code>sources</code> ของ <code>computing</code></li>
<li>หมายเหตุ: เรายังไม่เพิ่ม <code>computing</code> เข้าไปในเซ็ต <code>sinks</code> ของ Signal นี้จนกว่าจะถูก watch โดย Watcher</li>
<li>คืนค่า <code>value</code> ของ Signal นี้</li>
</ol>
<h4>Method: <code>Signal.State.prototype.set(newValue)</code></h4>
<ol>
<li>ถ้า context การทำงานปัจจุบันคือ <code>frozen</code> ให้ throw exception</li>
<li>รันอัลกอริทึม &quot;set Signal value&quot; โดยใช้ Signal นี้และค่า value ที่เป็นพารามิเตอร์แรก</li>
<li>ถ้าอัลกอริทึมนั้นคืนค่า <code>~clean~</code> ให้ return undefined</li>
<li>ตั้งค่า <code>state</code> ของ sinks ทั้งหมดของ Signal นี้ (ถ้าเป็น Computed Signal) เป็น <code>~dirty~</code> ถ้าเดิมเป็น clean หรือ (ถ้าเป็น Watcher) เป็น <code>~pending~</code> ถ้าเดิมเป็น <code>~watching~</code></li>
<li>ตั้งค่า <code>state</code> ของ Computed Signal dependencies ของ sinks ทั้งหมด (recursive) เป็น <code>~checked~</code> ถ้าเดิมเป็น <code>~clean~</code> (หมายถึง ให้คง dirty marking ไว้) หรือสำหรับ Watchers เป็น <code>~pending~</code> ถ้าเดิมเป็น <code>~watching~</code></li>
<li>สำหรับ Watcher ที่เคยเป็น <code>~watching~</code> ที่พบใน recursive search นั้น ให้ทำตามลำดับ depth-first:
<ol>
<li>ตั้งค่า <code>frozen</code> เป็น true</li>
<li>เรียก callback <code>notify</code> ของพวกมัน (บันทึก exception ที่ throw ไว้ แต่ไม่สนใจ return value ของ <code>notify</code>)</li>
<li>คืนค่า <code>frozen</code> เป็น false</li>
<li>ตั้งค่า <code>state</code> ของ Watcher เป็น <code>~waiting~</code></li>
</ol>
</li>
<li>ถ้ามี exception ถูก throw จาก notify callbacks ใด ๆ ให้ propagate กลับไปยัง caller หลังจาก notify callbacks ทั้งหมดรันจบ ถ้ามีหลาย exception ให้รวมเป็น AggregateError แล้ว throw</li>
<li>คืนค่า undefined</li>
</ol>
<h3>คลาส <code>Signal.Computed</code></h3>
<h4>สถานะของ <code>Signal.Computed</code> (State machine)</h4>
<p><code>state</code> ของ Computed Signal อาจเป็นสถานะใดสถานะหนึ่งดังต่อไปนี้:</p>
<ul>
<li><code>~clean~</code>: ค่าของ Signal มีอยู่และทราบแน่ว่าไม่ล้าสมัย</li>
<li><code>~checked~</code>: แหล่งข้อมูล (indirect) ของ Signal นี้มีการเปลี่ยนแปลง; Signal นี้ยังมีค่าอยู่แต่ <em>อาจจะ</em> ล้าสมัย การจะทราบว่าล้าสมัยหรือไม่ จะรู้ได้ก็ต่อเมื่อมีการประเมินแหล่งข้อมูลทั้งหมดแบบ immediate แล้ว</li>
<li><code>~computing~</code>: callback ของ Signal นี้กำลังถูกดำเนินการอยู่ในฐานะผลข้างเคียงของการเรียก <code>.get()</code></li>
<li><code>~dirty~</code>: Signal นี้มีค่าที่รู้แน่ว่าล้าสมัย หรือไม่เคยถูกประเมินค่ามาก่อนเลย</li>
</ul>
<p>กราฟการเปลี่ยนสถานะเป็นดังนี้:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; dirty
    dirty --&gt; computing: [4]
    computing --&gt; clean: [5]
    clean --&gt; dirty: [2]
    clean --&gt; checked: [3]
    checked --&gt; clean: [6]
    checked --&gt; dirty: [1]
</code></pre>
<p>การเปลี่ยนสถานะมีดังนี้:
| หมายเลข | จาก | ไป | เงื่อนไข | อัลกอริทึม |
| ------- | --- | -- | -------- | ---------- |
| 1 | <code>~checked~</code> | <code>~dirty~</code> | immediate source ของ signal นี้ซึ่งเป็น computed signal ได้ถูกประเมินค่าแล้วและค่าของมันเปลี่ยนแปลง | อัลกอริทึม: recalculate dirty computed Signal |
| 2 | <code>~clean~</code> | <code>~dirty~</code> | immediate source ของ signal นี้ซึ่งเป็น State ถูก set ด้วยค่าที่ไม่เท่ากับค่าก่อนหน้า | เมธอด: <code>Signal.State.prototype.set(newValue)</code> |
| 3 | <code>~clean~</code> | <code>~checked~</code> | แหล่งข้อมูล recursive (แต่ไม่ใช่ immediate) ของ signal นี้ซึ่งเป็น State ถูก set ด้วยค่าที่ไม่เท่ากับค่าก่อนหน้า | เมธอด: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~dirty~</code> | <code>~computing~</code> | กำลังจะทำการ execute <code>callback</code> | อัลกอริทึม: recalculate dirty computed Signal |
| 5 | <code>~computing~</code> | <code>~clean~</code> | <code>callback</code> ได้ประเมินค่าเสร็จสิ้นและคืนค่าหรือโยน exception | อัลกอริทึม: recalculate dirty computed Signal |
| 6 | <code>~checked~</code> | <code>~clean~</code> | แหล่งข้อมูล immediate ของ signal นี้ทั้งหมดถูกประเมินค่าแล้วและไม่มีการเปลี่ยนแปลงใดๆ จึงทราบแน่ว่าไม่ล้าสมัย | อัลกอริทึม: recalculate dirty computed Signal |</p>
<h4>Slot ภายในของ <code>Signal.Computed</code></h4>
<ul>
<li><code>value</code>: ค่าที่ cache ไว้ก่อนหน้าของ Signal หรือ <code>~uninitialized~</code> สำหรับ computed Signal ที่ไม่เคยถูกอ่าน ค่าอาจเป็น exception ที่จะถูกโยนซ้ำเมื่อมีการอ่านค่าเสมอ เป็น <code>undefined</code> เสมอสำหรับ effect signals</li>
<li><code>state</code>: อาจเป็น <code>~clean~</code>, <code>~checked~</code>, <code>~computing~</code> หรือ <code>~dirty~</code></li>
<li><code>sources</code>: ชุดของ Signals ที่ Signal นี้ขึ้นอยู่กับเรียงตามลำดับ</li>
<li><code>sinks</code>: ชุดของ Signals ที่ขึ้นอยู่กับ Signal นี้เรียงตามลำดับ</li>
<li><code>equals</code>: เมธอดเปรียบเทียบความเท่ากันที่กำหนดใน options</li>
<li><code>callback</code>: callback ที่ใช้เพื่อรับค่าของ computed Signal กำหนดค่าจากพารามิเตอร์แรกที่ส่งให้ constructor</li>
</ul>
<h4>คอนสตรัคเตอร์ของ <code>Signal.Computed</code></h4>
<p>คอนสตรัคเตอร์จะกำหนด</p>
<ul>
<li><code>callback</code> เป็นพารามิเตอร์แรกที่ได้รับ</li>
<li><code>equals</code> จาก options ถ้าไม่มีจะใช้ <code>Object.is</code> เป็นค่าเริ่มต้น</li>
<li><code>state</code> เป็น <code>~dirty~</code></li>
<li><code>value</code> เป็น <code>~uninitialized~</code></li>
</ul>
<p>เมื่อใช้ <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a> callback ที่ถูกส่งให้กับ <code>new Signal.Computed</code> จะปิดเหนือ snapshot ขณะเรียก constructor และคืนค่าสภาพแวดล้อมนั้นระหว่างการทำงาน</p>
<h4>เมธอด: <code>Signal.Computed.prototype.get</code></h4>
<ol>
<li>ถ้า execution context ปัจจุบันคือ <code>frozen</code> หรือ Signal นี้มี state เป็น <code>~computing~</code> หรือหาก signal นี้เป็น Watcher และกำลัง <code>computing</code> computed Signal ให้โยน exception</li>
<li>ถ้า <code>computing</code> ไม่เป็น <code>null</code> ให้เพิ่ม Signal นี้ในชุด <code>sources</code> ของ <code>computing</code></li>
<li>หมายเหตุ: จะไม่เพิ่ม <code>computing</code> ไปในชุด <code>sinks</code> ของ Signal นี้จนกว่าจะถูก Watcher เฝ้าดู</li>
<li>หาก state ของ Signal นี้คือ <code>~dirty~</code> หรือ <code>~checked~</code>: ทำขั้นตอนต่อไปนี้ซ้ำจนกว่า Signal นี้จะเป็น <code>~clean~</code>:
<ol>
<li>ไต่กลับขึ้นไปผ่าน <code>sources</code> เพื่อหา recursive source ที่ลึกสุด, ซ้ายสุด (คือ สังเกตเจอก่อนสุด) ซึ่งเป็น Computed Signal ที่ถูกทำเครื่องหมายว่า <code>~dirty~</code> (หยุดค้นหาเมื่อเจอ Computed Signal ที่ <code>~clean~</code> และรวม Computed Signal นี้เป็นตัวสุดท้ายที่ค้นหา)</li>
<li>ทำอัลกอริทึม &quot;recalculate dirty computed Signal&quot; กับ Signal นั้น</li>
</ol>
</li>
<li>ณ จุดนี้ Signal นี้จะมีสถานะ <code>~clean~</code> และ recursive sources ทั้งหมดจะไม่เป็น <code>~dirty~</code> หรือ <code>~checked~</code> คืนค่าของ Signal หากค่านั้นเป็น exception ให้โยน exception นั้น</li>
</ol>
<h3>คลาส <code>Signal.subtle.Watcher</code></h3>
<h4>สเตตแมชชีนของ <code>Signal.subtle.Watcher</code></h4>
<p><code>state</code> ของ Watcher อาจเป็นสถานะใดสถานะหนึ่งดังต่อไปนี้:</p>
<ul>
<li><code>~waiting~</code>: มีการ run <code>notify</code> callback แล้ว หรือ Watcher นี้ถูกสร้างขึ้นใหม่แต่ยังไม่ได้เฝ้าดู signal ใด</li>
<li><code>~watching~</code>: Watcher กำลังเฝ้าดู signals อยู่ แต่ยังไม่มีการเปลี่ยนแปลงใดที่จำเป็นต้องเรียก <code>notify</code> callback</li>
<li><code>~pending~</code>: มี dependency ของ Watcher เปลี่ยนแปลง แต่ยังไม่ได้ run <code>notify</code> callback</li>
</ul>
<p>กราฟการเปลี่ยนสถานะเป็นดังนี้:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; waiting
    waiting --&gt; watching: [1]
    watching --&gt; waiting: [2]
    watching --&gt; pending: [3]
    pending --&gt; waiting: [4]
</code></pre>
<p>การเปลี่ยนสถานะมีดังนี้:
| หมายเลข | จาก | ไป | เงื่อนไข | อัลกอริทึม |
| ------- | --- | -- | -------- | ---------- |
| 1 | <code>~waiting~</code> | <code>~watching~</code> | มีการเรียกใช้เมธอด <code>watch</code> ของ Watcher | เมธอด: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code> |
| 2 | <code>~watching~</code> | <code>~waiting~</code> | มีการเรียกใช้เมธอด <code>unwatch</code> ของ Watcher และสัญญาณที่เฝ้าดูตัวสุดท้ายถูกลบออก | เมธอด: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code> |
| 3 | <code>~watching~</code> | <code>~pending~</code> | signal ที่เฝ้าดูอาจมีการเปลี่ยนค่า | เมธอด: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~pending~</code> | <code>~waiting~</code> | มีการ run <code>notify</code> callback | เมธอด: <code>Signal.State.prototype.set(newValue)</code> |</p>
<h4>slot ภายในของ <code>Signal.subtle.Watcher</code></h4>
<ul>
<li><code>state</code>: อาจเป็น <code>~watching~</code>, <code>~pending~</code> หรือ <code>~waiting~</code></li>
<li><code>signals</code>: ชุดของ Signals ที่ Watcher นี้กำลังเฝ้าดู เรียงตามลำดับ</li>
<li><code>notifyCallback</code>: callback ที่ถูกเรียกเมื่อมีการเปลี่ยนแปลงบางอย่าง กำหนดจากพารามิเตอร์แรกที่ส่งให้ constructor</li>
</ul>
<h4>คอนสตรัคเตอร์: <code>new Signal.subtle.Watcher(callback)</code></h4>
<ol>
<li>กำหนด <code>state</code> เป็น <code>~waiting~</code></li>
<li>กำหนด <code>signals</code> ให้เป็นชุดว่าง</li>
<li>กำหนด <code>notifyCallback</code> เป็น callback ที่ได้รับเป็นพารามิเตอร์
ด้วย <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a> คอลแบ็กที่ถูกส่งเข้าไปใน <code>new Signal.subtle.Watcher</code> จะ <em>ไม่</em> ปิดทับ snapshot จากตอนที่ constructor ถูกเรียก ดังนั้นข้อมูลเชิงบริบทที่อยู่รอบๆ การเขียนจะสามารถมองเห็นได้</li>
</ol>
<h4>เมธอด: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code></h4>
<ol>
<li>หาก <code>frozen</code> เป็น true ให้โยนข้อยกเว้น</li>
<li>หากอาร์กิวเมนต์ใดไม่ใช่ signal ให้โยนข้อยกเว้น</li>
<li>เพิ่มอาร์กิวเมนต์ทั้งหมดต่อท้าย <code>signals</code> ของอ็อบเจ็กต์นี้</li>
<li>สำหรับแต่ละ signal ที่ถูกเฝ้าดูใหม่ โดยเรียงจากซ้ายไปขวา,
<ol>
<li>เพิ่ม watcher นี้เป็น <code>sink</code> ให้กับ signal นั้น</li>
<li>หากนี่คือ sink ตัวแรก ให้ไล่ขึ้นไปยัง source เพื่อตั้ง signal นั้นเป็น sink</li>
<li>ตั้งค่า <code>frozen</code> เป็น true</li>
<li>เรียกคอลแบ็ก <code>watched</code> หากมี</li>
<li>คืนค่า <code>frozen</code> กลับเป็น false</li>
</ol>
</li>
<li>หาก <code>state</code> ของ Signal เป็น <code>~waiting~</code> ให้ตั้งเป็น <code>~watching~</code></li>
</ol>
<h4>เมธอด: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code></h4>
<ol>
<li>หาก <code>frozen</code> เป็น true ให้โยนข้อยกเว้น</li>
<li>หากอาร์กิวเมนต์ใดไม่ใช่ signal หรือ signal นั้นไม่ได้ถูก watcher นี้ดูอยู่ ให้โยนข้อยกเว้น</li>
<li>สำหรับแต่ละ signal ในอาร์กิวเมนต์ โดยเรียงจากซ้ายไปขวา,
<ol>
<li>ลบ signal นั้นออกจากเซต <code>signals</code> ของ Watcher นี้</li>
<li>ลบ Watcher นี้ออกจากเซต <code>sink</code> ของ Signal นั้น</li>
<li>หากเซต <code>sink</code> ของ Signal นั้นว่างเปล่า ให้ลบ Signal นั้นออกจาก sink ของ source แต่ละตัว</li>
<li>ตั้งค่า <code>frozen</code> เป็น true</li>
<li>เรียกคอลแบ็ก <code>unwatched</code> หากมี</li>
<li>คืนค่า <code>frozen</code> กลับเป็น false</li>
</ol>
</li>
<li>หาก watcher นี้ไม่มี <code>signals</code> แล้วและ <code>state</code> เป็น <code>~watching~</code> ให้ตั้งเป็น <code>~waiting~</code></li>
</ol>
<h4>เมธอด: <code>Signal.subtle.Watcher.prototype.getPending()</code></h4>
<ol>
<li>คืนค่า Array ที่มี subset ของ <code>signals</code> ซึ่งเป็น Computed Signals ที่อยู่ในสถานะ <code>~dirty~</code> หรือ <code>~pending~</code></li>
</ol>
<h3>เมธอด: <code>Signal.subtle.untrack(cb)</code></h3>
<ol>
<li>กำหนด <code>c</code> ให้เป็น state <code>computing</code> ปัจจุบันของ execution context</li>
<li>ตั้ง <code>computing</code> เป็น null</li>
<li>เรียก <code>cb</code></li>
<li>คืนค่า <code>computing</code> เป็น <code>c</code> (แม้ว่า <code>cb</code> จะโยนข้อยกเว้น)</li>
<li>คืนค่าผลลัพธ์ของ <code>cb</code> (หากมีข้อยกเว้นให้โยนซ้ำ)</li>
</ol>
<p>หมายเหตุ: untrack จะไม่ทำให้คุณออกจาก state <code>frozen</code> ซึ่งจะถูกควบคุมไว้อย่างเข้มงวด</p>
<h3>เมธอด: <code>Signal.subtle.currentComputed()</code></h3>
<ol>
<li>คืนค่า <code>computing</code> ปัจจุบัน</li>
</ol>
<h3>อัลกอริทึมร่วม</h3>
<h5>อัลกอริทึม: คำนวณใหม่ dirty computed Signal</h5>
<ol>
<li>ล้างเซต <code>sources</code> ของ Signal นี้ และลบ Signal นี้ออกจากเซต <code>sinks</code> ของ sources เหล่านั้น</li>
<li>บันทึกค่า <code>computing</code> ก่อนหน้าและตั้ง <code>computing</code> เป็น Signal นี้</li>
<li>ตั้งสถานะ Signal นี้เป็น <code>~computing~</code></li>
<li>รันคอลแบ็กของ computed Signal นี้ โดยใช้ Signal นี้เป็นค่า this บันทึกค่าที่คืนกลับมา และหากคอลแบ็กโยนข้อยกเว้น ให้เก็บข้อยกเว้นนั้นเพื่อโยนซ้ำ</li>
<li>คืนค่า <code>computing</code> เป็นค่าก่อนหน้า</li>
<li>ใช้อัลกอริทึม &quot;set Signal value&quot; กับค่าที่ return จากคอลแบ็ก</li>
<li>ตั้งสถานะของ Signal นี้เป็น <code>~clean~</code></li>
<li>หากอัลกอริทึมนั้นคืนค่า <code>~dirty~</code>: ให้ mark sink ทั้งหมดของ Signal นี้เป็น <code>~dirty~</code> (ก่อนหน้านี้ sink อาจเป็นการผสมระหว่าง checked และ dirty) (หรือหาก Signal นี้ไม่ถูก watch ให้เปลี่ยน generation number ใหม่เพื่อบ่งบอกความ dirty หรืออย่างอื่นที่คล้ายกัน)</li>
<li>หากอัลกอริทึมนั้นคืนค่า <code>~clean~</code>: ในกรณีนี้ สำหรับแต่ละ sink สถานะ <code>~checked~</code> ของ Signal นี้ หากทุก source ของ Signal นั้นสะอาดแล้ว ให้ mark Signal นั้นเป็น <code>~clean~</code> ด้วย ทำขั้นตอน clean-up นี้ต่อไปยัง sink ที่เกี่ยวข้องแบบ recursive สำหรับ Signals ที่เพิ่ง clean และมี checked sinks (หรือถ้าไม่ได้ถูก watch ให้บ่งบอกเช่นเดียวกันเพื่อให้ clean-up ทำงานแบบ lazy ได้)</li>
</ol>
<h5>อัลกอริทึม Set Signal value</h5>
<ol>
<li>หากอัลกอริทึมนี้รับค่ามา (ไม่ใช่ exception สำหรับโยนซ้ำจากอัลกอริทึม recalculate dirty computed Signal):
<ol>
<li>เรียกฟังก์ชัน <code>equals</code> ของ Signal นี้ โดยส่งค่า <code>value</code> ปัจจุบัน, ค่าใหม่ และ Signal นี้เป็นพารามิเตอร์ หากเกิด exception ให้บันทึก exception นั้น (เพื่อโยนซ้ำเมื่ออ่าน) เป็นค่าของ Signal และทำต่อเหมือนคอลแบ็กคืนค่า false</li>
<li>หากฟังก์ชันนั้นคืนค่า true ให้ return <code>~clean~</code></li>
</ol>
</li>
<li>ตั้งค่า <code>value</code> ของ Signal นี้เป็นค่าพารามิเตอร์</li>
<li>return <code>~dirty~</code></li>
</ol>
<h2>FAQ</h2>
<p><strong>ถาม</strong>: มันเร็วไปไหมที่จะมาตรฐานบางอย่างที่เกี่ยวข้องกับ Signals ทั้งที่เพิ่งกลายเป็นกระแสใหม่ในปี 2022? ควรให้เวลามันพัฒนามากกว่านี้ไหมเพื่อให้เสถียร?</p>
<p><strong>ตอบ</strong>: สถานะปัจจุบันของ Signals ในเว็บเฟรมเวิร์กต่างๆ เกิดจากการพัฒนาอย่างต่อเนื่องมากกว่า 10 ปี เมื่อการลงทุนเพิ่มขึ้นในช่วงไม่กี่ปีที่ผ่านมา เฟรมเวิร์กเว็บเกือบทั้งหมดกำลังเข้าใกล้โมเดล core ของ Signals ที่คล้ายกันมาก ข้อเสนอนี้เกิดจากการออกแบบร่วมกันระหว่างผู้นำในวงการเว็บเฟรมเวิร์กจำนวนมาก และจะไม่ถูกผลักดันเข้าสู่มาตรฐานโดยไม่มีการยืนยันจากกลุ่มผู้เชี่ยวชาญในหลากหลายบริบท</p>
<h4>Signals ถูกใช้อย่างไร?</h4>
<p><strong>ถาม</strong>: Signals ที่ถูก build-in สามารถนำไปใช้กับ framework ได้จริงหรือ ในเมื่อมันผูกกับการเรนเดอร์และการเป็นเจ้าของอย่างแน่นแฟ้น?</p>
<p><strong>ตอบ</strong>: ส่วนที่เฉพาะของ framework มากกว่าจะอยู่ในเรื่องของเอฟเฟกต์, การ scheduling, และการเป็นเจ้าของ/การทำลายทิ้ง ซึ่งข้อเสนอนี้ไม่ได้พยายามจะแก้ปัญหา จุดประสงค์แรกของเรากับการ prototyping Signals ที่จะเข้าสู่มาตรฐาน คือพิสูจน์ว่ามันสามารถ &quot;รองรับ&quot; อยู่ใต้ framework ที่มีอยู่แล้วได้อย่างเข้ากันได้และมีประสิทธิภาพ</p>
<p><strong>ถาม</strong>: Signal API ถูกออกแบบมาให้ใช้โดยตรงกับนักพัฒนาแอปพลิเคชัน หรือควรให้ framework มาครอบอีกที?</p>
<p><strong>ตอบ</strong>: แม้ API นี้จะสามารถถูกใช้โดยตรงกับนักพัฒนาแอปพลิเคชัน (อย่างน้อยส่วนที่ไม่อยู่ใน namespace <code>Signal.subtle</code>) แต่มันไม่ได้ถูกออกแบบมาให้ใช้งานสะดวกเป็นพิเศษ ความต้องการของผู้เขียนไลบรารี/เฟรมเวิร์กเป็นสิ่งสำคัญ Framework ส่วนใหญ่คาดว่าจะครอบแม้แต่ API พื้นฐานอย่าง <code>Signal.State</code> และ <code>Signal.Computed</code> ด้วย abstraction ที่สะท้อนสไตล์ของ framework เอง ในทางปฏิบัติ มักจะดีที่สุดถ้าใช้ Signals ผ่าน framework ซึ่งจะจัดการฟีเจอร์ที่ซับซ้อนกว่า (เช่น Watcher, <code>untrack</code>) รวมถึงการจัดการ ownership และ disposal (เช่น การคำนวณว่า signal ใดควรถูกเพิ่มหรือลบออกจาก watcher) และการ scheduling การเรนเดอร์ไปยัง DOM — ข้อเสนอนี้ไม่ได้พยายามแก้ปัญหาเหล่านั้น</p>
<p><strong>ถาม</strong>: ต้อง tear down Signals ที่เกี่ยวข้องกับวิดเจ็ตเมื่อวิดเจ็ตนั้นถูกทำลายไหม? API สำหรับสิ่งนี้คืออะไร?</p>
<p><strong>ตอบ</strong>: การ teardown ที่เกี่ยวข้องคือ <code>Signal.subtle.Watcher.prototype.unwatch</code> เฉพาะ Signals ที่ถูก watch เท่านั้นที่ต้อง cleanup (โดยการ unwatch) ส่วน Signals ที่ไม่ได้ถูก watch จะถูกเก็บกวาดโดย garbage collector โดยอัตโนมัติ</p>
<p><strong>ถาม</strong>: Signals ใช้กับ VDOM หรือใช้งานตรงกับ HTML DOM ได้หรือไม่?</p>
<p><strong>ตอบ</strong>: ได้! Signals เป็นอิสระจากเทคโนโลยีเรนเดอร์ Framework JavaScript ที่มีอยู่ซึ่งใช้ construct ลักษณะ Signal สามารถทำงานร่วมกับ VDOM (เช่น Preact), native DOM (เช่น Solid) และแบบผสม (เช่น Vue) ได้เช่นกัน สิ่งเดียวกันนี้จะเป็นไปได้กับ Signals ที่ถูก build-in</p>
<p><strong>ถาม</strong>: การใช้ Signals ใน context ของ framework ที่เป็น class-based เช่น Angular และ Lit จะ ergonomic ไหม? แล้ว framework ที่ใช้ compiler อย่าง Svelte ล่ะ?</p>
<p><strong>ตอบ</strong>: ฟิลด์ของคลาสสามารถทำให้เป็น Signal-based ได้ด้วย accessor decorator ง่ายๆ ตามตัวอย่างใน <a href="https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators">Signal polyfill readme</a> Signals สอดคล้องกับ Svelte 5's Runes อย่างใกล้ชิด — compiler สามารถแปลง runes ไปเป็น Signal API ตามที่นิยามไว้ที่นี่ได้ง่าย และในความเป็นจริง Svelte 5 ก็ทำแบบนั้นภายใน (แต่ใช้ Signals library ของตัวเอง)</p>
<p><strong>ถาม</strong>: Signals ใช้กับ SSR ได้หรือไม่? Hydration? Resumability?</p>
<p><strong>ตอบ</strong>: ได้ Qwik ใช้ Signals ได้อย่างมีประสิทธิภาพกับคุณสมบัติทั้งสองนี้ และ framework อื่นๆ ก็มีแนวทางที่พัฒนาแล้วสำหรับ hydration ด้วย Signals พร้อมข้อแลกเปลี่ยนที่แตกต่างกัน เราคิดว่าสามารถจำลอง Signals แบบ resumable ของ Qwik ได้โดยใช้ State และ Computed signal ที่เชื่อมกัน และเราวางแผนจะพิสูจน์สิ่งนี้ในโค้ด
<strong>ถาม</strong>: Signals ทำงานร่วมกับการไหลของข้อมูลทางเดียวแบบที่ React ทำได้หรือไม่?</p>
<p><strong>ตอบ</strong>: ใช่, Signals เป็นกลไกสำหรับการไหลของข้อมูลทางเดียว เฟรมเวิร์ก UI ที่ใช้ Signal ช่วยให้คุณสามารถแสดงผลมุมมองของคุณเป็นฟังก์ชันของโมเดล (ซึ่งโมเดลมี Signals อยู่ด้วย) กราฟของสถานะและ Signals ที่คำนวณจะไม่มีวงจรโดยโครงสร้าง นอกจากนี้ยังสามารถสร้างรูปแบบที่ไม่แนะนำของ React ใน Signals ได้ (!) เช่น การใช้ Watcher เพื่อกำหนดเวลาการเขียนไปยัง State signal ซึ่งเทียบเท่ากับการใช้ <code>setState</code> ใน <code>useEffect</code></p>
<p><strong>ถาม</strong>: Signals เกี่ยวข้องกับระบบการจัดการสถานะอย่าง Redux อย่างไร? Signals ส่งเสริมการจัดการสถานะที่ไม่มีโครงสร้างหรือไม่?</p>
<p><strong>ตอบ</strong>: Signals สามารถเป็นพื้นฐานที่มีประสิทธิภาพสำหรับนามธรรมการจัดการสถานะแบบ store ได้ รูปแบบที่พบได้ทั่วไปในหลายเฟรมเวิร์กคือตัววัตถุที่สร้างจาก Proxy ที่ภายในแทนคุณสมบัติโดยใช้ Signals เช่น <a href="https://vuejs.org/api/reactivity-core.html#reactive">Vue <code>reactive()</code></a> หรือ <a href="https://docs.solidjs.com/concepts/stores">Solid stores</a> ระบบเหล่านี้ช่วยให้สามารถจัดกลุ่มสถานะได้อย่างยืดหยุ่นในระดับนามธรรมที่เหมาะสมกับแอปพลิเคชันแต่ละประเภท</p>
<p><strong>ถาม</strong>: Signals มีข้อเสนออะไรที่ <code>Proxy</code> ยังไม่สามารถจัดการได้ในปัจจุบัน?</p>
<p><strong>ตอบ</strong>: Proxy และ Signals เป็นสิ่งที่เสริมกันและทำงานร่วมกันได้ดี Proxy ช่วยให้คุณดักจับการทำงานกับวัตถุแบบตื้นและ signals ช่วยประสานกราฟของการพึ่งพา (dependency graph) การใช้ Proxy รองรับด้วย Signals เป็นวิธีที่ยอดเยี่ยมในการสร้างโครงสร้างแบบ reactive ซ้อนกันที่ใช้งานง่าย</p>
<p>ในตัวอย่างนี้, เราสามารถใช้ proxy เพื่อให้ signal มี property getter และ setter แทนการใช้เมธอด <code>get</code> และ <code>set</code>:</p>
<pre><code class="language-js">const a = new Signal.State(0);
const b = new Proxy(a, {
  get(target, property, receiver) {
    if (property === 'value') {
      return target.get():
    }
  }
  set(target, property, value, receiver) {
    if (property === 'value') {
      target.set(value)!
    }
  }
});

// การใช้งานใน context ที่เป็น reactive สมมุติ:
&lt;template&gt;
  {b.value}

  &lt;button onclick={() =&gt; {
    b.value++;
  }}&gt;change&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>เมื่อใช้ renderer ที่ถูกปรับให้เหมาะสมกับ reactivity แบบละเอียด การคลิกปุ่มจะทำให้เซลล์ <code>b.value</code> ถูกอัปเดต</p>
<p>ดู:</p>
<ul>
<li>ตัวอย่างโครงสร้าง reactive ซ้อนกันที่สร้างด้วยทั้ง Signals และ Proxies: <a href="https://github.com/NullVoxPopuli/signal-utils/tree/main/src">signal-utils</a></li>
<li>ตัวอย่างการใช้งานก่อนหน้านี้ที่แสดงความสัมพันธ์ระหว่างข้อมูล reactive และ proxies: <a href="https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private">tracked-built-ins</a></li>
<li><a href="https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574">การอภิปราย</a></li>
</ul>
<h4>Signals ทำงานอย่างไร?</h4>
<p><strong>ถาม</strong>: Signals เป็นแบบ push-based หรือ pull-based?</p>
<p><strong>ตอบ</strong>: การประเมิน Signals ที่คำนวณเป็นแบบ pull-based: Signals ที่คำนวณจะถูกประเมินก็ต่อเมื่อมีการเรียก <code>.get()</code> เท่านั้น แม้ว่าสถานะที่อยู่ข้างใต้จะเปลี่ยนแปลงไปนานแล้วก็ตาม ขณะเดียวกัน การเปลี่ยนแปลง State signal อาจทำให้ callback ของ Watcher ทำงานทันที, &quot;push&quot; การแจ้งเตือน ดังนั้น Signals อาจถูกมองว่าเป็นโครงสร้างแบบ &quot;push-pull&quot;</p>
<p><strong>ถาม</strong>: Signals ทำให้เกิดความไม่แน่นอนในการทำงานของ JavaScript หรือไม่?</p>
<p><strong>ตอบ</strong>: ไม่ ทั้งหมดของการดำเนินการกับ Signal มี semantics และลำดับที่นิยามไว้อย่างดี และจะไม่แตกต่างกันระหว่างการ implement ที่สอดคล้องกัน ในระดับที่สูงขึ้น Signals จะมี invariants ชุดหนึ่งที่ทำให้มัน &quot;sound&quot; เสมอ Signals ที่คำนวณจะสังเกตกราฟ Signal ในสถานะที่สอดคล้องกันเสมอ และการทำงานของมันจะไม่ถูกขัดจังหวะโดยโค้ดที่เปลี่ยน Signal อื่น ๆ (ยกเว้นสิ่งที่มันเรียกเอง) ดูคำอธิบายข้างต้น</p>
<p><strong>ถาม</strong>: เมื่อเขียนค่าลง state Signal, การอัปเดตไปยัง computed Signal จะถูกกำหนดเวลาไว้เมื่อใด?</p>
<p><strong>ตอบ</strong>: ไม่มีการกำหนดเวลา! Computed Signal จะคำนวณตัวเองใหม่ครั้งต่อไปที่มีผู้เรียกอ่านมัน Synchronously, อาจมีการเรียก callback ของ Watcher เพื่อให้เฟรมเวิร์กสามารถกำหนดเวลาในการอ่านได้ตามต้องการ</p>
<p><strong>ถาม</strong>: การเขียนลง state Signals มีผลทันทีหรือไม่ หรือมีการ batch?</p>
<p><strong>ตอบ</strong>: การเขียนลง state Signals จะสะท้อนผลทันที—Signal ที่คำนวณซึ่งพึ่งพา state Signal นั้นจะคำนวณตัวเองใหม่หากจำเป็นในการอ่านครั้งถัดไป แม้จะเป็นบรรทัดโค้ดถัดไปก็ตาม อย่างไรก็ตาม, ความ lazy ของกลไกนี้ (คือ computed Signals จะคำนวณเมื่อมีการอ่านเท่านั้น) ทำให้โดยปฏิบัติแล้ว การคำนวณอาจเกิดขึ้นแบบ batch</p>
<p><strong>ถาม</strong>: การที่ Signals ช่วยให้ &quot;glitch-free&quot; execution หมายถึงอะไร?</p>
<p><strong>ตอบ</strong>: โมเดล push-based แบบเก่าสำหรับ reactivity เจอปัญหาการคำนวณซ้ำซ้อน: ถ้าการอัปเดต state Signal ทำให้ computed Signal รันทันที สุดท้ายอาจผลักการอัปเดตไปยัง UI แต่การเขียนไปยัง UI นี้อาจเกิดก่อนเวลา หากจะมีการเปลี่ยนแปลง state Signal ต้นทางอีกก่อนเฟรมถัดไป บางครั้งค่ากลางที่ไม่ถูกต้องยังถูกแสดงต่อผู้ใช้เนื่องจาก <a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">glitches</a> ดังกล่าว Signals หลีกเลี่ยงปัญหานี้โดยเป็น pull-based แทน push-based: เมื่อเฟรมเวิร์กกำหนดเวลาการ render UI, มันจะ pull การอัปเดตที่เหมาะสม, หลีกเลี่ยงงานซ้ำทั้งในการคำนวณและการเขียนลง DOM</p>
<p><strong>ถาม</strong>: การที่ Signals เป็น &quot;lossy&quot; หมายถึงอะไร?</p>
<p><strong>ตอบ</strong>: นี่คืออีกด้านของ glitch-free execution: Signals แทนข้อมูลเซลล์เดียว—แค่ค่าปัจจุบันทันที (ซึ่งอาจเปลี่ยนแปลงได้) ไม่ใช่สตรีมข้อมูลตลอดเวลา ดังนั้น ถ้าคุณเขียนลง state Signal สองครั้งติดกันโดยไม่ทำอย่างอื่น การเขียนครั้งแรกจะ &quot;หาย&quot; ไปและไม่มี Signal ที่คำนวณหรือเอฟเฟกต์ใด ๆ เห็น นี่ถือเป็นฟีเจอร์มากกว่าบั๊ก—โครงสร้างอื่น ๆ (เช่น async iterables, observables) เหมาะสำหรับสตรีมมากกว่า</p>
<p><strong>ถาม</strong>: Signals แบบ native จะเร็วกว่า Signal implementation ใน JS ที่มีอยู่แล้วหรือไม่?</p>
<p><strong>ตอบ</strong>: เราหวังว่าจะเป็นเช่นนั้น (ด้วยตัวคูณค่าคงที่เล็กน้อย) แต่ยังต้องพิสูจน์ในโค้ด เอนจิน JS ไม่ใช่เวทมนตร์ และสุดท้ายก็ต้อง implement algorithm แบบเดียวกับ Signal ที่เขียนด้วย JS ดูหัวข้อข้างบนเกี่ยวกับประสิทธิภาพ</p>
<h4>Signals ถูกออกแบบเช่นนี้เพราะอะไร?</h4>
<p><strong>ถาม</strong>: ทำไมข้อเสนอนี้จึงไม่มีฟังก์ชัน <code>effect()</code> ในเมื่อ effect จำเป็นสำหรับการใช้งาน Signals ในทางปฏิบัติ?</p>
<p><strong>ตอบ</strong>: Effect ผูกกับ scheduling และ disposal โดยเนื้อแท้ ซึ่งถูกจัดการโดยเฟรมเวิร์กและอยู่นอกขอบเขตของข้อเสนอนี้ ข้อเสนอนี้จึงมีเพียงพื้นฐานสำหรับการ implement effect ผ่าน API ระดับต่ำอย่าง <code>Signal.subtle.Watcher</code></p>
<p><strong>ถาม</strong>: ทำไม subscription จึงเป็นแบบอัตโนมัติแทนที่จะให้ interface แบบ manual?</p>
<p><strong>ตอบ</strong>: ประสบการณ์แสดงให้เห็นว่า interface subscription แบบ manual สำหรับ reactivity ใช้งานยากและเกิดข้อผิดพลาดได้ง่าย การ tracking แบบอัตโนมัติสามารถนำไปประกอบต่อได้สะดวกกว่าและเป็นคุณสมบัติหลักของ Signals</p>
<p><strong>ถาม</strong>: ทำไม callback ของ <code>Watcher</code> จึงรันแบบ synchronous แทนที่จะกำหนดเวลาไว้ใน microtask?</p>
<p><strong>ตอบ</strong>: เพราะ callback ไม่สามารถอ่านหรือเขียน Signals ได้ จึงไม่มีความไม่แน่นอนที่เกิดจากการรัน synchronous โดยปกติ callback จะเพิ่ม Signal ลงใน Array เพื่ออ่านภายหลัง หรือ mark บิตที่ไหนสักแห่ง จึงไม่จำเป็นและสิ้นเปลืองเกินไปที่จะสร้าง microtask แยกสำหรับการกระทำเหล่านี้</p>
<p><strong>ถาม</strong>: API นี้ขาดฟีเจอร์ดี ๆ ที่เฟรมเวิร์กโปรดของฉันมี ซึ่งทำให้เขียนโค้ดกับ Signals ง่ายขึ้น สามารถเพิ่มเข้าในมาตรฐานได้ไหม?</p>
<p><strong>ตอบ</strong>: อาจจะได้ มีส่วนขยายต่าง ๆ อยู่ในระหว่างการพิจารณา กรุณาแจ้ง issue เพื่ออภิปรายเกี่ยวกับฟีเจอร์ที่คุณเห็นว่าสำคัญ</p>
<p><strong>ถาม</strong>: API นี้สามารถลดขนาดหรือความซับซ้อนได้หรือไม่?</p>
<p><strong>ตอบ</strong>: แน่นอนว่าเป้าหมายคือให้ API นี้เล็กที่สุดเท่าที่จะทำได้ และเราก็พยายามทำเช่นนั้นกับที่นำเสนอข้างต้น หากคุณมีไอเดียเพิ่มเติมว่าสามารถตัดอะไรออกได้อีก กรุณาแจ้ง issue เพื่ออภิปราย</p>
<h4>Signals กำลังเข้าสู่มาตรฐานอย่างไร?</h4>
<p><strong>ถาม</strong>: เราควรเริ่มทำมาตรฐานในเรื่องนี้ด้วยแนวคิดที่เป็น primitive กว่านี้ เช่น observables หรือไม่?
<strong>A</strong>: Observable อาจเป็นแนวคิดที่ดีสำหรับบางสิ่ง แต่พวกมันไม่ได้แก้ปัญหาที่ Signals ตั้งใจจะแก้ไข ดังที่อธิบายไว้ข้างต้น Observable หรือกลไก publish/subscribe อื่น ๆ ไม่ใช่ทางออกที่สมบูรณ์สำหรับการเขียนโปรแกรม UI หลายประเภท เนื่องจากต้องมีการตั้งค่าที่เสี่ยงต่อความผิดพลาดมากสำหรับนักพัฒนา และเกิดการทำงานที่สูญเปล่าเนื่องจากขาดความขี้เกียจ (laziness) ในกระบวนการทำงาน เป็นต้น</p>
<p><strong>Q</strong>: ทำไม Signals ถึงถูกเสนอใน TC39 แทนที่จะเป็น DOM ทั้งที่การใช้งานส่วนใหญ่เป็นแบบเว็บ?</p>
<p><strong>A</strong>: ผู้ร่วมเขียนข้อเสนอนี้บางคนมีความสนใจในสภาพแวดล้อม UI ที่ไม่ใช่เว็บเป็นเป้าหมายด้วย แต่ทุกวันนี้ไม่ว่าช่องทางไหนก็เหมาะสมได้ เพราะ web API มักถูกนำไปใช้ในสภาพแวดล้อมนอกเว็บบ่อยขึ้น สุดท้ายแล้ว Signals ไม่จำเป็นต้องขึ้นกับ DOM API ใด ๆ ดังนั้นไม่ว่าจะทางใดก็ใช้ได้ หากใครมีเหตุผลที่หนักแน่นว่ากลุ่มนี้ควรเปลี่ยนไปอีกทางหนึ่ง โปรดแจ้งให้เราทราบใน issue สำหรับตอนนี้ ผู้ร่วมเขียนทุกคนได้ลงนามในข้อตกลงทรัพย์สินทางปัญญาของ TC39 แล้ว และแผนคือจะนำเสนอนี้ต่อ TC39</p>
<p><strong>Q</strong>: จะใช้เวลานานแค่ไหนจนกว่าฉันจะสามารถใช้ Signals มาตรฐานได้?</p>
<p><strong>A</strong>: ขณะนี้มี polyfill ให้ใช้งานอยู่แล้ว แต่ไม่ควรพึ่งพาความเสถียรของมัน เนื่องจาก API นี้ยังคงพัฒนาและปรับเปลี่ยนระหว่างขั้นตอนการรีวิว อีกไม่กี่เดือนหรือหนึ่งปีข้างหน้า อาจมี polyfill ที่มีคุณภาพสูง เสถียร และประสิทธิภาพดีให้ใช้งานได้ แต่ก็ยังขึ้นอยู่กับการปรับแก้ของคณะกรรมการและยังไม่ถือเป็นมาตรฐาน ตามแนวทางปกติของข้อเสนอ TC39 คาดว่าจะใช้เวลาอย่างน้อย 2-3 ปีเป็นขั้นต่ำที่สุด กว่า Signals จะถูกนำไปใช้งานโดยเนทีฟในเบราว์เซอร์ทุกตัว (ย้อนหลังได้อีกไม่กี่เวอร์ชัน) โดยไม่ต้องพึ่ง polyfill</p>
<p><strong>Q</strong>: เราจะป้องกันไม่ให้เกิดมาตรฐาน Signals ที่ผิดประเภทเร็วเกินไป เหมือนกับ {{JS/web feature ที่คุณไม่ชอบ}} ได้อย่างไร?</p>
<p><strong>A</strong>: ผู้เขียนข้อเสนอนี้มีแผนจะทำงานต้นแบบและพิสูจน์แนวคิดอย่างละเอียดก่อนขอเลื่อนขั้นใน TC39 ดูหัวข้อ &quot;สถานะและแผนการพัฒนา&quot; ข้างต้น หากคุณเห็นช่องว่างในแผนนี้หรือโอกาสในการปรับปรุง โปรดแจ้งปัญหา (issue) พร้อมอธิบายด้วย</p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-28</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>