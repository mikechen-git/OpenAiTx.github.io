<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>proposal-signals - tc39/proposal-signals ar</title>
    <meta name="title" content="proposal-signals - tc39/proposal-signals ar | 🚦 اقتراح معيار إشارات جافاسكريبت 🚦 المرحلة 1 (توضيح) أبطال اقتراح TC39: دانيال إهرنبرغ، يهودا كاتز، جتين راماناثان، شاي لويس، كريستين هيويل جاريت، دومينيك جان...">
    <meta name="description" content="tc39/proposal-signals - GitHub repository ar documentation and information | 🚦 اقتراح معيار إشارات جافاسكريبت 🚦 المرحلة 1 (توضيح) أبطال اقتراح TC39: دانيال إهرنبرغ، يهودا كاتز، جتين راماناثان، شاي لويس، كريستين هيويل جاريت، دومينيك جان...">
    <meta name="keywords" content="tc39, proposal-signals, GitHub, repository, ar documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/tc39/proposal-signals/README-ar.html">
    <meta property="og:title" content="proposal-signals - tc39/proposal-signals ar | 🚦 اقتراح معيار إشارات جافاسكريبت 🚦 المرحلة 1 (توضيح) أبطال اقتراح TC39: دانيال إهرنبرغ، يهودا كاتز، جتين راماناثان، شاي لويس، كريستين هيويل جاريت، دومينيك جان...">
    <meta property="og:description" content="tc39/proposal-signals - GitHub repository ar documentation and information | 🚦 اقتراح معيار إشارات جافاسكريبت 🚦 المرحلة 1 (توضيح) أبطال اقتراح TC39: دانيال إهرنبرغ، يهودا كاتز، جتين راماناثان، شاي لويس، كريستين هيويل جاريت، دومينيك جان...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/tc39/proposal-signals" id="githubRepoLink" target="_blank">tc39/proposal-signals</a>
<h1 style="display: none;">🚦 اقتراح معيار إشارات جافاسكريبت 🚦 المرحلة 1 (توضيح) أبطال اقتراح TC39: دانيال إهرنبرغ، يهودا كاتز، جتين راماناثان، شاي لويس، كريستين هيويل جاريت، دومينيك جان...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>🚦 اقتراح معيار إشارات جافاسكريبت 🚦</h1>
<img align=right src="https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg" alt="شعار الإشارات" width=100>
<p>المرحلة 1 (<a href="https://tc39.es/process-document/">توضيح</a>)</p>
<p>أبطال اقتراح TC39: دانيال إهرنبرغ، يهودا كاتز، جتين راماناثان، شاي لويس، كريستين هيويل جاريت، دومينيك جاناواي، بريستون سيغو، ميلو إم، روب إيزنبرغ</p>
<p>المؤلفون الأصليون: روب إيزنبرغ ودانيال إهرنبرغ</p>
<p>يصف هذا المستند اتجاهًا مشتركًا مبكرًا للإشارات في جافاسكريبت، مشابهًا لجهود Promises/A+ التي سبقت توحيد الوعود من قبل TC39 في ES2015. يمكنك تجربته بنفسك باستخدام <a href="https://github.com/proposal-signals/signal-polyfill">polyfill</a>.</p>
<p>وبالمثل مع Promises/A+، يركز هذا الجهد على توحيد نظام جافاسكريبت البيئي. إذا تم تحقيق هذا التوحيد بنجاح، فقد يظهر معيار بناءً على تلك التجربة. يتعاون هنا العديد من مؤلفي الأطر على نموذج مشترك يمكن أن يدعم نواة التفاعلية لديهم. المسودة الحالية تستند إلى مدخلات تصميم من مؤلفي/صانعي <a href="https://angular.io/">Angular</a>، <a href="https://bubble.io/">Bubble</a>، <a href="https://emberjs.com/">Ember</a>، <a href="https://www.fast.design/">FAST</a>، <a href="https://mobx.js.org/">MobX</a>، <a href="https://preactjs.com/">Preact</a>، <a href="https://qwik.dev/">Qwik</a>، <a href="https://rxjs.dev/">RxJS</a>، <a href="https://www.solidjs.com/">Solid</a>، <a href="https://www.starbeamjs.com/">Starbeam</a>، <a href="https://svelte.dev/">Svelte</a>، <a href="https://vuejs.org/">Vue</a>، <a href="https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a">Wiz</a>، وأكثر...</p>
<p>وبخلاف Promises/A+، نحن لا نحاول حل واجهة برمجة تطبيقات مشتركة موجهة للمطورين، بل نركز على الدلالات الجوهرية الدقيقة للرسم البياني الأساسي للإشارات. يتضمن هذا الاقتراح واجهة برمجة تطبيقات ملموسة بالكامل، لكن الواجهة ليست موجهة لمعظم مطوري التطبيقات. بدلاً من ذلك، فإن واجهة برمجة تطبيقات الإشارات هنا مناسبة أكثر لبناء الأطر عليها، مما يوفر قابلية التشغيل البيني من خلال رسم إشارات مشترك وآلية تتبع تلقائي.</p>
<p>خطة هذا الاقتراح هي إجراء نمذجة أولية كبيرة مبكرًا، بما في ذلك التكامل في العديد من الأطر، قبل التقدم إلى ما بعد المرحلة 1. نحن مهتمون فقط بتوحيد الإشارات إذا كانت مناسبة للاستخدام العملي في عدة أطر عمل، وتوفر فوائد حقيقية على الإشارات المقدمة من الأطر. نأمل أن تمنحنا النمذجة الأولية المكثفة هذه المعلومات. راجع قسم &quot;الحالة وخطة التطوير&quot; أدناه لمزيد من التفاصيل.</p>
<h2>الخلفية: لماذا الإشارات؟</h2>
<p>لتطوير واجهة مستخدم (UI) معقدة، يحتاج مطورو تطبيقات جافاسكريبت إلى تخزين، وحساب، وإبطال، ومزامنة، ودفع الحالة إلى طبقة العرض الخاصة بالتطبيق بطريقة فعالة. غالبًا ما تتطلب واجهات المستخدم أكثر من مجرد إدارة قيم بسيطة، بل تشمل غالبًا عرض حالة محسوبة تعتمد على شجرة معقدة من القيم الأخرى أو الحالة التي يتم حسابها أيضًا. الهدف من الإشارات هو توفير بنية تحتية لإدارة مثل هذه الحالة التطبيقية حتى يتمكن المطورون من التركيز على منطق العمل بدلاً من هذه التفاصيل المتكررة.</p>
<p>لقد تم اكتشاف أن التركيبات الشبيهة بالإشارات مفيدة بشكل مستقل في السياقات غير المتعلقة بواجهة المستخدم أيضًا، خاصة في أنظمة البناء لتجنب إعادة البناء غير الضروري.</p>
<p>تُستخدم الإشارات في البرمجة التفاعلية لإزالة الحاجة لإدارة التحديثات في التطبيقات.</p>
<blockquote>
<p>نموذج برمجة تصريحي للتحديث بناءً على تغييرات الحالة.</p>
</blockquote>
<p>من <em><a href="https://www.pzuraq.com/blog/what-is-reactivity">ما هي التفاعلية؟</a></em>.</p>
<h4>مثال - عداد VanillaJS</h4>
<p>بالنظر إلى متغير <code>counter</code>، تريد عرضه في DOM لمعرفة ما إذا كان العداد زوجيًا أم فرديًا. في كل مرة يتغير فيها <code>counter</code>، تريد تحديث DOM بأحدث نوع زوجية. في جافاسكريبت العادية (Vanilla JS)، قد يكون لديك شيء مثل هذا:</p>
<pre><code class="language-js">let counter = 0;
const setCounter = (value) =&gt; {
  counter = value;
  render();
};

const isEven = () =&gt; (counter &amp; 1) == 0;
const parity = () =&gt; isEven() ? &quot;even&quot; : &quot;odd&quot;;
const render = () =&gt; element.innerText = parity();

// Simulate external updates to counter...
setInterval(() =&gt; setCounter(counter + 1), 1000);
</code></pre>
<blockquote>
<p>[!ملاحظة]<br />
تم استخدام المتغيرات العامة هنا لأغراض العرض فقط. هناك العديد من حلول إدارة الحالة السليمة، والأمثلة في هذا الاقتراح تهدف إلى أن تكون بسيطة قدر الإمكان. هذا الاقتراح لا يشجع على استخدام المتغيرات العامة.</p>
</blockquote>
<p>هذا يحتوي على عدد من المشاكل...</p>
<ul>
<li>إعداد <code>counter</code> مليء بالضوضاء والكود المتكرر.</li>
<li>حالة <code>counter</code> مرتبطة بقوة بنظام العرض.</li>
<li>إذا تغير <code>counter</code> لكن لم تتغير <code>parity</code> (مثلاً العداد انتقل من 2 إلى 4)، نقوم بحساب غير ضروري للزوجية وعرض غير ضروري.</li>
<li>ماذا إذا كان جزء آخر من واجهة المستخدم يريد فقط العرض عند تحديث <code>counter</code>؟</li>
<li>ماذا إذا كان جزء آخر من واجهة المستخدم يعتمد فقط على <code>isEven</code> أو <code>parity</code>؟</li>
</ul>
<p>حتى في هذا السيناريو البسيط نسبيًا، تظهر العديد من المشاكل بسرعة. يمكننا محاولة حل هذه المشاكل بإدخال pub/sub للعداد <code>counter</code>. سيسمح ذلك لمستهلكين إضافيين للعداد بالاشتراك لإضافة ردود أفعالهم على تغييرات الحالة.</p>
<p>ومع ذلك، ما زلنا عالقين مع المشاكل التالية:</p>
<ul>
<li>وظيفة العرض، التي تعتمد فقط على <code>parity</code> يجب بدلاً من ذلك أن &quot;تعرف&quot; أنها تحتاج فعليًا للاشتراك في <code>counter</code>.</li>
<li>ليس من الممكن تحديث واجهة المستخدم بناءً على <code>isEven</code> أو <code>parity</code> فقط، دون التفاعل المباشر مع <code>counter</code>.</li>
<li>لقد زاد الكود المتكرر لدينا. في كل مرة تستخدم فيها شيئًا، فالأمر ليس مجرد استدعاء دالة أو قراءة متغير، بل يجب الاشتراك وتحديثه هناك. إدارة إلغاء الاشتراك معقدة أيضًا بشكل خاص.</li>
</ul>
<p>الآن، يمكننا حل بعض المشاكل بإضافة pub/sub ليس فقط إلى <code>counter</code> ولكن أيضًا إلى <code>isEven</code> و <code>parity</code>. حينها علينا الاشتراك بـ <code>isEven</code> إلى <code>counter</code>، و <code>parity</code> إلى <code>isEven</code>، و <code>render</code> إلى <code>parity</code>. لسوء الحظ، لم يزد الكود المتكرر فقط، بل أصبح لدينا الكثير من مهام إدارة الاشتراكات، واحتمالية حدوث تسرب للذاكرة إذا لم ننظف كل شيء بشكل صحيح. إذًا، قمنا بحل بعض المشاكل ولكن أنشأنا فئة جديدة بالكامل من المشاكل والكثير من الكود. والأسوأ من ذلك، علينا المرور بهذه العملية لكل جزء من الحالة في نظامنا.</p>
<h3>تقديم الإشارات</h3>
<p>لطالما كانت تجريدات ربط البيانات بين النموذج والعرض جوهرية في أطر واجهة المستخدم عبر لغات البرمجة المتعددة، على الرغم من عدم وجود مثل هذه الآلية مدمجة في جافاسكريبت أو منصة الويب. ضمن أطر ومكتبات جافاسكريبت، كان هناك الكثير من التجريب عبر طرق مختلفة لتمثيل هذا الربط، وقد أظهرت التجربة قوة تدفق البيانات في اتجاه واحد جنبًا إلى جنب مع نوع بيانات من الدرجة الأولى يمثل خلية من الحالة أو حساب مشتق من بيانات أخرى، والذي يسمى الآن غالبًا &quot;الإشارات&quot;.
يبدو أن هذا النهج القيمي التفاعلي من الدرجة الأولى قد ظهر لأول مرة على نطاق واسع في أطر جافاسكريبت مفتوحة المصدر مع <a href="https://knockoutjs.com/">Knockout</a> <a href="https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/">في عام 2010</a>. منذ ذلك الحين، تم إنشاء العديد من التنويعات والتنفيذات. خلال السنوات الثلاث أو الأربع الأخيرة، اكتسبت بدائية الإشارة والمناهج ذات الصلة مزيدًا من الزخم، مع وجود شيء مشابه تقريبًا في كل مكتبة أو إطار حديث لجافاسكريبت، تحت اسم أو آخر.</p>
<p>لفهم الإشارات، دعنا نلقي نظرة على المثال أعلاه، معاد تصوره باستخدام واجهة برمجة تطبيقات الإشارة الموضحة أدناه.</p>
<h4>مثال - عداد باستخدام الإشارات</h4>
<pre><code class="language-js">const counter = new Signal.State(0);
const isEven = new Signal.Computed(() =&gt; (counter.get() &amp; 1) == 0);
const parity = new Signal.Computed(() =&gt; isEven.get() ? &quot;even&quot; : &quot;odd&quot;);

// مكتبة أو إطار عمل يحدد التأثيرات بناءً على إشارات أخرى
declare function effect(cb: () =&gt; void): (() =&gt; void);

effect(() =&gt; element.innerText = parity.get());

// محاكاة التحديثات الخارجية للعداد...
setInterval(() =&gt; counter.set(counter.get() + 1), 1000);
</code></pre>
<p>هناك بعض الأشياء التي يمكننا ملاحظتها على الفور:</p>
<ul>
<li>لقد أزلنا الكود المتكرر المزعج حول متغير <code>counter</code> من مثالنا السابق.</li>
<li>هناك واجهة موحدة للتعامل مع القيم، والحسابات، والتأثيرات الجانبية.</li>
<li>لا توجد مشكلة مرجعية دائرية أو تبعيات مقلوبة بين <code>counter</code> و <code>render</code>.</li>
<li>لا توجد اشتراكات يدوية، ولا حاجة لأي إدارة.</li>
<li>هناك وسيلة للتحكم في توقيت/جدولة التأثيرات الجانبية.</li>
</ul>
<p>توفر لنا الإشارات أكثر بكثير مما يمكن ملاحظته على سطح واجهة البرمجة:</p>
<ul>
<li><strong>تتبع التبعيات التلقائي</strong> - يقوم الـ Signal المحسوب باكتشاف أي Signals أخرى يعتمد عليها بشكل تلقائي، سواء كانت تلك الـ Signals قيم بسيطة أو عمليات حسابية أخرى.</li>
<li><strong>التقييم الكسول (Lazy Evaluation)</strong> - لا يتم تقييم العمليات الحسابية بشكل متعجل عند إعلانها، ولا يتم تقييمها مباشرة عند تغير التبعيات الخاصة بها. يتم تقييمها فقط عندما يُطلب قيمتها صراحة.</li>
<li><strong>تخزين النتائج (Memoization)</strong> - تقوم Signals المحسوبة بتخزين آخر قيمة لها بحيث لا يتم إعادة تقييم العمليات الحسابية التي لم تتغير تبعياتها، بغض النظر عن عدد مرات الوصول إليها.</li>
</ul>
<h2>الدوافع وراء توحيد الـ Signals</h2>
<h4>قابلية التشغيل البيني</h4>
<p>كل تنفيذ للـ Signal لديه آلية تتبع تلقائي خاصة به، لتتبع المصادر التي يتم الوصول إليها عند تقييم Signal محسوب. هذا يصعب مشاركة النماذج والمكونات والمكتبات بين أطر العمل المختلفة—حيث تميل إلى أن تأتي مع اقتران خاطئ بمحرك العرض الخاص بها (نظرًا لأن Signals غالبًا ما يتم تنفيذها كجزء من أطر عمل JS).</p>
<p>أحد أهداف هذا الاقتراح هو فك الارتباط الكامل بين النموذج التفاعلي (reactive model) وعرض البيانات (rendering view)، مما يتيح للمطورين الانتقال إلى تقنيات عرض جديدة بدون إعادة كتابة كود غير واجهة المستخدم، أو تطوير نماذج تفاعلية مشتركة في JS ليتم نشرها في سياقات مختلفة. للأسف، بسبب الإصدارات والتكرار، اتضح أن الوصول إلى مستوى مشاركة قوي من خلال مكتبات على مستوى JS أمر غير عملي—توفر المدمجات (built-ins) ضمان مشاركة أقوى.</p>
<h4>الأداء/استخدام الذاكرة</h4>
<p>هناك دائمًا إمكانية لتعزيز الأداء من خلال شحن كود أقل بسبب وجود مكتبات مستخدمة بشكل شائع مدمجة، لكن تنفيذات Signals عادةً ما تكون صغيرة جدًا، لذلك لا نتوقع أن يكون هذا التأثير كبيرًا.</p>
<p>نحن نعتقد أن تنفيذات C++ الأصلية لهياكل البيانات والخوارزميات المتعلقة بـ Signal يمكن أن تكون أكثر كفاءة قليلاً مما هو ممكن في JS، بعامل ثابت فقط. ومع ذلك، لا يُتوقع حدوث تغييرات خوارزمية مقابل ما يمكن أن يوجد في polyfill؛ ولا يُتوقع من المحركات أن تقدم سحرًا هنا، وستكون خوارزميات التفاعلية نفسها محددة جيدًا وواضحة.</p>
<p>تتوقع مجموعة الأبطال تطوير عدة تنفيذات لـ Signals، واستخدامها لاستكشاف هذه الاحتمالات المتعلقة بالأداء.</p>
<h4>أدوات المطورين (DevTools)</h4>
<p>مع مكتبات Signals الحالية في لغة JS، قد يكون من الصعب تتبع أشياء مثل:</p>
<ul>
<li>مكدس الاستدعاء عبر سلسلة Signals المحسوبة، لإظهار سلسلة السببية لخطأ ما</li>
<li>رسم بياني للمرجع بين Signals، عندما يعتمد أحدها على الآخر—وهو أمر مهم عند تصحيح استخدام الذاكرة</li>
</ul>
<p>تمكن Signals المدمجة بيئات تشغيل JS وأدوات المطورين من دعم محسّن لفحص Signals، خاصة لأغراض التصحيح أو تحليل الأداء، سواء تم تضمين هذا الدعم في المتصفحات أو من خلال امتداد مشترك. يمكن تحديث الأدوات الحالية مثل مفتش العناصر، ولقطات الأداء، وأدوات تحليل الذاكرة لتسليط الضوء بشكل خاص على Signals في عرض المعلومات.</p>
<h4>الفوائد الثانوية</h4>
<h5>فوائد مكتبة قياسية</h5>
<p>بشكل عام، كانت مكتبة JavaScript القياسية محدودة إلى حد ما، لكن هناك اتجاه في TC39 لجعل JS لغة أكثر &quot;شمولية&quot; مع مجموعة مدمجة عالية الجودة من الوظائف المتاحة. على سبيل المثال، Temporal تحل محل moment.js، وعدد من الميزات الصغيرة مثل <code>Array.prototype.flat</code> و<code>Object.groupBy</code> تحل محل العديد من استخدامات lodash. تشمل الفوائد تقليل حجم الحزم، وتحسين الاستقرار والجودة، وتقليل الحاجة للتعلم عند الانضمام إلى مشروع جديد، وتوفير مفردات شائعة بين مطوري JS.</p>
<h5>تكامل مع HTML/DOM (احتمال مستقبلي)</h5>
<p>العمل الحالي في W3C ومن قبل مطوري المتصفحات يسعى لجلب القوالب الأصلية إلى HTML (<a href="https://github.com/WICG/webcomponents/pull/1023">DOM Parts</a> و<a href="https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md">Template Instantiation</a>). بالإضافة إلى ذلك، تستكشف مجموعة W3C Web Components إمكانية توسيع Web Components لتقديم واجهة HTML تصريحيه بالكامل. لتحقيق كلا الهدفين، سيحتاج HTML في النهاية إلى بدائية تفاعلية. بالإضافة إلى ذلك، يمكن تخيل العديد من التحسينات العملية لـ DOM من خلال تكامل Signals وقد طلبها المجتمع بالفعل.</p>
<blockquote>
<p>ملاحظة، هذا التكامل سيكون جهدًا منفصلًا يأتي لاحقًا، وليس جزءًا من هذا الاقتراح نفسه.</p>
</blockquote>
<h5>تبادل المعلومات في النظام البيئي (وليس سببًا للإطلاق)</h5>
<p>يمكن أن تكون جهود التوحيد القياسي مفيدة أحيانًا فقط على مستوى &quot;المجتمع&quot;، حتى بدون تغييرات في المتصفحات. يجمع جهد Signals العديد من مؤلفي الأطر المختلفين لمناقشة عميقة حول طبيعة التفاعلية والخوارزميات وقابلية التشغيل البيني. كان هذا مفيدًا بالفعل، لكنه لا يبرر تضمينه في محركات JS والمتصفحات؛ يجب إضافة Signals إلى معيار JavaScript فقط إذا كانت هناك فوائد كبيرة <em>تتجاوز</em> مجرد تبادل المعلومات بين الأنظمة.</p>
<h2>أهداف التصميم للـ Signals</h2>
<p>يتضح أن مكتبات Signal الحالية ليست مختلفة كثيرًا عن بعضها في جوهرها. يهدف هذا الاقتراح إلى البناء على نجاحها من خلال تنفيذ الصفات المهمة للعديد من تلك المكتبات.</p>
<h3>الميزات الأساسية</h3>
<ul>
<li>نوع Signal يمثل الحالة، أي Signal قابلة للكتابة. هذه قيمة يمكن للآخرين قراءتها.</li>
<li>نوع Signal محسوب/مخزن/مشتق، يعتمد على الآخرين ويتم حسابه وتخزينه بشكل كسول.
<ul>
<li>الحساب كسول، أي أن Signals المحسوبة لا يتم حسابها مرة أخرى بشكل افتراضي عندما تتغير إحدى تبعياتها، بل يتم التشغيل فقط إذا قرأها أحد.</li>
<li>الحساب &quot;<a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">خالي من الأعطال (glitch)</a>&quot;، أي لا يتم إجراء حسابات غير ضرورية أبدًا. وهذا يعني أنه عند قراءة تطبيق ما لـ Signal محسوب، يكون هناك ترتيب طوبولوجي للأجزاء القابلة للتغيير المحتمل في الرسم البياني ليتم تشغيلها، لإزالة أي تكرارات.</li>
<li>الحساب مخزن، أي إذا لم تتغير أي تبعيات منذ آخر مرة تغيرت فيها التبعيات، فلن يتم إعادة حساب Signal المحسوبة عند الوصول إليها.</li>
<li>المقارنات المخصصة ممكنة لكل من Signals المحسوبة وSignals الحالة، لتحديد متى يجب تحديث Signals المحسوبة الأخرى التي تعتمد عليها.</li>
</ul>
</li>
<li>ردود فعل على الحالة التي يصبح فيها أحد تبعيات Signal المحسوبة (أو التبعيات المتداخلة) &quot;متسخًا&quot; ويتغير، مما يعني أن قيمة Signal قد تكون قديمة.
<ul>
<li>يهدف هذا التفاعل إلى جدولة عمل أكثر أهمية ليتم تنفيذه لاحقًا.</li>
<li>يتم تنفيذ التأثيرات من حيث هذه التفاعلات، بالإضافة إلى جدولة على مستوى الإطار.</li>
<li>Signals المحسوبة تحتاج إلى القدرة على التفاعل مع ما إذا كانت مسجلة كتبعيات (متداخلة) لإحدى هذه التفاعلات.</li>
</ul>
</li>
<li>تمكين أطر عمل JS من تنفيذ جدولة خاصة بها. لا يوجد جدولة مدمجة إجبارية على غرار Promise.
<ul>
<li>هناك حاجة إلى تفاعلات متزامنة لتمكين جدولة العمل لاحقًا بناءً على منطق الإطار.</li>
<li>الكتابة متزامنة وتصبح سارية المفعول فورًا (يمكن للإطار الذي يجمع الكتابات أن يفعل ذلك فوق ذلك).</li>
<li>من الممكن فصل التحقق مما إذا كان التأثير قد يكون &quot;متسخًا&quot; عن تشغيل التأثير نفسه (مما يمكّن مجدول تأثير من مرحلتين).</li>
</ul>
</li>
<li>إمكانية قراءة Signals <em>دون</em> تفعيل تسجيل التبعيات (<code>untrack</code>)</li>
<li>تمكين تركيب قواعد كود مختلفة تستخدم Signals/التفاعلية، على سبيل المثال،
<ul>
<li>استخدام أطر متعددة معًا فيما يتعلق بالتتبع/التفاعلية (مع وجود استثناءات، انظر أدناه)</li>
<li>هياكل بيانات تفاعلية مستقلة عن الإطار (مثل مخزن تفاعلي بشكل متكرر، Map وSet وArray تفاعلية، إلخ)</li>
</ul>
</li>
</ul>
<h3>السلامة</h3>
<ul>
<li>تثبيط/منع سوء استخدام التفاعلات المتزامنة بشكل ساذج.
<ul>
<li>مخاطر السلامة: قد تعرض &quot;<a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">الأعطال (glitches)</a>&quot; إذا استخدمت بشكل غير صحيح: إذا تم العرض فور تعيين Signal، فقد تعرض حالة تطبيق غير مكتملة للمستخدم النهائي. لذلك، يجب استخدام هذه الميزة فقط لجدولة العمل بذكاء لاحقًا، بمجرد الانتهاء من منطق التطبيق.</li>
<li>الحل: منع القراءة والكتابة لأي Signal من داخل رد نداء التفاعل المتزامن.</li>
</ul>
</li>
<li>تثبيط استخدام <code>untrack</code> وبيان طبيعته غير الآمنة
<ul>
<li>مخاطر السلامة: يسمح بإنشاء Signals محسوبة تعتمد قيمتها على Signals أخرى، ولكنها لا يتم تحديثها عند تغير تلك الـ Signals. يجب استخدامه عندما لا تؤثر عمليات الوصول غير المتعقبة على نتيجة الحساب.</li>
<li>الحل: يتم تمييز الـ API بأنه &quot;غير آمن&quot; في الاسم.</li>
</ul>
</li>
<li>ملاحظة: يسمح هذا الاقتراح بقراءة وكتابة signals من signals المحسوبة والتأثير، دون تقييد الكتابات التي تأتي بعد القراءات، على الرغم من خطر السلامة. تم اتخاذ هذا القرار للحفاظ على المرونة والتوافق في التكامل مع الأطر.</li>
</ul>
<h3>واجهة البرمجة السطحية (Surface API)</h3>
<ul>
<li>يجب أن تكون أساسًا قويًا لعدة أطر عمل لتنفيذ آليات Signals/التفاعلية الخاصة بها.
<ul>
<li>يجب أن تكون قاعدة جيدة لمخازن proxies التفاعلية المتكررة، وتفاعلية الحقول في الفئات المعتمدة على الزخرفة (decorator)، وواجهات برمجة التطبيقات بأسلوب <code>.value</code> و<code>[state, setState]</code>.</li>
<li>يجب أن تكون الدلالات قادرة على التعبير عن الأنماط الصالحة الممكنة بواسطة أطر العمل المختلفة. على سبيل المثال، يجب أن يكون من الممكن أن تكون هذه Signals أساسًا إما للكتابات المنعكسة فورًا أو الكتابات المجمعة التي يتم تطبيقها لاحقًا.</li>
</ul>
</li>
<li>من الجيد أن يكون هذا الـ API قابلاً للاستخدام مباشرة من قبل مطوري JavaScript.
<ul>
<li>إذا كانت ميزة ما تتطابق مع مفهوم في النظام البيئي، فاستخدام مفردات شائعة أمر جيد.
<ul>
<li>مع ذلك، من المهم عدم نسخ نفس الأسماء حرفيًا!</li>
</ul>
</li>
<li>هناك توتر بين &quot;قابلية الاستخدام من قبل مطوري JS&quot; و&quot;توفير جميع الخطافات للأطر&quot;
<ul>
<li>فكرة: توفير جميع الخطافات، لكن تضمين أخطاء عند سوء الاستخدام إذا أمكن.</li>
<li>فكرة: وضع واجهات برمجة التطبيقات الدقيقة في مساحة اسم <code>subtle</code>، على غرار <a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle"><code>crypto.subtle</code></a>، للفصل بين الواجهات اللازمة للاستخدامات المتقدمة مثل تنفيذ إطار عمل أو بناء أدوات مطورين مقابل الاستخدام اليومي لتطبيقات البرمجة مثل إنشاء signals لاستخدامها مع إطار عمل.</li>
</ul>
</li>
</ul>
</li>
<li>يجب أن تكون قابلة للتنفيذ والاستخدام بأداء جيد—أي لا تسبب واجهة البرمجة السطحية عبئًا زائدًا كبيرًا
<ul>
<li>تمكين الوراثة، بحيث يمكن للأطر إضافة طرقها وحقولها الخاصة، بما في ذلك الحقول الخاصة. هذا مهم لتجنب الحاجة لتخصيصات إضافية على مستوى الإطار. راجع &quot;إدارة الذاكرة&quot; أدناه.</li>
</ul>
</li>
</ul>
<h3>إدارة الذاكرة</h3>
<ul>
<li>إذا أمكن: يجب أن يكون من الممكن جمع Signal محسوب بواسطة جامع القمامة إذا لم يكن هناك أي مرجع حي يشير إليه لغرض القراءة المحتملة في المستقبل، حتى لو كان مرتبطًا برسم بياني أوسع يظل حيًا (مثلاً، من خلال قراءة حالة تظل حية).</li>
<li>لاحظ أن معظم الأطر الحالية تتطلب التخلص الصريح من الإشارات المحسوبة إذا كان لديها أي مرجع إلى أو من رسم إشارة آخر يبقى حيًا.</li>
<li>هذا لا يكون سيئًا جدًا عندما تكون فترة حياتها مرتبطة بفترة حياة مكون واجهة المستخدم، وتحتاج التأثيرات إلى التخلص منها على أي حال.</li>
<li>إذا كان تنفيذ ذلك مكلفًا جدًا بهذه الدلالات، فيجب علينا إضافة التخلص الصريح (أو &quot;فك الارتباط&quot;) من الإشارات المحسوبة إلى الواجهة البرمجية أدناه، والتي تفتقر إليه حاليًا.</li>
<li>هدف منفصل ذو صلة: تقليل عدد التخصيصات، مثلاً:
<ul>
<li>لإنشاء إشارة قابلة للكتابة (تجنب إغلاقين منفصلين + مصفوفة)</li>
<li>لتنفيذ التأثيرات (تجنب إغلاق لكل تفاعل فردي)</li>
<li>في واجهة برمجة التطبيقات لمراقبة تغييرات الإشارة، تجنب إنشاء هياكل بيانات مؤقتة إضافية</li>
<li>الحل: واجهة برمجة تطبيقات قائمة على الأصناف تُمكن من إعادة استخدام الدوال والحقول المعرفة في الأصناف الفرعية</li>
</ul>
</li>
</ul>
<h2>مخطط واجهة برمجة التطبيقات</h2>
<p>فكرة أولية عن واجهة برمجة تطبيقات الإشارة أدناه. لاحظ أن هذا مجرد مسودة أولية، ونتوقع تغييرات مع مرور الوقت. لنبدأ بملف <code>.d.ts</code> الكامل للحصول على فكرة عن الشكل العام، ثم سنناقش تفاصيل ما يعنيه كل ذلك.</p>
<pre><code class="language-ts">interface Signal&lt;T&gt; {
    // الحصول على قيمة الإشارة
    get(): T;
}

namespace Signal {
    // إشارة للقراءة والكتابة
    class State&lt;T&gt; implements Signal&lt;T&gt; {
        // إنشاء إشارة حالة تبدأ بالقيمة t
        constructor(t: T, options?: SignalOptions&lt;T&gt;);

        // الحصول على قيمة الإشارة
        get(): T;

        // تعيين قيمة إشارة الحالة إلى t
        set(t: T): void;
    }

    // إشارة هي عبارة عن صيغة تعتمد على إشارات أخرى
    class Computed&lt;T = unknown&gt; implements Signal&lt;T&gt; {
        // إنشاء إشارة يتم تقييمها إلى القيمة التي يتم إرجاعها من قبل رد الاستدعاء.
        // يتم استدعاء رد الاستدعاء مع هذه الإشارة كقيمة this.
        constructor(cb: (this: Computed&lt;T&gt;) =&gt; T, options?: SignalOptions&lt;T&gt;);

        // الحصول على قيمة الإشارة
        get(): T;
    }

    // تحتوي هذه المساحة الاسمية على ميزات &quot;متقدمة&quot; من الأفضل
    // تركها لمؤلفي الأطر بدلاً من مطوري التطبيقات.
    // مماثلة لـ `crypto.subtle`
    namespace subtle {
        // تنفيذ رد استدعاء مع تعطيل جميع التتبع
        function untrack&lt;T&gt;(cb: () =&gt; T): T;

        // الحصول على إشارة محسوبة حالية تتتبع أي قراءات إشارة، إذا وجدت
        function currentComputed(): Computed | null;

        // إرجاع قائمة مرتبة بجميع الإشارات التي تمت الإشارة إليها بواسطة هذه الإشارة
        // خلال آخر مرة تم تقييمها فيها.
        // بالنسبة للمراقب Watcher، يسرد مجموعة الإشارات التي يراقبها.
        function introspectSources(s: Computed | Watcher): (State | Computed)[];

        // إرجاع المراقبين Watchers الذين تحتويهم هذه الإشارة، بالإضافة إلى أي
        // إشارات محسوبة قرأت هذه الإشارة آخر مرة تم تقييمها،
        // إذا كانت تلك الإشارة المحسوبة (بشكل متكرر) مراقبة.
        function introspectSinks(s: State | Computed): (Computed | Watcher)[];

        // صحيح إذا كانت هذه الإشارة &quot;حية&quot;، أي تتم مراقبتها بواسطة مراقب Watcher،
        // أو تتم قراءتها بواسطة إشارة محسوبة (بشكل متكرر) حية.
        function hasSinks(s: State | Computed): boolean;

        // صحيح إذا كان هذا العنصر &quot;تفاعليًا&quot;، أي يعتمد
        // على إشارة أخرى. الإشارة المحسوبة التي يكون فيها hasSources خاطئًا
        // ستُرجع دائمًا نفس القيمة الثابتة.
        function hasSources(s: Computed | Watcher): boolean;

        class Watcher {
            // عند كتابة مصدر (بشكل متكرر) للمراقب Watcher، يتم استدعاء رد الاستدعاء هذا،
            // إذا لم يكن قد تم استدعاؤه بالفعل منذ آخر استدعاء لـ `watch`.
            // لا يمكن قراءة أو كتابة أي إشارات أثناء الإخطار.
            constructor(notify: (this: Watcher) =&gt; void);

            // إضافة هذه الإشارات إلى مجموعة المراقب، وتعيين المراقب لتشغيل
            // رد الاستدعاء للإخطار في المرة القادمة التي تتغير فيها أي إشارة في المجموعة (أو أحد تبعياتها).
            // يمكن استدعاؤها بدون معاملات فقط لإعادة تعيين حالة &quot;تم الإخطار&quot;، بحيث يتم استدعاء
            // رد الاستدعاء للإخطار مرة أخرى.
            watch(...s: Signal[]): void;

            // إزالة هذه الإشارات من المجموعة المراقبة (مثلاً، لتأثير تم التخلص منه)
            unwatch(...s: Signal[]): void;

            // إرجاع مجموعة المصادر في مجموعة المراقب التي لا تزال قيد التحديث، أو هي إشارة محسوبة
            // تحتوي على مصدر قيد التحديث أو قيد الانتظار ولم يتم إعادة تقييمه بعد
            getPending(): Signal[];
        }

        // خطافات لمراقبة البدء أو التوقف عن المراقبة
        var watched: Symbol;
        var unwatched: Symbol;
    }

    interface SignalOptions&lt;T&gt; {
        // دالة مقارنة مخصصة بين القيمة القديمة والجديدة. الافتراضي: Object.is.
        // يتم تمرير الإشارة كقيمة this للسياق.
        equals?: (this: Signal&lt;T&gt;, t: T, t2: T) =&gt; boolean;
</code></pre>
<pre><code class="language-ts">// دالة الاستدعاء تُستدعى عندما تصبح isWatched تساوي true، إذا كانت سابقًا false
[Signal.subtle.watched]?: (this: Signal&lt;T&gt;) =&gt; void;

// دالة الاستدعاء تُستدعى كلما أصبحت isWatched تساوي false، إذا كانت سابقًا true
[Signal.subtle.unwatched]?: (this: Signal&lt;T&gt;) =&gt; void;
}
}
</code></pre>
<h3>كيف تعمل الإشارات (Signals)</h3>
<p>تمثل الإشارة (Signal) خلية بيانات قد تتغير بمرور الوقت. قد تكون الإشارات إما &quot;حالة&quot; (مجرد قيمة يتم تعيينها يدويًا) أو &quot;محسوبة&quot; (معادلة تستند إلى إشارات أخرى).</p>
<p>تعمل الإشارات المحسوبة من خلال تتبع تلقائي للإشارات الأخرى التي تتم قراءتها أثناء التقييم. عند قراءة إشارة محسوبة، تتحقق مما إذا كان أي من التبعيات المسجلة سابقًا قد تغير، وتعيد تقييم نفسها إذا كان الأمر كذلك. عند تداخل إشارات محسوبة متعددة، فإن كل إسناد التتبع يذهب إلى الأعمق بينها.</p>
<p>الإشارات المحسوبة تعمل بشكل كسول (أي تعتمد على السحب): لا يتم إعادة تقييمها إلا عندما يتم الوصول إليها، حتى إذا كانت إحدى تبعياتها قد تغيرت مسبقًا.</p>
<p>ينبغي أن تكون دالة الاستدعاء الممررة إلى الإشارات المحسوبة &quot;نقية&quot; عمومًا، بمعنى أنها دالة حتمية وخالية من التأثيرات الجانبية بالنسبة للإشارات الأخرى التي تصل إليها. في الوقت ذاته، فإن توقيت استدعاء الدالة حتمي، مما يسمح باستخدام التأثيرات الجانبية بحذر.</p>
<p>تتميز الإشارات بوجود ذاكرة تخزين مؤقت/تذكير بارز: كل من الإشارات الحالة والمحسوبة تتذكر قيمتها الحالية، ولا تؤدي إلى إعادة حساب الإشارات المحسوبة التي تشير إليها إلا إذا تغيرت فعليًا. ولا يلزم حتى إجراء مقارنة متكررة بين القيم القديمة والجديدة -- تتم المقارنة مرة واحدة عند إعادة تعيين/تقييم مصدر الإشارة، وآلية الإشارة تتعقب أي العناصر التي تشير إلى تلك الإشارة لم يتم تحديثها بناءً على القيمة الجديدة بعد. داخليًا، يتم تمثيل ذلك عمومًا من خلال &quot;تلوين الرسم البياني&quot; كما هو موضح في (منشور مدونة ميلو).</p>
<p>تتبع الإشارات المحسوبة تبعياتها بشكل ديناميكي -- في كل مرة يتم تشغيلها، قد تعتمد على أشياء مختلفة، ويتم الحفاظ على مجموعة التبعيات الدقيقة هذه محدثة في رسم إشارة البيانات. هذا يعني أنه إذا كان لديك تبعية مطلوبة في أحد الفروع فقط، وكان التقييم السابق قد اتخذ الفرع الآخر، فإن التغيير في تلك القيمة غير المستخدمة مؤقتًا لن يتسبب في إعادة حساب الإشارة المحسوبة، حتى عند سحبها.</p>
<p>على عكس وعود الجافاسكريبت (Promises)، كل شيء في الإشارات يعمل بشكل متزامن:</p>
<ul>
<li>تعيين إشارة إلى قيمة جديدة يتم بشكل متزامن، وهذا ينعكس على الفور عند قراءة أي إشارة محسوبة تعتمد عليها لاحقًا. لا يوجد تجميع مدمج لهذا التغيير.</li>
<li>قراءة الإشارات المحسوبة متزامنة -- قيمتها متاحة دائمًا.</li>
<li>دالة الاستدعاء <code>notify</code> في المراقبين (Watchers)، كما هو موضح أدناه، تعمل بشكل متزامن أثناء استدعاء <code>.set()</code> الذي قام بتحفيزها (لكن بعد اكتمال تلوين الرسم البياني).</li>
</ul>
<p>مثل الوعود (Promises)، يمكن للإشارات أن تمثل حالة خطأ: إذا قامت دالة الاستدعاء لإشارة محسوبة برمي خطأ، فإنه يتم تخزين هذا الخطأ مؤقتًا مثل أي قيمة أخرى، ويعاد رميه في كل مرة تتم فيها قراءة الإشارة.</p>
<h3>فهم فئة Signal</h3>
<p>يمثل كائن <code>Signal</code> القدرة على قراءة قيمة تتغير ديناميكيًا وتتم متابعة تحديثاتها مع مرور الوقت. كما يتضمن ضمنيًا القدرة على الاشتراك في الإشارة، بشكل ضمني من خلال وصول متتبع من إشارة محسوبة أخرى.</p>
<p>تم تصميم واجهة البرمجة هذه لتتوافق مع التوافق التقريبي الكبير بين مكتبات الإشارات في النظام البيئي من حيث استخدام أسماء مثل &quot;signal&quot; و&quot;computed&quot; و&quot;state&quot;. ومع ذلك، يتم الوصول إلى الإشارات المحسوبة والحالة عبر دالة <code>.get()</code>، وهذا يخالف جميع واجهات برمجة تطبيقات الإشارات الشائعة، التي تستخدم إما وسيط وصول على شكل <code>.value</code>، أو استدعاء على شكل <code>signal()</code>.</p>
<p>تم تصميم الواجهة لتقليل عدد التخصيصات، لجعل الإشارات مناسبة للدمج في أطر عمل جافاسكريبت مع تحقيق نفس أو أداء أفضل من إشارات الأطر الحالية. هذا يعني:</p>
<ul>
<li>إشارات الحالة عبارة عن كائن قابل للكتابة مرة واحدة، يمكن الوصول إليه وتعيينه من نفس المرجع. (انظر الآثار أدناه في قسم &quot;فصل القدرات&quot;.)</li>
<li>كل من إشارات الحالة والمحسوبة مصممة لتكون قابلة للتوريث، لتسهيل قدرة الأطر على إضافة خصائص إضافية من خلال الحقول العامة والخاصة (وكذلك طرق استخدام تلك الحالة).</li>
<li>يتم استدعاء العديد من دوال الاستدعاء (مثل <code>equals</code>، ودالة الإشارة المحسوبة) مع إشارة السياق المناسبة كـ <code>this</code>، بحيث لا يلزم إغلاق جديد لكل إشارة. بدلاً من ذلك، يمكن حفظ السياق في خصائص إضافية للإشارة نفسها.</li>
</ul>
<p>بعض شروط الأخطاء التي تفرضها هذه الواجهة:</p>
<ul>
<li>من الخطأ قراءة إشارة محسوبة بشكل متكرر (recursively).</li>
<li>لا يمكن لدالة الاستدعاء <code>notify</code> في المراقب قراءة أو كتابة أي إشارات</li>
<li>إذا قامت دالة الاستدعاء لإشارة محسوبة برمي خطأ، فإن الوصولات اللاحقة إلى الإشارة تعيد رمي ذلك الخطأ المخزن، حتى تتغير إحدى التبعيات ويعاد حسابها.</li>
</ul>
<p>بعض الحالات التي <em>لا</em> تفرض:</p>
<ul>
<li>يمكن للإشارات المحسوبة الكتابة إلى إشارات أخرى، بشكل متزامن داخل دالة الاستدعاء الخاصة بها</li>
<li>يمكن للعمل المجدول بواسطة دالة الاستدعاء <code>notify</code> في المراقب قراءة أو كتابة إشارات، مما يجعل من الممكن تكرار <a href="https://react.dev/learn/you-might-not-need-an-effect">أنماط React الكلاسيكية غير الموصى بها</a> من حيث الإشارات!</li>
</ul>
<h3>تنفيذ التأثيرات (Effects)</h3>
<p>تعطي واجهة <code>Watcher</code> المعرفة أعلاه الأساس لتنفيذ واجهات برمجة تطبيقات جافاسكريبت النموذجية للتأثيرات: دوال الاستدعاء التي يعاد تشغيلها عند تغير إشارات أخرى، وذلك فقط لأثرها الجانبي. يمكن تعريف دالة <code>effect</code> المستخدمة أعلاه في المثال الأولي كما يلي:</p>
<pre><code class="language-ts">// عادة ما تعيش هذه الدالة في مكتبة/إطار عمل وليس في كود التطبيق
// ملاحظة: منطق الجدولة هذا بسيط جدًا ليكون مفيدًا. لا تنسخه أو تلصقه.
let pending = false;

let w = new Signal.subtle.Watcher(() =&gt; {
    if (!pending) {
        pending = true;
        queueMicrotask(() =&gt; {
            pending = false;
            for (let s of w.getPending()) s.get();
            w.watch();
        });
    }
});

// إشارة تأثير (effect) يتم تقييمها إلى cb، وتجدول قراءة نفسها في قائمة مهام microtask
// كلما تغيرت إحدى تبعياتها المحتملة
export function effect(cb) {
    let destructor;
    let c = new Signal.Computed(() =&gt; { destructor?.(); destructor = cb(); });
    w.watch(c);
    c.get();
    return () =&gt; { destructor?.(); w.unwatch(c) };
}
</code></pre>
<p>لا تتضمن واجهة برمجة الإشارات أي دالة مضمنة مثل <code>effect</code>. ذلك لأن جدولة التأثيرات أمر دقيق وغالبًا ما يرتبط بدورات العرض في الأطر وغيرها من الحالات أو الاستراتيجيات الخاصة بمستوى الأطر العليا التي لا يمكن لجافاسكريبت الوصول إليها.</p>
<p>عند استعراض العمليات المختلفة المستخدمة هنا: دالة الاستدعاء <code>notify</code> الممررة إلى منشئ <code>Watcher</code> هي الدالة التي تُستدعى عندما تنتقل الإشارة من حالة &quot;نظيفة&quot; (حيث نعلم أن ذاكرة التخزين المؤقت مهيأة وصحيحة) إلى حالة &quot;مفحوصة&quot; أو &quot;قذرة&quot; (حيث قد تكون ذاكرة التخزين المؤقت صحيحة أو لا، لأن واحدة على الأقل من الحالات التي تعتمد عليها تغيرت).</p>
<p>تتم في النهاية عمليات استدعاء <code>notify</code> بواسطة استدعاء <code>.set()</code> على إحدى إشارات الحالة. هذا الاستدعاء متزامن: يحدث قبل أن تعيد دالة <code>.set</code> النتيجة. لكن لا داعي للقلق من أن تلاحظ دالة الاستدعاء هذه رسم الإشارة في حالة معالجة جزئية، لأنه أثناء دالة الاستدعاء <code>notify</code>، لا يمكن قراءة أو كتابة أي إشارة، حتى في استدعاء <code>untrack</code>. نظرًا لأن <code>notify</code> تُستدعى أثناء <code>.set()</code>، فهي تقاطع خيطًا آخر من المنطق، قد لا يكون مكتملًا. لقراءة أو كتابة إشارات من <code>notify</code>، قم بجدولة العمل ليعمل لاحقًا، مثل كتابة الإشارة في قائمة ليتم الوصول إليها لاحقًا، أو باستخدام <code>queueMicrotask</code> كما في الأعلى.</p>
<p>لاحظ أنه من الممكن تمامًا استخدام الإشارات بفعالية دون <code>Signal.subtle.Watcher</code> من خلال جدولة الاستطلاع (polling) للإشارات المحسوبة، كما يفعل Glimmer. مع ذلك، وجدت العديد من الأطر أنه غالبًا ما يكون من المفيد أن يعمل منطق الجدولة هذا بشكل متزامن، ولهذا السبب تم تضمينه في واجهة برمجة الإشارات.</p>
<p>كل من الإشارات المحسوبة والحالة يتم جمعها (garbage-collected) مثل أي قيمة جافاسكريبت. لكن المراقبين (Watchers) لديهم طريقة خاصة للحفاظ على الأشياء حية: أي إشارات تتم مراقبتها بواسطة مراقب ستظل حية طالما أن أيًا من الحالات الأساسية قابلة للوصول، حيث يمكن أن تؤدي هذه إلى استدعاء <code>notify</code> في المستقبل (ثم استدعاء <code>.get()</code> في المستقبل). لهذا السبب، تذكر أن تستدعي <code>Watcher.prototype.unwatch</code> لتنظيف التأثيرات.</p>
<h3>مخرج غير سليم (Escape Hatch) غير آمن</h3>
<p><code>Signal.subtle.untrack</code> هو مخرج يسمح بقراءة الإشارات <em>دون</em> تتبع تلك القراءات. هذه الإمكانية غير آمنة لأنها تسمح بإنشاء إشارات محسوبة تعتمد قيمتها على إشارات أخرى، ولكنها لا تتحدث عند تغير تلك الإشارات. يجب استخدامها عندما لا تؤثر القراءات غير المتتبعة على نتيجة الحساب.</p>
<!--
TODO: عرض مثال حيث من المناسب استخدام untrack

### استخدام watched/unwatched
TODO: عرض مثال لتحويل كائن Observable إلى إشارة محسوبة، يتم الاشتراك بها فقط عند استخدامها من قبل تأثير

TODO: عرض مثال لإشارة محسوبة تمثل نتيجة عملية جلب fetch موجهة إلى حالة، يتم إلغاؤها

### الاستبطان لخوادم SSR

TODO: عرض كيفية عمل تسلسل رسم الإشارة (signal graph)

TODO: عرض كيفية "إحياء" إشارة من حالة إلى محسوبة لاحقًا، باستخدام بعض الإشارات.
-->
<h3>تم الاستبعاد حاليًا</h3>
<p>قد تتم إضافة هذه الميزات لاحقًا، لكنها غير مدرجة في المسودة الحالية. سبب الاستبعاد هو عدم وجود إجماع راسخ في مساحة التصميم بين الأطر البرمجية، بالإضافة إلى القدرة المثبتة على إيجاد حلول بديلة لغيابها باستخدام آليات مبنية فوق مفهوم الإشارات (Signals) الموضح في هذا المستند. ومع ذلك، للأسف، فإن هذا الاستبعاد يحد من إمكانيات التوافق البيني بين الأطر. مع إنتاج نماذج أولية للإشارات كما هو موضح في هذا المستند، ستكون هناك محاولة لإعادة تقييم ما إذا كان هذا الاستبعاد هو القرار المناسب.</p>
<ul>
<li><strong>غير المتزامن (Async)</strong>: الإشارات متوفرة دائمًا بشكل متزامن للتقييم في هذا النموذج. ومع ذلك، غالبًا ما يكون من المفيد وجود عمليات غير متزامنة معينة تؤدي إلى تعيين قيمة لإشارة ما، وفهم متى تكون الإشارة لا تزال &quot;قيد التحميل&quot;. إحدى الطرق البسيطة لنمذجة حالة التحميل هي باستخدام الاستثناءات، ويكوّن سلوك التخزين المؤقت للاستثناءات في الإشارات المحسوبة مع هذه التقنية بشكل معقول إلى حد ما. تم مناقشة تقنيات محسنة في <a href="https://github.com/proposal-signals/proposal-signals/issues/30">Issue #30</a>.</li>
<li><strong>المعاملات (Transactions)</strong>: من المفيد غالبًا أثناء الانتقال بين العروض الاحتفاظ بحالة نشطة لكل من حالتي &quot;من&quot; و&quot;إلى&quot;. يتم عرض الحالة &quot;إلى&quot; في الخلفية حتى تصبح جاهزة للتبديل (الالتزام بالمعاملة)، بينما تبقى الحالة &quot;من&quot; تفاعلية. يتطلب الحفاظ على كلتا الحالتين في نفس الوقت &quot;تفريع&quot; حالة رسم الإشارات، وقد يكون من المفيد حتى دعم عدة انتقالات معلقة في وقت واحد. مناقشة في <a href="https://github.com/proposal-signals/proposal-signals/issues/73">Issue #73</a>.</li>
</ul>
<p>تم أيضًا استبعاد بعض <a href="https://github.com/proposal-signals/proposal-signals/issues/32">طرق الراحة</a> المحتملة.</p>
<h2>الحالة وخطة التطوير</h2>
<p>هذا الاقتراح مدرج في جدول أعمال TC39 لشهر أبريل 2024 للمرحلة 1. ويمكن اعتباره حاليًا في &quot;المرحلة 0&quot;.</p>
<p><a href="https://github.com/proposal-signals/signal-polyfill">هناك polyfill</a> متاح لهذا الاقتراح، مع بعض الاختبارات الأساسية. بدأ بعض مؤلفي الأطر البرمجية بالفعل في تجربة استبدال هذه الإشارة في تطبيقاتهم، لكن هذا الاستخدام لا يزال في مرحلة مبكرة.</p>
<p>يرغب المتعاونون على اقتراح الإشارة في أن يكونوا <strong>محافظين</strong> للغاية في كيفية دفع هذا الاقتراح للأمام، حتى لا نقع في فخ شحن شيء نندم عليه في النهاية ولا نستخدمه فعليًا. خطتنا هي القيام بالمهام الإضافية التالية، غير المطلوبة من قبل عملية TC39، للتأكد من أن هذا الاقتراح على المسار الصحيح:</p>
<p>قبل التقدم للمرحلة 2، نخطط إلى:</p>
<ul>
<li>تطوير عدة تطبيقات polyfill بمستوى إنتاجي قوية، ومختبرة جيدًا (مثلاً، اجتياز اختبارات من أطر مختلفة بالإضافة إلى اختبارات بأسلوب test262)، وتنافسية من حيث الأداء (كما يتم التحقق من ذلك من خلال مجموعة اختبارات شاملة للإشارات/الأطر).</li>
<li>دمج واجهة برمجة تطبيقات الإشارة المقترحة في عدد كبير من أطر عمل JavaScript التي نعتبرها تمثيلية إلى حد ما، وأن تعمل بعض التطبيقات الكبيرة على هذا الأساس. اختبار أنها تعمل بكفاءة وبشكل صحيح في هذه السياقات.</li>
<li>الحصول على فهم راسخ لمجال الامتدادات الممكنة لواجهة برمجة التطبيقات، والتوصل إلى أي منها (إن وجدت) يجب إضافته إلى هذا الاقتراح.</li>
</ul>
<h2>خوارزميات الإشارة</h2>
<p>يصف هذا القسم كل واجهة برمجة التطبيقات التي يتم كشفها لجافاسكريبت، من حيث الخوارزميات التي تنفذها. يمكن اعتبار ذلك بمثابة مواصفات أولية، وتم تضمينها في هذه المرحلة المبكرة لتثبيت مجموعة ممكنة من الدلالات، مع الانفتاح التام على التغييرات.</p>
<p>بعض جوانب الخوارزمية:</p>
<ul>
<li>ترتيب قراءات الإشارات داخل المحسوبة مهم، ويمكن ملاحظته في ترتيب تنفيذ بعض callbacks (مثل استدعاء <code>Watcher</code>، و<code>equals</code>، والمعامل الأول لـ <code>new Signal.Computed</code>، وCallbacks <code>watched</code>/<code>unwatched</code>). هذا يعني أن مصادر إشارة محسوبة يجب أن يتم تخزينها بترتيب.</li>
<li>هذه callbacks الأربعة قد ترمي جميعها استثناءات، وتنتقل هذه الاستثناءات بطريقة متوقعة إلى كود جافاسكريبت المنادي. الاستثناءات <em>لا</em> توقف تنفيذ هذه الخوارزمية أو تترك الرسم البياني في حالة نصف معالجة. بالنسبة للأخطاء التي تحدث في استدعاء notify الخاص بـ Watcher، يتم إرسال هذا الاستثناء إلى استدعاء <code>.set()</code> الذي تسبب به، باستخدام AggregateError إذا تم رمي عدة استثناءات. أما البقية (بما في ذلك <code>watched</code>/<code>unwatched</code>؟) فيتم تخزينها في قيمة الإشارة، ليتم رميها مرة أخرى عند القراءة، ويمكن تمييز مثل هذه الإشارة التي تم إعادة رميها كـ <code>~clean~</code> مثل أي إشارة أخرى بقيمة عادية.</li>
<li>يتم اتخاذ الحيطة لتجنب الدوائر المغلقة في حالات الإشارات المحسوبة التي لا تتم &quot;مشاهدتها&quot; (أي غير مراقبة من قبل أي Watcher)، بحيث يمكن جمعها تلقائيًا بشكل مستقل عن أجزاء أخرى من رسم الإشارات. داخليًا، يمكن تنفيذ ذلك باستخدام نظام أرقام أجيال يتم جمعها دائمًا؛ لاحظ أن التطبيقات المحسنة قد تتضمن أيضًا أرقام أجيال محلية لكل عقدة، أو تتجنب تتبع بعض الأرقام على الإشارات المشاهدة.</li>
</ul>
<h3>الحالة العالمية المخفية</h3>
<p>تحتاج خوارزميات الإشارة إلى الإشارة إلى حالة عالمية معينة. هذه الحالة عالمية لكامل الخيط thread، أو &quot;الوكيل agent&quot;.</p>
<ul>
<li><code>computing</code>: أعمق إشارة محسوبة أو تأثير يتم إعادة تقييمها حاليًا بسبب استدعاء <code>.get</code> أو <code>.run</code>، أو <code>null</code>. في البداية تكون <code>null</code>.</li>
<li><code>frozen</code>: قيمة منطقية تدل على ما إذا كان هناك Callback يتم تنفيذه حاليًا يتطلب عدم تعديل الرسم البياني. في البداية <code>false</code>.</li>
<li><code>generation</code>: عدد صحيح متزايد، يبدأ من 0، يُستخدم لتعقب مدى حداثة القيمة أثناء تجنب الدوائر المغلقة.</li>
</ul>
<h3>فضاء الاسم <code>Signal</code></h3>
<p><code>Signal</code> هو كائن عادي يعمل كفضاء اسم للفئات والدوال المتعلقة بالإشارة.</p>
<p><code>Signal.subtle</code> هو كائن مماثل كفضاء اسم داخلي.</p>
<h3>فئة <code>Signal.State</code></h3>
<h4>الخانات الداخلية لـ <code>Signal.State</code></h4>
<ul>
<li><code>value</code>: القيمة الحالية لإشارة الحالة</li>
<li><code>equals</code>: دالة المقارنة المستخدمة عند تغيير القيم</li>
<li><code>watched</code>: Callback يتم استدعاؤه عند مراقبة الإشارة من قبل تأثير</li>
<li><code>unwatched</code>: Callback يتم استدعاؤه عند توقف الإشارة عن أن تكون مراقبة من قبل تأثير</li>
<li><code>sinks</code>: مجموعة من الإشارات المشاهدة التي تعتمد على هذه الإشارة</li>
</ul>
<h4>الباني: <code>Signal.State(initialValue, options)</code></h4>
<ol>
<li>عيّن قيمة <code>value</code> لهذه الإشارة إلى <code>initialValue</code>.</li>
<li>عيّن قيمة <code>equals</code> إلى options?.equals</li>
<li>عيّن قيمة <code>watched</code> إلى options?.[Signal.subtle.watched]</li>
<li>عيّن قيمة <code>unwatched</code> إلى options?.[Signal.subtle.unwatched]</li>
<li>عيّن قيمة <code>sinks</code> إلى مجموعة فارغة</li>
</ol>
<h4>طريقة: <code>Signal.State.prototype.get()</code></h4>
<ol>
<li>إذا كانت <code>frozen</code> تساوي true، ارمي استثناءً.</li>
<li>إذا كانت <code>computing</code> ليست <code>undefined</code>، أضف هذه الإشارة إلى مجموعة <code>sources</code> الخاصة بـ <code>computing</code>.</li>
<li>ملاحظة: لا نضيف <code>computing</code> إلى مجموعة <code>sinks</code> لهذه الإشارة حتى تتم مراقبتها من قبل Watcher.</li>
<li>أرجع قيمة <code>value</code> لهذه الإشارة.</li>
</ol>
<h4>طريقة: <code>Signal.State.prototype.set(newValue)</code></h4>
<ol>
<li>إذا كان سياق التنفيذ الحالي هو <code>frozen</code>، ارمي استثناءً.</li>
<li>نفذ خوارزمية &quot;تعيين قيمة الإشارة&quot; مع هذه الإشارة والمعامل الأول للقيمة.</li>
<li>إذا أعادت تلك الخوارزمية <code>~clean~</code>، أرجع undefined.</li>
<li>عيّن حالة جميع <code>sinks</code> لهذه الإشارة إلى (إذا كانت إشارة محسوبة) <code>~dirty~</code> إذا كانت نظيفة سابقًا، أو (إذا كانت Watcher) <code>~pending~</code> إذا كانت سابقًا <code>~watching~</code>.</li>
<li>عيّن حالة جميع تبعيات الإشارات المحسوبة لـ sinks (بشكل متكرر) إلى <code>~checked~</code> إذا كانت نظيفة سابقًا (أي، اترك العلامات المتسخة كما هي)، أو بالنسبة لـ Watchers، <code>~pending~</code> إذا كانت سابقًا <code>~watching~</code>.</li>
<li>لكل Watcher كان سابقًا في حالة <code>~watching~</code> تم العثور عليه في ذلك البحث المتكرر، ثم بترتيب العمق أولاً (depth-first):
<ol>
<li>عيّن <code>frozen</code> إلى true.</li>
<li>استدعِ Callback <code>notify</code> الخاص بهم (مع حفظ أي استثناء تم رميه، ولكن تجاهل القيمة المرجعة لـ <code>notify</code>).</li>
<li>أعد <code>frozen</code> إلى false.</li>
<li>عيّن حالة الـ Watcher إلى <code>~waiting~</code>.</li>
</ol>
</li>
<li>إذا تم رمي أي استثناء من Callbacks <code>notify</code>، مرره إلى المنادي بعد تنفيذ جميع Callbacks <code>notify</code>. إذا كان هناك عدة استثناءات، اجمعها في AggregateError وارمه.</li>
<li>أرجع undefined.</li>
</ol>
<h3>فئة <code>Signal.Computed</code></h3>
<h4>آلة الحالة لـ <code>Signal.Computed</code></h4>
<p>قد تكون حالة الـ <code>state</code> لإشارة محسوبة (Computed Signal) واحدة من الحالات التالية:</p>
<ul>
<li><code>~clean~</code>: قيمة الإشارة موجودة ومعروفة بأنها غير قديمة (غير باطلة).</li>
<li><code>~checked~</code>: أحد المصادر (غير المباشرة) لهذه الإشارة قد تغيّر؛ هذه الإشارة لديها قيمة ولكن <em>قد</em> تكون قديمة. سيتم معرفة ما إذا كانت قديمة أم لا فقط بعد تقييم جميع المصادر المباشرة.</li>
<li><code>~computing~</code>: يتم حالياً تنفيذ رد نداء (callback) هذه الإشارة كأثر جانبي لاستدعاء <code>.get()</code>.</li>
<li><code>~dirty~</code>: إما أن تكون هذه الإشارة لديها قيمة معروفة بأنها قديمة، أو أنها لم يتم تقييمها أبداً.</li>
</ul>
<p>مخطط الانتقال كما يلي:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; dirty
    dirty --&gt; computing: [4]
    computing --&gt; clean: [5]
    clean --&gt; dirty: [2]
    clean --&gt; checked: [3]
    checked --&gt; clean: [6]
    checked --&gt; dirty: [1]
</code></pre>
<p>الانتقالات هي:
| الرقم | من | إلى | الشرط | الخوارزمية |
| ----- | --- | -- | ------ | ----------- |
| 1 | <code>~checked~</code> | <code>~dirty~</code> | تم تقييم مصدر مباشر لهذه الإشارة، وهو إشارة محسوبة، وتغيّرت قيمته. | الخوارزمية: إعادة حساب الإشارة المحسوبة القديمة |
| 2 | <code>~clean~</code> | <code>~dirty~</code> | تم تعيين مصدر مباشر لهذه الإشارة، وهو حالة (State)، بقيمة لا تساوي القيمة السابقة. | الطريقة: <code>Signal.State.prototype.set(newValue)</code> |
| 3 | <code>~clean~</code> | <code>~checked~</code> | تم تعيين مصدر متكرر (وليس مباشر) لهذه الإشارة، وهو حالة (State)، بقيمة لا تساوي القيمة السابقة. | الطريقة: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~dirty~</code> | <code>~computing~</code> | على وشك تنفيذ الـ <code>callback</code>. | الخوارزمية: إعادة حساب الإشارة المحسوبة القديمة |
| 5 | <code>~computing~</code> | <code>~clean~</code> | انتهى تقييم الـ <code>callback</code> وأعاد قيمة أو رمى استثناء. | الخوارزمية: إعادة حساب الإشارة المحسوبة القديمة |
| 6 | <code>~checked~</code> | <code>~clean~</code> | تم تقييم جميع المصادر المباشرة لهذه الإشارة، ولم تتغير أي منها، وبالتالي نعلم الآن أنها ليست قديمة. | الخوارزمية: إعادة حساب الإشارة المحسوبة القديمة |</p>
<h4>الخانات الداخلية لـ <code>Signal.Computed</code></h4>
<ul>
<li><code>value</code>: القيمة المخبأة السابقة للإشارة، أو <code>~uninitialized~</code> لإشارة محسوبة لم يتم قراءتها أبداً. قد تكون القيمة استثناءً يتم إعادة رميه عند قراءة القيمة. دائماً <code>undefined</code> لإشارات التأثير (effect signals).</li>
<li><code>state</code>: قد تكون <code>~clean~</code> أو <code>~checked~</code> أو <code>~computing~</code> أو <code>~dirty~</code>.</li>
<li><code>sources</code>: مجموعة مرتبة من الإشارات التي تعتمد عليها هذه الإشارة.</li>
<li><code>sinks</code>: مجموعة مرتبة من الإشارات التي تعتمد على هذه الإشارة.</li>
<li><code>equals</code>: طريقة المقارنة المقدمة في الخيارات.</li>
<li><code>callback</code>: رد النداء الذي يتم استدعاؤه لجلب قيمة الإشارة المحسوبة. يتم تعيينه إلى أول وسيط يُمرر إلى الباني.</li>
</ul>
<h4>باني <code>Signal.Computed</code></h4>
<p>يقوم الباني بتعيين</p>
<ul>
<li><code>callback</code> إلى أول وسيط يُمرر له</li>
<li><code>equals</code> بناءً على الخيارات، الافتراضي هو <code>Object.is</code> إذا لم يوجد</li>
<li><code>state</code> إلى <code>~dirty~</code></li>
<li><code>value</code> إلى <code>~uninitialized~</code></li>
</ul>
<p>مع <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a>، يقوم رد النداء الممرر إلى <code>new Signal.Computed</code> بالاحتفاظ بلقطة من السياق عند استدعاء الباني، ويعيد هذه اللقطة أثناء التنفيذ.</p>
<h4>الطريقة: <code>Signal.Computed.prototype.get</code></h4>
<ol>
<li>إذا كان سياق التنفيذ الحالي <code>frozen</code> أو إذا كانت حالة هذه الإشارة هي <code>~computing~</code>، أو إذا كانت هذه الإشارة Watcher و<code>computing</code> لإشارة محسوبة، قم برمي استثناء.</li>
<li>إذا لم يكن <code>computing</code> يساوي <code>null</code>، أضف هذه الإشارة إلى مجموعة <code>sources</code> الخاصة بـ <code>computing</code>.</li>
<li>ملاحظة: لا نضيف <code>computing</code> إلى مجموعة <code>sinks</code> لهذه الإشارة حتى/إلا إذا تمت مراقبتها من قبل Watcher.</li>
<li>إذا كانت حالة هذه الإشارة <code>~dirty~</code> أو <code>~checked~</code>: كرر الخطوات التالية حتى تصبح حالة هذه الإشارة <code>~clean~</code>:
<ol>
<li>تتبع للأعلى عبر <code>sources</code> للعثور على أعمق مصدر متكرر (الأيسر، أي تم ملاحظته أولاً) وهو إشارة محسوبة موسومة بـ <code>~dirty~</code> (توقف البحث عند الوصول إلى إشارة محسوبة <code>~clean~</code>، وضم هذه الإشارة المحسوبة كآخر شيء يتم البحث عنه).</li>
<li>نفذ خوارزمية &quot;إعادة حساب الإشارة المحسوبة القديمة&quot; على تلك الإشارة.</li>
</ol>
</li>
<li>في هذه المرحلة، ستكون حالة هذه الإشارة <code>~clean~</code>، ولن تكون هناك مصادر متكررة حالتها <code>~dirty~</code> أو <code>~checked~</code>. أعد قيمة الإشارة. إذا كانت القيمة استثناءً، قم بإعادة رمي ذلك الاستثناء.</li>
</ol>
<h3>صنف <code>Signal.subtle.Watcher</code></h3>
<h4>آلة الحالات لـ <code>Signal.subtle.Watcher</code></h4>
<p>قد تكون حالة Watcher واحدة من الحالات التالية:</p>
<ul>
<li><code>~waiting~</code>: تم تنفيذ رد النداء <code>notify</code>، أو أن الـ Watcher جديد، لكنه لا يراقب أي إشارات نشطة.</li>
<li><code>~watching~</code>: الـ Watcher يراقب إشارات بنشاط، ولم يحدث أي تغيير بعد يستلزم رد النداء <code>notify</code>.</li>
<li><code>~pending~</code>: أحد اعتماديات الـ Watcher قد تغيّر، ولكن لم يتم تنفيذ رد النداء <code>notify</code> بعد.</li>
</ul>
<p>مخطط الانتقال كما يلي:</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; waiting
    waiting --&gt; watching: [1]
    watching --&gt; waiting: [2]
    watching --&gt; pending: [3]
    pending --&gt; waiting: [4]
</code></pre>
<p>الانتقالات هي:
| الرقم | من | إلى | الشرط | الخوارزمية |
| ----- | --- | -- | ------ | ----------- |
| 1 | <code>~waiting~</code> | <code>~watching~</code> | تم استدعاء طريقة <code>watch</code> الخاصة بالـ Watcher. | الطريقة: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code> |
| 2 | <code>~watching~</code> | <code>~waiting~</code> | تم استدعاء طريقة <code>unwatch</code> الخاصة بالـ Watcher، وتمت إزالة آخر إشارة مراقبة. | الطريقة: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code> |
| 3 | <code>~watching~</code> | <code>~pending~</code> | قد تكون إحدى الإشارات المراقبة قد تغيّرت قيمتها. | الطريقة: <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~pending~</code> | <code>~waiting~</code> | تم تنفيذ رد النداء <code>notify</code>. | الطريقة: <code>Signal.State.prototype.set(newValue)</code> |</p>
<h4>الخانات الداخلية لـ <code>Signal.subtle.Watcher</code></h4>
<ul>
<li><code>state</code>: قد تكون <code>~watching~</code> أو <code>~pending~</code> أو <code>~waiting~</code></li>
<li><code>signals</code>: مجموعة مرتبة من الإشارات التي يراقبها هذا الـ Watcher</li>
<li><code>notifyCallback</code>: رد النداء الذي يتم استدعاؤه عند حدوث تغيير ما. يُعين إلى أول وسيط يُمرر إلى الباني.</li>
</ul>
<h4>الباني: <code>new Signal.subtle.Watcher(callback)</code></h4>
<ol>
<li>يتم تعيين <code>state</code> إلى <code>~waiting~</code>.</li>
<li>تهيئة <code>signals</code> كمجموعة فارغة.</li>
<li>يتم تعيين <code>notifyCallback</code> إلى معامل الـ callback.
مع <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a>، فإن الاستدعاء العكسي (callback) الذي يُمرر إلى <code>new Signal.subtle.Watcher</code> لا يغلق (close over) على اللقطة (snapshot) من وقت استدعاء المُنشئ، بحيث تكون المعلومات السياقية حول الكتابة مرئية.</li>
</ol>
<h4>الطريقة: <code>Signal.subtle.Watcher.prototype.watch(...signals)</code></h4>
<ol>
<li>إذا كانت قيمة <code>frozen</code> تساوي true، قم برمي استثناء.</li>
<li>إذا كان أي من الوسائط ليس إشارة (signal)، قم برمي استثناء.</li>
<li>أضف جميع الوسائط إلى نهاية خاصية <code>signals</code> لهذا الكائن.</li>
<li>لكل إشارة تتم مراقبتها حديثًا، من اليسار إلى اليمين،
<ol>
<li>أضف هذا المراقب (watcher) كـ <code>sink</code> لتلك الإشارة.</li>
<li>إذا كان هذا هو الـ sink الأول، عندها قم بالتكرار تصاعديًا إلى المصادر لإضافة تلك الإشارة كـ sink.</li>
<li>اضبط <code>frozen</code> إلى true.</li>
<li>استدعِ الاستدعاء العكسي <code>watched</code> إذا كان موجودًا.</li>
<li>أعد قيمة <code>frozen</code> إلى false.</li>
</ol>
</li>
<li>إذا كانت حالة الإشارة (Signal) هي <code>~waiting~</code>، قم بتغييرها إلى <code>~watching~</code>.</li>
</ol>
<h4>الطريقة: <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code></h4>
<ol>
<li>إذا كانت قيمة <code>frozen</code> تساوي true، قم برمي استثناء.</li>
<li>إذا كان أي من الوسائط ليس إشارة، أو لا تتم مراقبته بواسطة هذا المراقب، قم برمي استثناء.</li>
<li>لكل إشارة في الوسائط، من اليسار إلى اليمين،
<ol>
<li>أزل تلك الإشارة من مجموعة <code>signals</code> لهذا المراقب.</li>
<li>أزل هذا المراقب من مجموعة <code>sink</code> لتلك الإشارة.</li>
<li>إذا أصبحت مجموعة الـ <code>sink</code> لتلك الإشارة فارغة، أزل تلك الإشارة كـ sink من كل مصادرها.</li>
<li>اضبط <code>frozen</code> إلى true.</li>
<li>استدعِ الاستدعاء العكسي <code>unwatched</code> إذا كان موجودًا.</li>
<li>أعد قيمة <code>frozen</code> إلى false.</li>
</ol>
</li>
<li>إذا لم يكن لدى المراقب الآن أي <code>signals</code>، وكانت حالته <code>~watching~</code>، فغيّرها إلى <code>~waiting~</code>.</li>
</ol>
<h4>الطريقة: <code>Signal.subtle.Watcher.prototype.getPending()</code></h4>
<ol>
<li>أعد مصفوفة تحتوي على مجموعة فرعية من <code>signals</code> والتي هي إشارات محسوبة (Computed Signals) في حالتي <code>~dirty~</code> أو <code>~pending~</code>.</li>
</ol>
<h3>الطريقة: <code>Signal.subtle.untrack(cb)</code></h3>
<ol>
<li>دع <code>c</code> تساوي حالة <code>computing</code> الحالية لسياق التنفيذ.</li>
<li>اضبط <code>computing</code> إلى null.</li>
<li>استدعِ <code>cb</code>.</li>
<li>أعد قيمة <code>computing</code> إلى <code>c</code> (حتى لو رمى <code>cb</code> استثناءً).</li>
<li>أعد قيمة الإرجاع لـ <code>cb</code> (مع إعادة رمي أي استثناء).</li>
</ol>
<p>ملاحظة: <code>untrack</code> لا يخرجك من حالة <code>frozen</code>، والتي يتم الحفاظ عليها بدقة.</p>
<h3>الطريقة: <code>Signal.subtle.currentComputed()</code></h3>
<ol>
<li>أعد قيمة <code>computing</code> الحالية.</li>
</ol>
<h3>الخوارزميات الشائعة</h3>
<h5>خوارزمية: إعادة حساب إشارة محسوبة متسخة (dirty computed Signal)</h5>
<ol>
<li>امسح مجموعة <code>sources</code> لهذه الإشارة، وأزلها من مجموعات الـ <code>sinks</code> لتلك المصادر.</li>
<li>احفظ قيمة <code>computing</code> السابقة واضبط <code>computing</code> إلى هذه الإشارة.</li>
<li>اضبط حالة هذه الإشارة إلى <code>~computing~</code>.</li>
<li>نفذ الاستدعاء العكسي (callback) لهذه الإشارة المحسوبة، باستخدام هذه الإشارة كقيمة this. احفظ قيمة الإرجاع، وإذا رمى الاستدعاء العكسي استثناءً، خزّنه لإعادة رميه لاحقًا.</li>
<li>أعد قيمة <code>computing</code> السابقة.</li>
<li>طبق خوارزمية &quot;تعيين قيمة الإشارة&quot; على قيمة الإرجاع للاستدعاء العكسي.</li>
<li>اضبط حالة هذه الإشارة إلى <code>~clean~</code>.</li>
<li>إذا أعادت تلك الخوارزمية القيمة <code>~dirty~</code>: علّم جميع sinks لهذه الإشارة كـ <code>~dirty~</code> (ربما كانت sinks سابقًا مزيجًا من checked وdirty). (أو، إذا لم تكن هذه الإشارة مراقبة، اعتمد رقم جيل جديد للدلالة على الاتساخ، أو شيء من هذا القبيل.)</li>
<li>وإلا، إذا أعادت تلك الخوارزمية القيمة <code>~clean~</code>: في هذه الحالة، لكل sink بحالة <code>~checked~</code> لهذه الإشارة، إذا كانت كل مصادر تلك الإشارة الآن نظيفة، علّم تلك الإشارة كـ <code>~clean~</code> أيضًا. طبق هذه الخطوة التنظيفية بشكل متكرر على sinks إضافية، على أي إشارات أصبحت نظيفة حديثًا ولديها sinks بحالة checked. (أو، إذا لم تكن هذه الإشارة مراقبة، أشر إلى نفس الشيء بطريقة ما، بحيث يمكن متابعة عملية التنظيف بشكل كسول.)</li>
</ol>
<h5>خوارزمية تعيين قيمة الإشارة (Set Signal value algorithm)</h5>
<ol>
<li>إذا تم تمرير قيمة لهذه الخوارزمية (وليس استثناء لإعادة رميه، من خوارزمية إعادة حساب إشارة محسوبة متسخة):
<ol>
<li>استدعِ دالة <code>equals</code> لهذه الإشارة، مع تمرير القيم الحالية والجديدة وهذه الإشارة كوسائط. إذا تم رمي استثناء، احفظ ذلك الاستثناء (لإعادة رميه عند القراءة) كقيمة للإشارة وواصل كما لو أن الاستدعاء العكسي أعاد false.</li>
<li>إذا أعادت تلك الدالة true، أعد <code>~clean~</code>.</li>
</ol>
</li>
<li>اضبط قيمة <code>value</code> لهذه الإشارة إلى الوسيط.</li>
<li>أعد <code>~dirty~</code></li>
</ol>
<h2>الأسئلة الشائعة (FAQ)</h2>
<p><strong>س</strong>: أليس من المبكر بعض الشيء توحيد شيء متعلق بالإشارات (Signals)، وقد بدأت لتوها تصبح شيئًا رائجًا في عام 2022؟ ألا يجب أن نمنحها مزيدًا من الوقت لتتطور وتستقر؟</p>
<p><strong>ج</strong>: الحالة الحالية للإشارات في أطر عمل الويب هي نتيجة أكثر من 10 سنوات من التطوير المستمر. مع زيادة الاستثمارات، كما حدث في السنوات الأخيرة، تقترب معظم أطر العمل من نموذج أساسي متشابه جدًا للإشارات. هذا الاقتراح هو نتيجة تمرين تصميم مشترك بين عدد كبير من القادة الحاليين في أطر عمل الويب، ولن يتم دفعه إلى التوحيد القياسي بدون تحقق تلك المجموعة من خبراء المجال في سياقات متنوعة.</p>
<h4>كيف تُستخدم الإشارات؟</h4>
<p><strong>س</strong>: هل يمكن حتى للأطر (frameworks) استخدام الإشارات المدمجة (built-in Signals)، بالنظر إلى تكاملها الوثيق مع العرض (rendering) والملكية (ownership)؟</p>
<p><strong>ج</strong>: الأجزاء التي تميل لأن تكون أكثر خصوصية بالإطار تكون في مجال التأثيرات (effects)، والجدولة (scheduling)، والملكية/التخلص (ownership/disposal)، والتي لا يحاول هذا الاقتراح حلها. أولويتنا الأولى مع نمذجة إشارات معيارية هي التحقق من أنه يمكنها العمل &quot;تحت&quot; الأطر الحالية بشكل متوافق وبأداء جيد.</p>
<p><strong>س</strong>: هل من المفترض استخدام واجهة برمجة التطبيقات (API) الخاصة بالإشارة مباشرة من قبل مطوري التطبيقات، أم مغلفة من قبل الأطر؟</p>
<p><strong>ج</strong>: بينما يمكن لمطوري التطبيقات استخدام هذه الواجهة مباشرة (على الأقل الجزء الذي ليس ضمن مساحة الاسم <code>Signal.subtle</code>)، إلا أنها ليست مصممة لتكون مريحة بشكل خاص. بدلاً من ذلك، تم إعطاء الأولوية لاحتياجات مؤلفي المكتبات/الأطر. من المتوقع أن تغلف معظم الأطر حتى واجهات <code>Signal.State</code> و<code>Signal.Computed</code> الأساسية بشيء يعكس أسلوبها المريح. عمليًا، غالبًا ما يكون من الأفضل استخدام الإشارات عبر إطار، حيث يدير الميزات الأكثر تعقيدًا (مثل Watcher، <code>untrack</code>)، بالإضافة إلى إدارة الملكية والتخلص (مثل تحديد متى يجب إضافة الإشارات إلى المراقبين وإزالتها)، وجدولة العرض إلى DOM--هذا الاقتراح لا يحاول حل تلك المشاكل.</p>
<p><strong>س</strong>: هل يجب علي تفكيك الإشارات المرتبطة بعنصر واجهة المستخدم (widget) عند تدمير ذلك العنصر؟ ما هي واجهة برمجة التطبيقات لذلك؟</p>
<p><strong>ج</strong>: عملية التفكيك ذات الصلة هنا هي <code>Signal.subtle.Watcher.prototype.unwatch</code>. فقط الإشارات المراقبة تحتاج إلى تنظيف (عن طريق إلغاء مراقبتها)، بينما يمكن جمع الإشارات غير المراقبة تلقائيًا عبر الـ garbage collector.</p>
<p><strong>س</strong>: هل تعمل الإشارات مع VDOM، أم مباشرة مع DOM الـ HTML الأساسي؟</p>
<p><strong>ج</strong>: نعم! الإشارات مستقلة عن تقنية العرض. أطر جافاسكريبت الحالية التي تستخدم بنى شبيهة بالإشارات تتكامل مع VDOM (مثل Preact)، وDOM الأصلي (مثل Solid)، ومزيج بينهما (مثل Vue). سيكون نفس الشيء ممكنًا مع الإشارات المدمجة.</p>
<p><strong>س</strong>: هل سيكون من المريح استخدام الإشارات في سياق الأطر المعتمدة على الفئات (class-based) مثل Angular وLit؟ ماذا عن الأطر المعتمدة على المترجم (compiler) مثل Svelte؟</p>
<p><strong>ج</strong>: يمكن جعل حقول الفئة (class fields) معتمدة على الإشارات بسهولة باستخدام مزين accessors، كما هو موضح في <a href="https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators">دليل polyfill للإشارة</a>. الإشارات متماشية جدًا مع Runes في Svelte 5--من السهل على المترجم تحويل runes إلى واجهة Signal API المحددة هنا، وفي الواقع هذا ما يفعله Svelte 5 داخليًا (ولكن مع مكتبته الخاصة للإشارات).</p>
<p><strong>س</strong>: هل تعمل الإشارات مع SSR؟ الترطيب (Hydration)؟ الاستئناف (Resumability)؟</p>
<p><strong>ج</strong>: نعم. يستخدم Qwik الإشارات بفاعلية مع كل من هذه الخصائص، ولدى أطر أخرى طرق متطورة أخرى للترطيب باستخدام الإشارات مع مفاضلات مختلفة. نعتقد أنه من الممكن نمذجة إشارات Qwik القابلة للاستئناف باستخدام إشارة State وإشارة Computed مرتبطتين معًا، ونخطط لإثبات ذلك في الكود.
<strong>س</strong>: هل تعمل Signals مع تدفق البيانات أحادي الاتجاه كما يفعل React؟</p>
<p><strong>ج</strong>: نعم، Signals هي آلية لتدفق البيانات أحادي الاتجاه. تتيح لك أطر عمل واجهات المستخدم المعتمدة على Signals التعبير عن العرض الخاص بك كدالة للنموذج (حيث يدمج النموذج Signals). رسم بياني للحالة وSignals المحسوبة يكون غير دوري بطبيعته. من الممكن أيضًا إعادة إنشاء أنماط مضادة لـ React داخل Signals (!)؛ على سبيل المثال، ما يعادل <code>setState</code> داخل <code>useEffect</code> هو استخدام Watcher لجدولة كتابة إلى إشارة State.</p>
<p><strong>س</strong>: كيف ترتبط Signals بأنظمة إدارة الحالة مثل Redux؟ هل تشجع Signals على الحالة غير المنظمة؟</p>
<p><strong>ج</strong>: يمكن أن تشكل Signals أساسًا فعالًا لتجريدات إدارة الحالة المشابهة للمخزن (store-like). نمط شائع موجود في العديد من الأطر هو كائن يعتمد على Proxy والذي يمثل داخليًا الخصائص باستخدام Signals، مثل <a href="https://vuejs.org/api/reactivity-core.html#reactive">Vue <code>reactive()</code></a>، أو <a href="https://docs.solidjs.com/concepts/stores">Solid stores</a>. تتيح هذه الأنظمة تجميع الحالة بشكل مرن على المستوى المناسب من التجريد للتطبيق المعني.</p>
<p><strong>س</strong>: ما الذي تقدمه Signals ولا يمكن لـ <code>Proxy</code> التعامل معه حاليًا؟</p>
<p><strong>ج</strong>: Proxies و Signals يكملان بعضهما البعض ويتوافقان معًا بشكل جيد. تتيح لك Proxies اعتراض العمليات السطحية على الكائنات بينما تنسق signals رسم بياني للاعتمادية (الخلايا). دعم Proxy باستخدام Signals هو طريقة رائعة لإنشاء بنية متداخلة تفاعلية مع سهولة كبيرة في الاستخدام.</p>
<p>في هذا المثال، يمكننا استخدام proxy لجعل الإشارة تحتوي على خاصية getter وsetter بدلاً من استخدام طريقتي <code>get</code> و <code>set</code>:</p>
<pre><code class="language-js">const a = new Signal.State(0);
const b = new Proxy(a, {
  get(target, property, receiver) {
    if (property === 'value') {
      return target.get():
    }
  }
  set(target, property, value, receiver) {
    if (property === 'value') {
      target.set(value)!
    }
  }
});

// الاستخدام في سياق تفاعلي افتراضي:
&lt;template&gt;
  {b.value}

  &lt;button onclick={() =&gt; {
    b.value++;
  }}&gt;change&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>عند استخدام عارض (renderer) مُحسّن للتفاعلية الدقيقة، سيؤدي النقر على الزر إلى تحديث خلية <code>b.value</code>.</p>
<p>راجع:</p>
<ul>
<li>أمثلة على البنى التفاعلية المتداخلة التي تم إنشاؤها باستخدام Signals وProxies معًا: <a href="https://github.com/NullVoxPopuli/signal-utils/tree/main/src">signal-utils</a></li>
<li>مثال على تطبيقات سابقة توضح العلاقة بين البيانات التفاعلية وproxies: <a href="https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private">tracked-built-ins</a></li>
<li><a href="https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574">نقاش</a>.</li>
</ul>
<h4>كيف تعمل Signals؟</h4>
<p><strong>س</strong>: هل Signals تعتمد على الدفع (push) أم السحب (pull)؟</p>
<p><strong>ج</strong>: تقييم Signals المحسوبة يعتمد على السحب: يتم تقييم Signals المحسوبة فقط عندما يتم استدعاء <code>.get()</code>، حتى لو تغيرت الحالة الأساسية في وقت سابق بكثير. في نفس الوقت، قد يؤدي تغيير إشارة State إلى استدعاء رد الاتصال الخاص بـ Watcher فورًا، &quot;دافعًا&quot; الإشعار. لذا يمكن اعتبار Signals على أنها بنية &quot;دفع-سحب&quot;.</p>
<p><strong>س</strong>: هل تقدم Signals عدم تحديد في تنفيذ جافاسكريبت؟</p>
<p><strong>ج</strong>: لا. جميع عمليات Signal لها دلالات وترتيب محددين جيدًا، ولن تختلف بين تطبيقات متوافقة. على مستوى أعلى، تتبع Signals مجموعة معينة من الثوابت (invariants)، والتي تكون بالنسبة لها &quot;صحيحة&quot;. دائماً تلاحظ Signal المحسوبة رسم الإشارة في حالة متسقة، ولا يتم مقاطعة تنفيذها بواسطة أكواد أخرى تغير Signals (باستثناء الأشياء التي تستدعيها بنفسها). راجع الوصف أعلاه.</p>
<p><strong>س</strong>: متى تتم جدولة تحديث Signal المحسوبة عند الكتابة إلى إشارة State؟</p>
<p><strong>ج</strong>: لا يتم جدولة ذلك! ستعيد Signal المحسوبة حساب نفسها في المرة التالية التي يقرأها فيها أحدهم. بشكل متزامن، قد يتم استدعاء رد الاتصال <code>notify</code> الخاص بـ Watcher، مما يمكّن الأطر من جدولة قراءة في الوقت المناسب لهم.</p>
<p><strong>س</strong>: متى تصبح الكتابات إلى Signals الحالة فعالة؟ فورًا أم يتم تجميعها؟</p>
<p><strong>ج</strong>: تنعكس الكتابات إلى Signals الحالة فورًا--في المرة التالية التي تتم فيها قراءة Signal المحسوبة التي تعتمد على Signal الحالة، ستعيد حساب نفسها إذا لزم الأمر، حتى لو كان ذلك في السطر التالي من الكود مباشرةً. ومع ذلك، فإن الكسل المتأصل في هذه الآلية (حيث يتم حساب Signals المحسوبة فقط عند قراءتها) يعني أنه في الواقع، قد تحدث الحسابات بطريقة مجمعة.</p>
<p><strong>س</strong>: ماذا يعني أن Signals تتيح تنفيذًا &quot;خاليًا من العيوب&quot; (glitch-free)؟</p>
<p><strong>ج</strong>: واجهت نماذج الدفع (push-based) القديمة للتفاعلية مشكلة الحسابات المتكررة غير الضرورية: إذا أدى تحديث Signal الحالة إلى تشغيل Signal المحسوبة بشكل متلهف، فقد يؤدي ذلك في النهاية إلى تحديث واجهة المستخدم. لكن هذه الكتابة إلى الواجهة قد تكون مبكرة، إذا كان هناك تغيير آخر على وشك الحدوث في Signal الحالة الأصلية قبل الإطار التالي. أحيانًا، قد تظهر للمستخدمين النهائيين قيم وسيطة غير دقيقة بسبب مثل هذه <a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">العيوب</a>. تتجنب Signals هذا السلوك من خلال اعتمادها على السحب بدلاً من الدفع: في الوقت الذي يحدد فيه الإطار الزمني لعرض واجهة المستخدم، سيقوم النظام بسحب التحديثات المناسبة، مما يتجنب العمل المهدور سواء في الحساب أو في الكتابة إلى DOM.</p>
<p><strong>س</strong>: ماذا يعني أن Signals &quot;تفقد&quot; البيانات (lossy)؟</p>
<p><strong>ج</strong>: هذا هو الجانب الآخر من التنفيذ الخالي من العيوب: تمثل Signals خلية من البيانات--القيمة الحالية الفورية فقط (التي قد تتغير)، وليس تدفق بيانات عبر الزمن. لذلك، إذا كتبت إلى إشارة State مرتين متتاليتين، دون القيام بأي شيء آخر، فإن الكتابة الأولى &quot;تُفقد&quot; ولا تُرى أبدًا من قبل أي Signal محسوبة أو تأثيرات. ويُعتبر هذا ميزة وليس خطأ--البُنى الأخرى (مثل async iterables، أو observables) أكثر ملاءمة للتدفقات.</p>
<p><strong>س</strong>: هل ستكون Signals الأصلية أسرع من تطبيقات Signals في جافاسكريبت الحالية؟</p>
<p><strong>ج</strong>: نأمل ذلك (بمقدار ثابت صغير)، لكن هذا لا يزال بحاجة لإثباته في الكود. محركات جافاسكريبت ليست سحرية، وفي النهاية ستحتاج إلى تنفيذ نفس أنواع الخوارزميات الموجودة في تطبيقات Signals في جافاسكريبت. راجع القسم أعلاه حول الأداء.</p>
<h4>لماذا تم تصميم Signals بهذه الطريقة؟</h4>
<p><strong>س</strong>: لماذا لا تتضمن هذه المقترحات دالة <code>effect()</code>، مع أن التأثيرات ضرورية لأي استخدام عملي لـ Signals؟</p>
<p><strong>ج</strong>: التأثيرات ترتبط بطبيعتها بالجدولة والإلغاء، والتي تديرها الأطر وتخرج عن نطاق هذا المقترح. بدلاً من ذلك، يتضمن هذا المقترح الأساس لتنفيذ التأثيرات من خلال API منخفض المستوى <code>Signal.subtle.Watcher</code>.</p>
<p><strong>س</strong>: لماذا الاشتراكات تلقائية بدلاً من توفير واجهة يدوية؟</p>
<p><strong>ج</strong>: أظهرت التجربة أن واجهات الاشتراك اليدوي للتفاعلية غير عملية وعرضة للأخطاء. التتبع التلقائي أكثر قابلية للتكوين وهو ميزة أساسية في Signals.</p>
<p><strong>س</strong>: لماذا يتم تشغيل رد الاتصال الخاص بـ <code>Watcher</code> بشكل متزامن، وليس مجدولًا في مهمة صغيرة (microtask)؟</p>
<p><strong>ج</strong>: لأن رد الاتصال لا يمكنه قراءة أو كتابة Signals، فلا يوجد خلل في استدعائه بشكل متزامن. غالبًا ما يضيف رد الاتصال Signal إلى مصفوفة ليتم قراءتها لاحقًا، أو يضع علامة في مكان ما. من غير الضروري ومكلف جدًا إنشاء مهمة صغيرة منفصلة لجميع هذه الإجراءات.</p>
<p><strong>س</strong>: تفتقد هذه الواجهة البرمجية لبعض الميزات الجميلة التي يوفرها إطاري المفضل، والتي تسهّل البرمجة باستخدام Signals. هل يمكن إضافتها إلى المعيار أيضًا؟</p>
<p><strong>ج</strong>: ربما. لا تزال هناك امتدادات متنوعة قيد الدراسة. يرجى فتح قضية لمناقشة أي ميزة مفقودة تراها مهمة.</p>
<p><strong>س</strong>: هل يمكن تقليل حجم أو تعقيد هذه الواجهة البرمجية؟</p>
<p><strong>ج</strong>: من المؤكد أن الحفاظ على هذه الواجهة البرمجية بسيطة هو هدف، وقد حاولنا القيام بذلك فيما عُرض أعلاه. إذا كانت لديك أفكار حول أشياء أخرى يمكن إزالتها، يرجى فتح قضية للنقاش.</p>
<h4>كيف يتم توحيد Signals؟</h4>
<p><strong>س</strong>: أليس من الأفضل أن نبدأ أعمال التوحيد في هذا المجال بمفهوم أكثر بدائية، مثل observables؟</p>
<p><strong>س</strong>: قد تكون الـ Observables فكرة جيدة لبعض الأمور، لكنها لا تحل المشاكل التي تهدف الإشارات (Signals) إلى حلها. كما هو موضح أعلاه، فإن الـ Observables أو آليات النشر/الاشتراك الأخرى ليست حلاً كاملاً للعديد من أنواع برمجة واجهات المستخدم، وذلك بسبب كثرة أعمال التهيئة المعرضة للأخطاء للمطورين، والعمل المهدور بسبب غياب الكسل (laziness)، وغيرها من المشكلات.</p>
<p><strong>س</strong>: لماذا يتم اقتراح الإشارات (Signals) في TC39 بدلاً من DOM، مع أن معظم تطبيقاتها تعتمد على الويب؟</p>
<p><strong>ج</strong>: بعض المشاركين في كتابة هذا الاقتراح مهتمون ببيئات واجهات المستخدم غير المعتمدة على الويب كهدف، لكن في الوقت الحالي، أي من الجهتين قد يكون مناسبًا لذلك، حيث أن واجهات برمجة تطبيقات الويب تُطبق بشكل متزايد خارج الويب أيضًا. في النهاية، الإشارات (Signals) لا تحتاج للاعتماد على أي من واجهات برمجة تطبيقات الـ DOM، لذا كلا الطريقتين تعملان. إذا كان لدى أي شخص سبب قوي لجعل هذه المجموعة تنتقل، يرجى إعلامنا عبر فتح قضية. حالياً، جميع المساهمين قد وقعوا على اتفاقيات الملكية الفكرية لـ TC39، والخطة هي عرض هذا على TC39.</p>
<p><strong>س</strong>: كم من الوقت سيستغرق الأمر حتى أتمكن من استخدام الإشارات القياسية (Standard Signals)؟</p>
<p><strong>ج</strong>: هناك polyfill متاح بالفعل، ولكن من الأفضل عدم الاعتماد على استقراره، حيث أن واجهة برمجة التطبيقات هذه تتطور أثناء عملية المراجعة. في غضون عدة أشهر أو سنة، يجب أن يكون هناك polyfill مستقر عالي الجودة وعالي الأداء قابل للاستخدام، ولكن هذا سيظل خاضعًا لمراجعات اللجنة ولم يصبح معيارًا بعد. ووفقًا للمسار المعتاد لمقترحات TC39، من المتوقع أن يستغرق الأمر على الأقل من 2-3 سنوات كحد أدنى ليتم توفير الإشارات (Signals) بشكل أصلي في جميع المتصفحات عبر عدة إصدارات سابقة، بحيث لا تكون هناك حاجة إلى polyfills.</p>
<p><strong>س</strong>: كيف سنمنع اعتماد النوع الخاطئ من الإشارات (Signals) في المعايير بسرعة، كما حدث مع {{JS/web feature that you don't like}}؟</p>
<p><strong>ج</strong>: يخطط مؤلفو هذا الاقتراح لبذل جهد إضافي في النمذجة الأولية وإثبات الأمور قبل طلب التقدم في مراحل TC39. راجع قسم &quot;الحالة وخطة التطوير&quot; أعلاه. إذا رأيت ثغرات في هذه الخطة أو فرصًا للتحسين، يرجى فتح قضية وشرح ذلك.</p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-28</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>