<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>proposal-signals - tc39/proposal-signals fr</title>
    <meta name="title" content="proposal-signals - tc39/proposal-signals fr | 🚦 Proposition de standard JavaScript Signals 🚦 Étape 1 (explication) Champions de la proposition TC39 : Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay ...">
    <meta name="description" content="tc39/proposal-signals - GitHub repository fr documentation and information | 🚦 Proposition de standard JavaScript Signals 🚦 Étape 1 (explication) Champions de la proposition TC39 : Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay ...">
    <meta name="keywords" content="tc39, proposal-signals, GitHub, repository, fr documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/tc39/proposal-signals/README-fr.html">
    <meta property="og:title" content="proposal-signals - tc39/proposal-signals fr | 🚦 Proposition de standard JavaScript Signals 🚦 Étape 1 (explication) Champions de la proposition TC39 : Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay ...">
    <meta property="og:description" content="tc39/proposal-signals - GitHub repository fr documentation and information | 🚦 Proposition de standard JavaScript Signals 🚦 Étape 1 (explication) Champions de la proposition TC39 : Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay ...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/tc39/proposal-signals" id="githubRepoLink" target="_blank">tc39/proposal-signals</a>
<h1 style="display: none;">🚦 Proposition de standard JavaScript Signals 🚦 Étape 1 (explication) Champions de la proposition TC39 : Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay ...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>🚦 Proposition de standard JavaScript Signals 🚦</h1>
<img align=right src="https://raw.githubusercontent.com/tc39/proposal-signals/main/Signals.svg" alt="Logo Signals" width=100>
<p>Étape 1 (<a href="https://tc39.es/process-document/">explication</a>)</p>
<p>Champions de la proposition TC39 : Daniel Ehrenberg, Yehuda Katz, Jatin Ramanathan, Shay Lewis, Kristen Hewell Garrett, Dominic Gannaway, Preston Sego, Milo M, Rob Eisenberg</p>
<p>Auteurs originaux : Rob Eisenberg et Daniel Ehrenberg</p>
<p>Ce document décrit une première orientation commune pour les signaux en JavaScript, similaire à l’effort Promises/A+ qui a précédé la standardisation des Promises par TC39 dans ES2015. Essayez-le vous-même, en utilisant <a href="https://github.com/proposal-signals/signal-polyfill">un polyfill</a>.</p>
<p>De manière similaire à Promises/A+, cet effort vise à aligner l’écosystème JavaScript. Si cet alignement est réussi, une norme pourrait émerger, basée sur cette expérience. Plusieurs auteurs de frameworks collaborent ici sur un modèle commun qui pourrait servir de base à leur cœur de réactivité. Le brouillon actuel se base sur les retours de conception des auteurs/mainteneurs de <a href="https://angular.io/">Angular</a>, <a href="https://bubble.io/">Bubble</a>, <a href="https://emberjs.com/">Ember</a>, <a href="https://www.fast.design/">FAST</a>, <a href="https://mobx.js.org/">MobX</a>, <a href="https://preactjs.com/">Preact</a>, <a href="https://qwik.dev/">Qwik</a>, <a href="https://rxjs.dev/">RxJS</a>, <a href="https://www.solidjs.com/">Solid</a>, <a href="https://www.starbeamjs.com/">Starbeam</a>, <a href="https://svelte.dev/">Svelte</a>, <a href="https://vuejs.org/">Vue</a>, <a href="https://blog.angular.io/angular-and-wiz-are-better-together-91e633d8cd5a">Wiz</a>, et plus encore…</p>
<p>Contrairement à Promises/A+, nous ne cherchons pas à résoudre une API commune orientée développeur, mais plutôt à définir précisément les sémantiques du cœur du graphe de signaux sous-jacent. Cette proposition inclut une API concrète complète, mais cette API n’est pas destinée à la majorité des développeurs d’applications. Au contraire, l’API de signal proposée ici est mieux adaptée pour les frameworks qui pourront se baser dessus, offrant l’interopérabilité via un graphe de signaux commun et un mécanisme d’auto-suivi.</p>
<p>Le plan pour cette proposition est de faire des prototypes précoces significatifs, y compris l’intégration dans plusieurs frameworks, avant d’aller au-delà de l’étape 1. Nous ne sommes intéressés par la standardisation des Signals que s’ils sont adaptés à une utilisation pratique dans plusieurs frameworks, et qu’ils apportent de réels bénéfices par rapport aux signaux fournis par les frameworks. Nous espérons que ces prototypes précoces nous apporteront ces informations. Voir « Statut et plan de développement » ci-dessous pour plus de détails.</p>
<h2>Contexte : Pourquoi des Signals ?</h2>
<p>Pour développer une interface utilisateur (UI) complexe, les développeurs d’applications JavaScript doivent stocker, calculer, invalider, synchroniser et pousser l’état vers la couche d’affichage de l’application de manière efficace. Les interfaces utilisateur impliquent souvent plus que la gestion de simples valeurs, mais nécessitent aussi le rendu d’un état calculé dépendant d’un arbre complexe d’autres valeurs ou d’états eux-mêmes calculés. L’objectif des Signals est de fournir l’infrastructure permettant de gérer un tel état applicatif afin que les développeurs puissent se concentrer sur la logique métier plutôt que sur ces détails répétitifs.</p>
<p>Des constructions similaires aux signaux se sont également avérées utiles dans des contextes non-UI, notamment dans les systèmes de build pour éviter les reconstructions inutiles.</p>
<p>Les signaux sont utilisés en programmation réactive pour éliminer le besoin de gérer manuellement les mises à jour dans les applications.</p>
<blockquote>
<p>Un modèle de programmation déclaratif pour la mise à jour basée sur les changements d’état.</p>
</blockquote>
<p>tiré de <em><a href="https://www.pzuraq.com/blog/what-is-reactivity">What is Reactivity?</a></em>.</p>
<h4>Exemple – Un compteur VanillaJS</h4>
<p>Étant donné une variable <code>counter</code>, vous souhaitez afficher dans le DOM si le compteur est pair ou impair. Chaque fois que <code>counter</code> change, vous souhaitez mettre à jour le DOM avec la nouvelle parité. En Vanilla JS, vous pourriez avoir quelque chose comme ceci :</p>
<pre><code class="language-js">let counter = 0;
const setCounter = (value) =&gt; {
  counter = value;
  render();
};

const isEven = () =&gt; (counter &amp; 1) == 0;
const parity = () =&gt; isEven() ? &quot;even&quot; : &quot;odd&quot;;
const render = () =&gt; element.innerText = parity();

// Simuler des mises à jour externes de counter...
setInterval(() =&gt; setCounter(counter + 1), 1000);
</code></pre>
<blockquote>
<p>[!NOTE]<br />
Des variables globales sont utilisées ici uniquement à des fins de démonstration. La gestion correcte de l’état a de nombreuses solutions, et les exemples de cette proposition se veulent les plus minimalistes possible. Cette proposition n’encourage pas l’utilisation de variables globales.</p>
</blockquote>
<p>Cela pose plusieurs problèmes...</p>
<ul>
<li>La mise en place de <code>counter</code> est verbeuse et nécessite beaucoup de code passe-partout.</li>
<li>L’état de <code>counter</code> est fortement couplé au système de rendu.</li>
<li>Si <code>counter</code> change mais que <code>parity</code> ne change pas (par exemple, si le compteur passe de 2 à 4), alors nous faisons un calcul de parité et un rendu inutiles.</li>
<li>Que faire si une autre partie de notre UI souhaite juste se mettre à jour quand <code>counter</code> change ?</li>
<li>Que faire si une autre partie de notre UI dépend uniquement de <code>isEven</code> ou <code>parity</code> ?</li>
</ul>
<p>Même dans ce scénario relativement simple, plusieurs problèmes surgissent rapidement. Nous pourrions essayer de les contourner en introduisant un système pub/sub pour <code>counter</code>. Cela permettrait à d’autres consommateurs de <code>counter</code> de s’abonner pour réagir aux changements d’état.</p>
<p>Cependant, nous restons confrontés aux problèmes suivants :</p>
<ul>
<li>La fonction de rendu, qui ne dépend que de <code>parity</code>, doit « savoir » qu’elle doit en réalité s’abonner à <code>counter</code>.</li>
<li>Il n’est pas possible de mettre à jour l’UI en se basant uniquement sur <code>isEven</code> ou <code>parity</code>, sans interagir directement avec <code>counter</code>.</li>
<li>Nous avons augmenté le code passe-partout. À chaque fois que vous utilisez quelque chose, il ne s’agit plus simplement d’appeler une fonction ou de lire une variable, mais de s’abonner et de gérer les mises à jour. La gestion du désabonnement devient également particulièrement compliquée.</li>
</ul>
<p>Nous pourrions maintenant résoudre certains problèmes en ajoutant pub/sub non seulement à <code>counter</code> mais aussi à <code>isEven</code> et <code>parity</code>. Il faudrait alors abonner <code>isEven</code> à <code>counter</code>, <code>parity</code> à <code>isEven</code>, et <code>render</code> à <code>parity</code>. Malheureusement, non seulement notre code passe-partout explose, mais nous devons aussi gérer une multitude d’abonnements, avec un risque important de fuite mémoire si nous ne nettoyons pas tout correctement. Nous avons donc résolu certains problèmes, mais créé toute une nouvelle catégorie de soucis, et beaucoup de code. Pire encore, il faudrait répéter tout ce processus pour chaque morceau d’état dans notre système.</p>
<h3>Introduction aux Signals</h3>
<p>Les abstractions de liaison de données entre le modèle et la vue sont depuis longtemps au cœur des frameworks UI dans de nombreux langages de programmation, malgré l’absence de tel mécanisme natif dans JS ou la plateforme web. Dans les frameworks et bibliothèques JS, il y a eu énormément d’expérimentations quant à la façon de représenter cette liaison, et l’expérience a montré la puissance du flux de données unidirectionnel combiné à un type de donnée de première classe représentant une cellule d’état ou un calcul dérivé d’autres données, qu’on appelle aujourd’hui souvent « Signals ».
Cette approche de valeur réactive de première classe semble être apparue pour la première fois dans les frameworks web open-source JavaScript avec <a href="https://knockoutjs.com/">Knockout</a> <a href="https://blog.stevensanderson.com/2010/07/05/introducing-knockout-a-ui-library-for-javascript/">en 2010</a>. Depuis, de nombreuses variantes et implémentations ont vu le jour. Au cours des 3-4 dernières années, la primitive Signal et les approches associées ont connu un regain d’intérêt, avec presque toutes les bibliothèques ou frameworks JavaScript modernes disposant d’un équivalent, sous un nom ou un autre.</p>
<p>Pour comprendre les Signals, examinons l’exemple précédent, ré-imaginé avec une API Signal détaillée ci-dessous.</p>
<h4>Exemple – Un compteur avec Signals</h4>
<pre><code class="language-js">const counter = new Signal.State(0);
const isEven = new Signal.Computed(() =&gt; (counter.get() &amp; 1) == 0);
const parity = new Signal.Computed(() =&gt; isEven.get() ? &quot;even&quot; : &quot;odd&quot;);

// Une bibliothèque ou un framework définit des effets basés sur d’autres primitives Signal
declare function effect(cb: () =&gt; void): (() =&gt; void);

effect(() =&gt; element.innerText = parity.get());

// Simuler des mises à jour externes de counter...
setInterval(() =&gt; counter.set(counter.get() + 1), 1000);
</code></pre>
<p>On remarque immédiatement plusieurs choses :</p>
<ul>
<li>Nous avons éliminé le code passe-partout verbeux autour de la variable <code>counter</code> de l’exemple précédent.</li>
<li>Il existe une API unifiée pour gérer les valeurs, les calculs et les effets de bord.</li>
<li>Il n’y a plus de problème de référence circulaire ni de dépendances inversées entre <code>counter</code> et <code>render</code>.</li>
<li>Il n’y a pas d’abonnements manuels, ni de besoin de gestion administrative.</li>
<li>Il existe un moyen de contrôler le moment/la planification des effets de bord.</li>
</ul>
<p>Les Signals nous offrent bien plus que ce que l’on peut voir en surface de l’API :</p>
<ul>
<li><strong>Suivi automatique des dépendances</strong> - Un Signal calculé découvre automatiquement tous les autres Signaux dont il dépend, que ces Signaux soient de simples valeurs ou d’autres calculs.</li>
<li><strong>Évaluation paresseuse</strong> - Les calculs ne sont pas évalués de manière impatiente lors de leur déclaration, ni immédiatement lors d’un changement de leurs dépendances. Ils ne sont évalués que lorsque leur valeur est explicitement demandée.</li>
<li><strong>Mémorisation</strong> - Les Signaux calculés mettent en cache leur dernière valeur afin que les calculs dont les dépendances n’ont pas changé n’aient pas besoin d’être réévalués, quel que soit le nombre d’accès.</li>
</ul>
<h2>Motivation pour la standardisation des Signaux</h2>
<h4>Interopérabilité</h4>
<p>Chaque implémentation de Signal possède son propre mécanisme d’auto-suivi pour garder trace des sources rencontrées lors de l’évaluation d’un Signal calculé. Cela rend difficile le partage de modèles, composants et bibliothèques entre différents frameworks — ils ont tendance à être faussement couplés à leur moteur de vue (étant donné que les Signaux sont généralement implémentés comme partie intégrante des frameworks JS).</p>
<p>L’un des objectifs de cette proposition est de découpler complètement le modèle réactif de la vue de rendu, permettant ainsi aux développeurs de migrer vers de nouvelles technologies de rendu sans réécrire leur code non-UI, ou de développer des modèles réactifs partagés en JS à déployer dans différents contextes. Malheureusement, en raison du versionnage et de la duplication, il s’est avéré peu pratique d’atteindre un niveau élevé de partage via des bibliothèques JS — les objets natifs offrent une meilleure garantie de partage.</p>
<h4>Performance/Utilisation mémoire</h4>
<p>Il y a toujours un petit gain potentiel de performance à embarquer moins de code grâce à l’inclusion native de bibliothèques courantes, mais les implémentations de Signaux sont généralement assez petites, donc nous ne nous attendons pas à ce que cet effet soit très important.</p>
<p>Nous pensons que des implémentations natives en C++ des structures de données et algorithmes liés aux Signaux peuvent être légèrement plus efficaces que ce qu’il est possible d’atteindre en JS, d’un facteur constant. Cependant, aucun changement algorithmique n’est anticipé par rapport à ce qui serait présent dans un polyfill ; il n’est pas attendu que les moteurs fassent de la magie ici, et les algorithmes de réactivité eux-mêmes seront bien définis et non ambigus.</p>
<p>Le groupe de pilotage prévoit de développer diverses implémentations de Signaux et d’utiliser celles-ci pour étudier ces possibilités de performance.</p>
<h4>Outils de développement (DevTools)</h4>
<p>Avec les bibliothèques de Signaux existantes en JS, il peut être difficile de tracer des éléments comme :</p>
<ul>
<li>La pile d’appels à travers une chaîne de Signaux calculés, montrant la chaîne causale d’une erreur</li>
<li>Le graphe de références entre Signaux, lorsqu’un Signal dépend d’un autre — important lors du débogage de l’utilisation mémoire</li>
</ul>
<p>Les Signaux natifs permettent aux environnements JS et aux outils de développement d’avoir potentiellement un meilleur support pour l’inspection des Signaux, en particulier pour le débogage ou l’analyse de performances, que ce soit intégré aux navigateurs ou via une extension partagée. Les outils existants comme l’inspecteur d’éléments, les instantanés de performance et les profileurs mémoire pourraient être mis à jour pour mettre en évidence spécifiquement les Signaux lors de la présentation des informations.</p>
<h4>Bénéfices secondaires</h4>
<h5>Bénéfices d’une bibliothèque standard</h5>
<p>De manière générale, JavaScript dispose d’une bibliothèque standard assez minimale, mais une tendance au sein de TC39 est de faire évoluer JS vers un langage « tout compris », avec un ensemble de fonctionnalités intégrées et de haute qualité. Par exemple, Temporal remplace moment.js, et un certain nombre de petites fonctionnalités, comme <code>Array.prototype.flat</code> et <code>Object.groupBy</code>, remplacent beaucoup de cas d’usage de lodash. Les bénéfices incluent des tailles de bundle réduites, une stabilité et qualité améliorées, moins de choses à apprendre lors de l’arrivée sur un nouveau projet, et un vocabulaire généralement commun entre développeurs JS.</p>
<h5>Intégration HTML/DOM (possibilité future)</h5>
<p>Des travaux actuels au sein du W3C et des implémenteurs de navigateurs cherchent à apporter le templating natif à HTML (<a href="https://github.com/WICG/webcomponents/pull/1023">DOM Parts</a> et <a href="https://github.com/WICG/webcomponents/blob/gh-pages/proposals/Template-Instantiation.md">Template Instantiation</a>). De plus, le W3C Web Components CG explore la possibilité d’étendre les Web Components pour offrir une API HTML entièrement déclarative. Pour atteindre ces deux objectifs, une primitive réactive sera finalement nécessaire en HTML. Par ailleurs, de nombreuses améliorations ergonomiques du DOM via l’intégration des Signaux peuvent être imaginées et ont été demandées par la communauté.</p>
<blockquote>
<p>Remarque : cette intégration constituerait un effort séparé à venir, et ne fait pas partie de cette proposition.</p>
</blockquote>
<h5>Échanges d’informations dans l’écosystème (<em>ce n’est pas</em> une raison de standardiser)</h5>
<p>Les efforts de standardisation peuvent parfois être utiles au niveau de la « communauté », même sans changement dans les navigateurs. L’initiative sur les Signaux réunit de nombreux auteurs de frameworks pour une discussion approfondie sur la nature de la réactivité, des algorithmes et de l’interopérabilité. Cela s’est déjà avéré utile, mais ne justifie pas l’inclusion dans les moteurs JS et navigateurs ; les Signaux ne devraient être ajoutés au standard JavaScript que s’il existe des avantages significatifs <em>au-delà</em> de l’échange d’informations permis dans l’écosystème.</p>
<h2>Objectifs de conception pour les Signaux</h2>
<p>Il s’avère que les bibliothèques de Signaux existantes ne sont pas si différentes les unes des autres, au fond. Cette proposition vise à capitaliser sur leur succès en mettant en œuvre les qualités importantes de nombre de ces bibliothèques.</p>
<h3>Fonctionnalités principales</h3>
<ul>
<li>Un type Signal qui représente un état, c’est-à-dire un Signal modifiable. C’est une valeur que d’autres peuvent lire.</li>
<li>Un type Signal calculé/mémo/dérivé, qui dépend d’autres et est calculé paresseusement et mis en cache.
<ul>
<li>Le calcul est paresseux, ce qui signifie que les Signaux calculés ne sont pas recalculés par défaut lorsqu’une de leurs dépendances change, mais uniquement si quelqu’un les lit réellement.</li>
<li>Le calcul est « sans glitch » (<a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">glitch</a>), ce qui signifie qu’aucun calcul inutile n’est jamais effectué. Cela implique que, lorsqu’une application lit un Signal calculé, il existe un tri topologique des parties potentiellement obsolètes du graphe à exécuter, pour éliminer les doublons.</li>
<li>Le calcul est mis en cache, ce qui signifie que si, après le dernier changement de dépendance, aucune dépendance n’a changé, alors le Signal calculé <em>n’est pas</em> recalculé lors de l’accès.</li>
<li>Des comparaisons personnalisées sont possibles pour les Signaux calculés ainsi que pour les Signaux d’état, afin de déterminer à quel moment d’autres Signaux calculés qui en dépendent doivent être mis à jour.</li>
</ul>
</li>
<li>Réactions à la situation où un Signal calculé voit l’une de ses dépendances (ou dépendances imbriquées) devenir « sale » et changer, signifiant que la valeur du Signal pourrait être obsolète.
<ul>
<li>Cette réaction vise à planifier un travail plus important à effectuer plus tard.</li>
<li>Les effets sont implémentés en termes de ces réactions, plus une planification au niveau du framework.</li>
<li>Les signaux calculés doivent pouvoir réagir au fait d’être enregistrés comme dépendance (imbriquée) d’une de ces réactions.</li>
</ul>
</li>
<li>Permettre aux frameworks JS de gérer leur propre planification. Pas de planification forcée intégrée de type Promise.
<ul>
<li>Des réactions synchrones sont nécessaires pour permettre la planification ultérieure de travaux selon la logique du framework.</li>
<li>Les écritures sont synchrones et prennent effet immédiatement (un framework qui regroupe les écritures peut le faire par-dessus).</li>
<li>Il est possible de séparer la vérification qu’un effet peut être « sale » de l’exécution effective de l’effet (permettant un ordonnanceur d’effets en deux étapes).</li>
</ul>
</li>
<li>Possibilité de lire des Signaux <em>sans</em> déclencher l’enregistrement des dépendances (<code>untrack</code>)</li>
<li>Permettre la composition de différents bases de code utilisant les Signaux/la réactivité, par exemple,
<ul>
<li>Utiliser plusieurs frameworks ensemble en ce qui concerne le suivi/la réactivité elle-même (modulo omissions, voir ci-dessous)</li>
<li>Structures de données réactives indépendantes du framework (par exemple, proxy de store récursivement réactif, Map, Set et Array réactifs, etc.)</li>
</ul>
</li>
</ul>
<h3>Solidité</h3>
<ul>
<li>Décourager/interdire une mauvaise utilisation naïve des réactions synchrones.
<ul>
<li>Risque pour la solidité : cela peut exposer des « <a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">glitches</a> » si mal utilisé : si le rendu est effectué immédiatement lorsqu’un Signal est modifié, cela peut exposer un état d’application incomplet à l’utilisateur final. Ainsi, cette fonctionnalité doit uniquement servir à planifier intelligemment du travail pour plus tard, une fois la logique applicative terminée.</li>
<li>Solution : Interdire la lecture et l’écriture de tout Signal depuis un rappel de réaction synchrone.</li>
</ul>
</li>
<li>Décourager <code>untrack</code> et signaler sa nature non sûre
<ul>
<li>Risque pour la solidité : permet la création de Signaux calculés dont la valeur dépend d’autres Signaux, mais qui ne sont pas mis à jour lorsque ces Signaux changent. Il doit être utilisé lorsque les accès non suivis ne changent pas le résultat du calcul.</li>
<li>Solution : L’API porte la mention « unsafe » dans son nom.</li>
</ul>
</li>
<li>Remarque : Cette proposition permet la lecture et l’écriture de signaux depuis des signaux calculés et d’effet, sans restreindre les écritures qui suivent des lectures, malgré le risque pour la solidité. Cette décision vise à préserver la flexibilité et la compatibilité lors de l’intégration avec des frameworks.</li>
</ul>
<h3>API de surface</h3>
<ul>
<li>Doit constituer une base solide pour que plusieurs frameworks implémentent leurs mécanismes de Signaux/réactivité.
<ul>
<li>Doit être une bonne base pour les proxys de store récursifs, la réactivité des champs de classe basée sur des décorateurs, et les API de style <code>.value</code> ou <code>[state, setState]</code>.</li>
<li>La sémantique doit permettre d’exprimer les modèles valides proposés par différents frameworks. Par exemple, il doit être possible que ces Signaux servent de base à des écritures immédiatement reflétées ou à des écritures regroupées et appliquées ultérieurement.</li>
</ul>
</li>
<li>Il serait appréciable que cette API soit utilisable directement par les développeurs JavaScript.
<ul>
<li>Si une fonctionnalité correspond à un concept de l’écosystème, utiliser un vocabulaire commun est souhaitable.
<ul>
<li>Cependant, il est important de ne pas réutiliser exactement les mêmes noms !</li>
</ul>
</li>
<li>Tension entre « utilisabilité par les développeurs JS » et « fournir tous les points d’extension aux frameworks »
<ul>
<li>Idée : Fournir tous les points d’extension, mais inclure des erreurs en cas de mauvaise utilisation si possible.</li>
<li>Idée : Placer les API subtiles dans un espace de nommage <code>subtle</code>, similaire à <a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle"><code>crypto.subtle</code></a>, pour marquer la frontière entre les API nécessaires à un usage avancé (implémentation de framework ou outils de développement) et le développement applicatif courant (instanciation de signaux à utiliser avec un framework).</li>
</ul>
</li>
</ul>
</li>
<li>Être implémentable et utilisable avec de bonnes performances — l’API de surface ne doit pas entraîner trop de surcoût.
<ul>
<li>Permettre l’héritage, afin que les frameworks puissent ajouter leurs propres méthodes et champs, y compris des champs privés. Cela est important pour éviter le besoin d’allocations supplémentaires au niveau du framework. Voir « Gestion mémoire » ci-dessous.</li>
</ul>
</li>
</ul>
<h3>Gestion mémoire</h3>
<ul>
<li>Si possible : un Signal calculé devrait pouvoir être collecté par le ramasse-miettes si rien de vivant ne le référence pour de futures lectures, même s’il est lié à un graphe plus large qui reste vivant (par exemple en lisant un état qui reste vivant).</li>
<li>Notez que la plupart des frameworks actuels nécessitent une suppression explicite des Signaux calculés s'ils ont une référence vers ou depuis un autre graphe de Signaux qui reste vivant.</li>
<li>Cela n'est finalement pas si problématique lorsque leur durée de vie est liée à celle d'un composant UI, et que les effets doivent de toute façon être supprimés.</li>
<li>Si l'exécution avec ces sémantiques est trop coûteuse, alors nous devrions ajouter la suppression explicite (ou le &quot;déliaisonnement&quot;) des Signaux calculés à l'API ci-dessous, qui en est actuellement dépourvue.</li>
<li>Un objectif connexe : Minimiser le nombre d'allocations, par exemple :
<ul>
<li>pour créer un Signal modifiable (éviter deux closures séparées + un tableau)</li>
<li>pour implémenter des effets (éviter une closure pour chaque réaction)</li>
<li>Dans l'API d'observation des changements de Signal, éviter de créer des structures de données temporaires supplémentaires</li>
<li>Solution : API basée sur des classes permettant la réutilisation de méthodes et de champs définis dans les sous-classes</li>
</ul>
</li>
</ul>
<h2>Ébauche d’API</h2>
<p>Voici une première idée d'une API de Signal. Notez qu'il ne s'agit que d'une ébauche préliminaire, et nous prévoyons des modifications au fil du temps. Commençons par le <code>.d.ts</code> complet pour avoir une idée de la structure générale, puis nous discuterons des détails de ce que cela signifie.</p>
<pre><code class="language-ts">interface Signal&lt;T&gt; {
    // Obtenir la valeur du signal
    get(): T;
}

namespace Signal {
    // Un Signal en lecture-écriture
    class State&lt;T&gt; implements Signal&lt;T&gt; {
        // Créer un Signal d'état initialisé avec la valeur t
        constructor(t: T, options?: SignalOptions&lt;T&gt;);

        // Obtenir la valeur du signal
        get(): T;

        // Définir la valeur du Signal d'état à t
        set(t: T): void;
    }

    // Un Signal qui est une formule basée sur d'autres Signaux
    class Computed&lt;T = unknown&gt; implements Signal&lt;T&gt; {
        // Créer un Signal qui s'évalue à la valeur retournée par le callback.
        // Le callback est appelé avec ce signal comme valeur de this.
        constructor(cb: (this: Computed&lt;T&gt;) =&gt; T, options?: SignalOptions&lt;T&gt;);

        // Obtenir la valeur du signal
        get(): T;
    }

    // Cet espace de noms inclut des fonctionnalités &quot;avancées&quot; qu’il vaut mieux
    // laisser aux auteurs de frameworks plutôt qu’aux développeurs d’applications.
    // Analogue à `crypto.subtle`
    namespace subtle {
        // Exécuter un callback avec tout le suivi désactivé
        function untrack&lt;T&gt;(cb: () =&gt; T): T;

        // Obtenir le signal calculé courant qui suit toutes les lectures de signal, si existant
        function currentComputed(): Computed | null;

        // Retourne la liste ordonnée de tous les signaux référencés par celui-ci
        // lors de sa dernière évaluation.
        // Pour un Watcher, liste l’ensemble des signaux surveillés.
        function introspectSources(s: Computed | Watcher): (State | Computed)[];

        // Retourne les Watchers auxquels ce signal appartient, ainsi que tous les
        // signaux Computed qui ont lu ce signal lors de leur dernière évaluation,
        // si ce signal calculé est (récursivement) surveillé.
        function introspectSinks(s: State | Computed): (Computed | Watcher)[];

        // Vrai si ce signal est &quot;vivant&quot;, c’est-à-dire qu’il est surveillé par un Watcher,
        // ou qu’il est lu par un signal Computed qui est (récursivement) vivant.
        function hasSinks(s: State | Computed): boolean;

        // Vrai si cet élément est &quot;réactif&quot;, c’est-à-dire qu’il dépend
        // d’un autre signal. Un Computed où hasSources est faux
        // renverra toujours la même constante.
        function hasSources(s: Computed | Watcher): boolean;

        class Watcher {
            // Lorsqu'une source (récursive) du Watcher est modifiée, appeler ce callback,
            // s’il n’a pas déjà été appelé depuis le dernier appel à `watch`.
            // Aucun signal ne peut être lu ou modifié pendant la notification.
            constructor(notify: (this: Watcher) =&gt; void);

            // Ajouter ces signaux à l’ensemble surveillé du Watcher, et configurer le watcher pour exécuter son
            // callback notify lors du prochain changement de l’un des signaux de l’ensemble (ou de l’une de ses dépendances).
            // Peut être appelé sans arguments uniquement pour réinitialiser l’état &quot;notifié&quot;, afin que
            // le callback notify soit de nouveau invoqué.
            watch(...s: Signal[]): void;

            // Retirer ces signaux de l’ensemble surveillé (par exemple, pour un effet qui est supprimé)
            unwatch(...s: Signal[]): void;

            // Retourne l’ensemble des sources dans l’ensemble surveillé du Watcher qui sont encore sales, ou un signal computed
            // avec une source sale ou en attente et qui n’a pas encore été réévalué
            getPending(): Signal[];
        }

        // Hooks pour observer quand un signal est surveillé ou ne l’est plus
        var watched: Symbol;
        var unwatched: Symbol;
    }

    interface SignalOptions&lt;T&gt; {
        // Fonction de comparaison personnalisée entre l’ancienne et la nouvelle valeur. Par défaut : Object.is.
        // Le signal est passé en tant que valeur this pour le contexte.
        equals?: (this: Signal&lt;T&gt;, t: T, t2: T) =&gt; boolean;
</code></pre>
<pre><code class="language-ts">// Callback appelé lorsque isWatched devient vrai, s'il était auparavant faux
[Signal.subtle.watched]?: (this: Signal&lt;T&gt;) =&gt; void;

// Callback appelé chaque fois que isWatched devient faux, s'il était auparavant vrai
[Signal.subtle.unwatched]?: (this: Signal&lt;T&gt;) =&gt; void;
}
}
</code></pre>
<h3>Fonctionnement des Signaux</h3>
<p>Un Signal représente une cellule de données qui peut changer au fil du temps. Les Signaux peuvent être soit de &quot;state&quot; (juste une valeur définie manuellement), soit &quot;computed&quot; (une formule basée sur d'autres Signaux).</p>
<p>Les Signaux calculés fonctionnent en suivant automatiquement les autres Signaux qui sont lus lors de leur évaluation. Lorsqu'un signal calculé est lu, il vérifie si l'une de ses dépendances précédemment enregistrées a changé, et se réévalue le cas échéant. Lorsque plusieurs signaux calculés sont imbriqués, toute l’attribution du suivi revient au signal le plus interne.</p>
<p>Les Signaux calculés sont paresseux, c’est-à-dire en mode &quot;pull&quot; : ils ne sont réévalués que lorsqu’ils sont accédés, même si l’une de leurs dépendances a changé auparavant.</p>
<p>Le callback passé dans les Signaux calculés doit généralement être &quot;pur&quot; au sens d’une fonction déterministe, sans effets de bord, des autres Signaux auxquels il accède. En même temps, le moment où le callback est appelé est déterministe, permettant d’utiliser les effets de bord avec précaution.</p>
<p>Les Signaux mettent fortement en avant le cache/mémoïsation : les Signaux d’état et les Signaux calculés mémorisent leur valeur actuelle, et ne déclenchent la réévaluation des Signaux calculés qui les référencent que s'ils changent effectivement. Une comparaison répétée de l’ancienne et de la nouvelle valeur n’est même pas nécessaire : la comparaison est effectuée une fois lorsque le Signal source est réinitialisé/réévalué, et le mécanisme de Signal garde une trace des éléments qui n’ont pas encore été mis à jour en fonction de la nouvelle valeur. En interne, cela est généralement représenté par la &quot;coloration de graphe&quot;, comme décrit dans <a href="https://raw.githubusercontent.com/tc39/proposal-signals/main/blog/graph-coloring.md">l’article de blog de Milo</a>.</p>
<p>Les Signaux calculés suivent dynamiquement leurs dépendances : à chaque exécution, ils peuvent finir par dépendre de choses différentes, et cet ensemble précis de dépendances est maintenu à jour dans le graphe de Signaux. Cela signifie que si vous avez une dépendance nécessaire dans une seule branche, et que le calcul précédent a pris l’autre branche, alors un changement de cette valeur temporairement inutilisée ne provoquera pas la réévaluation du Signal calculé, même lors d'une demande de sa valeur.</p>
<p>Contrairement aux Promesses JavaScript, tout dans les Signaux s’exécute de manière synchrone :</p>
<ul>
<li>La définition d’un Signal à une nouvelle valeur est synchrone, et cela se reflète immédiatement lors de la lecture de tout Signal calculé qui en dépend par la suite. Il n’y a pas de regroupement (&quot;batching&quot;) intégré de cette mutation.</li>
<li>La lecture des Signaux calculés est synchrone : leur valeur est toujours disponible.</li>
<li>Le callback <code>notify</code> dans les Watchers, comme expliqué ci-dessous, s’exécute de manière synchrone, lors de l’appel à <code>.set()</code> qui l’a déclenché (mais après la complétion de la coloration du graphe).</li>
</ul>
<p>Comme les Promesses, les Signaux peuvent représenter un état d’erreur : si le callback d’un Signal calculé lève une exception, alors cette erreur est mémorisée comme une valeur, et relancée à chaque lecture du Signal.</p>
<h3>Comprendre la classe Signal</h3>
<p>Une instance de <code>Signal</code> représente la capacité de lire une valeur qui change dynamiquement et dont les mises à jour sont suivies dans le temps. Elle inclut également implicitement la capacité de s’abonner au Signal, implicitement via un accès suivi depuis un autre Signal calculé.</p>
<p>L’API ici est conçue pour correspondre au consensus assez large de l’écosystème entre de nombreuses bibliothèques de Signaux concernant l’utilisation de noms comme &quot;signal&quot;, &quot;computed&quot; et &quot;state&quot;. Cependant, l’accès aux Signaux calculés et d’état se fait via une méthode <code>.get()</code>, ce qui diffère de toutes les API populaires de Signaux, qui utilisent soit un accesseur de style <code>.value</code>, soit une syntaxe d’appel <code>signal()</code>.</p>
<p>L’API est conçue pour réduire le nombre d’allocations, afin de rendre les Signaux adaptés à l’intégration dans des frameworks JavaScript tout en atteignant des performances similaires ou supérieures aux Signaux personnalisés des frameworks existants. Cela implique :</p>
<ul>
<li>Les Signaux d’état sont un unique objet inscriptible, qui peut être à la fois accédé et modifié à partir de la même référence. (Voir les implications ci-dessous dans la section &quot;Séparation des capacités&quot;.)</li>
<li>Les Signaux d’état et calculés sont conçus pour pouvoir être sous-classés, afin de faciliter l’ajout par les frameworks de propriétés supplémentaires via des champs de classe publics/privés (ainsi que des méthodes pour utiliser cet état).</li>
<li>Divers callbacks (par exemple, <code>equals</code>, le callback de computed) sont appelés avec le Signal concerné en tant que valeur de <code>this</code> pour le contexte, de sorte qu’une nouvelle closure n’est pas nécessaire par Signal. À la place, le contexte peut être sauvegardé dans des propriétés supplémentaires du signal lui-même.</li>
</ul>
<p>Certaines conditions d’erreur imposées par cette API :</p>
<ul>
<li>Il est interdit de lire un Signal calculé de façon récursive.</li>
<li>Le callback <code>notify</code> d’un Watcher ne peut ni lire ni écrire de signaux.</li>
<li>Si le callback d’un Signal calculé lève une exception, les accès ultérieurs à ce Signal relanceront cette erreur mémorisée, jusqu’à ce qu’une des dépendances change et qu’il soit recalculé.</li>
</ul>
<p>Certaines conditions qui ne sont <em>pas</em> imposées :</p>
<ul>
<li>Les Signaux calculés peuvent écrire dans d’autres Signaux, de façon synchrone dans leur callback.</li>
<li>Le travail mis en file d’attente par le callback <code>notify</code> d’un Watcher peut lire ou écrire des signaux, ce qui permet de reproduire <a href="https://react.dev/learn/you-might-not-need-an-effect">des anti-patterns React classiques</a> en termes de Signaux !</li>
</ul>
<h3>Implémentation des effets</h3>
<p>L’interface <code>Watcher</code> définie ci-dessus sert de base à l’implémentation des API JS classiques pour les effets : des callbacks réexécutés lorsque d’autres Signaux changent, uniquement pour leurs effets de bord. La fonction <code>effect</code> utilisée plus haut dans l’exemple initial peut être définie comme suit :</p>
<pre><code class="language-ts">// Cette fonction vivrait généralement dans une bibliothèque/framework, pas dans le code applicatif
// REMARQUE : Cette logique de planification est trop simple pour être utile. Ne pas copier/coller.
let pending = false;

let w = new Signal.subtle.Watcher(() =&gt; {
    if (!pending) {
        pending = true;
        queueMicrotask(() =&gt; {
            pending = false;
            for (let s of w.getPending()) s.get();
            w.watch();
        });
    }
});

// Un Signal d’effet qui évalue cb, qui programme une lecture de lui-même dans la file de micro-tâches chaque fois qu’une de ses dépendances peut changer
export function effect(cb) {
    let destructor;
    let c = new Signal.Computed(() =&gt; { destructor?.(); destructor = cb(); });
    w.watch(c);
    c.get();
    return () =&gt; { destructor?.(); w.unwatch(c) };
}
</code></pre>
<p>L’API Signal n’inclut pas de fonction intégrée comme <code>effect</code>. En effet, la planification des effets est subtile et s’intègre souvent dans les cycles de rendu des frameworks et d’autres états ou stratégies spécifiques de haut niveau, auxquels JS n’a pas accès.</p>
<p>Décomposons les différentes opérations utilisées ici : le callback <code>notify</code> passé au constructeur de <code>Watcher</code> est la fonction appelée lorsque le Signal passe d’un état &quot;propre&quot; (où l’on sait que le cache est initialisé et valide) à un état &quot;checked&quot; ou &quot;dirty&quot; (où le cache peut ne plus être valide car au moins un des états dont il dépend récursivement a changé).</p>
<p>Les appels à <code>notify</code> sont finalement déclenchés par un appel à <code>.set()</code> sur un Signal d’état. Cet appel est synchrone : il a lieu avant que <code>.set</code> ne retourne. Mais il n’est pas nécessaire de s’inquiéter que ce callback observe le graphe de Signaux dans un état partiellement traité, car pendant un callback <code>notify</code>, aucun Signal ne peut être lu ou écrit, même dans un appel à <code>untrack</code>. Comme <code>notify</code> est appelé pendant <code>.set()</code>, il interrompt un autre flux logique, qui pourrait ne pas être terminé. Pour lire ou écrire des Signaux depuis <code>notify</code>, programmez le travail pour plus tard, par exemple en enregistrant le Signal dans une liste à traiter plus tard, ou avec <code>queueMicrotask</code> comme ci-dessus.</p>
<p>Notez qu’il est parfaitement possible d’utiliser efficacement les Signaux sans <code>Signal.subtle.Watcher</code> en planifiant des interrogations (&quot;polling&quot;) de Signaux calculés, comme le fait Glimmer. Cependant, de nombreux frameworks ont constaté qu’il est très souvent utile d’exécuter cette logique de planification de façon synchrone, c’est pourquoi l’API Signals l’inclut.</p>
<p>Les Signaux calculés et d’état sont tous deux collectés par le ramasse-miettes comme n’importe quelle valeur JS. Mais les Watchers disposent d’un mécanisme spécial pour maintenir des objets vivants : tout Signal surveillé par un Watcher sera maintenu vivant tant qu’un des états sous-jacents reste accessible, car ceux-ci peuvent déclencher un futur appel à <code>notify</code> (et ensuite un futur <code>.get()</code>). Pour cette raison, pensez à appeler <code>Watcher.prototype.unwatch</code> pour nettoyer les effets.</p>
<h3>Une échappatoire dangereuse</h3>
<p><code>Signal.subtle.untrack</code> est une échappatoire permettant de lire des Signaux <em>sans</em> suivre ces lectures. Cette capacité est dangereuse car elle permet de créer des Signaux calculés dont la valeur dépend d’autres Signaux, mais qui ne sont pas mis à jour lorsque ces Signaux changent. Elle doit être utilisée uniquement lorsque les accès non suivis ne changent pas le résultat du calcul.</p>
<!--
TODO: Montrer un exemple où il est pertinent d’utiliser untrack

### Utilisation de watched/unwatched
TODO : Montrer un exemple de conversion d’un Observable en signal calculé, abonné uniquement lorsqu’il est utilisé par un effet

TODO : Montrer un exemple d’un signal calculé représentant le résultat d’un fetch dirigé vers un état, qui est annulé

### Introspection pour le SSR

TODO : Montrer comment fonctionne la sérialisation du graphe de signaux

TODO : Montrer comment « hydrater » un signal d’un état vers un calculé plus tard, en utilisant quelques signaux.
-->
<h3>Ommis pour l’instant</h3>
<p>Ces fonctionnalités pourront être ajoutées ultérieurement, mais elles ne sont pas incluses dans la version actuelle du projet. Leur omission est due à l’absence de consensus établi dans le domaine de conception entre les frameworks, ainsi qu’à la capacité démontrée de contourner leur absence avec des mécanismes supplémentaires basés sur la notion de Signals décrite dans ce document. Cependant, malheureusement, cette omission limite le potentiel d’interopérabilité entre frameworks. Lorsque des prototypes de Signals tels que décrits dans ce document seront produits, un effort sera fait pour réexaminer si ces omissions étaient la bonne décision.</p>
<ul>
<li><strong>Async</strong> : Les signaux sont toujours disponibles de manière synchrone pour l’évaluation, dans ce modèle. Cependant, il est souvent utile d’avoir certains processus asynchrones qui mènent à la modification d’un signal, et de savoir quand un signal est encore en « chargement ». Une façon simple de modéliser l’état de chargement est d’utiliser des exceptions, et le comportement de mise en cache des exceptions des signaux calculés se compose raisonnablement avec cette technique. Des techniques améliorées sont discutées dans <a href="https://github.com/proposal-signals/proposal-signals/issues/30">Issue #30</a>.</li>
<li><strong>Transactions</strong> : Pour les transitions entre vues, il est souvent utile de maintenir un état actif à la fois pour les états « de » et « vers ». L’état « vers » s’affiche en arrière-plan, jusqu’à ce qu’il soit prêt à prendre la relève (commit de la transaction), tandis que l’état « de » reste interactif. Maintenir les deux états en même temps nécessite de « forker » l’état du graphe de signaux, et il peut même être utile de prendre en charge plusieurs transitions en attente simultanément. Discussion dans <a href="https://github.com/proposal-signals/proposal-signals/issues/73">Issue #73</a>.</li>
</ul>
<p>Certaines <a href="https://github.com/proposal-signals/proposal-signals/issues/32">méthodes utilitaires</a> possibles sont également omises.</p>
<h2>Statut et plan de développement</h2>
<p>Cette proposition figure à l’agenda d’avril 2024 du TC39 pour l’étape 1. Elle peut actuellement être considérée comme « étape 0 ».</p>
<p><a href="https://github.com/proposal-signals/signal-polyfill">Un polyfill</a> pour cette proposition est disponible, avec quelques tests basiques. Certains auteurs de frameworks ont commencé à expérimenter avec le remplacement de cette implémentation de signal, mais cette utilisation en est à un stade précoce.</p>
<p>Les collaborateurs sur la proposition Signal souhaitent être particulièrement <strong>prudents</strong> dans la façon de faire avancer cette proposition, afin d’éviter de se retrouver piégés avec quelque chose qui serait publié, mais que l’on regretterait et n’utiliserait finalement pas. Notre plan est d’effectuer les tâches supplémentaires suivantes, non requises par le processus TC39, afin de s’assurer que cette proposition est sur la bonne voie :</p>
<p>Avant de proposer pour l’étape 2, nous prévoyons de :</p>
<ul>
<li>Développer plusieurs implémentations polyfill de niveau production, solides, bien testées (par exemple, réussissant les tests de divers frameworks ainsi que des tests de type test262) et performantes (comme vérifié par un ensemble de benchmarks signal/framework complet).</li>
<li>Intégrer l’API Signal proposée dans un grand nombre de frameworks JS que nous considérons comme représentatifs, et quelques grandes applications fonctionnant avec cette base. Tester son efficacité et sa correction dans ces contextes.</li>
<li>Avoir une compréhension solide de l’espace des extensions possibles à l’API, et avoir conclu lesquelles (le cas échéant) doivent être ajoutées à cette proposition.</li>
</ul>
<h2>Algorithmes de Signal</h2>
<p>Cette section décrit chacune des API exposées à JavaScript, en termes des algorithmes qu’elles implémentent. On peut la considérer comme une proto-spécification, et elle est incluse à ce stade précoce pour fixer un ensemble possible de sémantiques, tout en restant très ouvert aux changements.</p>
<p>Certains aspects de l’algorithme :</p>
<ul>
<li>L’ordre de lecture des Signaux à l’intérieur d’un calculé est significatif, et il est observable dans l’ordre d’exécution de certains callbacks (<code>Watcher</code> invoqué, <code>equals</code>, le premier paramètre de <code>new Signal.Computed</code>, et les callbacks <code>watched</code>/<code>unwatched</code>). Cela signifie que les sources d’un Signal calculé doivent être stockées de manière ordonnée.</li>
<li>Ces quatre callbacks peuvent tous lancer des exceptions, et ces exceptions sont propagées de manière prévisible au code JS appelant. Les exceptions ne <em>stoppent pas</em> l’exécution de cet algorithme et ne laissent pas le graphe dans un état partiellement traité. Pour les erreurs levées dans le callback <code>notify</code> d’un Watcher, cette exception est transmise à l’appel <code>.set()</code> qui l’a déclenchée, en utilisant un AggregateError si plusieurs exceptions sont levées. Les autres (y compris <code>watched</code>/<code>unwatched</code> ?) sont stockées dans la valeur du Signal, pour être relancées lors de la lecture, et un Signal relançant ainsi une exception peut être marqué <code>~clean~</code> comme n’importe quel autre ayant une valeur normale.</li>
<li>Des précautions sont prises pour éviter les circularités dans le cas de signaux calculés qui ne sont pas « observés » (surveillés par un Watcher), afin qu’ils puissent être collectés séparément des autres parties du graphe de signaux. En interne, cela peut être implémenté avec un système de numéros de génération toujours collectés ; notez que les implémentations optimisées peuvent aussi inclure des numéros de génération locaux par nœud, ou éviter de suivre certains numéros sur les signaux surveillés.</li>
</ul>
<h3>État global caché</h3>
<p>Les algorithmes de Signal doivent référencer certains états globaux. Cet état est global pour tout le thread, ou « agent ».</p>
<ul>
<li><code>computing</code> : Le signal calculé ou d’effet le plus interne actuellement réévalué suite à un appel <code>.get</code> ou <code>.run</code>, ou <code>null</code>. Initialement <code>null</code>.</li>
<li><code>frozen</code> : Booléen indiquant si un callback s’exécute actuellement et nécessite que le graphe ne soit pas modifié. Initialement <code>false</code>.</li>
<li><code>generation</code> : Un entier incrémental, commençant à 0, utilisé pour suivre l’actualité d’une valeur tout en évitant les circularités.</li>
</ul>
<h3>L’espace de noms <code>Signal</code></h3>
<p><code>Signal</code> est un objet ordinaire servant d’espace de noms pour les classes et fonctions liées aux Signaux.</p>
<p><code>Signal.subtle</code> est un objet espace de noms interne similaire.</p>
<h3>La classe <code>Signal.State</code></h3>
<h4>Slots internes de <code>Signal.State</code></h4>
<ul>
<li><code>value</code> : La valeur actuelle du signal d’état</li>
<li><code>equals</code> : La fonction de comparaison utilisée lors des changements de valeur</li>
<li><code>watched</code> : Le callback appelé quand le signal devient observé par un effet</li>
<li><code>unwatched</code> : Le callback appelé quand le signal n’est plus observé par un effet</li>
<li><code>sinks</code> : Ensemble des signaux surveillés dépendant de celui-ci</li>
</ul>
<h4>Constructeur : <code>Signal.State(initialValue, options)</code></h4>
<ol>
<li>Définit la propriété <code>value</code> de ce Signal sur <code>initialValue</code>.</li>
<li>Définit la propriété <code>equals</code> de ce Signal sur options?.equals</li>
<li>Définit la propriété <code>watched</code> de ce Signal sur options?.[Signal.subtle.watched]</li>
<li>Définit la propriété <code>unwatched</code> de ce Signal sur options?.[Signal.subtle.unwatched]</li>
<li>Définit la propriété <code>sinks</code> de ce Signal comme ensemble vide</li>
</ol>
<h4>Méthode : <code>Signal.State.prototype.get()</code></h4>
<ol>
<li>Si <code>frozen</code> est vrai, lancer une exception.</li>
<li>Si <code>computing</code> n’est pas <code>undefined</code>, ajouter ce Signal à l’ensemble <code>sources</code> de <code>computing</code>.</li>
<li>REMARQUE : On n’ajoute pas <code>computing</code> à l’ensemble <code>sinks</code> de ce Signal tant qu’il n’est pas surveillé par un Watcher.</li>
<li>Retourner la valeur de ce Signal.</li>
</ol>
<h4>Méthode : <code>Signal.State.prototype.set(newValue)</code></h4>
<ol>
<li>Si le contexte d’exécution courant est <code>frozen</code>, lancer une exception.</li>
<li>Exécuter l’algorithme « set Signal value » avec ce Signal et la première valeur passée en paramètre.</li>
<li>Si cet algorithme a retourné <code>~clean~</code>, retourner undefined.</li>
<li>Mettre à jour la propriété <code>state</code> de tous les <code>sinks</code> de ce Signal à (si c’est un Signal Calculé) <code>~dirty~</code> s’ils étaient auparavant propres, ou (si c’est un Watcher) à <code>~pending~</code> s’il était auparavant <code>~watching~</code>.</li>
<li>Mettre à jour la propriété <code>state</code> de toutes les dépendances de type Signal Calculé (récursivement) des sinks à <code>~checked~</code> si elles étaient auparavant <code>~clean~</code> (c’est-à-dire, laisser les marquages dirty en place), ou pour les Watchers, à <code>~pending~</code> si auparavant <code>~watching~</code>.</li>
<li>Pour chaque Watcher précédemment <code>~watching~</code> rencontré lors de cette recherche récursive, puis en ordre de profondeur :
<ol>
<li>Définir <code>frozen</code> à true.</li>
<li>Appeler leur callback <code>notify</code> (en sauvegardant toute exception levée, mais en ignorant la valeur de retour de <code>notify</code>).</li>
<li>Restaurer <code>frozen</code> à false.</li>
<li>Définir l’état du Watcher à <code>~waiting~</code>.</li>
</ol>
</li>
<li>Si une exception a été levée depuis les callbacks <code>notify</code>, la propager à l’appelant après l’exécution de tous les callbacks <code>notify</code>. S’il y a plusieurs exceptions, les regrouper dans un AggregateError et les lancer.</li>
<li>Retourner undefined.</li>
</ol>
<h3>La classe <code>Signal.Computed</code></h3>
<h4>Machine à états de <code>Signal.Computed</code></h4>
<p>L’<code>état</code> d’un Signal Calculé peut être l’un des suivants :</p>
<ul>
<li><code>~clean~</code> : La valeur du Signal est présente et connue pour ne pas être obsolète.</li>
<li><code>~checked~</code> : Une source (indirecte) de ce Signal a changé ; ce Signal a une valeur mais elle <em>peut</em> être obsolète. On ne saura si elle est effectivement obsolète que lorsque toutes les sources immédiates auront été évaluées.</li>
<li><code>~computing~</code> : Le callback de ce Signal est actuellement en cours d’exécution suite à un appel <code>.get()</code>.</li>
<li><code>~dirty~</code> : Ce Signal a soit une valeur connue pour être obsolète, soit il n’a jamais été évalué.</li>
</ul>
<p>Le graphe de transition est le suivant :</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; dirty
    dirty --&gt; computing: [4]
    computing --&gt; clean: [5]
    clean --&gt; dirty: [2]
    clean --&gt; checked: [3]
    checked --&gt; clean: [6]
    checked --&gt; dirty: [1]
</code></pre>
<p>Les transitions sont :
| Numéro | De | À | Condition | Algorithme |
| ------ | ---- | -- | --------- | --------- |
| 1 | <code>~checked~</code> | <code>~dirty~</code> | Une source immédiate de ce signal, qui est un signal calculé, a été évaluée et sa valeur a changé. | Algorithme : recalculer un signal calculé obsolète |
| 2 | <code>~clean~</code> | <code>~dirty~</code> | Une source immédiate de ce signal, qui est un State, a été définie avec une valeur différente de sa précédente valeur. | Méthode : <code>Signal.State.prototype.set(newValue)</code> |
| 3 | <code>~clean~</code> | <code>~checked~</code> | Une source récursive, mais pas immédiate, de ce signal, qui est un State, a été définie avec une valeur différente de sa précédente valeur. | Méthode : <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~dirty~</code> | <code>~computing~</code> | On est sur le point d’exécuter le <code>callback</code>. | Algorithme : recalculer un signal calculé obsolète |
| 5 | <code>~computing~</code> | <code>~clean~</code> | Le <code>callback</code> a terminé son évaluation et a soit retourné une valeur, soit levé une exception. | Algorithme : recalculer un signal calculé obsolète |
| 6 | <code>~checked~</code> | <code>~clean~</code> | Toutes les sources immédiates de ce signal ont été évaluées, et toutes ont été découvertes inchangées, donc on sait maintenant qu’il n’est pas obsolète. | Algorithme : recalculer un signal calculé obsolète |</p>
<h4>Slots internes de <code>Signal.Computed</code></h4>
<ul>
<li><code>value</code> : La précédente valeur en cache du Signal, ou <code>~uninitialized~</code> pour un Signal calculé jamais lu. La valeur peut être une exception qui sera relancée lors de la lecture de la valeur. Toujours <code>undefined</code> pour les effect signals.</li>
<li><code>state</code> : Peut être <code>~clean~</code>, <code>~checked~</code>, <code>~computing~</code> ou <code>~dirty~</code>.</li>
<li><code>sources</code> : Un ensemble ordonné de Signaux dont dépend ce Signal.</li>
<li><code>sinks</code> : Un ensemble ordonné de Signaux qui dépendent de ce Signal.</li>
<li><code>equals</code> : La méthode d’égalité fournie dans les options.</li>
<li><code>callback</code> : Le callback appelé pour obtenir la valeur du Signal calculé. Défini au premier paramètre passé au constructeur.</li>
</ul>
<h4>Constructeur de <code>Signal.Computed</code></h4>
<p>Le constructeur définit :</p>
<ul>
<li><code>callback</code> à son premier paramètre</li>
<li><code>equals</code> basé sur les options, par défaut à <code>Object.is</code> si absent</li>
<li><code>state</code> à <code>~dirty~</code></li>
<li><code>value</code> à <code>~uninitialized~</code></li>
</ul>
<p>Avec <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a>, le callback passé à <code>new Signal.Computed</code> ferme sur le snapshot du moment de l’appel du constructeur, et restaure ce snapshot pendant son exécution.</p>
<h4>Méthode : <code>Signal.Computed.prototype.get</code></h4>
<ol>
<li>Si le contexte d’exécution courant est <code>frozen</code> ou si ce Signal a l’état <code>~computing~</code>, ou si ce signal est un Watcher et <code>computing</code> un Signal calculé, lever une exception.</li>
<li>Si <code>computing</code> n’est pas <code>null</code>, ajouter ce Signal à l’ensemble <code>sources</code> de <code>computing</code>.</li>
<li>REMARQUE : On n’ajoute pas <code>computing</code> à l’ensemble <code>sinks</code> de ce Signal tant qu’il n’est pas observé par un Watcher.</li>
<li>Si l’état de ce Signal est <code>~dirty~</code> ou <code>~checked~</code> : Répéter les étapes suivantes jusqu’à ce que ce Signal soit <code>~clean~</code> :
<ol>
<li>Remonter via <code>sources</code> pour trouver la source récursive la plus profonde et la plus à gauche (c’est-à-dire la première observée) qui est un Signal Calculé marqué <code>~dirty~</code> (arrêter la recherche en atteignant un Signal Calculé <code>~clean~</code>, et inclure ce Signal Calculé comme dernier à chercher).</li>
<li>Exécuter l’algorithme « recalculer un signal calculé obsolète » sur ce Signal.</li>
</ol>
</li>
<li>À ce stade, l’état de ce Signal sera <code>~clean~</code>, et aucune source récursive ne sera <code>~dirty~</code> ni <code>~checked~</code>. Retourner la <code>value</code> du Signal. Si la valeur est une exception, relancer cette exception.</li>
</ol>
<h3>La classe <code>Signal.subtle.Watcher</code></h3>
<h4>Machine à états de <code>Signal.subtle.Watcher</code></h4>
<p>L’<code>état</code> d’un Watcher peut être l’un des suivants :</p>
<ul>
<li><code>~waiting~</code> : Le callback <code>notify</code> a été exécuté, ou le Watcher est nouveau, mais il ne surveille activement aucun signal.</li>
<li><code>~watching~</code> : Le Watcher surveille activement des signaux, mais aucun changement n’a encore eu lieu nécessitant un callback <code>notify</code>.</li>
<li><code>~pending~</code> : Une dépendance du Watcher a changé, mais le callback <code>notify</code> n’a pas encore été exécuté.</li>
</ul>
<p>Le graphe de transition est le suivant :</p>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; waiting
    waiting --&gt; watching: [1]
    watching --&gt; waiting: [2]
    watching --&gt; pending: [3]
    pending --&gt; waiting: [4]
</code></pre>
<p>Les transitions sont :
| Numéro | De | À | Condition | Algorithme |
| ------ | ---- | -- | --------- | --------- |
| 1 | <code>~waiting~</code> | <code>~watching~</code> | La méthode <code>watch</code> du Watcher a été appelée. | Méthode : <code>Signal.subtle.Watcher.prototype.watch(...signals)</code> |
| 2 | <code>~watching~</code> | <code>~waiting~</code> | La méthode <code>unwatch</code> du Watcher a été appelée et le dernier signal surveillé a été supprimé. | Méthode : <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code> |
| 3 | <code>~watching~</code> | <code>~pending~</code> | Un signal surveillé a pu changer de valeur. | Méthode : <code>Signal.State.prototype.set(newValue)</code> |
| 4 | <code>~pending~</code> | <code>~waiting~</code> | Le callback <code>notify</code> a été exécuté. | Méthode : <code>Signal.State.prototype.set(newValue)</code> |</p>
<h4>Slots internes de <code>Signal.subtle.Watcher</code></h4>
<ul>
<li><code>state</code> : Peut être <code>~watching~</code>, <code>~pending~</code> ou <code>~waiting~</code></li>
<li><code>signals</code> : Un ensemble ordonné de Signaux surveillés par ce Watcher</li>
<li><code>notifyCallback</code> : Le callback appelé lorsqu’un changement se produit. Défini au premier paramètre passé au constructeur.</li>
</ul>
<h4>Constructeur : <code>new Signal.subtle.Watcher(callback)</code></h4>
<ol>
<li><code>state</code> est initialisé à <code>~waiting~</code>.</li>
<li>Initialiser <code>signals</code> comme un ensemble vide.</li>
<li><code>notifyCallback</code> est défini au paramètre callback.
Avec <a href="https://github.com/tc39/proposal-async-context">AsyncContext</a>, le callback passé à <code>new Signal.subtle.Watcher</code> ne ferme <em>pas</em> sur l’instantané du moment où le constructeur a été appelé, afin que l’information contextuelle autour de l’écriture soit visible.</li>
</ol>
<h4>Méthode : <code>Signal.subtle.Watcher.prototype.watch(...signals)</code></h4>
<ol>
<li>Si <code>frozen</code> est vrai, lancez une exception.</li>
<li>Si l’un des arguments n’est pas un signal, lancez une exception.</li>
<li>Ajoutez tous les arguments à la fin du champ <code>signals</code> de cet objet.</li>
<li>Pour chaque signal nouvellement surveillé, de gauche à droite,
<ol>
<li>Ajoutez ce watcher comme un <code>sink</code> à ce signal.</li>
<li>Si c’était le premier sink, alors remontez vers les sources pour ajouter ce signal comme un sink.</li>
<li>Définissez <code>frozen</code> à true.</li>
<li>Appelez le callback <code>watched</code> s’il existe.</li>
<li>Restaurez <code>frozen</code> à false.</li>
</ol>
</li>
<li>Si l’état du Signal est <code>~waiting~</code>, alors définissez-le à <code>~watching~</code>.</li>
</ol>
<h4>Méthode : <code>Signal.subtle.Watcher.prototype.unwatch(...signals)</code></h4>
<ol>
<li>Si <code>frozen</code> est vrai, lancez une exception.</li>
<li>Si l’un des arguments n’est pas un signal, ou n’est pas surveillé par ce watcher, lancez une exception.</li>
<li>Pour chaque signal dans les arguments, de gauche à droite,
<ol>
<li>Retirez ce signal de l’ensemble <code>signals</code> de ce Watcher.</li>
<li>Retirez ce Watcher de l’ensemble <code>sink</code> de ce Signal.</li>
<li>Si l’ensemble <code>sink</code> de ce Signal devient vide, retirez ce Signal comme un sink de chacune de ses sources.</li>
<li>Définissez <code>frozen</code> à true.</li>
<li>Appelez le callback <code>unwatched</code> s’il existe.</li>
<li>Restaurez <code>frozen</code> à false.</li>
</ol>
</li>
<li>Si le watcher n’a maintenant plus de <code>signals</code>, et que son état est <code>~watching~</code>, alors définissez-le à <code>~waiting~</code>.</li>
</ol>
<h4>Méthode : <code>Signal.subtle.Watcher.prototype.getPending()</code></h4>
<ol>
<li>Retournez un tableau contenant le sous-ensemble des <code>signals</code> qui sont des Signaux Calculés dans les états <code>~dirty~</code> ou <code>~pending~</code>.</li>
</ol>
<h3>Méthode : <code>Signal.subtle.untrack(cb)</code></h3>
<ol>
<li>Laissez <code>c</code> être l’état <code>computing</code> courant du contexte d’exécution.</li>
<li>Définissez <code>computing</code> à null.</li>
<li>Appelez <code>cb</code>.</li>
<li>Restaurez <code>computing</code> à <code>c</code> (même si <code>cb</code> a lancé une exception).</li>
<li>Retournez la valeur de retour de <code>cb</code> (en relançant toute exception).</li>
</ol>
<p>Remarque : <code>untrack</code> ne vous sort pas de l’état <code>frozen</code>, qui est strictement maintenu.</p>
<h3>Méthode : <code>Signal.subtle.currentComputed()</code></h3>
<ol>
<li>Retournez la valeur actuelle de <code>computing</code>.</li>
</ol>
<h3>Algorithmes communs</h3>
<h5>Algorithme : recalculer un Signal Calculé sale</h5>
<ol>
<li>Videz l’ensemble <code>sources</code> de ce Signal, et retirez-le des ensembles <code>sinks</code> de ces sources.</li>
<li>Sauvegardez la valeur précédente de <code>computing</code> et définissez <code>computing</code> à ce Signal.</li>
<li>Définissez l’état de ce Signal à <code>~computing~</code>.</li>
<li>Exécutez le callback de ce Signal Calculé, en utilisant ce Signal comme valeur de <code>this</code>. Sauvegardez la valeur de retour, et si le callback a lancé une exception, stockez-la pour la relancer.</li>
<li>Restaurez la valeur précédente de <code>computing</code>.</li>
<li>Appliquez l’algorithme &quot;définir la valeur du Signal&quot; à la valeur de retour du callback.</li>
<li>Définissez l’état de ce Signal à <code>~clean~</code>.</li>
<li>Si cet algorithme a retourné <code>~dirty~</code> : marquez tous les sinks de ce Signal comme <code>~dirty~</code> (auparavant, les sinks pouvaient être un mélange de checked et dirty). (Ou, si ce Signal n’est pas surveillé, adoptez un nouveau numéro de génération pour indiquer la saleté, ou quelque chose de ce genre.)</li>
<li>Sinon, si l’algorithme a retourné <code>~clean~</code> : dans ce cas, pour chaque sink <code>~checked~</code> de ce Signal, si toutes les sources de ce Signal sont maintenant propres, marquez ce Signal comme <code>~clean~</code> également. Appliquez cette étape de nettoyage aux autres sinks récursivement, à tout Signal nouvellement propre qui a des sinks checked. (Ou, si ce Signal n’est pas surveillé, indiquez-le d’une manière ou d’une autre, afin que le nettoyage puisse se faire de manière paresseuse.)</li>
</ol>
<h5>Algorithme définir la valeur du Signal</h5>
<ol>
<li>Si cet algorithme a reçu une valeur (par opposition à une exception à relancer, depuis l’algorithme de recalcul d’un Signal Calculé sale) :
<ol>
<li>Appelez la fonction <code>equals</code> de ce Signal, en passant comme paramètres la <code>value</code> courante, la nouvelle valeur, et ce Signal. Si une exception est lancée, sauvegardez cette exception (pour la relancer lors de la lecture) comme valeur du Signal et continuez comme si le callback avait retourné false.</li>
<li>Si cette fonction a retourné true, retournez <code>~clean~</code>.</li>
</ol>
</li>
<li>Définissez la <code>value</code> de ce Signal à la valeur passée en paramètre.</li>
<li>Retournez <code>~dirty~</code></li>
</ol>
<h2>FAQ</h2>
<p><strong>Q</strong> : N’est-il pas un peu tôt pour standardiser quelque chose lié aux Signaux, alors qu’ils viennent tout juste de devenir tendance en 2022 ? Ne devrait-on pas leur laisser plus de temps pour évoluer et se stabiliser ?</p>
<p><strong>R</strong> : L’état actuel des Signaux dans les frameworks web est le fruit de plus de 10 ans de développement continu. À mesure que les investissements augmentent, comme c’est le cas ces dernières années, quasiment tous les frameworks web convergent vers un modèle de base très similaire pour les Signaux. Cette proposition est le résultat d’un exercice de conception partagé entre un grand nombre de leaders actuels des frameworks web, et elle ne sera pas poussée vers la standardisation sans validation par ce groupe d’experts du domaine dans divers contextes.</p>
<h4>Comment les Signaux sont-ils utilisés ?</h4>
<p><strong>Q</strong> : Les Signaux intégrés peuvent-ils même être utilisés par les frameworks, étant donné leur forte intégration avec le rendu et la gestion de la propriété ?</p>
<p><strong>R</strong> : Les parties les plus spécifiques aux frameworks concernent généralement les effets, la planification (scheduling), et la gestion/propriété, ce que cette proposition ne tente pas de résoudre. Notre première priorité avec la standardisation des Signaux est de valider qu’ils peuvent fonctionner &quot;en dessous&quot; des frameworks existants de manière compatible et avec de bonnes performances.</p>
<p><strong>Q</strong> : L’API Signal est-elle destinée à être utilisée directement par les développeurs d’applications, ou enveloppée par des frameworks ?</p>
<p><strong>R</strong> : Bien que cette API puisse être utilisée directement par les développeurs d’applications (au moins la partie qui n’est pas dans l’espace de noms <code>Signal.subtle</code>), elle n’est pas conçue pour être particulièrement ergonomique. À la place, les besoins des auteurs de bibliothèques/frameworks sont prioritaires. La plupart des frameworks devraient envelopper même les API de base <code>Signal.State</code> et <code>Signal.Computed</code> avec quelque chose d’adapté à leur ergonomie. En pratique, il est généralement préférable d’utiliser les Signaux via un framework, qui gère les fonctionnalités plus complexes (par exemple, Watcher, <code>untrack</code>), ainsi que la gestion de la propriété et la destruction (par exemple, déterminer quand les signaux doivent être ajoutés ou retirés des watchers), et la planification du rendu vers le DOM — cette proposition ne tente pas de résoudre ces problèmes.</p>
<p><strong>Q</strong> : Dois-je détruire les Signaux liés à un widget lorsque ce widget est détruit ? Quelle est l’API pour cela ?</p>
<p><strong>R</strong> : L’opération de destruction pertinente ici est <code>Signal.subtle.Watcher.prototype.unwatch</code>. Seuls les Signaux surveillés doivent être nettoyés (en les désurveillance), tandis que les Signaux non surveillés peuvent être collectés automatiquement par le garbage collector.</p>
<p><strong>Q</strong> : Les Signaux fonctionnent-ils avec le VDOM, ou directement avec le DOM HTML sous-jacent ?</p>
<p><strong>R</strong> : Oui ! Les Signaux sont indépendants de la technologie de rendu. Les frameworks JavaScript existants qui utilisent des constructions proches des Signaux s’intègrent avec le VDOM (par exemple, Preact), le DOM natif (par exemple, Solid) et une combinaison des deux (par exemple, Vue). Il en sera de même pour les Signaux natifs.</p>
<p><strong>Q</strong> : Est-ce que l’utilisation des Signaux sera ergonomique dans le contexte de frameworks à base de classes comme Angular et Lit ? Qu’en est-il des frameworks basés sur un compilateur comme Svelte ?</p>
<p><strong>R</strong> : Les champs de classe peuvent être rendus basés sur les Signaux via un simple décorateur d’accesseur, comme montré dans <a href="https://github.com/proposal-signals/signal-polyfill#combining-signals-and-decorators">le readme du polyfill Signal</a>. Les Signaux sont très proches des Runes de Svelte 5 — il est simple pour un compilateur de transformer les runes en API Signal telle que définie ici, et en fait c’est ce que fait Svelte 5 en interne (mais avec sa propre bibliothèque de Signaux).</p>
<p><strong>Q</strong> : Les Signaux fonctionnent-ils avec le SSR ? L’hydratation ? La résumabilité ?</p>
<p><strong>R</strong> : Oui. Qwik utilise les Signaux avec succès pour ces deux propriétés, et d’autres frameworks ont d’autres approches bien développées pour l’hydratation avec les Signaux, avec différents compromis. Nous pensons qu’il est possible de modéliser les Signaux résumables de Qwik en utilisant un Signal State et un Signal Computed reliés ensemble, et nous prévoyons de le prouver en code.
<strong>Q</strong> : Les signaux fonctionnent-ils avec un flux de données unidirectionnel, comme le fait React ?</p>
<p><strong>R</strong> : Oui, les signaux sont un mécanisme pour le flux de données unidirectionnel. Les frameworks d'interface utilisateur basés sur les signaux vous permettent d'exprimer votre vue comme une fonction du modèle (où le modèle intègre des signaux). Un graphe d’état et de signaux calculés est acyclique par construction. Il est également possible de recréer les anti-patterns de React avec les signaux (!), par exemple, l’équivalent signal de <code>setState</code> dans <code>useEffect</code> consiste à utiliser un Watcher pour planifier une écriture sur un signal d’état.</p>
<p><strong>Q</strong> : Comment les signaux se rapportent-ils aux systèmes de gestion d’état comme Redux ? Les signaux encouragent-ils un état non structuré ?</p>
<p><strong>R</strong> : Les signaux peuvent constituer une base efficace pour des abstractions de gestion d’état de type store. Un schéma courant trouvé dans plusieurs frameworks est un objet basé sur un Proxy qui représente en interne les propriétés à l’aide de signaux, par exemple <a href="https://vuejs.org/api/reactivity-core.html#reactive">Vue <code>reactive()</code></a>, ou <a href="https://docs.solidjs.com/concepts/stores">Solid stores</a>. Ces systèmes permettent de regrouper l’état de manière flexible au niveau d’abstraction adapté à l’application concernée.</p>
<p><strong>Q</strong> : Qu’apportent les signaux que le <code>Proxy</code> ne gère pas actuellement ?</p>
<p><strong>R</strong> : Les proxys et les signaux sont complémentaires et fonctionnent bien ensemble. Les proxys permettent d’intercepter les opérations superficielles sur les objets et les signaux coordonnent un graphe de dépendances (de cellules). Adosser un Proxy à des signaux est un excellent moyen de créer une structure réactive imbriquée avec une bonne ergonomie.</p>
<p>Dans cet exemple, nous pouvons utiliser un proxy pour que le signal dispose d’une propriété getter et setter au lieu d’utiliser les méthodes <code>get</code> et <code>set</code> :</p>
<pre><code class="language-js">const a = new Signal.State(0);
const b = new Proxy(a, {
  get(target, property, receiver) {
    if (property === 'value') {
      return target.get():
    }
  }
  set(target, property, value, receiver) {
    if (property === 'value') {
      target.set(value)!
    }
  }
});

// utilisation dans un contexte réactif hypothétique :
&lt;template&gt;
  {b.value}

  &lt;button onclick={() =&gt; {
    b.value++;
  }}&gt;changer&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>En utilisant un renderer optimisé pour la réactivité fine, cliquer sur le bouton entraînera la mise à jour de la cellule <code>b.value</code>.</p>
<p>Voir :</p>
<ul>
<li>exemples de structures réactives imbriquées créées avec les signaux et les proxys : <a href="https://github.com/NullVoxPopuli/signal-utils/tree/main/src">signal-utils</a></li>
<li>exemple d’implémentations antérieures montrant la relation entre les données réactives et les proxys : <a href="https://github.com/tracked-tools/tracked-built-ins/tree/master/addon/src/-private">tracked-built-ins</a></li>
<li><a href="https://github.com/proposal-signals/proposal-signals/issues/101#issuecomment-2029802574">discussion</a>.</li>
</ul>
<h4>Comment fonctionnent les signaux ?</h4>
<p><strong>Q</strong> : Les signaux sont-ils basés sur le push ou le pull ?</p>
<p><strong>R</strong> : L’évaluation des signaux calculés est basée sur le pull : les signaux calculés ne sont évalués que lorsque <code>.get()</code> est appelé, même si l’état sous-jacent a changé bien avant. En même temps, la modification d’un signal d’état peut immédiatement déclencher le callback d’un Watcher, &quot;poussant&quot; la notification. Les signaux peuvent donc être considérés comme une construction &quot;push-pull&quot;.</p>
<p><strong>Q</strong> : Les signaux introduisent-ils du non-déterminisme dans l’exécution JavaScript ?</p>
<p><strong>R</strong> : Non. D’une part, toutes les opérations sur les signaux ont une sémantique et un ordre bien définis, qui ne diffèrent pas selon les implémentations conformes. À un niveau supérieur, les signaux respectent un certain ensemble d’invariants, par rapport auxquels ils sont &quot;cohérents&quot;. Un signal calculé observe toujours le graphe de signaux dans un état cohérent, et son exécution n’est pas interrompue par d’autres codes modifiant des signaux (sauf pour ce qu’il appelle lui-même). Voir la description ci-dessus.</p>
<p><strong>Q</strong> : Quand j’écris sur un signal d’état, quand la mise à jour du signal calculé est-elle planifiée ?</p>
<p><strong>R</strong> : Elle n’est pas planifiée ! Le signal calculé se recalculera la prochaine fois que quelqu’un le lira. De façon synchrone, le callback <code>notify</code> d’un Watcher peut être appelé, permettant aux frameworks de planifier une lecture au moment qu’ils jugent approprié.</p>
<p><strong>Q</strong> : Quand les écritures sur les signaux d’état prennent-elles effet ? Immédiatement, ou sont-elles regroupées ?</p>
<p><strong>R</strong> : Les écritures sur les signaux d’état sont reflétées immédiatement — la prochaine fois qu’un signal calculé dépendant du signal d’état est lu, il se recalculera si besoin, même si c’est à la ligne de code immédiatement suivante. Cependant, la paresse inhérente à ce mécanisme (les signaux calculés ne sont calculés que lorsqu’ils sont lus) fait que, dans la pratique, les calculs peuvent avoir lieu de manière groupée.</p>
<p><strong>Q</strong> : Que signifie pour les signaux de permettre une exécution &quot;sans glitch&quot; ?</p>
<p><strong>R</strong> : Les anciens modèles basés sur le push pour la réactivité faisaient face à un problème de calculs redondants : Si une mise à jour d’un signal d’état provoque l’exécution immédiate d’un signal calculé, cela peut finir par déclencher une mise à jour de l’UI. Mais cette écriture dans l’UI peut être prématurée, s’il devait y avoir un autre changement du signal d’état d’origine avant la prochaine frame. Parfois, des valeurs intermédiaires incorrectes étaient même montrées aux utilisateurs finaux à cause de tels <a href="https://en.wikipedia.org/wiki/Reactive_programming#Glitches">glitches</a>. Les signaux évitent cette dynamique en étant basés sur le pull plutôt que sur le push : Au moment où le framework planifie le rendu de l’UI, il va tirer les mises à jour appropriées, évitant ainsi du travail inutile, tant dans le calcul que dans l’écriture dans le DOM.</p>
<p><strong>Q</strong> : Que signifie pour les signaux d’être &quot;perdants&quot; (lossy) ?</p>
<p><strong>R</strong> : C’est le revers de l’exécution sans glitch : les signaux représentent une cellule de données — juste la valeur courante immédiate (qui peut changer), pas un flux de données dans le temps. Ainsi, si vous écrivez deux fois de suite sur un signal d’état sans rien faire d’autre, la première écriture est &quot;perdue&quot; et jamais vue par aucun signal calculé ou effet. Ceci est considéré comme une fonctionnalité et non un bug — d’autres constructions (par ex., les itérables asynchrones, les observables) sont plus adaptées aux flux.</p>
<p><strong>Q</strong> : Les signaux natifs seront-ils plus rapides que les implémentations existantes de signaux en JS ?</p>
<p><strong>R</strong> : Nous l’espérons (d’un petit facteur constant), mais cela reste à prouver dans le code. Les moteurs JS ne font pas de magie, et devront finalement implémenter les mêmes types d’algorithmes que les implémentations JS des signaux. Voir la section ci-dessus sur les performances.</p>
<h4>Pourquoi les signaux sont-ils conçus de cette façon ?</h4>
<p><strong>Q</strong> : Pourquoi cette proposition n’inclut-elle pas de fonction <code>effect()</code>, alors que les effets sont nécessaires à toute utilisation pratique des signaux ?</p>
<p><strong>R</strong> : Les effets sont intrinsèquement liés à la planification et à la suppression, qui sont gérées par les frameworks et hors du champ de cette proposition. À la place, cette proposition inclut la base pour implémenter des effets via l’API plus bas niveau <code>Signal.subtle.Watcher</code>.</p>
<p><strong>Q</strong> : Pourquoi les abonnements sont-ils automatiques plutôt que de fournir une interface manuelle ?</p>
<p><strong>R</strong> : L’expérience a montré que les interfaces d’abonnement manuelles pour la réactivité sont peu ergonomiques et sujettes aux erreurs. Le suivi automatique est plus composable et constitue une fonctionnalité clé des signaux.</p>
<p><strong>Q</strong> : Pourquoi le callback du <code>Watcher</code> s’exécute-t-il de façon synchrone, plutôt que planifié dans une micro-tâche ?</p>
<p><strong>R</strong> : Parce que le callback ne peut ni lire ni écrire des signaux, il n’y a pas d’incohérence à l’appeler de façon synchrone. Un callback typique ajoutera un signal à un Array pour être lu plus tard, ou marquera un bit quelque part. Il est inutile et coûteux en pratique de créer une micro-tâche séparée pour ce genre d’actions.</p>
<p><strong>Q</strong> : Cette API manque de certaines choses agréables que mon framework préféré fournit, ce qui facilite la programmation avec les signaux. Peut-on aussi les ajouter au standard ?</p>
<p><strong>R</strong> : Peut-être. Diverses extensions sont encore à l’étude. Merci d’ouvrir une issue pour lancer la discussion sur toute fonctionnalité manquante que vous jugez importante.</p>
<p><strong>Q</strong> : Cette API peut-elle être réduite en taille ou en complexité ?</p>
<p><strong>R</strong> : Il est clairement souhaité de garder cette API minimale, et nous avons essayé de le faire avec ce qui est présenté ci-dessus. Si vous avez des idées pour retirer d’autres éléments, merci d’ouvrir une issue pour en discuter.</p>
<h4>Comment les signaux sont-ils standardisés ?</h4>
<p><strong>Q</strong> : Ne devrait-on pas commencer le travail de standardisation dans ce domaine avec un concept plus primitif, comme les observables ?
<strong>A</strong> : Les observables peuvent être une bonne idée pour certaines choses, mais ils ne résolvent pas les problèmes que les Signaux visent à résoudre. Comme décrit ci-dessus, les observables ou d'autres mécanismes de publication/abonnement ne sont pas une solution complète pour de nombreux types de programmation d'interface utilisateur, en raison d'une configuration trop sujette aux erreurs pour les développeurs, et d'un travail gaspillé dû au manque de paresse, entre autres problèmes.</p>
<p><strong>Q</strong> : Pourquoi les Signaux sont-ils proposés au sein de TC39 plutôt qu'au sein du DOM, étant donné que la plupart de leurs applications sont basées sur le web ?</p>
<p><strong>A</strong> : Certains coauteurs de cette proposition s'intéressent aux environnements d'interface utilisateur non web comme objectif, mais aujourd'hui, l'un ou l'autre lieu peut convenir, car les API web sont de plus en plus fréquemment implémentées en dehors du web. En fin de compte, les Signaux n'ont pas besoin de dépendre d'aucune API DOM, donc l'une ou l'autre option fonctionne. Si quelqu'un a une raison solide pour que ce groupe change, merci de nous en faire part via une issue. Pour l'instant, tous les contributeurs ont signé les accords de propriété intellectuelle du TC39, et le plan est de présenter cela à TC39.</p>
<p><strong>Q</strong> : Combien de temps cela va-t-il prendre avant que je puisse utiliser les Signaux standardisés ?</p>
<p><strong>A</strong> : Un polyfill est déjà disponible, mais il est préférable de ne pas compter sur sa stabilité, car cette API évolue pendant son processus de révision. D'ici quelques mois ou un an, un polyfill stable, de haute qualité et haute performance devrait être utilisable, mais il restera soumis aux révisions du comité et ne sera pas encore standardisé. En suivant la trajectoire typique d'une proposition TC39, il est prévu qu'il faille au moins 2 à 3 ans, au strict minimum, pour que les Signaux soient nativement disponibles sur tous les navigateurs, y compris sur quelques versions précédentes, afin que les polyfills ne soient plus nécessaires.</p>
<p><strong>Q</strong> : Comment allons-nous éviter de standardiser trop tôt le mauvais type de Signaux, comme {{JS/web feature that you don't like}} ?</p>
<p><strong>A</strong> : Les auteurs de cette proposition prévoient de faire des efforts supplémentaires avec des prototypes et des validations avant de demander l'avancement de l'étape au TC39. Voir &quot;État et plan de développement&quot; ci-dessus. Si vous voyez des lacunes dans ce plan ou des opportunités d'amélioration, merci de soumettre une issue en expliquant.</p>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-28</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>