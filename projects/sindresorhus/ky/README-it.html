<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ky - sindresorhus/ky it</title>
    <meta name="title" content="ky - sindresorhus/ky it | Ky è un client HTTP piccolo ed elegante basato su Fetch API Ky è progettato per browser moderni, Node.js, Bun e Deno. È solo un piccolo pacchetto senza dipenden...">
    <meta name="description" content="sindresorhus/ky - GitHub repository it documentation and information | Ky è un client HTTP piccolo ed elegante basato su Fetch API Ky è progettato per browser moderni, Node.js, Bun e Deno. È solo un piccolo pacchetto senza dipenden...">
    <meta name="keywords" content="sindresorhus, ky, GitHub, repository, it documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/sindresorhus/ky/README-it.html">
    <meta property="og:title" content="ky - sindresorhus/ky it | Ky è un client HTTP piccolo ed elegante basato su Fetch API Ky è progettato per browser moderni, Node.js, Bun e Deno. È solo un piccolo pacchetto senza dipenden...">
    <meta property="og:description" content="sindresorhus/ky - GitHub repository it documentation and information | Ky è un client HTTP piccolo ed elegante basato su Fetch API Ky è progettato per browser moderni, Node.js, Bun e Deno. È solo un piccolo pacchetto senza dipenden...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/sindresorhus/ky" id="githubRepoLink" target="_blank">sindresorhus/ky</a>
<h1 style="display: none;">Ky è un client HTTP piccolo ed elegante basato su Fetch API Ky è progettato per browser moderni, Node.js, Bun e Deno. È solo un piccolo pacchetto senza dipenden...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div align="center">
	<br>
	<div>
		<img width="600" height="600" src="https://raw.githubusercontent.com/sindresorhus/ky/main/media/logo.svg" alt="ky">
	</div>
	<br>
	<br>
	<br>
</div>
<blockquote>
<p>Ky è un client HTTP piccolo ed elegante basato su <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">Fetch API</a></p>
</blockquote>
<p><a href="https://codecov.io/gh/sindresorhus/ky"><img src="https://codecov.io/gh/sindresorhus/ky/branch/main/graph/badge.svg" alt="Coverage Status" /></a>
<a href="https://bundlephobia.com/result?p=ky"><img src="https://badgen.net/bundlephobia/minzip/ky" alt="" /></a></p>
<p>Ky è progettato per <a href="#browser-support">browser moderni</a>, Node.js, Bun e Deno.</p>
<p>È solo un piccolo pacchetto senza dipendenze.</p>
<h2>Vantaggi rispetto a <code>fetch</code> puro</h2>
<ul>
<li>API più semplice</li>
<li>Scorciatoie per i metodi (<code>ky.post()</code>)</li>
<li>Tratta i codici di stato non-2xx come errori (dopo i redirect)</li>
<li>Ritenta le richieste fallite</li>
<li>Opzione JSON</li>
<li>Supporto timeout</li>
<li>Opzione prefisso URL</li>
<li>Istanza con impostazioni predefinite personalizzate</li>
<li>Hook</li>
<li>Funzionalità TypeScript (ad es. <code>.json()</code> supporta generics e predefinito su <code>unknown</code>, non su <code>any</code>)</li>
</ul>
<h2>Installazione</h2>
<pre><code class="language-sh">npm install ky
</code></pre>
<h6>CDN</h6>
<ul>
<li><a href="https://cdn.jsdelivr.net/npm/ky/+esm">jsdelivr</a></li>
<li><a href="https://unpkg.com/ky">unpkg</a></li>
<li><a href="https://esm.sh/ky">esm.sh</a></li>
</ul>
<h2>Utilizzo</h2>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {json: {foo: true}}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Con <code>fetch</code> puro, sarebbe:</p>
<pre><code class="language-js">class HTTPError extends Error {}

const response = await fetch('https://example.com', {
	method: 'POST',
	body: JSON.stringify({foo: true}),
	headers: {
		'content-type': 'application/json'
	}
});

if (!response.ok) {
	throw new HTTPError(`Fetch error: ${response.statusText}`);
}

const json = await response.json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Se stai usando <a href="https://github.com/denoland/deno">Deno</a>, importa Ky da un URL. Ad esempio, usando un CDN:</p>
<pre><code class="language-js">import ky from 'https://esm.sh/ky';
</code></pre>
<h2>API</h2>
<h3>ky(input, options?)</h3>
<p><code>input</code> e <code>options</code> sono gli stessi di <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code></a>, con opzioni aggiuntive disponibili (vedi sotto).</p>
<p>Restituisce un <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>oggetto Response</code></a> con i <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body">metodi <code>Body</code></a> aggiunti per comodità. Quindi puoi, ad esempio, chiamare direttamente <code>ky.get(input).json()</code> senza dover prima attendere la <code>Response</code>. Quando chiamato in questo modo, verrà impostata un'intestazione <code>Accept</code> appropriata a seconda del metodo body utilizzato. A differenza dei metodi <code>Body</code> di <code>window.Fetch</code>, questi genereranno un <code>HTTPError</code> se lo stato della risposta non è compreso nell'intervallo <code>200...299</code>. Inoltre, <code>.json()</code> restituirà una stringa vuota se il body è vuoto o lo stato della risposta è <code>204</code> invece di generare un errore di parsing a causa di un body vuoto.</p>
<pre><code class="language-js">import ky from 'ky';

const user = await ky('/api/user').json();

console.log(user);
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> Accetta un <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">parametro di tipo</a> opzionale, che per impostazione predefinita è <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>, e viene passato al tipo restituito di <code>.json()</code>.</p>
<pre><code class="language-ts">import ky from 'ky';

// user1 è unknown
const user1 = await ky('/api/users/1').json();
// user2 è di tipo User
const user2 = await ky&lt;User&gt;('/api/users/2').json();
// user3 è di tipo User
const user3 = await ky('/api/users/3').json&lt;User&gt;();

console.log([user1, user2, user3]);
</code></pre>
<h3>ky.get(input, options?)</h3>
<h3>ky.post(input, options?)</h3>
<h3>ky.put(input, options?)</h3>
<h3>ky.patch(input, options?)</h3>
<h3>ky.head(input, options?)</h3>
<h3>ky.delete(input, options?)</h3>
<p>Imposta <code>options.method</code> con il nome del metodo ed effettua una richiesta.</p>
<p>⌨️ <strong>TypeScript:</strong> Accetta un parametro di tipo opzionale da usare con le risposte JSON (vedi <a href="#kyinput-options"><code>ky()</code></a>).</p>
<h4>input</h4>
<p>Tipo: <code>string</code> | <code>URL</code> | <code>Request</code></p>
<p>Uguale all'<a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#input"><code>input</code> di fetch</a>.</p>
<p>Quando si utilizza un'istanza <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> come <code>input</code>, qualsiasi opzione che altera l'URL (come <code>prefixUrl</code>) verrà ignorata.</p>
<h4>options</h4>
<p>Tipo: <code>object</code></p>
<p>Uguale alle <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch#options">opzioni di <code>fetch</code></a>, più le seguenti opzioni aggiuntive:</p>
<h5>method</h5>
<p>Tipo: <code>string</code><br />
Predefinito: <code>'get'</code></p>
<p>Metodo HTTP utilizzato per effettuare la richiesta.</p>
<p>Internamente, i metodi standard (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>HEAD</code> e <code>DELETE</code>) vengono convertiti in maiuscolo per evitare errori del server dovuti alla sensibilità alle maiuscole.</p>
<h5>json</h5>
<p>Tipo: <code>object</code> e qualsiasi altro valore accettato da <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a></p>
<p>Scorciatoia per inviare JSON. Usa questa opzione invece dell'opzione <code>body</code>. Accetta qualsiasi oggetto semplice o valore, che verrà convertito in stringa da <code>JSON.stringify()</code> e inviato nel body con l'intestazione corretta impostata.</p>
<h5>searchParams</h5>
<p>Tipo: <code>string | object&lt;string, string | number | boolean&gt; | Array&lt;Array&lt;string | number | boolean&gt;&gt; | URLSearchParams</code><br />
Predefinito: <code>''</code></p>
<p>Parametri di ricerca da includere nell'URL della richiesta. Impostando questo valore sovrascriverai tutti i parametri di ricerca esistenti nell'URL di input.</p>
<p>Accetta qualsiasi valore supportato da <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams"><code>URLSearchParams()</code></a>.</p>
<h5>prefixUrl</h5>
<p>Tipo: <code>string | URL</code></p>
<p>Un prefisso da anteporre all'URL <code>input</code> durante la richiesta. Può essere qualsiasi URL valido, relativo o assoluto. Una barra finale <code>/</code> è opzionale e verrà aggiunta automaticamente, se necessario, quando viene unito a <code>input</code>. Ha effetto solo quando <code>input</code> è una stringa. L'argomento <code>input</code> non può iniziare con una barra <code>/</code> quando si utilizza questa opzione.</p>
<p>Utile se usato con <a href="#kyextenddefaultoptions"><code>ky.extend()</code></a> per creare istanze di Ky specifiche per una nicchia.</p>
<pre><code class="language-js">import ky from 'ky';

// Su https://example.com

const response = await ky('unicorn', {prefixUrl: '/api'});
//=&gt; 'https://example.com/api/unicorn'

const response2 = await ky('unicorn', {prefixUrl: 'https://cats.com'});
//=&gt; 'https://cats.com/unicorn'
</code></pre>
<p>Note:</p>
<ul>
<li>Dopo che <code>prefixUrl</code> e <code>input</code> sono stati uniti, il risultato viene risolto rispetto all'<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/baseURI">URL di base</a> della pagina (se presente).</li>
<li>I caratteri di slash iniziali in <code>input</code> non sono consentiti quando si utilizza questa opzione per garantire coerenza ed evitare confusione su come viene gestito l'URL <code>input</code>, dato che non seguirà le normali regole di risoluzione degli URL quando viene usato <code>prefixUrl</code>, il che cambia il significato di uno slash iniziale.</li>
</ul>
<h5>retry</h5>
<p>Tipo: <code>object | number</code><br />
Predefinito:</p>
<ul>
<li><code>limit</code>: <code>2</code></li>
<li><code>methods</code>: <code>get</code> <code>put</code> <code>head</code> <code>delete</code> <code>options</code> <code>trace</code></li>
<li><code>statusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"><code>408</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"><code>500</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"><code>502</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"><code>504</code></a></li>
<li><code>afterStatusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a></li>
<li><code>maxRetryAfter</code>: <code>undefined</code></li>
<li><code>backoffLimit</code>: <code>undefined</code></li>
<li><code>delay</code>: <code>attemptCount =&gt; 0.3 * (2 ** (attemptCount - 1)) * 1000</code></li>
</ul>
<p>Un oggetto che rappresenta i campi <code>limit</code>, <code>methods</code>, <code>statusCodes</code>, <code>afterStatusCodes</code> e <code>maxRetryAfter</code> per il conteggio massimo dei tentativi, i metodi consentiti, i codici di stato consentiti, i codici di stato autorizzati a utilizzare il tempo specificato nell'header <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> e il tempo massimo <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>.</p>
<p>Se <code>retry</code> è un numero, verrà utilizzato come <code>limit</code> e gli altri valori predefiniti rimarranno invariati.</p>
<p>Se la risposta fornisce un codice di stato HTTP contenuto in <code>afterStatusCodes</code>, Ky attenderà fino alla data, timeout o timestamp specificato nell'header <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> prima di riprovare la richiesta. Se <code>Retry-After</code> è assente, viene utilizzato come fallback l'header non standard <a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-05.html#section-3.3"><code>RateLimit-Reset</code></a>. Se il codice di stato fornito non è nell'elenco, l'header <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> verrà ignorato.</p>
<p>Se <code>maxRetryAfter</code> è impostato su <code>undefined</code>, verrà utilizzato <code>options.timeout</code>. Se l'header <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> supera <code>maxRetryAfter</code>, verrà utilizzato <code>maxRetryAfter</code>.</p>
<p>L'opzione <code>backoffLimit</code> è il limite superiore del ritardo per ogni tentativo di retry, espresso in millisecondi.
Per limitare il ritardo, ad esempio, impostare <code>backoffLimit</code> a 1000.
Per impostazione predefinita, il ritardo è calcolato con <code>0.3 * (2 ** (attemptCount - 1)) * 1000</code>. Il ritardo aumenta in modo esponenziale.</p>
<p>L'opzione <code>delay</code> può essere utilizzata per cambiare come viene calcolato il ritardo tra i tentativi. La funzione riceve come parametro il numero di tentativi, a partire da <code>1</code>.</p>
<p>I tentativi di retry non vengono attivati dopo un <a href="#timeout">timeout</a>.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky('https://example.com', {
	retry: {
		limit: 10,
		methods: ['get'],
		statusCodes: [413],
		backoffLimit: 3000
	}
}).json();
</code></pre>
<h5>timeout</h5>
<p>Tipo: <code>number | false</code><br />
Predefinito: <code>10000</code></p>
<p>Timeout in millisecondi per ottenere una risposta, inclusi eventuali retry. Non può essere superiore a 2147483647.
Se impostato su <code>false</code>, non ci sarà alcun timeout.</p>
<h5>hooks</h5>
<p>Tipo: <code>object&lt;string, Function[]&gt;</code><br />
Predefinito: <code>{beforeRequest: [], beforeRetry: [], afterResponse: []}</code></p>
<p>Gli hooks permettono modifiche durante il ciclo di vita della richiesta. Le funzioni hook possono essere asincrone e vengono eseguite in serie.</p>
<h6>hooks.beforeRequest</h6>
<p>Tipo: <code>Function[]</code><br />
Predefinito: <code>[]</code></p>
<p>Questo hook consente di modificare la richiesta subito prima che venga inviata. Ky non apporterà ulteriori modifiche alla richiesta dopo questo punto. La funzione hook riceve <code>request</code> e <code>options</code> come argomenti. Ad esempio, qui potresti modificare <code>request.headers</code>.</p>
<p>L'hook può restituire un oggetto <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> per sostituire la richiesta in uscita, oppure restituire un oggetto <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> per evitare completamente l'invio della richiesta HTTP. Questo può essere utilizzato per simulare una richiesta, controllare una cache interna, ecc. Una considerazione <strong>importante</strong> quando si restituisce una richiesta o una risposta da questo hook è che tutti gli altri hook <code>beforeRequest</code> rimanenti verranno saltati, quindi potresti volerli restituire solo dall'ultimo hook.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.extend({
	hooks: {
		beforeRequest: [
			request =&gt; {
				request.headers.set('X-Requested-With', 'ky');
			}
		]
	}
});

const response = await api.get('https://example.com/api/users');
</code></pre>
<h6>hooks.beforeRetry</h6>
<p>Tipo: <code>Function[]</code><br />
Predefinito: <code>[]</code></p>
<p>Questo hook consente di modificare la richiesta subito prima del retry. Ky non apporterà ulteriori modifiche alla richiesta dopo questo punto. La funzione hook riceve un oggetto con la richiesta normalizzata e le opzioni, un'istanza di errore e il numero di retry. Ad esempio, qui potresti modificare <code>request.headers</code>.</p>
<p>Se la richiesta ha ricevuto una risposta, l'errore sarà di tipo <code>HTTPError</code> e l'oggetto <code>Response</code> sarà disponibile in <code>error.response</code>. Tieni presente che alcuni tipi di errori, come gli errori di rete, implicano che una risposta non è stata ricevuta. In tal caso, l'errore non sarà un'istanza di <code>HTTPError</code>.</p>
<p>Puoi impedire a Ky di effettuare il retry della richiesta lanciando un errore. Ky non lo gestirà in alcun modo e l'errore verrà propagato all'iniziatore della richiesta. Il resto degli hook <code>beforeRetry</code> non verrà chiamato in questo caso. In alternativa, puoi restituire il simbolo <a href="#kystop"><code>ky.stop</code></a> per ottenere lo stesso risultato ma senza propagare un errore (questo ha alcune limitazioni, vedi la documentazione di <code>ky.stop</code> per i dettagli).</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const token = await ky('https://example.com/refresh-token');
				request.headers.set('Authorization', `token ${token}`);
			}
		]
	}
});
</code></pre>
<h6>hooks.beforeError</h6>
<p>Tipo: <code>Function[]</code><br />
Predefinito: <code>[]</code></p>
<p>Questo hook permette di modificare l'oggetto <code>HTTPError</code> subito prima che venga lanciato. La funzione hook riceve un oggetto <code>HTTPError</code> come argomento e dovrebbe restituire un'istanza di <code>HTTPError</code>.</p>
<pre><code class="language-js">import ky from 'ky';

await ky('https://example.com', {
	hooks: {
		beforeError: [
			error =&gt; {
				const {response} = error;
				if (response &amp;&amp; response.body) {
					error.name = 'GitHubError';
					error.message = `${response.body.message} (${response.status})`;
				}

				return error;
			}
		]
	}
});
</code></pre>
<h6>hooks.afterResponse</h6>
<p>Tipo: <code>Function[]</code><br />
Predefinito: <code>[]</code></p>
<p>Questo hook permette di leggere e opzionalmente modificare la risposta. La funzione hook riceve la richiesta normalizzata, le opzioni e una copia della risposta come argomenti. Il valore restituito dalla funzione hook verrà utilizzato da Ky come oggetto risposta se è un'istanza di <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a>.</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		afterResponse: [
			(_request, _options, response) =&gt; {
				// Puoi fare qualcosa con la risposta, ad esempio il logging.
				log(response);

				// Oppure restituire un'istanza di `Response` per sovrascrivere la risposta.
				return new Response('A different response', {status: 200});
			},

			// Oppure riprovare con un nuovo token in caso di errore 403
			async (request, options, response) =&gt; {
				if (response.status === 403) {
					// Ottieni un nuovo token
					const token = await ky('https://example.com/token').text();

					// Riprova con il token
					request.headers.set('Authorization', `token ${token}`);

					return ky(request);
				}
			}
		]
	}
});
</code></pre>
<h5>throwHttpErrors</h5>
<p>Tipo: <code>boolean</code><br />
Predefinito: <code>true</code></p>
<p>Lancia un <code>HTTPError</code> quando, dopo aver seguito i redirect, la risposta ha un codice di stato non 2xx. Per lanciare errori anche per i redirect invece di seguirli, imposta l'opzione <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters"><code>redirect</code></a> su <code>'manual'</code>.</p>
<p>Impostare questo valore su <code>false</code> può essere utile se stai verificando la disponibilità di una risorsa e ti aspetti risposte di errore.</p>
<p>Nota: Se impostato su <code>false</code>, le risposte di errore sono considerate di successo e la richiesta non verrà riprovata.</p>
<h5>onDownloadProgress</h5>
<p>Tipo: <code>Function</code></p>
<p>Gestore evento per il progresso del download.</p>
<p>La funzione riceve questi argomenti:</p>
<ul>
<li><code>progress</code> è un oggetto con queste proprietà:</li>
<li>
<ul>
<li><code>percent</code> è un numero compreso tra 0 e 1 che rappresenta la percentuale di avanzamento.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> è il numero di byte trasferiti finora.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> è il numero totale di byte da trasferire. Questo è una stima e può essere 0 se la dimensione totale non può essere determinata.</li>
</ul>
</li>
<li><code>chunk</code> è un'istanza di <code>Uint8Array</code> contenente i dati inviati. Nota: è vuoto alla prima chiamata.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	onDownloadProgress: (progress, chunk) =&gt; {
		// Esempio di output:
		// `0% - 0 di 1271 byte`
		// `100% - 1271 di 1271 byte`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} di ${progress.totalBytes} byte`);
	}
});
</code></pre>
<h5>onUploadProgress</h5>
<p>Tipo: <code>Function</code>
Gestore dell’evento di avanzamento del caricamento.</p>
<p>La funzione riceve questi argomenti:</p>
<ul>
<li><code>progress</code> è un oggetto con le seguenti proprietà:</li>
<li>
<ul>
<li><code>percent</code> è un numero compreso tra 0 e 1 che rappresenta la percentuale di avanzamento.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> è il numero di byte trasferiti finora.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> è il numero totale di byte da trasferire. Questo è una stima e può essere 0 se la dimensione totale non può essere determinata.</li>
</ul>
</li>
<li><code>chunk</code> è un’istanza di <code>Uint8Array</code> contenente i dati che sono stati inviati. Nota: È vuoto per l’ultima chiamata.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky.post('https://example.com/upload', {
	body: largeFile,
	onUploadProgress: (progress, chunk) =&gt; {
		// Esempio di output:
		// `0% - 0 di 1271 byte`
		// `100% - 1271 di 1271 byte`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} di ${progress.totalBytes} byte`);
	}
});
</code></pre>
<h5>parseJson</h5>
<p>Tipo: <code>Function</code><br />
Predefinito: <code>JSON.parse()</code></p>
<p>Funzione di parsing JSON definita dall’utente.</p>
<p>Casi d’uso:</p>
<ol>
<li>Analizzare JSON tramite il pacchetto <a href="https://github.com/hapijs/bourne"><code>bourne</code></a> per proteggere da inquinamento del prototipo.</li>
<li>Analizzare JSON con l’opzione <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>reviver</code> di <code>JSON.parse()</code></a>.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import bourne from '@hapijs/bourne';

const json = await ky('https://example.com', {
	parseJson: text =&gt; bourne(text)
}).json();
</code></pre>
<h5>stringifyJson</h5>
<p>Tipo: <code>Function</code><br />
Predefinito: <code>JSON.stringify()</code></p>
<p>Funzione di serializzazione JSON definita dall’utente.</p>
<p>Casi d’uso:</p>
<ol>
<li>Serializzare JSON con una funzione <code>replacer</code> personalizzata.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import {DateTime} from 'luxon';

const json = await ky('https://example.com', {
	stringifyJson: data =&gt; JSON.stringify(data, (key, value) =&gt; {
		if (key.endsWith('_at')) {
			return DateTime.fromISO(value).toSeconds();
		}

		return value;
	})
}).json();
</code></pre>
<h5>fetch</h5>
<p>Tipo: <code>Function</code><br />
Predefinito: <code>fetch</code></p>
<p>Funzione <code>fetch</code> definita dall’utente.
Deve essere completamente compatibile con lo standard <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>.</p>
<p>Casi d’uso:</p>
<ol>
<li>Utilizzare implementazioni personalizzate di <code>fetch</code> come <a href="https://www.npmjs.com/package/isomorphic-unfetch"><code>isomorphic-unfetch</code></a>.</li>
<li>Utilizzare la funzione wrapper <code>fetch</code> fornita da alcuni framework che usano il server-side rendering (SSR).</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import fetch from 'isomorphic-unfetch';

const json = await ky('https://example.com', {fetch}).json();
</code></pre>
<h3>ky.extend(defaultOptions)</h3>
<p>Crea una nuova istanza di <code>ky</code> con alcune impostazioni predefinite sovrascritte con le tue.</p>
<p>A differenza di <code>ky.create()</code>, <code>ky.extend()</code> eredita le impostazioni predefinite dal suo genitore.</p>
<p>Puoi passare le intestazioni come istanza di <code>Headers</code> o come oggetto semplice.</p>
<p>Puoi rimuovere un’intestazione con <code>.extend()</code> passando l’intestazione con valore <code>undefined</code>.
Passando <code>undefined</code> come stringa si rimuove l’intestazione solo se proviene da un’istanza di <code>Headers</code>.</p>
<p>Allo stesso modo, puoi rimuovere le voci esistenti di <code>hooks</code> estendendo l’hook con un esplicito <code>undefined</code>.</p>
<pre><code class="language-js">import ky from 'ky';

const url = 'https://sindresorhus.com';

const original = ky.create({
	headers: {
		rainbow: 'rainbow',
		unicorn: 'unicorn'
	},
	hooks: {
		beforeRequest: [ () =&gt; console.log('prima 1') ],
		afterResponse: [ () =&gt; console.log('dopo 1') ],
	},
});

const extended = original.extend({
	headers: {
		rainbow: undefined
	},
	hooks: {
		beforeRequest: undefined,
		afterResponse: [ () =&gt; console.log('dopo 2') ],
	}
});

const response = await extended(url).json();
//=&gt; dopo 1
//=&gt; dopo 2

console.log('rainbow' in response);
//=&gt; false

console.log('unicorn' in response);
//=&gt; true
</code></pre>
<p>Puoi anche fare riferimento alle impostazioni predefinite del genitore fornendo una funzione a <code>.extend()</code>.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.create({prefixUrl: 'https://example.com/api'});

const usersApi = api.extend((options) =&gt; ({prefixUrl: `${options.prefixUrl}/users`}));

const response = await usersApi.get('123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('version');
//=&gt; 'https://example.com/api/version'
</code></pre>
<h3>ky.create(defaultOptions)</h3>
<p>Crea una nuova istanza di Ky con impostazioni predefinite completamente nuove.</p>
<pre><code class="language-js">import ky from 'ky';

// Su https://my-site.com

const api = ky.create({prefixUrl: 'https://example.com/api'});

const response = await api.get('users/123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('/status', {prefixUrl: ''});
//=&gt; 'https://my-site.com/status'
</code></pre>
<h4>defaultOptions</h4>
<p>Tipo: <code>object</code></p>
<h3>ky.stop</h3>
<p>Un <code>Symbol</code> che può essere restituito da un hook <code>beforeRetry</code> per interrompere il tentativo di ripetizione. Questo interromperà anche i restanti hook <code>beforeRetry</code>.</p>
<p>Nota: Restituire questo simbolo fa sì che Ky si interrompa e restituisca una risposta <code>undefined</code>. Assicurati di verificare la presenza di una risposta prima di accedere a qualsiasi proprietà o usa <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a>. È anche incompatibile con i metodi del body, come <code>.json()</code> o <code>.text()</code>, perché non c’è risposta da analizzare. In generale, si consiglia di generare un errore invece di restituire questo simbolo, poiché ciò farà sì che Ky si interrompa e poi generi un’eccezione, evitando queste limitazioni.</p>
<p>Un caso d’uso valido per <code>ky.stop</code> è prevenire i tentativi di ripetizione quando si effettuano richieste per effetti collaterali, dove i dati restituiti non sono importanti. Ad esempio, registrare l’attività del client sul server.</p>
<pre><code class="language-js">import ky from 'ky';

const options = {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const shouldStopRetry = await ky('https://example.com/api');
				if (shouldStopRetry) {
					return ky.stop;
				}
			}
		]
	}
};
</code></pre>
<pre><code class="language-markdown">// Nota che la risposta sarà `undefined` nel caso venga restituito `ky.stop`.
const response = await ky.post('https://example.com', options);

// L'utilizzo di `.text()` o di altri metodi del corpo non è supportato.
const text = await ky('https://example.com', options).text();
</code></pre>
<h3>HTTPError</h3>
<p>Esportato per i controlli <code>instanceof</code>. L'errore ha una proprietà <code>response</code> con l'oggetto <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a>, una proprietà <code>request</code> con l'oggetto <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> e una proprietà <code>options</code> con le opzioni normalizzate (o passate a <code>ky</code> durante la creazione di un'istanza con <code>ky.create()</code> o direttamente durante l'esecuzione della richiesta).</p>
<p>Tieni presente che alcuni tipi di errori, come gli errori di rete, implicano intrinsecamente che non sia stata ricevuta alcuna risposta. In tal caso, l'errore non sarà un'istanza di HTTPError e non conterrà la proprietà <code>response</code>.</p>
<p>Se hai bisogno di leggere la risposta effettiva quando si verifica un <code>HTTPError</code>, chiama il rispettivo metodo di parsing sull'oggetto response. Ad esempio:</p>
<pre><code class="language-js">try {
	await ky('https://example.com').json();
} catch (error) {
	if (error.name === 'HTTPError') {
		const errorJson = await error.response.json();
	}
}
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> Accetta un <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">parametro di tipo</a> opzionale, che per impostazione predefinita è <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>, e viene passato al tipo di ritorno di <code>error.response.json()</code>.</p>
<h3>TimeoutError</h3>
<p>L'errore lanciato quando la richiesta va in timeout. Ha una proprietà <code>request</code> con l'oggetto <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a>.</p>
<h2>Suggerimenti</h2>
<h3>Invio di dati di form</h3>
<p>L'invio di dati di form in Ky è identico a <code>fetch</code>. Basta passare un'istanza di <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a> all'opzione <code>body</code>. L'intestazione <code>Content-Type</code> verrà impostata automaticamente su <code>multipart/form-data</code>.</p>
<pre><code class="language-js">import ky from 'ky';

// `multipart/form-data`
const formData = new FormData();
formData.append('food', 'fries');
formData.append('drink', 'icetea');

const response = await ky.post(url, {body: formData});
</code></pre>
<p>Se vuoi inviare i dati in formato <code>application/x-www-form-urlencoded</code>, dovrai codificare i dati con <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a>.</p>
<pre><code class="language-js">import ky from 'ky';

// `application/x-www-form-urlencoded`
const searchParams = new URLSearchParams();
searchParams.set('food', 'fries');
searchParams.set('drink', 'icetea');

const response = await ky.post(url, {body: searchParams});
</code></pre>
<h3>Impostare un <code>Content-Type</code> personalizzato</h3>
<p>Ky imposta automaticamente un'intestazione <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> appropriata per ogni richiesta in base ai dati nel corpo della richiesta. Tuttavia, alcune API richiedono tipi di contenuto personalizzati o non standard, come <code>application/x-amz-json-1.1</code>. Utilizzando l'opzione <code>headers</code>, puoi sovrascrivere manualmente il content type.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {
	headers: {
		'content-type': 'application/json'
	},
	json: {
		foo: true
	},
}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<h3>Cancellazione</h3>
<p>Fetch (e quindi Ky) supporta nativamente la cancellazione delle richieste tramite l'<a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController">API <code>AbortController</code></a>. <a href="https://developers.google.com/web/updates/2017/09/abortable-fetch">Leggi di più.</a></p>
<p>Esempio:</p>
<pre><code class="language-js">import ky from 'ky';

const controller = new AbortController();
const {signal} = controller;

setTimeout(() =&gt; {
	controller.abort();
}, 5000);

try {
	console.log(await ky(url, {signal}).text());
} catch (error) {
	if (error.name === 'AbortError') {
		console.log('Fetch annullato');
	} else {
		console.error('Errore fetch:', error);
	}
}
</code></pre>
<h2>FAQ</h2>
<h4>Come si usa in Node.js?</h4>
<p>Node.js 18 e versioni successive supportano nativamente <code>fetch</code>, quindi puoi semplicemente usare questo pacchetto direttamente.</p>
<h4>Come si usa con una web app (React, Vue.js, ecc.) che utilizza il server-side rendering (SSR)?</h4>
<p>Come sopra.</p>
<h4>Come posso testare una libreria browser che utilizza questo?</h4>
<p>Usa un test runner che può essere eseguito nel browser, come Mocha, oppure usa <a href="https://avajs.dev">AVA</a> con <code>ky-universal</code>. <a href="https://github.com/sindresorhus/ky-universal#faq">Leggi di più.</a></p>
<h4>Come lo uso senza un bundler come Webpack?</h4>
<p>Assicurati che il tuo codice venga eseguito come modulo JavaScript (ESM), ad esempio utilizzando un tag <code>&lt;script type=&quot;module&quot;&gt;</code> nel documento HTML. Ky può quindi essere importato direttamente da quel modulo senza un bundler o altri strumenti.</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
import ky from 'https://unpkg.com/ky/distribution/index.js';

const json = await ky('https://jsonplaceholder.typicode.com/todos/1').json();

console.log(json.title);
//=&gt; 'delectus aut autem'
&lt;/script&gt;
</code></pre>
<h4>In cosa è diverso da <a href="https://github.com/sindresorhus/got"><code>got</code></a></h4>
<p>Vedi la mia risposta <a href="https://twitter.com/sindresorhus/status/1037406558945042432">qui</a>. Got è mantenuto dalle stesse persone di Ky.</p>
<h4>In cosa è diverso da <a href="https://github.com/axios/axios"><code>axios</code></a>?</h4>
<p>Vedi la mia risposta <a href="https://twitter.com/sindresorhus/status/1037763588826398720">qui</a>.</p>
<h4>In cosa è diverso da <a href="https://github.com/mikeal/r2"><code>r2</code></a>?</h4>
<p>Vedi la mia risposta in <a href="https://github.com/sindresorhus/ky/issues/10">#10</a>.</p>
<h4>Cosa significa <code>ky</code>?</h4>
<p>È semplicemente un nome di pacchetto npm breve e casuale che sono riuscito a ottenere. Tuttavia, ha un significato in giapponese:</p>
<blockquote>
<p>Una forma di gergo testuale, KY è un'abbreviazione di 空気読めない (kuuki yomenai), che letteralmente si traduce in “non sa leggere l'aria.” È una frase applicata a qualcuno che non coglie il significato implicito.</p>
</blockquote>
<h2>Compatibilità browser</h2>
<p>Le ultime versioni di Chrome, Firefox e Safari.</p>
<h2>Compatibilità Node.js</h2>
<p>Node.js 18 e versioni successive.</p>
<h2>Correlati</h2>
<ul>
<li><a href="https://github.com/sindresorhus/fetch-extras">fetch-extras</a> - Utilità utili per lavorare con Fetch</li>
<li><a href="https://github.com/alice-health/ky-hooks-change-case">ky-hooks-change-case</a> - Ky hooks per modificare i casi su richieste e risposte di oggetti</li>
</ul>
<h2>Maintainer</h2>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a></li>
<li><a href="https://github.com/sholladay">Seth Holladay</a></li>
<li><a href="https://github.com/szmarczak">Szymon Marczak</a></li>
</ul>
<pre><code>

---


Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-11


---
</code></pre>

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>