<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ky - sindresorhus/ky</title>
    <meta name="title" content="ky - sindresorhus/ky">
    <meta name="description" content="sindresorhus/ky - GitHub repository zh-TW documentation and informationKy 是一個基於 Fetch API 的小巧且優雅的 HTTP 用戶端 Ky 目標支援現代瀏覽器、Node.js、Bun 和 Deno。 它只是一個沒有任何依賴的小型套件。 比原生 fetch 的優點 更簡單的 API 方法快捷方式（如 ky.post()） 將非 2xx 狀態碼視為錯誤（重定向後） 失敗請求自動重試 JSON 選項 支援逾時 URL 前綴選項 可自訂預設值的實例 Hooks TypeScript 友善（例如 .json() 支援泛型且預設為 unknown 而非 any） 安裝 npm install ky CDN jsdelivr unpkg esm.sh 使用方式 import ky from 'ky'; const json = await ky.post('https://example.com', {json: {foo: true}}).json(); console.log(json); //=&gt; {data: '🦄'} 若使用原生 fetch，則為： class HTTPError extends Error {} const response = await fetch('https://example.com', { method: 'POST', body: JSON.stringify({foo: true}), headers: { 'content-type': 'application/json' } }); if (!response.ok) { throw new HTTPError(`Fetch error: ${response.statusText}`); } const json = await response.json(); console.log(json); //=&gt; {data: '🦄'} 如果你使用 Deno，請從 URL 匯入 Ky。例如，使用 CDN： import ky from 'https://esm.sh/ky'; API ky(input, options?) input 和 options 與 fetch 相同，並提供額外的 options（見下方）。 回傳一個帶有 Body 方法 的 Response 物件，方便使用。例如，你可以直接呼叫 ky.get(input).json()，無需先等待 Response。如此呼叫時，會根據所用的 body 方法自動設置合適的 Accept 標頭。與 window.Fetch 的 Body 方法不同，若回應狀態不在 200...299 範圍內，這些方法會拋出 HTTPError。此外，.json() 若遇到空 body 或回應狀態為 204 時，會回傳空字串，而不是因為空 body 拋出解析錯誤。...">
    <meta name="keywords" content="sindresorhus, ky, GitHub, repository, zh-TW documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/sindresorhus/ky/README-zh-TW.html">
    <meta property="og:title" content="ky - sindresorhus/ky">
    <meta property="og:description" content="sindresorhus/ky - GitHub repository zh-TW documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/sindresorhus/ky" id="githubRepoLink" target="_blank">sindresorhus/ky</a>
<br>
<h1 style="display: none;">Ky 是一個基於 Fetch API 的小巧且優雅的 HTTP 用戶端 Ky 目標支援現代瀏覽器、Node.js、Bun 和 Deno。 它只是一個沒有任何依賴的小型套件。 比原生 fetch 的優點 更簡單的 API 方法快捷方式（如 ky.post()） 將非 2xx 狀態碼視為錯誤（重定向後） 失敗請求自動重試 JSON 選項 支援逾時 URL 前綴選項 可自訂預設值的實例 Hooks TypeScript 友善（例如 .json() 支援泛型且預設為 unknown 而非 any） 安裝 npm install ky CDN jsdelivr unpkg esm.sh 使用方式 import ky from 'ky'; const json = await ky.post('https://example.com', {json: {foo: true}}).json(); console.log(json); //=&gt; {data: '🦄'} 若使用原生 fetch，則為： class HTTPError extends Error {} const response = await fetch('https://example.com', { method: 'POST', body: JSON.stringify({foo: true}), headers: { 'content-type': 'application/json' } }); if (!response.ok) { throw new HTTPError(`Fetch error: ${response.statusText}`); } const json = await response.json(); console.log(json); //=&gt; {data: '🦄'} 如果你使用 Deno，請從 URL 匯入 Ky。例如，使用 CDN： import ky from 'https://esm.sh/ky'; API ky(input, options?) input 和 options 與 fetch 相同，並提供額外的 options（見下方）。 回傳一個帶有 Body 方法 的 Response 物件，方便使用。例如，你可以直接呼叫 ky.get(input).json()，無需先等待 Response。如此呼叫時，會根據所用的 body 方法自動設置合適的 Accept 標頭。與 window.Fetch 的 Body 方法不同，若回應狀態不在 200...299 範圍內，這些方法會拋出 HTTPError。此外，.json() 若遇到空 body 或回應狀態為 204 時，會回傳空字串，而不是因為空 body 拋出解析錯誤。...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div align="center">
	<br>
	<div>
		<img width="600" height="600" src="https://raw.githubusercontent.com/sindresorhus/ky/main/media/logo.svg" alt="ky">
	</div>
	<br>
	<br>
	<br>
</div>
<blockquote>
<p>Ky 是一個基於 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">Fetch API</a> 的小巧且優雅的 HTTP 用戶端</p>
</blockquote>
<p><a href="https://codecov.io/gh/sindresorhus/ky"><img src="https://codecov.io/gh/sindresorhus/ky/branch/main/graph/badge.svg" alt="Coverage Status" /></a>
<a href="https://bundlephobia.com/result?p=ky"><img src="https://badgen.net/bundlephobia/minzip/ky" alt="" /></a></p>
<p>Ky 目標支援<a href="#browser-support">現代瀏覽器</a>、Node.js、Bun 和 Deno。</p>
<p>它只是一個沒有任何依賴的小型套件。</p>
<h2>比原生 <code>fetch</code> 的優點</h2>
<ul>
<li>更簡單的 API</li>
<li>方法快捷方式（如 <code>ky.post()</code>）</li>
<li>將非 2xx 狀態碼視為錯誤（重定向後）</li>
<li>失敗請求自動重試</li>
<li>JSON 選項</li>
<li>支援逾時</li>
<li>URL 前綴選項</li>
<li>可自訂預設值的實例</li>
<li>Hooks</li>
<li>TypeScript 友善（例如 <code>.json()</code> 支援泛型且預設為 <code>unknown</code> 而非 <code>any</code>）</li>
</ul>
<h2>安裝</h2>
<pre><code class="language-sh">npm install ky
</code></pre>
<h6>CDN</h6>
<ul>
<li><a href="https://cdn.jsdelivr.net/npm/ky/+esm">jsdelivr</a></li>
<li><a href="https://unpkg.com/ky">unpkg</a></li>
<li><a href="https://esm.sh/ky">esm.sh</a></li>
</ul>
<h2>使用方式</h2>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {json: {foo: true}}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>若使用原生 <code>fetch</code>，則為：</p>
<pre><code class="language-js">class HTTPError extends Error {}

const response = await fetch('https://example.com', {
	method: 'POST',
	body: JSON.stringify({foo: true}),
	headers: {
		'content-type': 'application/json'
	}
});

if (!response.ok) {
	throw new HTTPError(`Fetch error: ${response.statusText}`);
}

const json = await response.json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>如果你使用 <a href="https://github.com/denoland/deno">Deno</a>，請從 URL 匯入 Ky。例如，使用 CDN：</p>
<pre><code class="language-js">import ky from 'https://esm.sh/ky';
</code></pre>
<h2>API</h2>
<h3>ky(input, options?)</h3>
<p><code>input</code> 和 <code>options</code> 與 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code></a> 相同，並提供額外的 <code>options</code>（見下方）。</p>
<p>回傳一個帶有<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body"> <code>Body</code> 方法</a> 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code> 物件</a>，方便使用。例如，你可以直接呼叫 <code>ky.get(input).json()</code>，無需先等待 <code>Response</code>。如此呼叫時，會根據所用的 body 方法自動設置合適的 <code>Accept</code> 標頭。與 <code>window.Fetch</code> 的 <code>Body</code> 方法不同，若回應狀態不在 <code>200...299</code> 範圍內，這些方法會拋出 <code>HTTPError</code>。此外，<code>.json()</code> 若遇到空 body 或回應狀態為 <code>204</code> 時，會回傳空字串，而不是因為空 body 拋出解析錯誤。</p>
<pre><code class="language-js">import ky from 'ky';

const user = await ky('/api/user').json();

console.log(user);
</code></pre>
<p>⌨️ <strong>TypeScript：</strong> 可選用<a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">型別參數</a>（預設為 <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>），並會傳遞至 <code>.json()</code> 的回傳型別。</p>
<pre><code class="language-ts">import ky from 'ky';

// user1 是 unknown
const user1 = await ky('/api/users/1').json();
// user2 是 User
const user2 = await ky&lt;User&gt;('/api/users/2').json();
// user3 是 User
const user3 = await ky('/api/users/3').json&lt;User&gt;();

console.log([user1, user2, user3]);
</code></pre>
<h3>ky.get(input, options?)</h3>
<h3>ky.post(input, options?)</h3>
<h3>ky.put(input, options?)</h3>
<h3>ky.patch(input, options?)</h3>
<h3>ky.head(input, options?)</h3>
<h3>ky.delete(input, options?)</h3>
<p>將 <code>options.method</code> 設為方法名稱並發出請求。</p>
<p>⌨️ <strong>TypeScript：</strong> 可選用型別參數，用於 JSON 回應（參見 <a href="#kyinput-options"><code>ky()</code></a>）。</p>
<h4>input</h4>
<p>型別：<code>string</code> | <code>URL</code> | <code>Request</code></p>
<p>同 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#input"><code>fetch</code> 的 input</a>。</p>
<p>當 <code>input</code> 為 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> 實例時，所有會更改 URL 的選項（例如 <code>prefixUrl</code>）將會被忽略。</p>
<h4>options</h4>
<p>型別：<code>object</code></p>
<p>同 <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch#options"><code>fetch</code> 的 options</a>，並額外支援以下選項：</p>
<h5>method</h5>
<p>型別：<code>string</code><br />
預設值：<code>'get'</code></p>
<p>發送請求所用的 HTTP 方法。</p>
<p>在內部，標準方法（<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code> 和 <code>DELETE</code>）會自動轉為大寫，以避免因大小寫敏感導致的伺服器錯誤。</p>
<h5>json</h5>
<p>型別：<code>object</code> 及任何 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> 可接受的值</p>
<p>用於傳送 JSON 的捷徑。請用這個選項取代 <code>body</code>。接受任何純物件或值，並會自動用 <code>JSON.stringify()</code> 處理，並附帶正確的標頭。</p>
<h5>searchParams</h5>
<p>型別：<code>string | object&lt;string, string | number | boolean&gt; | Array&lt;Array&lt;string | number | boolean&gt;&gt; | URLSearchParams</code><br />
預設值：<code>''</code></p>
<p>要包含在請求 URL 中的查詢參數。設定此選項會覆蓋輸入 URL 中所有現有的查詢參數。</p>
<p>接受任何 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams"><code>URLSearchParams()</code></a> 支援的值。</p>
<h5>prefixUrl</h5>
<p>型別：<code>string | URL</code></p>
<p>發送請求時，會將此前綴加在 <code>input</code> URL 前。可以是任何有效的 URL，無論是相對還是絕對。結尾的斜線 <code>/</code> 可有可無，必要時會自動補上。僅在 <code>input</code> 為字串時生效。使用此選項時，<code>input</code> 參數不能以斜線 <code>/</code> 開頭。</p>
<p>與 <a href="#kyextenddefaultoptions"><code>ky.extend()</code></a> 搭配使用，可建立針對特定用途的 Ky 實例。</p>
<pre><code class="language-js">import ky from 'ky';

// 於 https://example.com

const response = await ky('unicorn', {prefixUrl: '/api'});
//=&gt; 'https://example.com/api/unicorn'

const response2 = await ky('unicorn', {prefixUrl: 'https://cats.com'});
//=&gt; 'https://cats.com/unicorn'
</code></pre>
<p>注意事項：</p>
<ul>
<li><code>prefixUrl</code> 與 <code>input</code> 合併後，結果會根據頁面的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/baseURI">基底 URL</a>（若有）來解析。</li>
<li>使用此選項時，<code>input</code> 不可有開頭斜線，以強制一致性並避免 <code>input</code> URL 處理方式的混淆，因為啟用 <code>prefixUrl</code> 後，<code>input</code> 不會遵循正常的 URL 解析規則，這會改變開頭斜線的意義。</li>
</ul>
<h5>retry</h5>
<p>型別：<code>object | number</code><br />
預設值：</p>
<ul>
<li><code>limit</code>: <code>2</code></li>
<li><code>methods</code>: <code>get</code> <code>put</code> <code>head</code> <code>delete</code> <code>options</code> <code>trace</code></li>
<li><code>statusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"><code>408</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"><code>500</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"><code>502</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"><code>504</code></a></li>
<li><code>afterStatusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a></li>
<li><code>maxRetryAfter</code>: <code>undefined</code></li>
<li><code>backoffLimit</code>: <code>undefined</code></li>
<li><code>delay</code>: <code>attemptCount =&gt; 0.3 * (2 ** (attemptCount - 1)) * 1000</code></li>
</ul>
<p>一個物件，表示 <code>limit</code>、<code>methods</code>、<code>statusCodes</code>、<code>afterStatusCodes</code> 及 <code>maxRetryAfter</code> 欄位，用於設定最大重試次數、允許的請求方法、允許的狀態碼、允許使用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 時間的狀態碼，以及最大 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 時間。</p>
<p>如果 <code>retry</code> 為數字，則會被用作 <code>limit</code>，其他預設值則會保持不變。</p>
<p>如果回應提供的 HTTP 狀態碼包含在 <code>afterStatusCodes</code> 中，Ky 會等待 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 標頭中給定的日期、逾時或時間戳記過後才會重試請求。如果沒有 <code>Retry-After</code>，則會以非標準的 <a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-05.html#section-3.3"><code>RateLimit-Reset</code></a> 標頭作為備用。如果提供的狀態碼不在清單中，則會忽略 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 標頭。</p>
<p>如果 <code>maxRetryAfter</code> 設為 <code>undefined</code>，則會使用 <code>options.timeout</code>。如果 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 標頭大於 <code>maxRetryAfter</code>，則會使用 <code>maxRetryAfter</code>。</p>
<p><code>backoffLimit</code> 選項為每次重試延遲的上限（毫秒）。
如要限制延遲，例如設置 <code>backoffLimit</code> 為 1000。
預設情況下，延遲計算方式為 <code>0.3 * (2 ** (attemptCount - 1)) * 1000</code>。延遲會呈指數增長。</p>
<p><code>delay</code> 選項可用來變更重試間隔延遲的計算方式。該函式接收一個參數，為目前的重試次數（從 1 開始）。</p>
<p>重試不會在 <a href="#timeout">逾時</a> 後觸發。</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky('https://example.com', {
	retry: {
		limit: 10,
		methods: ['get'],
		statusCodes: [413],
		backoffLimit: 3000
	}
}).json();
</code></pre>
<h5>timeout</h5>
<p>類型：<code>number | false</code><br />
預設值：<code>10000</code></p>
<p>取得回應的逾時時間（毫秒），包含所有重試。不可超過 2147483647。
若設為 <code>false</code>，則不會有逾時限制。</p>
<h5>hooks</h5>
<p>類型：<code>object&lt;string, Function[]&gt;</code><br />
預設值：<code>{beforeRequest: [], beforeRetry: [], afterResponse: []}</code></p>
<p>hooks 允許在請求生命週期中進行修改。hook 函式可以是 async，且會依序執行。</p>
<h6>hooks.beforeRequest</h6>
<p>類型：<code>Function[]</code><br />
預設值：<code>[]</code></p>
<p>此 hook 可讓你在請求發送前修改請求。Ky 在此之後不會再對請求做任何更動。hook 函式會接收 <code>request</code> 與 <code>options</code> 作為參數。你可以在這裡修改 <code>request.headers</code>。</p>
<p>hook 可回傳一個 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> 以取代即將送出的請求，或回傳 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> 以完全避免發送 HTTP 請求。這可以用來模擬請求、檢查內部快取等。<strong>重要提示</strong>：若從此 hook 回傳 request 或 response，剩下的 <code>beforeRequest</code> hooks 會被略過，所以你可能只想在最後一個 hook 回傳它們。</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.extend({
	hooks: {
		beforeRequest: [
			request =&gt; {
				request.headers.set('X-Requested-With', 'ky');
			}
		]
	}
});

const response = await api.get('https://example.com/api/users');
</code></pre>
<h6>hooks.beforeRetry</h6>
<p>類型：<code>Function[]</code><br />
預設值：<code>[]</code></p>
<p>此 hook 可讓你在重試前修改請求。Ky 在此之後不會再對請求做任何更動。hook 函式接收一個包含標準化 request 和 options 的物件、一個錯誤實例，以及重試次數。你可以在這裡修改 <code>request.headers</code>。</p>
<p>如果請求收到回應，錯誤將是 <code>HTTPError</code> 類型，<code>Response</code> 物件可從 <code>error.response</code> 取得。請注意，某些錯誤如網路錯誤，代表請求沒有收到回應，這時錯誤就不會是 <code>HTTPError</code> 實例。</p>
<p>你可以透過丟出錯誤來阻止 Ky 重試請求。Ky 不會再處理該錯誤，錯誤會傳遞給請求發起者。剩下的 <code>beforeRetry</code> hooks 也不會被呼叫。或者，你也可以回傳 <a href="#kystop"><code>ky.stop</code></a> 符號以達到相同效果，但不會拋出錯誤（有些限制，詳見 <code>ky.stop</code> 文件）。</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const token = await ky('https://example.com/refresh-token');
				request.headers.set('Authorization', `token ${token}`);
			}
		]
	}
});
</code></pre>
<h6>hooks.beforeError</h6>
<p>類型：<code>Function[]</code><br />
預設值：<code>[]</code></p>
<p>此 hook 可讓你在拋出 <code>HTTPError</code> 前修改錯誤。hook 函式接收一個 <code>HTTPError</code> 作為參數，且應回傳一個 <code>HTTPError</code> 實例。</p>
<pre><code class="language-js">import ky from 'ky';

await ky('https://example.com', {
	hooks: {
		beforeError: [
			error =&gt; {
				const {response} = error;
				if (response &amp;&amp; response.body) {
					error.name = 'GitHubError';
					error.message = `${response.body.message} (${response.status})`;
				}

				return error;
			}
		]
	}
});
</code></pre>
<h6>hooks.afterResponse</h6>
<p>類型：<code>Function[]</code><br />
預設值：<code>[]</code></p>
<p>此 hook 可讓你讀取並選擇性地修改回應。hook 函式會接收標準化的 request、options，以及回應的 clone 作為參數。如果回傳值為 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> 實例，Ky 會將其作為回應物件使用。</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		afterResponse: [
			(_request, _options, response) =&gt; {
				// 你可以在這裡對 response 做一些操作，例如記錄。
				log(response);

				// 或回傳一個 `Response` 實例以覆蓋回應內容。
				return new Response('A different response', {status: 200});
			},

			// 或者在 403 錯誤時用新 token 重試
			async (request, options, response) =&gt; {
				if (response.status === 403) {
					// 取得新 token
					const token = await ky('https://example.com/token').text();

					// 攜帶 token 重試
					request.headers.set('Authorization', `token ${token}`);

					return ky(request);
				}
			}
		]
	}
});
</code></pre>
<h5>throwHttpErrors</h5>
<p>類型：<code>boolean</code><br />
預設值：<code>true</code></p>
<p>當回應最終（經過重導之後）狀態碼不是 2xx 時，拋出 <code>HTTPError</code>。若你想對重導也拋錯而不是跟隨重導，請將 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters"><code>redirect</code></a> 選項設為 <code>'manual'</code>。</p>
<p>將此設為 <code>false</code> 在你需檢查資源可用性、預期會有錯誤回應時很有用。</p>
<p>注意：若為 <code>false</code>，錯誤回應會被當作成功，且請求將不會被重試。</p>
<h5>onDownloadProgress</h5>
<p>類型：<code>Function</code></p>
<p>下載進度事件處理器。</p>
<p>該函式會收到以下參數：</p>
<ul>
<li><code>progress</code> 是一個包含下列屬性的物件：</li>
<li>
<ul>
<li><code>percent</code>：0 到 1 之間的數字，表示進度百分比。</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code>：目前已傳輸的位元組數。</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code>：預計要傳輸的總位元組數。如果無法確定總大小則為 0。</li>
</ul>
</li>
<li><code>chunk</code>：一個包含已傳輸資料的 <code>Uint8Array</code> 實例。注意：第一次呼叫時為空。</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	onDownloadProgress: (progress, chunk) =&gt; {
		// 範例輸出：
		// `0% - 0 of 1271 bytes`
		// `100% - 1271 of 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} of ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>onUploadProgress</h5>
<p>類型：<code>Function</code>
上傳進度事件處理器。</p>
<p>該函數接收以下參數：</p>
<ul>
<li><code>progress</code> 是一個物件，具有以下屬性：</li>
<li>
<ul>
<li><code>percent</code> 是一個介於 0 和 1 之間的數字，表示進度百分比。</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> 是目前已傳輸的位元組數。</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> 是要傳輸的總位元組數。這是個估計值，若無法確定總大小則可能為 0。</li>
</ul>
</li>
<li><code>chunk</code> 是一個包含已傳送資料的 <code>Uint8Array</code> 實例。注意：最後一次呼叫時為空。</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky.post('https://example.com/upload', {
	body: largeFile,
	onUploadProgress: (progress, chunk) =&gt; {
		// 範例輸出：
		// `0% - 0 of 1271 bytes`
		// `100% - 1271 of 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} of ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>parseJson</h5>
<p>型別：<code>Function</code><br />
預設值：<code>JSON.parse()</code></p>
<p>自訂的 JSON 解析函數。</p>
<p>使用情境：</p>
<ol>
<li>透過 <a href="https://github.com/hapijs/bourne"><code>bourne</code> 套件</a> 解析 JSON，以防止原型污染。</li>
<li>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>JSON.parse()</code> 的 <code>reviver</code> 選項</a> 解析 JSON。</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import bourne from '@hapijs/bourne';

const json = await ky('https://example.com', {
	parseJson: text =&gt; bourne(text)
}).json();
</code></pre>
<h5>stringifyJson</h5>
<p>型別：<code>Function</code><br />
預設值：<code>JSON.stringify()</code></p>
<p>自訂的 JSON 字串化函數。</p>
<p>使用情境：</p>
<ol>
<li>使用自訂的 <code>replacer</code> 函數將 JSON 字串化。</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import {DateTime} from 'luxon';

const json = await ky('https://example.com', {
	stringifyJson: data =&gt; JSON.stringify(data, (key, value) =&gt; {
		if (key.endsWith('_at')) {
			return DateTime.fromISO(value).toSeconds();
		}

		return value;
	})
}).json();
</code></pre>
<h5>fetch</h5>
<p>型別：<code>Function</code><br />
預設值：<code>fetch</code></p>
<p>自訂的 <code>fetch</code> 函數。
必須完全相容於 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> 標準。</p>
<p>使用情境：</p>
<ol>
<li>使用自訂的 <code>fetch</code> 實作，例如 <a href="https://www.npmjs.com/package/isomorphic-unfetch"><code>isomorphic-unfetch</code></a>。</li>
<li>使用某些使用伺服器端渲染 (SSR) 框架提供的 <code>fetch</code> 包裝函數。</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import fetch from 'isomorphic-unfetch';

const json = await ky('https://example.com', {fetch}).json();
</code></pre>
<h3>ky.extend(defaultOptions)</h3>
<p>建立一個新的 <code>ky</code> 實例，並用你自己的預設值覆蓋部分設定。</p>
<p>與 <code>ky.create()</code> 不同，<code>ky.extend()</code> 會從其父級繼承預設值。</p>
<p>你可以將 headers 以 <code>Headers</code> 實例或純物件的形式傳遞。</p>
<p>你可以透過傳遞 <code>undefined</code> 值來使用 <code>.extend()</code> 移除標頭。
若以字串型態傳遞 <code>undefined</code>，僅會從 <code>Headers</code> 實例來源移除該標頭。</p>
<p>同樣地，你也可以通過將 hook 明確設為 <code>undefined</code> 來移除現有的 <code>hooks</code> 項目。</p>
<pre><code class="language-js">import ky from 'ky';

const url = 'https://sindresorhus.com';

const original = ky.create({
	headers: {
		rainbow: 'rainbow',
		unicorn: 'unicorn'
	},
	hooks: {
		beforeRequest: [ () =&gt; console.log('before 1') ],
		afterResponse: [ () =&gt; console.log('after 1') ],
	},
});

const extended = original.extend({
	headers: {
		rainbow: undefined
	},
	hooks: {
		beforeRequest: undefined,
		afterResponse: [ () =&gt; console.log('after 2') ],
	}
});

const response = await extended(url).json();
//=&gt; after 1
//=&gt; after 2

console.log('rainbow' in response);
//=&gt; false

console.log('unicorn' in response);
//=&gt; true
</code></pre>
<p>你也可以通過傳遞函數給 <code>.extend()</code> 來參考父級的預設值。</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.create({prefixUrl: 'https://example.com/api'});

const usersApi = api.extend((options) =&gt; ({prefixUrl: `${options.prefixUrl}/users`}));

const response = await usersApi.get('123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('version');
//=&gt; 'https://example.com/api/version'
</code></pre>
<h3>ky.create(defaultOptions)</h3>
<p>建立一個具有全新預設值的 Ky 實例。</p>
<pre><code class="language-js">import ky from 'ky';

// 在 https://my-site.com

const api = ky.create({prefixUrl: 'https://example.com/api'});

const response = await api.get('users/123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('/status', {prefixUrl: ''});
//=&gt; 'https://my-site.com/status'
</code></pre>
<h4>defaultOptions</h4>
<p>型別：<code>object</code></p>
<h3>ky.stop</h3>
<p>一個可以由 <code>beforeRetry</code> hook 回傳以停止重試的 <code>Symbol</code>。這也會中斷剩餘的 <code>beforeRetry</code> hooks。</p>
<p>注意：回傳此 symbol 會讓 Ky 中止並回傳 <code>undefined</code> 作為回應。在存取回應任何屬性之前請務必先檢查是否有回應，或使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a>。此外，它與如 <code>.json()</code> 或 <code>.text()</code> 等 body 方法不相容，因為沒有回應可供解析。通常，我們建議改為拋出錯誤，這樣會讓 Ky 中止並拋出異常，從而避免這些限制。</p>
<p><code>ky.stop</code> 的一個合理用途是在進行具有副作用的請求時防止重試，例如將用戶端活動記錄到伺服器，這時回傳的資料並不重要。</p>
<pre><code class="language-js">import ky from 'ky';

const options = {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const shouldStopRetry = await ky('https://example.com/api');
				if (shouldStopRetry) {
					return ky.stop;
				}
			}
		]
	}
};
</code></pre>
<p>// 請注意，如果回傳 <code>ky.stop</code>，則 response 會是 <code>undefined</code>。
const response = await ky.post('https://example.com', options);</p>
<p>// 不支援使用 <code>.text()</code> 或其他 body 方法。
const text = await ky('https://example.com', options).text();</p>
<pre><code>
### HTTPError

暴露給 `instanceof` 檢查。該錯誤具有一個 `response` 屬性，包含 [`Response` 物件](https://developer.mozilla.org/en-US/docs/Web/API/Response)，`request` 屬性包含 [`Request` 物件](https://developer.mozilla.org/en-US/docs/Web/API/Request)，以及 `options` 屬性，為標準化後的選項（可以是在使用 `ky.create()` 建立實例時傳入 `ky` 的選項，也可以是在執行請求時直接傳入的）。

請注意，某些型別的錯誤，例如網路錯誤，本質上表示未收到回應。在這種情況下，該錯誤不會是 HTTPError 的實例，且不會包含 `response` 屬性。

如果你需要在發生 `HTTPError` 時讀取實際回應，可以在回應物件上呼叫對應的解析器方法。例如：

```js
try {
	await ky('https://example.com').json();
} catch (error) {
	if (error.name === 'HTTPError') {
		const errorJson = await error.response.json();
	}
}
</code></pre>
<p>⌨️ <strong>TypeScript：</strong> 接受一個可選的 <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">型別參數</a>，預設為 <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>，並會傳遞到 <code>error.response.json()</code> 的回傳型別中。</p>
<h3>TimeoutError</h3>
<p>當請求逾時時所拋出的錯誤。它有一個 <code>request</code> 屬性，包含 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code> 物件</a>。</p>
<h2>小技巧</h2>
<h3>傳送表單資料</h3>
<p>在 Ky 中傳送表單資料與 <code>fetch</code> 完全相同。只要將 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a> 實例傳給 <code>body</code> 選項即可。<code>Content-Type</code> 標頭會自動設為 <code>multipart/form-data</code>。</p>
<pre><code class="language-js">import ky from 'ky';

// `multipart/form-data`
const formData = new FormData();
formData.append('food', 'fries');
formData.append('drink', 'icetea');

const response = await ky.post(url, {body: formData});
</code></pre>
<p>如果你想以 <code>application/x-www-form-urlencoded</code> 格式傳送資料，你需要使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a> 來編碼資料。</p>
<pre><code class="language-js">import ky from 'ky';

// `application/x-www-form-urlencoded`
const searchParams = new URLSearchParams();
searchParams.set('food', 'fries');
searchParams.set('drink', 'icetea');

const response = await ky.post(url, {body: searchParams});
</code></pre>
<h3>設定自訂 <code>Content-Type</code></h3>
<p>Ky 會根據請求主體中的資料，自動為每個請求設置合適的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 標頭。不過，有些 API 需要自訂的、非標準的內容型別，例如 <code>application/x-amz-json-1.1</code>。你可以使用 <code>headers</code> 選項手動覆蓋內容型別。</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {
	headers: {
		'content-type': 'application/json'
	},
	json: {
		foo: true
	},
}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<h3>取消請求</h3>
<p>Fetch（Ky 也是如此）內建通過 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code> API</a> 支援請求取消。<a href="https://developers.google.com/web/updates/2017/09/abortable-fetch">進一步閱讀。</a></p>
<p>範例：</p>
<pre><code class="language-js">import ky from 'ky';

const controller = new AbortController();
const {signal} = controller;

setTimeout(() =&gt; {
	controller.abort();
}, 5000);

try {
	console.log(await ky(url, {signal}).text());
} catch (error) {
	if (error.name === 'AbortError') {
		console.log('Fetch aborted');
	} else {
		console.error('Fetch error:', error);
	}
}
</code></pre>
<h2>常見問題</h2>
<h4>如何在 Node.js 中使用這個套件？</h4>
<p>Node.js 18 及以上版本原生支援 <code>fetch</code>，所以可以直接使用這個套件。</p>
<h4>如何在使用伺服器端渲染（SSR）的 Web 應用（React、Vue.js 等）中使用？</h4>
<p>同上。</p>
<h4>如何測試使用這個套件的瀏覽器函式庫？</h4>
<p>可以使用能在瀏覽器中運行的測試執行器，例如 Mocha，或使用 <a href="https://avajs.dev">AVA</a> 搭配 <code>ky-universal</code>。<a href="https://github.com/sindresorhus/ky-universal#faq">進一步閱讀。</a></p>
<h4>如何在不使用 Webpack 等打包工具的情況下使用這個套件？</h4>
<p>請確保你的程式碼以 JavaScript 模組（ESM）形式運行，例如在 HTML 文件中使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 標籤。這樣 Ky 就可以直接被該模組引用，而無需打包工具或其他工具。</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
import ky from 'https://unpkg.com/ky/distribution/index.js';

const json = await ky('https://jsonplaceholder.typicode.com/todos/1').json();

console.log(json.title);
//=&gt; 'delectus aut autem'
&lt;/script&gt;
</code></pre>
<h4>它與 <a href="https://github.com/sindresorhus/got"><code>got</code></a> 有什麼不同？</h4>
<p>請參考我在 <a href="https://twitter.com/sindresorhus/status/1037406558945042432">這裡</a> 的回答。Got 由與 Ky 相同的人維護。</p>
<h4>它與 <a href="https://github.com/axios/axios"><code>axios</code></a> 有什麼不同？</h4>
<p>請參考我在 <a href="https://twitter.com/sindresorhus/status/1037763588826398720">這裡</a> 的回答。</p>
<h4>它與 <a href="https://github.com/mikeal/r2"><code>r2</code></a> 有什麼不同？</h4>
<p>請參考我在 <a href="https://github.com/sindresorhus/ky/issues/10">#10</a> 的回答。</p>
<h4><code>ky</code> 是什麼意思？</h4>
<p>這只是我能搶到的一個隨機 npm 套件短名稱。不過，在日語中它確實有一個意思：</p>
<blockquote>
<p>一種可用於簡訊的俚語，KY 是「空気読めない」(kuuki yomenai) 的縮寫，意思是「不會讀空氣」。這個詞用來形容那些察覺不到言外之意的人。</p>
</blockquote>
<h2>瀏覽器支援</h2>
<p>最新版本的 Chrome、Firefox 和 Safari。</p>
<h2>Node.js 支援</h2>
<p>Node.js 18 及以上版本。</p>
<h2>相關資源</h2>
<ul>
<li><a href="https://github.com/sindresorhus/fetch-extras">fetch-extras</a> - 用於 Fetch 的實用工具</li>
<li><a href="https://github.com/alice-health/ky-hooks-change-case">ky-hooks-change-case</a> - 用於修改物件請求和回應大小寫的 Ky hooks</li>
</ul>
<h2>維護者</h2>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a></li>
<li><a href="https://github.com/sholladay">Seth Holladay</a></li>
<li><a href="https://github.com/szmarczak">Szymon Marczak</a></li>
</ul>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-11</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Statcounter and other scripts can be added here -->
</body>
</html>