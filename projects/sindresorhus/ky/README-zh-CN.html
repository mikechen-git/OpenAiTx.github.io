<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ky - sindresorhus/ky</title>
    <meta name="title" content="ky - sindresorhus/ky">
    <meta name="description" content="sindresorhus/ky - GitHub repository zh-CN documentation and informationKy 是一个基于 Fetch API 的小巧优雅的 HTTP 客户端 Ky 适用于现代浏览器、Node.js、Bun 和 Deno。 它只是一个无依赖的小型包。 相较于原生 fetch 的优势 更简单的 API 方法快捷方式（如 ky.post()） 将非 2xx 状态码视为错误（重定向后） 自动重试失败的请求 JSON 选项 支持超时 URL 前缀选项 带有自定义默认值的实例 钩子（Hooks） TypeScript 优化（如 .json() 支持泛型并默认为 unknown，而不是 any） 安装 npm install ky CDN jsdelivr unpkg esm.sh 用法 import ky from 'ky'; const json = await ky.post('https://example.com', {json: {foo: true}}).json(); console.log(json); //=&gt; {data: '🦄'} 如果使用原生 fetch，则为： class HTTPError extends Error {} const response = await fetch('https://example.com', { method: 'POST', body: JSON.stringify({foo: true}), headers: { 'content-type': 'application/json' } }); if (!response.ok) { throw new HTTPError(`Fetch error: ${response.statusText}`); } const json = await response.json(); console.log(json); //=&gt; {data: '🦄'} 如果你在使用 Deno，请从 URL 导入 Ky。例如，使用 CDN： import ky from 'https://esm.sh/ky'; API ky(input, options?) input 和 options 与 fetch 相同，同时还提供了额外的 options（见下文）。 返回一个带有便捷 Body 方法 的 Response 对象。因此，你可以直接调用 ky.get(input).json()，而无需先等待 Response。以这种方式调用时，会根据所使用的 body 方法自动设置合适的 Accept 头。与 window.Fetch 的 Body 方法不同，这些方法会在响应状态码不在 200...299 区间时抛出 HTTPError。另外，如果响应体为空或状态码为 204，.json() 将返回空字符串，而不是因空 body 抛出解析错误。 import ky from 'ky';...">
    <meta name="keywords" content="sindresorhus, ky, GitHub, repository, zh-CN documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/sindresorhus/ky/README-zh-CN.html">
    <meta property="og:title" content="ky - sindresorhus/ky">
    <meta property="og:description" content="sindresorhus/ky - GitHub repository zh-CN documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/sindresorhus/ky" id="githubRepoLink" target="_blank">sindresorhus/ky</a>
<br>
<h1 style="display: none;">Ky 是一个基于 Fetch API 的小巧优雅的 HTTP 客户端 Ky 适用于现代浏览器、Node.js、Bun 和 Deno。 它只是一个无依赖的小型包。 相较于原生 fetch 的优势 更简单的 API 方法快捷方式（如 ky.post()） 将非 2xx 状态码视为错误（重定向后） 自动重试失败的请求 JSON 选项 支持超时 URL 前缀选项 带有自定义默认值的实例 钩子（Hooks） TypeScript 优化（如 .json() 支持泛型并默认为 unknown，而不是 any） 安装 npm install ky CDN jsdelivr unpkg esm.sh 用法 import ky from 'ky'; const json = await ky.post('https://example.com', {json: {foo: true}}).json(); console.log(json); //=&gt; {data: '🦄'} 如果使用原生 fetch，则为： class HTTPError extends Error {} const response = await fetch('https://example.com', { method: 'POST', body: JSON.stringify({foo: true}), headers: { 'content-type': 'application/json' } }); if (!response.ok) { throw new HTTPError(`Fetch error: ${response.statusText}`); } const json = await response.json(); console.log(json); //=&gt; {data: '🦄'} 如果你在使用 Deno，请从 URL 导入 Ky。例如，使用 CDN： import ky from 'https://esm.sh/ky'; API ky(input, options?) input 和 options 与 fetch 相同，同时还提供了额外的 options（见下文）。 返回一个带有便捷 Body 方法 的 Response 对象。因此，你可以直接调用 ky.get(input).json()，而无需先等待 Response。以这种方式调用时，会根据所使用的 body 方法自动设置合适的 Accept 头。与 window.Fetch 的 Body 方法不同，这些方法会在响应状态码不在 200...299 区间时抛出 HTTPError。另外，如果响应体为空或状态码为 204，.json() 将返回空字符串，而不是因空 body 抛出解析错误。 import ky from 'ky';...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div align="center">
	<br>
	<div>
		<img width="600" height="600" src="https://raw.githubusercontent.com/sindresorhus/ky/main/media/logo.svg" alt="ky">
	</div>
	<br>
	<br>
	<br>
</div>
<blockquote>
<p>Ky 是一个基于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">Fetch API</a> 的小巧优雅的 HTTP 客户端</p>
</blockquote>
<p><a href="https://codecov.io/gh/sindresorhus/ky"><img src="https://codecov.io/gh/sindresorhus/ky/branch/main/graph/badge.svg" alt="Coverage Status" /></a>
<a href="https://bundlephobia.com/result?p=ky"><img src="https://badgen.net/bundlephobia/minzip/ky" alt="" /></a></p>
<p>Ky 适用于<a href="#browser-support">现代浏览器</a>、Node.js、Bun 和 Deno。</p>
<p>它只是一个无依赖的小型包。</p>
<h2>相较于原生 <code>fetch</code> 的优势</h2>
<ul>
<li>更简单的 API</li>
<li>方法快捷方式（如 <code>ky.post()</code>）</li>
<li>将非 2xx 状态码视为错误（重定向后）</li>
<li>自动重试失败的请求</li>
<li>JSON 选项</li>
<li>支持超时</li>
<li>URL 前缀选项</li>
<li>带有自定义默认值的实例</li>
<li>钩子（Hooks）</li>
<li>TypeScript 优化（如 <code>.json()</code> 支持泛型并默认为 <code>unknown</code>，而不是 <code>any</code>）</li>
</ul>
<h2>安装</h2>
<pre><code class="language-sh">npm install ky
</code></pre>
<h6>CDN</h6>
<ul>
<li><a href="https://cdn.jsdelivr.net/npm/ky/+esm">jsdelivr</a></li>
<li><a href="https://unpkg.com/ky">unpkg</a></li>
<li><a href="https://esm.sh/ky">esm.sh</a></li>
</ul>
<h2>用法</h2>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {json: {foo: true}}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>如果使用原生 <code>fetch</code>，则为：</p>
<pre><code class="language-js">class HTTPError extends Error {}

const response = await fetch('https://example.com', {
	method: 'POST',
	body: JSON.stringify({foo: true}),
	headers: {
		'content-type': 'application/json'
	}
});

if (!response.ok) {
	throw new HTTPError(`Fetch error: ${response.statusText}`);
}

const json = await response.json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>如果你在使用 <a href="https://github.com/denoland/deno">Deno</a>，请从 URL 导入 Ky。例如，使用 CDN：</p>
<pre><code class="language-js">import ky from 'https://esm.sh/ky';
</code></pre>
<h2>API</h2>
<h3>ky(input, options?)</h3>
<p><code>input</code> 和 <code>options</code> 与 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code></a> 相同，同时还提供了额外的 <code>options</code>（见下文）。</p>
<p>返回一个带有便捷 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body"><code>Body</code> 方法</a> 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code> 对象</a>。因此，你可以直接调用 <code>ky.get(input).json()</code>，而无需先等待 <code>Response</code>。以这种方式调用时，会根据所使用的 body 方法自动设置合适的 <code>Accept</code> 头。与 <code>window.Fetch</code> 的 <code>Body</code> 方法不同，这些方法会在响应状态码不在 <code>200...299</code> 区间时抛出 <code>HTTPError</code>。另外，如果响应体为空或状态码为 <code>204</code>，<code>.json()</code> 将返回空字符串，而不是因空 body 抛出解析错误。</p>
<pre><code class="language-js">import ky from 'ky';

const user = await ky('/api/user').json();

console.log(user);
</code></pre>
<p>⌨️ <strong>TypeScript：</strong> 接受一个可选的<a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">类型参数</a>，默认为 <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>，并会传递给 <code>.json()</code> 的返回类型。</p>
<pre><code class="language-ts">import ky from 'ky';

// user1 类型为 unknown
const user1 = await ky('/api/users/1').json();
// user2 类型为 User
const user2 = await ky&lt;User&gt;('/api/users/2').json();
// user3 类型为 User
const user3 = await ky('/api/users/3').json&lt;User&gt;();

console.log([user1, user2, user3]);
</code></pre>
<h3>ky.get(input, options?)</h3>
<h3>ky.post(input, options?)</h3>
<h3>ky.put(input, options?)</h3>
<h3>ky.patch(input, options?)</h3>
<h3>ky.head(input, options?)</h3>
<h3>ky.delete(input, options?)</h3>
<p>将 <code>options.method</code> 设置为方法名并发起请求。</p>
<p>⌨️ <strong>TypeScript：</strong> JSON 响应时可选类型参数（见 <a href="#kyinput-options"><code>ky()</code></a>）。</p>
<h4>input</h4>
<p>类型: <code>string</code> | <code>URL</code> | <code>Request</code></p>
<p>与 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#input"><code>fetch</code> input</a> 相同。</p>
<p>当使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> 实例作为 <code>input</code> 时，任何修改 URL 的选项（如 <code>prefixUrl</code>）都将被忽略。</p>
<h4>options</h4>
<p>类型: <code>object</code></p>
<p>与 <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch#options"><code>fetch</code> options</a> 相同，另外还支持以下附加选项：</p>
<h5>method</h5>
<p>类型: <code>string</code><br />
默认值: <code>'get'</code></p>
<p>用于发起请求的 HTTP 方法。</p>
<p>在内部，标准方法（<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code> 和 <code>DELETE</code>）会被转为大写，以避免因大小写敏感导致的服务器错误。</p>
<h5>json</h5>
<p>类型: <code>object</code> 及 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> 支持的任何其他值</p>
<p>用于发送 JSON 的简写。使用此选项代替 <code>body</code> 选项。接受任意普通对象或值，将被 <code>JSON.stringify()</code> 并作为请求体发送，并自动设置正确的头部。</p>
<h5>searchParams</h5>
<p>类型: <code>string | object&lt;string, string | number | boolean&gt; | Array&lt;Array&lt;string | number | boolean&gt;&gt; | URLSearchParams</code><br />
默认值: <code>''</code></p>
<p>请求 URL 中要包含的查询参数。设置此项时会覆盖输入 URL 中所有已存在的查询参数。</p>
<p>接受 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams"><code>URLSearchParams()</code></a> 支持的任何值。</p>
<h5>prefixUrl</h5>
<p>类型: <code>string | URL</code></p>
<p>在发起请求时添加到 <code>input</code> URL 前的前缀。它可以是任意有效的 URL，相对或绝对皆可。末尾斜杠 <code>/</code> 可选，必要时会自动补全。仅当 <code>input</code> 为字符串时生效。使用此选项时，<code>input</code> 参数不能以斜杠 <code>/</code> 开头。</p>
<p>与 <a href="#kyextenddefaultoptions"><code>ky.extend()</code></a> 配合使用时，适合创建特定领域的 Ky 实例。</p>
<pre><code class="language-js">import ky from 'ky';

// 当前页面为 https://example.com

const response = await ky('unicorn', {prefixUrl: '/api'});
//=&gt; 'https://example.com/api/unicorn'

const response2 = await ky('unicorn', {prefixUrl: 'https://cats.com'});
//=&gt; 'https://cats.com/unicorn'
</code></pre>
<p>注意事项：</p>
<ul>
<li><code>prefixUrl</code> 与 <code>input</code> 拼接后，会根据页面的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/baseURI">基础 URL</a>（如有）进行解析。</li>
<li>为保证一致性并避免对 <code>input</code> URL 处理方式产生困惑，使用此选项时禁止 <code>input</code> 以斜杠开头，因为 <code>prefixUrl</code> 会改变 URL 的解析方式，导致以斜杠开头的含义发生变化。</li>
</ul>
<h5>retry</h5>
<p>类型: <code>object | number</code><br />
默认值:</p>
<ul>
<li><code>limit</code>: <code>2</code></li>
<li><code>methods</code>: <code>get</code> <code>put</code> <code>head</code> <code>delete</code> <code>options</code> <code>trace</code></li>
<li><code>statusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"><code>408</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"><code>500</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"><code>502</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"><code>504</code></a></li>
<li><code>afterStatusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a></li>
<li><code>maxRetryAfter</code>: <code>undefined</code></li>
<li><code>backoffLimit</code>: <code>undefined</code></li>
<li><code>delay</code>: <code>attemptCount =&gt; 0.3 * (2 ** (attemptCount - 1)) * 1000</code></li>
</ul>
<p>一个对象，表示用于最大重试次数、允许的方法、允许的状态码、允许使用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 时间的状态码，以及最大 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 时间的 <code>limit</code>、<code>methods</code>、<code>statusCodes</code>、<code>afterStatusCodes</code> 和 <code>maxRetryAfter</code> 字段。</p>
<p>如果 <code>retry</code> 是一个数字，则它将被用作 <code>limit</code>，其他默认值保持不变。</p>
<p>如果响应返回的 HTTP 状态码包含在 <code>afterStatusCodes</code> 中，Ky 会等待 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 头部中指定的日期、超时或时间戳过去后再重试请求。如果没有 <code>Retry-After</code>，则会使用非标准的 <a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-05.html#section-3.3"><code>RateLimit-Reset</code></a> 头作为后备。如果提供的状态码不在列表中，则会忽略 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 头。</p>
<p>如果 <code>maxRetryAfter</code> 设置为 <code>undefined</code>，则会使用 <code>options.timeout</code>。如果 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 头的值大于 <code>maxRetryAfter</code>，则将使用 <code>maxRetryAfter</code>。</p>
<p><code>backoffLimit</code> 选项是每次重试的最大延迟（以毫秒为单位）。
例如，为了限制延迟，可以将 <code>backoffLimit</code> 设置为 1000。
默认情况下，延迟的计算公式为 <code>0.3 * (2 ** (attemptCount - 1)) * 1000</code>，即延迟呈指数增加。</p>
<p><code>delay</code> 选项可用于更改重试之间的延迟计算方式。该函数接收一个参数，即尝试次数，从 <code>1</code> 开始。</p>
<p>重试不会在 <a href="#timeout">超时</a> 后触发。</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky('https://example.com', {
	retry: {
		limit: 10,
		methods: ['get'],
		statusCodes: [413],
		backoffLimit: 3000
	}
}).json();
</code></pre>
<h5>timeout</h5>
<p>类型：<code>number | false</code><br />
默认值：<code>10000</code></p>
<p>获取响应的超时时间（以毫秒为单位），包括所有重试。不能大于 2147483647。
如果设置为 <code>false</code>，则没有超时限制。</p>
<h5>hooks</h5>
<p>类型：<code>object&lt;string, Function[]&gt;</code><br />
默认值：<code>{beforeRequest: [], beforeRetry: [], afterResponse: []}</code></p>
<p>钩子允许你在请求生命周期中进行修改。钩子函数可以是异步的，并且会串行运行。</p>
<h6>hooks.beforeRequest</h6>
<p>类型：<code>Function[]</code><br />
默认值：<code>[]</code></p>
<p>此钩子允许你在请求发送前修改请求。Ky 在此之后不会再对请求做任何更改。钩子函数接收 <code>request</code> 和 <code>options</code> 作为参数。例如，你可以在这里修改 <code>request.headers</code>。</p>
<p>钩子可以返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> 来替换即将发送的请求，或者返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> 以完全避免发起 HTTP 请求。这可以用于模拟请求、检查内部缓存等。<strong>重要提示</strong>：当从该钩子返回请求或响应时，剩余的 <code>beforeRequest</code> 钩子将被跳过，因此建议仅在最后一个钩子中返回它们。</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.extend({
	hooks: {
		beforeRequest: [
			request =&gt; {
				request.headers.set('X-Requested-With', 'ky');
			}
		]
	}
});

const response = await api.get('https://example.com/api/users');
</code></pre>
<h6>hooks.beforeRetry</h6>
<p>类型：<code>Function[]</code><br />
默认值：<code>[]</code></p>
<p>此钩子允许你在重试前修改请求。Ky 在此之后不会再对请求做任何更改。钩子函数接收一个包含标准化请求和选项的对象、错误实例和重试次数。例如，你可以在这里修改 <code>request.headers</code>。</p>
<p>如果请求收到了响应，错误类型为 <code>HTTPError</code>，<code>Response</code> 对象可通过 <code>error.response</code> 获取。请注意，一些类型的错误（如网络错误）本身意味着未收到响应。在这种情况下，错误不会是 <code>HTTPError</code> 的实例。</p>
<p>你可以通过抛出错误来阻止 Ky 重试请求。Ky 不会以任何方式处理该错误，错误会被传递到请求发起方。在这种情况下，剩余的 <code>beforeRetry</code> 钩子不会被调用。或者，你可以返回 <a href="#kystop"><code>ky.stop</code></a> 符号来实现同样的效果，但不会抛出错误（有一些限制，详见 <code>ky.stop</code> 文档）。</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const token = await ky('https://example.com/refresh-token');
				request.headers.set('Authorization', `token ${token}`);
			}
		]
	}
});
</code></pre>
<h6>hooks.beforeError</h6>
<p>类型：<code>Function[]</code><br />
默认值：<code>[]</code></p>
<p>此钩子允许你在抛出 <code>HTTPError</code> 之前修改它。钩子函数接收一个 <code>HTTPError</code> 作为参数，并应返回一个 <code>HTTPError</code> 实例。</p>
<pre><code class="language-js">import ky from 'ky';

await ky('https://example.com', {
	hooks: {
		beforeError: [
			error =&gt; {
				const {response} = error;
				if (response &amp;&amp; response.body) {
					error.name = 'GitHubError';
					error.message = `${response.body.message} (${response.status})`;
				}

				return error;
			}
		]
	}
});
</code></pre>
<h6>hooks.afterResponse</h6>
<p>类型：<code>Function[]</code><br />
默认值：<code>[]</code></p>
<p>此钩子允许你读取并可选地修改响应。钩子函数接收标准化请求、选项和响应的克隆作为参数。如果返回值是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> 的实例，则 Ky 会将其用作响应对象。</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		afterResponse: [
			(_request, _options, response) =&gt; {
				// 你可以在这里处理响应，例如日志记录。
				log(response);

				// 或返回一个 `Response` 实例以覆盖响应。
				return new Response('A different response', {status: 200});
			},

			// 或在 403 错误时使用新令牌重试
			async (request, options, response) =&gt; {
				if (response.status === 403) {
					// 获取新令牌
					const token = await ky('https://example.com/token').text();

					// 使用令牌重试
					request.headers.set('Authorization', `token ${token}`);

					return ky(request);
				}
			}
		]
	}
});
</code></pre>
<h5>throwHttpErrors</h5>
<p>类型：<code>boolean</code><br />
默认值：<code>true</code></p>
<p>当跟随重定向后响应的状态码不是 2xx 时，抛出 <code>HTTPError</code>。如果要在遇到重定向时抛出错误而不是跟随重定向，请将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters"><code>redirect</code></a> 选项设置为 <code>'manual'</code>。</p>
<p>如果你在检查资源可用性并且期望错误响应，将此设置为 <code>false</code> 可能会很有用。</p>
<p>注意：如果为 <code>false</code>，错误响应将被视为成功，请求不会被重试。</p>
<h5>onDownloadProgress</h5>
<p>类型：<code>Function</code></p>
<p>下载进度事件处理函数。</p>
<p>该函数接收以下参数：</p>
<ul>
<li><code>progress</code> 是一个对象，包含以下属性：</li>
<li>
<ul>
<li><code>percent</code>：表示进度百分比的 0 到 1 之间的数字。</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code>：已传输的字节数。</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code>：要传输的总字节数。该值为估算值，如果无法确定总大小则可能为 0。</li>
</ul>
</li>
<li><code>chunk</code> 是包含已发送数据的 <code>Uint8Array</code> 实例。注意：第一次调用时为空。</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	onDownloadProgress: (progress, chunk) =&gt; {
		// 示例输出：
		// `0% - 0 of 1271 bytes`
		// `100% - 1271 of 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} of ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>onUploadProgress</h5>
<p>类型：<code>Function</code>
上传进度事件处理器。</p>
<p>该函数接收以下参数：</p>
<ul>
<li><code>progress</code> 是一个对象，包含以下属性：</li>
<li>
<ul>
<li><code>percent</code> 是一个介于 0 和 1 之间的数字，表示进度百分比。</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> 是到目前为止已传输的字节数。</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> 是要传输的总字节数。该值为估算值，如果无法确定总大小，可能为 0。</li>
</ul>
</li>
<li><code>chunk</code> 是包含已发送数据的 <code>Uint8Array</code> 实例。注意：最后一次调用时为空。</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky.post('https://example.com/upload', {
	body: largeFile,
	onUploadProgress: (progress, chunk) =&gt; {
		// 示例输出：
		// `0% - 0 of 1271 bytes`
		// `100% - 1271 of 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} of ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>parseJson</h5>
<p>类型: <code>Function</code><br />
默认值: <code>JSON.parse()</code></p>
<p>用户自定义的 JSON 解析函数。</p>
<p>使用场景：</p>
<ol>
<li>通过 <a href="https://github.com/hapijs/bourne"><code>bourne</code> 包</a> 解析 JSON，以防止原型污染。</li>
<li>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>JSON.parse()</code> 的 <code>reviver</code> 选项</a> 解析 JSON。</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import bourne from '@hapijs/bourne';

const json = await ky('https://example.com', {
	parseJson: text =&gt; bourne(text)
}).json();
</code></pre>
<h5>stringifyJson</h5>
<p>类型: <code>Function</code><br />
默认值: <code>JSON.stringify()</code></p>
<p>用户自定义的 JSON 字符串化函数。</p>
<p>使用场景：</p>
<ol>
<li>使用自定义的 <code>replacer</code> 函数对 JSON 进行字符串化。</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import {DateTime} from 'luxon';

const json = await ky('https://example.com', {
	stringifyJson: data =&gt; JSON.stringify(data, (key, value) =&gt; {
		if (key.endsWith('_at')) {
			return DateTime.fromISO(value).toSeconds();
		}

		return value;
	})
}).json();
</code></pre>
<h5>fetch</h5>
<p>类型: <code>Function</code><br />
默认值: <code>fetch</code></p>
<p>用户自定义的 <code>fetch</code> 函数。
必须完全兼容 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> 标准。</p>
<p>使用场景：</p>
<ol>
<li>使用自定义的 <code>fetch</code> 实现，如 <a href="https://www.npmjs.com/package/isomorphic-unfetch"><code>isomorphic-unfetch</code></a>。</li>
<li>使用某些框架为服务端渲染（SSR）提供的 <code>fetch</code> 包装函数。</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import fetch from 'isomorphic-unfetch';

const json = await ky('https://example.com', {fetch}).json();
</code></pre>
<h3>ky.extend(defaultOptions)</h3>
<p>创建一个新的 <code>ky</code> 实例，并用你自己的默认值覆盖部分默认设置。</p>
<p>与 <code>ky.create()</code> 不同，<code>ky.extend()</code> 会从其父级继承默认设置。</p>
<p>你可以将 headers 作为 <code>Headers</code> 实例或普通对象传递。</p>
<p>你可以通过在 <code>.extend()</code> 中传递值为 <code>undefined</code> 的 header 来移除该 header。
以字符串形式传递 <code>undefined</code> 只会在 header 来自 <code>Headers</code> 实例时移除该 header。</p>
<p>同样，你可以通过将钩子（hooks）显式设置为 <code>undefined</code>，来移除已存在的 <code>hooks</code> 条目。</p>
<pre><code class="language-js">import ky from 'ky';

const url = 'https://sindresorhus.com';

const original = ky.create({
	headers: {
		rainbow: 'rainbow',
		unicorn: 'unicorn'
	},
	hooks: {
		beforeRequest: [ () =&gt; console.log('before 1') ],
		afterResponse: [ () =&gt; console.log('after 1') ],
	},
});

const extended = original.extend({
	headers: {
		rainbow: undefined
	},
	hooks: {
		beforeRequest: undefined,
		afterResponse: [ () =&gt; console.log('after 2') ],
	}
});

const response = await extended(url).json();
//=&gt; after 1
//=&gt; after 2

console.log('rainbow' in response);
//=&gt; false

console.log('unicorn' in response);
//=&gt; true
</code></pre>
<p>你还可以通过给 <code>.extend()</code> 提供一个函数来引用父级默认值。</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.create({prefixUrl: 'https://example.com/api'});

const usersApi = api.extend((options) =&gt; ({prefixUrl: `${options.prefixUrl}/users`}));

const response = await usersApi.get('123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('version');
//=&gt; 'https://example.com/api/version'
</code></pre>
<h3>ky.create(defaultOptions)</h3>
<p>使用全新的默认值创建一个新的 Ky 实例。</p>
<pre><code class="language-js">import ky from 'ky';

// 在 https://my-site.com

const api = ky.create({prefixUrl: 'https://example.com/api'});

const response = await api.get('users/123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('/status', {prefixUrl: ''});
//=&gt; 'https://my-site.com/status'
</code></pre>
<h4>defaultOptions</h4>
<p>类型: <code>object</code></p>
<h3>ky.stop</h3>
<p><code>Symbol</code>，可由 <code>beforeRetry</code> 钩子返回以停止重试。这也会终止剩余的 <code>beforeRetry</code> 钩子。</p>
<p>注意：返回该 symbol 会使 Ky 中止并返回 <code>undefined</code> 响应。在访问响应的任何属性之前务必检查响应，或使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">可选链</a>。这也与诸如 <code>.json()</code> 或 <code>.text()</code> 之类的 body 方法不兼容，因为没有响应可以解析。一般来说，我们建议抛出错误而不是返回该 symbol，这样 Ky 会中止并抛出异常，从而避免这些限制。</p>
<p><code>ky.stop</code> 的一个合理用例是：当你进行副作用请求且返回的数据并不重要时，防止重试。例如，将客户端活动日志发送到服务器。</p>
<pre><code class="language-js">import ky from 'ky';

const options = {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const shouldStopRetry = await ky('https://example.com/api');
				if (shouldStopRetry) {
					return ky.stop;
				}
			}
		]
	}
};
</code></pre>
<pre><code class="language-js">// 请注意，如果返回了 `ky.stop`，则 response 会是 `undefined`。
const response = await ky.post('https://example.com', options);

// 不支持使用 `.text()` 或其他 body 方法。
const text = await ky('https://example.com', options).text();
</code></pre>
<h3>HTTPError</h3>
<p>暴露用于 <code>instanceof</code> 检查。该错误具有一个 <code>response</code> 属性，包含 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code> 对象</a>，一个 <code>request</code> 属性，包含 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code> 对象</a>，以及一个 <code>options</code> 属性，包含标准化后的选项（这些选项是在使用 <code>ky.create()</code> 创建实例时传递给 <code>ky</code> 的，或直接在请求时传递的）。</p>
<p>请注意，某些类型的错误（如网络错误）本质上意味着没有收到响应。在这种情况下，错误不会是 HTTPError 的实例，并且不会包含 <code>response</code> 属性。</p>
<p>如果你需要在发生 <code>HTTPError</code> 时读取实际响应，请在响应对象上调用相应的解析方法。例如：</p>
<pre><code class="language-js">try {
	await ky('https://example.com').json();
} catch (error) {
	if (error.name === 'HTTPError') {
		const errorJson = await error.response.json();
	}
}
</code></pre>
<p>⌨️ <strong>TypeScript：</strong> 接受一个可选的<a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">类型参数</a>，默认为 <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>，该类型会传递给 <code>error.response.json()</code> 的返回类型。</p>
<h3>TimeoutError</h3>
<p>请求超时时抛出的错误。它具有一个 <code>request</code> 属性，包含 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code> 对象</a>。</p>
<h2>小贴士</h2>
<h3>发送表单数据</h3>
<p>在 Ky 中发送表单数据与 <code>fetch</code> 完全相同。只需将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a> 实例传递给 <code>body</code> 选项即可。<code>Content-Type</code> 头会自动设置为 <code>multipart/form-data</code>。</p>
<pre><code class="language-js">import ky from 'ky';

// `multipart/form-data`
const formData = new FormData();
formData.append('food', 'fries');
formData.append('drink', 'icetea');

const response = await ky.post(url, {body: formData});
</code></pre>
<p>如果你想以 <code>application/x-www-form-urlencoded</code> 格式发送数据，则需要使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a> 对数据进行编码。</p>
<pre><code class="language-js">import ky from 'ky';

// `application/x-www-form-urlencoded`
const searchParams = new URLSearchParams();
searchParams.set('food', 'fries');
searchParams.set('drink', 'icetea');

const response = await ky.post(url, {body: searchParams});
</code></pre>
<h3>设置自定义 <code>Content-Type</code></h3>
<p>Ky 会根据请求体中的数据自动为每个请求设置合适的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 头。不过，某些 API 需要自定义的、非标准的内容类型，比如 <code>application/x-amz-json-1.1</code>。你可以通过 <code>headers</code> 选项手动覆盖内容类型。</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {
	headers: {
		'content-type': 'application/json'
	},
	json: {
		foo: true
	},
}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<h3>取消请求</h3>
<p>Fetch（因此 Ky 也一样）通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code> API</a> 内置支持请求取消。<a href="https://developers.google.com/web/updates/2017/09/abortable-fetch">了解更多。</a></p>
<p>示例：</p>
<pre><code class="language-js">import ky from 'ky';

const controller = new AbortController();
const {signal} = controller;

setTimeout(() =&gt; {
	controller.abort();
}, 5000);

try {
	console.log(await ky(url, {signal}).text());
} catch (error) {
	if (error.name === 'AbortError') {
		console.log('Fetch aborted');
	} else {
		console.error('Fetch error:', error);
	}
}
</code></pre>
<h2>常见问题</h2>
<h4>如何在 Node.js 中使用？</h4>
<p>Node.js 18 及以上版本原生支持 <code>fetch</code>，所以可以直接使用本包。</p>
<h4>如何在使用服务端渲染（SSR）的 Web 应用（React、Vue.js 等）中使用？</h4>
<p>同上。</p>
<h4>如何测试使用此库的浏览器库？</h4>
<p>可以使用可在浏览器中运行的测试运行器，如 Mocha，或使用 <a href="https://avajs.dev">AVA</a> 搭配 <code>ky-universal</code>。<a href="https://github.com/sindresorhus/ky-universal#faq">了解更多。</a></p>
<h4>如何在没有如 Webpack 这样的打包工具的情况下使用？</h4>
<p>确保你的代码以 JavaScript 模块（ESM）方式运行，例如在 HTML 文档中使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签。这样 Ky 可以被该模块直接导入，无需打包工具或其他工具。</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
import ky from 'https://unpkg.com/ky/distribution/index.js';

const json = await ky('https://jsonplaceholder.typicode.com/todos/1').json();

console.log(json.title);
//=&gt; 'delectus aut autem'
&lt;/script&gt;
</code></pre>
<h4>它与 <a href="https://github.com/sindresorhus/got"><code>got</code></a> 有何不同？</h4>
<p>请参见我在 <a href="https://twitter.com/sindresorhus/status/1037406558945042432">这里</a> 的回答。Got 由 Ky 的同一团队维护。</p>
<h4>它与 <a href="https://github.com/axios/axios"><code>axios</code></a> 有何不同？</h4>
<p>请参见我在 <a href="https://twitter.com/sindresorhus/status/1037763588826398720">这里</a> 的回答。</p>
<h4>它与 <a href="https://github.com/mikeal/r2"><code>r2</code></a> 有何不同？</h4>
<p>请参见我在 <a href="https://github.com/sindresorhus/ky/issues/10">#10</a> 的回答。</p>
<h4><code>ky</code> 是什么意思？</h4>
<p>这只是我抢到的一个随机简短 npm 包名。不过，它在日语中确实有含义：</p>
<blockquote>
<p>一种可用于短信的俚语，KY 是 “空気読めない (kuuki yomenai)” 的缩写，字面意思是“不会读空气”。用来形容那些没有领会言外之意的人。</p>
</blockquote>
<h2>浏览器支持</h2>
<p>最新版的 Chrome、Firefox 和 Safari。</p>
<h2>Node.js 支持</h2>
<p>Node.js 18 及以上版本。</p>
<h2>相关项目</h2>
<ul>
<li><a href="https://github.com/sindresorhus/fetch-extras">fetch-extras</a> - 用于处理 Fetch 的实用工具</li>
<li><a href="https://github.com/alice-health/ky-hooks-change-case">ky-hooks-change-case</a> - 用于在对象的请求和响应中修改大小写的 Ky 钩子</li>
</ul>
<h2>维护者</h2>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a></li>
<li><a href="https://github.com/sholladay">Seth Holladay</a></li>
<li><a href="https://github.com/szmarczak">Szymon Marczak</a></li>
</ul>
<pre><code>

---


Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-11


---
</code></pre>

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Statcounter and other scripts can be added here -->
</body>
</html>