<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ky - sindresorhus/ky ko</title>
    <meta name="title" content="ky - sindresorhus/ky ko | Ky는 Fetch API를 기반으로 한 작고 우아한 HTTP 클라이언트입니다. Ky는 최신 브라우저, Node.js, Bun, 그리고 Deno를 지원합니다. 이 패키지는 의존성이 없는 매우 작은 패키지입니다. 순수 fetch 대비 장점 더 간단한 API 메서드 단축키 (ky.post()...">
    <meta name="description" content="sindresorhus/ky - GitHub repository ko documentation and information | Ky는 Fetch API를 기반으로 한 작고 우아한 HTTP 클라이언트입니다. Ky는 최신 브라우저, Node.js, Bun, 그리고 Deno를 지원합니다. 이 패키지는 의존성이 없는 매우 작은 패키지입니다. 순수 fetch 대비 장점 더 간단한 API 메서드 단축키 (ky.post()...">
    <meta name="keywords" content="sindresorhus, ky, GitHub, repository, ko documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/sindresorhus/ky/README-ko.html">
    <meta property="og:title" content="ky - sindresorhus/ky ko | Ky는 Fetch API를 기반으로 한 작고 우아한 HTTP 클라이언트입니다. Ky는 최신 브라우저, Node.js, Bun, 그리고 Deno를 지원합니다. 이 패키지는 의존성이 없는 매우 작은 패키지입니다. 순수 fetch 대비 장점 더 간단한 API 메서드 단축키 (ky.post()...">
    <meta property="og:description" content="sindresorhus/ky - GitHub repository ko documentation and information | Ky는 Fetch API를 기반으로 한 작고 우아한 HTTP 클라이언트입니다. Ky는 최신 브라우저, Node.js, Bun, 그리고 Deno를 지원합니다. 이 패키지는 의존성이 없는 매우 작은 패키지입니다. 순수 fetch 대비 장점 더 간단한 API 메서드 단축키 (ky.post()...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/sindresorhus/ky" id="githubRepoLink" target="_blank">sindresorhus/ky</a>
<h1 style="display: none;">Ky는 Fetch API를 기반으로 한 작고 우아한 HTTP 클라이언트입니다. Ky는 최신 브라우저, Node.js, Bun, 그리고 Deno를 지원합니다. 이 패키지는 의존성이 없는 매우 작은 패키지입니다. 순수 fetch 대비 장점 더 간단한 API 메서드 단축키 (ky.post()...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div align="center">
	<br>
	<div>
		<img width="600" height="600" src="https://raw.githubusercontent.com/sindresorhus/ky/main/media/logo.svg" alt="ky">
	</div>
	<br>
	<br>
	<br>
</div>
<blockquote>
<p>Ky는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">Fetch API</a>를 기반으로 한 작고 우아한 HTTP 클라이언트입니다.</p>
</blockquote>
<p><a href="https://codecov.io/gh/sindresorhus/ky"><img src="https://codecov.io/gh/sindresorhus/ky/branch/main/graph/badge.svg" alt="Coverage Status" /></a>
<a href="https://bundlephobia.com/result?p=ky"><img src="https://badgen.net/bundlephobia/minzip/ky" alt="" /></a></p>
<p>Ky는 <a href="#browser-support">최신 브라우저</a>, Node.js, Bun, 그리고 Deno를 지원합니다.</p>
<p>이 패키지는 의존성이 없는 매우 작은 패키지입니다.</p>
<h2>순수 <code>fetch</code> 대비 장점</h2>
<ul>
<li>더 간단한 API</li>
<li>메서드 단축키 (<code>ky.post()</code>)</li>
<li>2xx가 아닌 상태 코드를 오류로 처리 (리디렉션 이후)</li>
<li>실패한 요청 재시도</li>
<li>JSON 옵션</li>
<li>타임아웃 지원</li>
<li>URL prefix 옵션</li>
<li>사용자 정의 기본값이 적용된 인스턴스</li>
<li>Hooks</li>
<li>TypeScript 편의성 (예: <code>.json()</code>은 제네릭을 지원하며 기본값이 <code>any</code>가 아닌 <code>unknown</code>)</li>
</ul>
<h2>설치</h2>
<pre><code class="language-sh">npm install ky
</code></pre>
<h6>CDN</h6>
<ul>
<li><a href="https://cdn.jsdelivr.net/npm/ky/+esm">jsdelivr</a></li>
<li><a href="https://unpkg.com/ky">unpkg</a></li>
<li><a href="https://esm.sh/ky">esm.sh</a></li>
</ul>
<h2>사용법</h2>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {json: {foo: true}}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>순수 <code>fetch</code>를 사용할 경우:</p>
<pre><code class="language-js">class HTTPError extends Error {}

const response = await fetch('https://example.com', {
	method: 'POST',
	body: JSON.stringify({foo: true}),
	headers: {
		'content-type': 'application/json'
	}
});

if (!response.ok) {
	throw new HTTPError(`Fetch error: ${response.statusText}`);
}

const json = await response.json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p><a href="https://github.com/denoland/deno">Deno</a>를 사용하는 경우, Ky를 URL에서 import 하십시오. 예를 들어 CDN을 사용할 때:</p>
<pre><code class="language-js">import ky from 'https://esm.sh/ky';
</code></pre>
<h2>API</h2>
<h3>ky(input, options?)</h3>
<p><code>input</code>과 <code>options</code>는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code></a>와 동일하며, 추가적인 <code>options</code>도 사용할 수 있습니다(아래 참고).</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body"><code>Body</code> 메서드</a>가 추가된 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code> 객체</a>를 반환합니다. 따라서, 예를 들어 <code>ky.get(input).json()</code>을 바로 호출할 수 있으며 <code>Response</code>를 먼저 await 할 필요가 없습니다. 이렇게 호출할 경우, 사용된 body 메서드에 따라 적절한 <code>Accept</code> 헤더가 설정됩니다. <code>window.Fetch</code>의 <code>Body</code> 메서드와 달리, 응답 상태가 <code>200...299</code> 범위가 아니면 <code>HTTPError</code>를 throw 합니다. 또한, <code>.json()</code>은 body가 비어있거나 응답 상태가 <code>204</code>일 경우 파싱 오류를 발생시키지 않고 빈 문자열을 반환합니다.</p>
<pre><code class="language-js">import ky from 'ky';

const user = await ky('/api/user').json();

console.log(user);
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> 선택적으로 <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">타입 파라미터</a>를 받을 수 있으며, 기본값은 <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>이고, <code>.json()</code>의 반환 타입으로 전달됩니다.</p>
<pre><code class="language-ts">import ky from 'ky';

// user1의 타입은 unknown
const user1 = await ky('/api/users/1').json();
// user2의 타입은 User
const user2 = await ky&lt;User&gt;('/api/users/2').json();
// user3의 타입은 User
const user3 = await ky('/api/users/3').json&lt;User&gt;();

console.log([user1, user2, user3]);
</code></pre>
<h3>ky.get(input, options?)</h3>
<h3>ky.post(input, options?)</h3>
<h3>ky.put(input, options?)</h3>
<h3>ky.patch(input, options?)</h3>
<h3>ky.head(input, options?)</h3>
<h3>ky.delete(input, options?)</h3>
<p><code>options.method</code>를 해당 메서드명으로 설정하고 요청을 보냅니다.</p>
<p>⌨️ <strong>TypeScript:</strong> JSON 응답에 사용할 선택적 타입 파라미터를 받을 수 있습니다(<a href="#kyinput-options"><code>ky()</code></a> 참고).</p>
<h4>input</h4>
<p>타입: <code>string</code> | <code>URL</code> | <code>Request</code></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#input"><code>fetch</code> input</a>과 동일합니다.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> 인스턴스를 <code>input</code>으로 사용할 때는, URL을 변경하는 옵션(예: <code>prefixUrl</code>)이 무시됩니다.</p>
<h4>options</h4>
<p>타입: <code>object</code></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch#options"><code>fetch</code> 옵션</a>과 동일하며, 다음과 같은 추가 옵션이 있습니다:</p>
<h5>method</h5>
<p>타입: <code>string</code><br />
기본값: <code>'get'</code></p>
<p>요청에 사용할 HTTP 메서드입니다.</p>
<p>내부적으로 표준 메서드(<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>HEAD</code>, <code>DELETE</code>)는 대문자로 변환되어 서버의 대소문자 구분 오류를 방지합니다.</p>
<h5>json</h5>
<p>타입: <code>object</code> 및 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a>가 허용하는 기타 값</p>
<p>JSON 전송을 위한 단축키입니다. <code>body</code> 옵션 대신 사용하세요. 일반 객체나 값을 받아 <code>JSON.stringify()</code>로 변환 후, 적절한 헤더와 함께 body에 전송합니다.</p>
<h5>searchParams</h5>
<p>타입: <code>string | object&lt;string, string | number | boolean&gt; | Array&lt;Array&lt;string | number | boolean&gt;&gt; | URLSearchParams</code><br />
기본값: <code>''</code></p>
<p>요청 URL에 포함할 쿼리 파라미터입니다. 설정 시 input URL의 기존 쿼리 파라미터를 모두 덮어씁니다.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams"><code>URLSearchParams()</code></a>가 지원하는 모든 값을 허용합니다.</p>
<h5>prefixUrl</h5>
<p>타입: <code>string | URL</code></p>
<p>요청 시 <code>input</code> URL 앞에 붙일 prefix입니다. 상대 또는 절대 경로 모두 허용합니다. 후행 슬래시 <code>/</code>는 필요시 자동으로 추가됩니다. 문자열로 <code>input</code>을 사용할 때만 적용됩니다. 이 옵션을 사용할 때 <code>input</code> 인자는 슬래시 <code>/</code>로 시작할 수 없습니다.</p>
<p><a href="#kyextenddefaultoptions"><code>ky.extend()</code></a>와 함께 사용하여 특정 목적에 맞는 Ky 인스턴스를 만들 때 유용합니다.</p>
<pre><code class="language-js">import ky from 'ky';

// https://example.com에서

const response = await ky('unicorn', {prefixUrl: '/api'});
//=&gt; 'https://example.com/api/unicorn'

const response2 = await ky('unicorn', {prefixUrl: 'https://cats.com'});
//=&gt; 'https://cats.com/unicorn'
</code></pre>
<p>참고:</p>
<ul>
<li><code>prefixUrl</code>과 <code>input</code>이 결합된 후, 결과는 페이지의 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/baseURI">base URL</a>(있을 경우)을 기준으로 해석됩니다.</li>
<li>이 옵션을 사용할 때 <code>input</code>에 슬래시(<code>/</code>)로 시작하는 것은 허용되지 않습니다. 일관성 및 URL 처리 방식의 혼란을 방지하기 위함이며, <code>prefixUrl</code> 사용 시 <code>input</code>이 일반적인 URL 해석 규칙을 따르지 않기 때문입니다.</li>
</ul>
<h5>retry</h5>
<p>타입: <code>object | number</code><br />
기본값:</p>
<ul>
<li><code>limit</code>: <code>2</code></li>
<li><code>methods</code>: <code>get</code> <code>put</code> <code>head</code> <code>delete</code> <code>options</code> <code>trace</code></li>
<li><code>statusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"><code>408</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"><code>500</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"><code>502</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"><code>504</code></a></li>
<li><code>afterStatusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a></li>
<li><code>maxRetryAfter</code>: <code>undefined</code></li>
<li><code>backoffLimit</code>: <code>undefined</code></li>
<li><code>delay</code>: <code>attemptCount =&gt; 0.3 * (2 ** (attemptCount - 1)) * 1000</code></li>
</ul>
<p><code>limit</code>, <code>methods</code>, <code>statusCodes</code>, <code>afterStatusCodes</code>, 그리고 <code>maxRetryAfter</code> 필드를 나타내는 객체로, 최대 재시도 횟수, 허용되는 메서드, 허용되는 상태 코드, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 시간을 사용할 수 있는 상태 코드, 그리고 최대 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 시간을 지정합니다.</p>
<p><code>retry</code>가 숫자인 경우, 해당 값이 <code>limit</code>으로 사용되며 나머지 기본값은 그대로 유지됩니다.</p>
<p>응답이 <code>afterStatusCodes</code>에 포함된 HTTP 상태 코드를 제공하면 Ky는 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 헤더에 명시된 날짜, 타임아웃 또는 타임스탬프가 지난 후 요청을 재시도합니다. 만약 <code>Retry-After</code>가 없으면, 비표준 <a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-05.html#section-3.3"><code>RateLimit-Reset</code></a> 헤더가 대체로 사용됩니다. 제공된 상태 코드가 목록에 없으면 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 헤더는 무시됩니다.</p>
<p><code>maxRetryAfter</code>가 <code>undefined</code>로 설정되면, <code>options.timeout</code>이 사용됩니다. <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> 헤더 값이 <code>maxRetryAfter</code>보다 크면, <code>maxRetryAfter</code> 값이 사용됩니다.</p>
<p><code>backoffLimit</code> 옵션은 재시도마다 최대 지연 시간을 밀리초 단위로 지정합니다.
예를 들어, 지연 시간을 제한하려면 <code>backoffLimit</code>을 1000으로 설정하십시오.
기본적으로 지연 시간은 <code>0.3 * (2 ** (attemptCount - 1)) * 1000</code>으로 계산됩니다. 지연 시간은 지수적으로 증가합니다.</p>
<p><code>delay</code> 옵션을 사용하여 재시도 간 지연 시간 계산 방식을 변경할 수 있습니다. 이 함수는 시도 횟수(1부터 시작)를 인자로 받습니다.</p>
<p><a href="#timeout">timeout</a> 이후에는 재시도가 발생하지 않습니다.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky('https://example.com', {
	retry: {
		limit: 10,
		methods: ['get'],
		statusCodes: [413],
		backoffLimit: 3000
	}
}).json();
</code></pre>
<h5>timeout</h5>
<p>타입: <code>number | false</code><br />
기본값: <code>10000</code></p>
<p>응답을 받기 위한 타임아웃(밀리초 단위, 재시도 포함)입니다. 2147483647보다 클 수 없습니다.
<code>false</code>로 설정하면 타임아웃이 없습니다.</p>
<h5>hooks</h5>
<p>타입: <code>object&lt;string, Function[]&gt;</code><br />
기본값: <code>{beforeRequest: [], beforeRetry: [], afterResponse: []}</code></p>
<p>Hooks는 요청 라이프사이클 중에 수정 작업을 허용합니다. Hook 함수는 async일 수 있으며 순차적으로 실행됩니다.</p>
<h6>hooks.beforeRequest</h6>
<p>타입: <code>Function[]</code><br />
기본값: <code>[]</code></p>
<p>이 훅을 사용하면 요청이 전송되기 직전에 요청을 수정할 수 있습니다. 이 이후로 Ky는 요청에 대해 추가로 변경하지 않습니다. 훅 함수는 <code>request</code>와 <code>options</code>를 인수로 받습니다. 예를 들어, 여기서 <code>request.headers</code>를 수정할 수 있습니다.</p>
<p>훅은 나가는 요청을 대체할 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a>를 반환하거나, HTTP 요청 자체를 하지 않도록 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a>를 반환할 수 있습니다. 이를 통해 요청을 모킹하거나, 내부 캐시를 확인하는 등의 작업이 가능합니다. <strong>중요:</strong> 이 훅에서 request나 response를 반환하면 남은 <code>beforeRequest</code> 훅들은 건너뛰게 되므로, 마지막 훅에서만 반환하는 것이 좋습니다.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.extend({
	hooks: {
		beforeRequest: [
			request =&gt; {
				request.headers.set('X-Requested-With', 'ky');
			}
		]
	}
});

const response = await api.get('https://example.com/api/users');
</code></pre>
<h6>hooks.beforeRetry</h6>
<p>타입: <code>Function[]</code><br />
기본값: <code>[]</code></p>
<p>이 훅을 사용하면 재시도 직전에 요청을 수정할 수 있습니다. 이 이후로 Ky는 요청에 대해 추가로 변경하지 않습니다. 훅 함수는 정규화된 request, options, 에러 인스턴스, 재시도 횟수가 포함된 객체를 인수로 받습니다. 예를 들어 여기서 <code>request.headers</code>를 수정할 수 있습니다.</p>
<p>요청이 응답을 받았다면, 에러는 <code>HTTPError</code> 타입이며 <code>error.response</code>에서 <code>Response</code> 객체를 사용할 수 있습니다. 네트워크 오류 등 일부 에러는 응답을 받지 못할 수 있으니, 이 경우에는 에러가 <code>HTTPError</code> 인스턴스가 아닐 수 있습니다.</p>
<p>재시도를 방지하려면 에러를 throw 하십시오. Ky는 해당 에러를 처리하지 않으며, 요청을 시작한 쪽으로 에러가 전파됩니다. 이런 경우 남은 <code>beforeRetry</code> 훅들은 호출되지 않습니다. 또는 <a href="#kystop"><code>ky.stop</code></a> 심볼을 반환하여 에러를 전파하지 않고 같은 효과를 낼 수 있습니다(자세한 내용은 <code>ky.stop</code> 문서 참조).</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const token = await ky('https://example.com/refresh-token');
				request.headers.set('Authorization', `token ${token}`);
			}
		]
	}
});
</code></pre>
<h6>hooks.beforeError</h6>
<p>타입: <code>Function[]</code><br />
기본값: <code>[]</code></p>
<p>이 훅을 사용하면 <code>HTTPError</code>가 throw 되기 직전에 수정할 수 있습니다. 훅 함수는 <code>HTTPError</code>를 인수로 받고, <code>HTTPError</code> 인스턴스를 반환해야 합니다.</p>
<pre><code class="language-js">import ky from 'ky';

await ky('https://example.com', {
	hooks: {
		beforeError: [
			error =&gt; {
				const {response} = error;
				if (response &amp;&amp; response.body) {
					error.name = 'GitHubError';
					error.message = `${response.body.message} (${response.status})`;
				}

				return error;
			}
		]
	}
});
</code></pre>
<h6>hooks.afterResponse</h6>
<p>타입: <code>Function[]</code><br />
기본값: <code>[]</code></p>
<p>이 훅을 사용하면 응답을 읽고 선택적으로 수정할 수 있습니다. 훅 함수는 정규화된 request, options, 복제된 response를 인수로 받습니다. 훅 함수의 반환값이 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> 인스턴스라면 Ky는 이를 응답 객체로 사용합니다.</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		afterResponse: [
			(_request, _options, response) =&gt; {
				// 예시: 응답을 로깅하는 등
				log(response);

				// 또는 응답을 덮어쓸 `Response` 인스턴스 반환
				return new Response('A different response', {status: 200});
			},

			// 또는 403 에러 시 토큰 갱신 후 재시도
			async (request, options, response) =&gt; {
				if (response.status === 403) {
					// 새 토큰 발급
					const token = await ky('https://example.com/token').text();

					// 토큰과 함께 재시도
					request.headers.set('Authorization', `token ${token}`);

					return ky(request);
				}
			}
		]
	}
});
</code></pre>
<h5>throwHttpErrors</h5>
<p>타입: <code>boolean</code><br />
기본값: <code>true</code></p>
<p>리디렉션을 따른 후에도 응답이 2xx가 아닌 상태 코드일 때 <code>HTTPError</code>를 throw 합니다. 리디렉션도 예외로 처리하려면 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters"><code>redirect</code></a> 옵션을 <code>'manual'</code>로 설정하세요.</p>
<p>리소스 가용성 확인 등 에러 응답이 예상되는 경우, 이 값을 <code>false</code>로 설정하는 것이 유용할 수 있습니다.</p>
<p>참고: <code>false</code>인 경우 에러 응답도 성공으로 간주되며, 요청이 재시도되지 않습니다.</p>
<h5>onDownloadProgress</h5>
<p>타입: <code>Function</code></p>
<p>다운로드 진행 상황 이벤트 핸들러입니다.</p>
<p>함수는 다음 인자를 받습니다:</p>
<ul>
<li><code>progress</code>: 아래 속성을 가진 객체</li>
<li>
<ul>
<li><code>percent</code>: 진행률(0과 1 사이의 숫자)</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code>: 지금까지 전송된 바이트 수</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code>: 전체 전송 바이트 수(추정치, 전체 크기를 알 수 없는 경우 0일 수 있음)</li>
</ul>
</li>
<li><code>chunk</code>: 전송된 데이터가 담긴 <code>Uint8Array</code> 인스턴스. 참고: 첫 호출에서는 비어 있음.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	onDownloadProgress: (progress, chunk) =&gt; {
		// 예시 출력:
		// `0% - 0 of 1271 bytes`
		// `100% - 1271 of 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} of ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>onUploadProgress</h5>
<p>타입: <code>Function</code>
업로드 진행 이벤트 핸들러.</p>
<p>이 함수는 다음과 같은 인수를 받습니다:</p>
<ul>
<li><code>progress</code>는 다음 속성을 가진 객체입니다:
<ul>
<li><code>percent</code>는 진행 퍼센티지를 나타내는 0과 1 사이의 숫자입니다.</li>
<li><code>transferredBytes</code>는 지금까지 전송된 바이트 수입니다.</li>
<li><code>totalBytes</code>는 전송될 전체 바이트 수입니다. 이는 추정치이며 전체 크기를 알 수 없을 경우 0일 수 있습니다.</li>
</ul>
</li>
<li><code>chunk</code>는 전송된 데이터를 포함하는 <code>Uint8Array</code> 인스턴스입니다. 참고: 마지막 호출에서는 비어 있습니다.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky.post('https://example.com/upload', {
	body: largeFile,
	onUploadProgress: (progress, chunk) =&gt; {
		// 예시 출력:
		// `0% - 0 of 1271 bytes`
		// `100% - 1271 of 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} of ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>parseJson</h5>
<p>타입: <code>Function</code><br />
기본값: <code>JSON.parse()</code></p>
<p>사용자 정의 JSON 파싱 함수.</p>
<p>사용 사례:</p>
<ol>
<li><a href="https://github.com/hapijs/bourne"><code>bourne</code> 패키지</a>를 통해 JSON을 파싱하여 프로토타입 오염을 방지.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>JSON.parse()</code>의 <code>reviver</code> 옵션</a>을 사용하여 JSON 파싱.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import bourne from '@hapijs/bourne';

const json = await ky('https://example.com', {
	parseJson: text =&gt; bourne(text)
}).json();
</code></pre>
<h5>stringifyJson</h5>
<p>타입: <code>Function</code><br />
기본값: <code>JSON.stringify()</code></p>
<p>사용자 정의 JSON 문자열화 함수.</p>
<p>사용 사례:</p>
<ol>
<li>사용자 정의 <code>replacer</code> 함수를 사용하여 JSON을 문자열화.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import {DateTime} from 'luxon';

const json = await ky('https://example.com', {
	stringifyJson: data =&gt; JSON.stringify(data, (key, value) =&gt; {
		if (key.endsWith('_at')) {
			return DateTime.fromISO(value).toSeconds();
		}

		return value;
	})
}).json();
</code></pre>
<h5>fetch</h5>
<p>타입: <code>Function</code><br />
기본값: <code>fetch</code></p>
<p>사용자 정의 <code>fetch</code> 함수.
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> 표준과 완전히 호환되어야 합니다.</p>
<p>사용 사례:</p>
<ol>
<li><a href="https://www.npmjs.com/package/isomorphic-unfetch"><code>isomorphic-unfetch</code></a>과 같은 사용자 정의 <code>fetch</code> 구현 사용.</li>
<li>서버 사이드 렌더링(SSR)을 사용하는 일부 프레임워크에서 제공하는 <code>fetch</code> 래퍼 함수 사용.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import fetch from 'isomorphic-unfetch';

const json = await ky('https://example.com', {fetch}).json();
</code></pre>
<h3>ky.extend(defaultOptions)</h3>
<p>기본값 중 일부를 자신의 값으로 덮어쓴 새로운 <code>ky</code> 인스턴스를 생성합니다.</p>
<p><code>ky.create()</code>와 달리, <code>ky.extend()</code>는 부모의 기본값을 상속합니다.</p>
<p>헤더는 <code>Headers</code> 인스턴스나 일반 객체로 전달할 수 있습니다.</p>
<p><code>.extend()</code>에 헤더를 <code>undefined</code> 값으로 전달하여 헤더를 제거할 수 있습니다.
문자열로서 <code>undefined</code>를 전달하면 해당 헤더가 <code>Headers</code> 인스턴스에서 온 경우에만 제거됩니다.</p>
<p>마찬가지로, 명시적으로 <code>undefined</code>로 후크를 확장하여 기존 <code>hooks</code> 항목을 제거할 수 있습니다.</p>
<pre><code class="language-js">import ky from 'ky';

const url = 'https://sindresorhus.com';

const original = ky.create({
	headers: {
		rainbow: 'rainbow',
		unicorn: 'unicorn'
	},
	hooks: {
		beforeRequest: [ () =&gt; console.log('before 1') ],
		afterResponse: [ () =&gt; console.log('after 1') ],
	},
});

const extended = original.extend({
	headers: {
		rainbow: undefined
	},
	hooks: {
		beforeRequest: undefined,
		afterResponse: [ () =&gt; console.log('after 2') ],
	}
});

const response = await extended(url).json();
//=&gt; after 1
//=&gt; after 2

console.log('rainbow' in response);
//=&gt; false

console.log('unicorn' in response);
//=&gt; true
</code></pre>
<p>함수를 <code>.extend()</code>에 제공하여 부모 기본값을 참조할 수도 있습니다.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.create({prefixUrl: 'https://example.com/api'});

const usersApi = api.extend((options) =&gt; ({prefixUrl: `${options.prefixUrl}/users`}));

const response = await usersApi.get('123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('version');
//=&gt; 'https://example.com/api/version'
</code></pre>
<h3>ky.create(defaultOptions)</h3>
<p>완전히 새로운 기본값으로 새로운 Ky 인스턴스를 생성합니다.</p>
<pre><code class="language-js">import ky from 'ky';

// https://my-site.com 에서

const api = ky.create({prefixUrl: 'https://example.com/api'});

const response = await api.get('users/123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('/status', {prefixUrl: ''});
//=&gt; 'https://my-site.com/status'
</code></pre>
<h4>defaultOptions</h4>
<p>타입: <code>object</code></p>
<h3>ky.stop</h3>
<p>재시도를 중지하기 위해 <code>beforeRetry</code> 훅에서 반환할 수 있는 <code>Symbol</code>입니다. 이것은 남은 <code>beforeRetry</code> 훅도 단락(short circuit)됩니다.</p>
<p>참고: 이 심볼을 반환하면 Ky는 중단되고 <code>undefined</code> 응답을 반환합니다. 응답의 속성에 접근하기 전에 반드시 응답이 있는지 확인하거나 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">옵셔널 체이닝</a>을 사용하세요. 또한, 본문 메서드(예: <code>.json()</code>, <code>.text()</code> 등)와는 호환되지 않습니다. 응답이 없기 때문입니다. 일반적으로 이 심볼을 반환하는 것보다 오류를 throw하는 것이 더 낫습니다. 오류를 throw하면 Ky가 중단되고 예외를 발생시키므로 이런 제한을 피할 수 있습니다.</p>
<p><code>ky.stop</code>의 유효한 사용 사례는 반환 데이터가 중요하지 않은 부수 효과(side effect)를 위한 요청에서 재시도를 방지하는 것입니다. 예: 클라이언트 활동을 서버에 로깅할 때.</p>
<pre><code class="language-js">import ky from 'ky';

const options = {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const shouldStopRetry = await ky('https://example.com/api');
				if (shouldStopRetry) {
					return ky.stop;
				}
			}
		]
	}
};
</code></pre>
<pre><code class="language-js">// `ky.stop`이 반환된 경우 `response`는 `undefined`가 됩니다.
const response = await ky.post('https://example.com', options);

// `.text()` 또는 기타 body 메서드는 지원되지 않습니다.
const text = await ky('https://example.com', options).text();
</code></pre>
<h3>HTTPError</h3>
<p><code>instanceof</code> 체크를 위해 노출되어 있습니다. 이 에러는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code> 객체</a>를 가진 <code>response</code> 속성, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code> 객체</a>를 가진 <code>request</code> 속성, 그리고 정규화된 옵션(인스턴스를 <code>ky.create()</code>로 생성할 때 또는 요청 수행 시 직접 <code>ky</code>에 전달된 옵션)을 가진 <code>options</code> 속성을 가집니다.</p>
<p>일부 에러 유형, 예를 들어 네트워크 에러 등은 본질적으로 응답을 받지 못했음을 의미합니다. 이 경우 에러는 HTTPError의 인스턴스가 아니며 <code>response</code> 속성을 포함하지 않습니다.</p>
<p><code>HTTPError</code>가 발생했을 때 실제 응답을 읽어야 한다면, response 객체에서 해당 파서 메서드를 호출하세요. 예시:</p>
<pre><code class="language-js">try {
	await ky('https://example.com').json();
} catch (error) {
	if (error.name === 'HTTPError') {
		const errorJson = await error.response.json();
	}
}
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">타입 매개변수</a>를 옵션으로 받아들이며, 기본값은 <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>이고, <code>error.response.json()</code>의 반환 타입으로 전달됩니다.</p>
<h3>TimeoutError</h3>
<p>요청이 타임아웃될 때 발생하는 에러입니다. <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code> 객체</a>를 가진 <code>request</code> 속성을 가집니다.</p>
<h2>Tips</h2>
<h3>폼 데이터 전송</h3>
<p>Ky에서 폼 데이터를 전송하는 방법은 <code>fetch</code>와 동일합니다. <code>body</code> 옵션에 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a> 인스턴스를 전달하세요. <code>Content-Type</code> 헤더는 자동으로 <code>multipart/form-data</code>로 설정됩니다.</p>
<pre><code class="language-js">import ky from 'ky';

// `multipart/form-data`
const formData = new FormData();
formData.append('food', 'fries');
formData.append('drink', 'icetea');

const response = await ky.post(url, {body: formData});
</code></pre>
<p><code>application/x-www-form-urlencoded</code> 형식으로 데이터를 보내고 싶다면, <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a>로 데이터를 인코딩해야 합니다.</p>
<pre><code class="language-js">import ky from 'ky';

// `application/x-www-form-urlencoded`
const searchParams = new URLSearchParams();
searchParams.set('food', 'fries');
searchParams.set('drink', 'icetea');

const response = await ky.post(url, {body: searchParams});
</code></pre>
<h3>사용자 지정 <code>Content-Type</code> 설정</h3>
<p>Ky는 요청 본문의 데이터에 따라 적절한 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 헤더를 자동으로 설정합니다. 하지만 일부 API는 <code>application/x-amz-json-1.1</code>과 같은 비표준 콘텐츠 타입을 요구할 수 있습니다. 이 경우 <code>headers</code> 옵션을 사용해 수동으로 콘텐츠 타입을 오버라이드할 수 있습니다.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {
	headers: {
		'content-type': 'application/json'
	},
	json: {
		foo: true
	},
}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<h3>요청 취소</h3>
<p>Fetch(그리고 Ky)는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code> API</a>를 통한 요청 취소를 기본적으로 지원합니다. <a href="https://developers.google.com/web/updates/2017/09/abortable-fetch">더 알아보기.</a></p>
<p>예시:</p>
<pre><code class="language-js">import ky from 'ky';

const controller = new AbortController();
const {signal} = controller;

setTimeout(() =&gt; {
	controller.abort();
}, 5000);

try {
	console.log(await ky(url, {signal}).text());
} catch (error) {
	if (error.name === 'AbortError') {
		console.log('Fetch aborted');
	} else {
		console.error('Fetch error:', error);
	}
}
</code></pre>
<h2>FAQ</h2>
<h4>Node.js에서 어떻게 사용하나요?</h4>
<p>Node.js 18 이상에서는 <code>fetch</code>를 네이티브로 지원하므로 이 패키지를 바로 사용할 수 있습니다.</p>
<h4>서버 사이드 렌더링(SSR)을 사용하는 웹 앱(React, Vue.js 등)에서 어떻게 사용하나요?</h4>
<p>위와 동일하게 사용하면 됩니다.</p>
<h4>이 패키지를 사용하는 브라우저 라이브러리를 어떻게 테스트하나요?</h4>
<p>Mocha와 같이 브라우저에서 실행 가능한 테스트 러너를 사용하거나, <a href="https://avajs.dev">AVA</a>와 <code>ky-universal</code>을 사용하세요. <a href="https://github.com/sindresorhus/ky-universal#faq">더 알아보기.</a></p>
<h4>Webpack과 같은 번들러 없이 사용하려면 어떻게 하나요?</h4>
<p>코드가 JavaScript 모듈(ESM)로 실행되고 있는지 확인하세요. 예를 들어 HTML 문서에서 <code>&lt;script type=&quot;module&quot;&gt;</code> 태그를 사용하세요. 그러면 Ky를 번들러나 다른 도구 없이 해당 모듈에서 직접 임포트할 수 있습니다.</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
import ky from 'https://unpkg.com/ky/distribution/index.js';

const json = await ky('https://jsonplaceholder.typicode.com/todos/1').json();

console.log(json.title);
//=&gt; 'delectus aut autem'
&lt;/script&gt;
</code></pre>
<h4><a href="https://github.com/sindresorhus/got"><code>got</code></a>과의 차이점은 무엇인가요?</h4>
<p><a href="https://twitter.com/sindresorhus/status/1037406558945042432">여기</a>에서 답변을 확인하세요. Got은 Ky와 동일한 사람들이 관리합니다.</p>
<h4><a href="https://github.com/axios/axios"><code>axios</code></a>와의 차이점은 무엇인가요?</h4>
<p><a href="https://twitter.com/sindresorhus/status/1037763588826398720">여기</a>에서 답변을 확인하세요.</p>
<h4><a href="https://github.com/mikeal/r2"><code>r2</code></a>와의 차이점은 무엇인가요?</h4>
<p><a href="https://github.com/sindresorhus/ky/issues/10">#10</a>에서 답변을 확인하세요.</p>
<h4><code>ky</code>는 무슨 뜻인가요?</h4>
<p>그냥 운좋게 얻은 짧은 npm 패키지명입니다. 하지만 일본어로 의미가 있긴 합니다:</p>
<blockquote>
<p>문자로 표현 가능한 속어의 한 형태인 KY는 空気読めない(쿠키 요메나이)의 약자로, 직역하면 &quot;공기를 읽지 못한다&quot;라는 뜻입니다. 암시된 의미를 읽지 못하는 사람에게 사용되는 표현입니다.</p>
</blockquote>
<h2>브라우저 지원</h2>
<p>최신 버전의 Chrome, Firefox, Safari를 지원합니다.</p>
<h2>Node.js 지원</h2>
<p>Node.js 18 이상.</p>
<h2>관련</h2>
<ul>
<li><a href="https://github.com/sindresorhus/fetch-extras">fetch-extras</a> - Fetch 작업에 유용한 유틸리티</li>
<li><a href="https://github.com/alice-health/ky-hooks-change-case">ky-hooks-change-case</a> - 객체의 요청과 응답 케이스를 변경하는 Ky 훅</li>
</ul>
<h2>유지관리자</h2>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a></li>
<li><a href="https://github.com/sholladay">Seth Holladay</a></li>
<li><a href="https://github.com/szmarczak">Szymon Marczak</a></li>
</ul>
<pre><code>

---


Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-11


---
</code></pre>

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>