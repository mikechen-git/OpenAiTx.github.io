<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ky - sindresorhus/ky</title>
    <meta name="title" content="ky - sindresorhus/ky">
    <meta name="description" content="sindresorhus/ky - GitHub repository es documentation and informationKy es un cliente HTTP pequeño y elegante basado en la Fetch API Ky está orientado a navegadores modernos, Node.js, Bun y Deno. Es solo un paquete pequeño sin de...">
    <meta name="keywords" content="sindresorhus, ky, GitHub, repository, es documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/sindresorhus/ky/README-es.html">
    <meta property="og:title" content="ky - sindresorhus/ky">
    <meta property="og:description" content="sindresorhus/ky - GitHub repository es documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/sindresorhus/ky" id="githubRepoLink" target="_blank">sindresorhus/ky</a>
<h1 style="display: none;">Ky es un cliente HTTP pequeño y elegante basado en la Fetch API Ky está orientado a navegadores modernos, Node.js, Bun y Deno. Es solo un paquete pequeño sin de...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div align="center">
	<br>
	<div>
		<img width="600" height="600" src="https://raw.githubusercontent.com/sindresorhus/ky/main/media/logo.svg" alt="ky">
	</div>
	<br>
	<br>
	<br>
</div>
<blockquote>
<p>Ky es un cliente HTTP pequeño y elegante basado en la <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">Fetch API</a></p>
</blockquote>
<p><a href="https://codecov.io/gh/sindresorhus/ky"><img src="https://codecov.io/gh/sindresorhus/ky/branch/main/graph/badge.svg" alt="Coverage Status" /></a>
<a href="https://bundlephobia.com/result?p=ky"><img src="https://badgen.net/bundlephobia/minzip/ky" alt="" /></a></p>
<p>Ky está orientado a <a href="#browser-support">navegadores modernos</a>, Node.js, Bun y Deno.</p>
<p>Es solo un paquete pequeño sin dependencias.</p>
<h2>Ventajas sobre el <code>fetch</code> puro</h2>
<ul>
<li>API más simple</li>
<li>Atajos para métodos (<code>ky.post()</code>)</li>
<li>Trata los códigos de estado no 2xx como errores (después de redirecciones)</li>
<li>Reintenta solicitudes fallidas</li>
<li>Opción para JSON</li>
<li>Soporte para tiempo de espera (timeout)</li>
<li>Opción de prefijo de URL</li>
<li>Instancias con valores predeterminados personalizados</li>
<li>Hooks</li>
<li>Mejoras para TypeScript (por ejemplo, <code>.json()</code> soporta genéricos y por defecto retorna <code>unknown</code>, no <code>any</code>)</li>
</ul>
<h2>Instalación</h2>
<pre><code class="language-sh">npm install ky
</code></pre>
<h6>CDN</h6>
<ul>
<li><a href="https://cdn.jsdelivr.net/npm/ky/+esm">jsdelivr</a></li>
<li><a href="https://unpkg.com/ky">unpkg</a></li>
<li><a href="https://esm.sh/ky">esm.sh</a></li>
</ul>
<h2>Uso</h2>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {json: {foo: true}}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Con <code>fetch</code> puro, sería:</p>
<pre><code class="language-js">class HTTPError extends Error {}

const response = await fetch('https://example.com', {
	method: 'POST',
	body: JSON.stringify({foo: true}),
	headers: {
		'content-type': 'application/json'
	}
});

if (!response.ok) {
	throw new HTTPError(`Fetch error: ${response.statusText}`);
}

const json = await response.json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Si usas <a href="https://github.com/denoland/deno">Deno</a>, importa Ky desde una URL. Por ejemplo, usando un CDN:</p>
<pre><code class="language-js">import ky from 'https://esm.sh/ky';
</code></pre>
<h2>API</h2>
<h3>ky(input, options?)</h3>
<p>El <code>input</code> y las <code>options</code> son las mismas que en <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code></a>, con opciones adicionales disponibles (ver más abajo).</p>
<p>Devuelve un <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">objeto <code>Response</code></a> con <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body">métodos de <code>Body</code></a> añadidos para mayor comodidad. Así puedes, por ejemplo, llamar a <code>ky.get(input).json()</code> directamente sin tener que esperar primero el <code>Response</code>. Cuando se llama de esta manera, se establecerá una cabecera <code>Accept</code> apropiada dependiendo del método de cuerpo utilizado. A diferencia de los métodos <code>Body</code> de <code>window.Fetch</code>, estos lanzarán un <code>HTTPError</code> si el estado de la respuesta no está en el rango de <code>200...299</code>. Además, <code>.json()</code> devolverá una cadena vacía si el cuerpo está vacío o el estado de la respuesta es <code>204</code> en lugar de lanzar un error de análisis debido a un cuerpo vacío.</p>
<pre><code class="language-js">import ky from 'ky';

const user = await ky('/api/user').json();

console.log(user);
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> Acepta un <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">parámetro de tipo</a> opcional, que por defecto es <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>, y se pasa al tipo de retorno de <code>.json()</code>.</p>
<pre><code class="language-ts">import ky from 'ky';

// user1 es unknown
const user1 = await ky('/api/users/1').json();
// user2 es un User
const user2 = await ky&lt;User&gt;('/api/users/2').json();
// user3 es un User
const user3 = await ky('/api/users/3').json&lt;User&gt;();

console.log([user1, user2, user3]);
</code></pre>
<h3>ky.get(input, options?)</h3>
<h3>ky.post(input, options?)</h3>
<h3>ky.put(input, options?)</h3>
<h3>ky.patch(input, options?)</h3>
<h3>ky.head(input, options?)</h3>
<h3>ky.delete(input, options?)</h3>
<p>Establece <code>options.method</code> al nombre del método y realiza una solicitud.</p>
<p>⌨️ <strong>TypeScript:</strong> Acepta un parámetro de tipo opcional para usar con respuestas JSON (ver <a href="#kyinput-options"><code>ky()</code></a>).</p>
<h4>input</h4>
<p>Tipo: <code>string</code> | <code>URL</code> | <code>Request</code></p>
<p>Igual que el <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#input">input de <code>fetch</code></a>.</p>
<p>Cuando se usa una instancia de <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> como <code>input</code>, se ignorarán todas las opciones que alteran la URL (como <code>prefixUrl</code>).</p>
<h4>options</h4>
<p>Tipo: <code>object</code></p>
<p>Igual que las <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch#options">opciones de <code>fetch</code></a>, más las siguientes opciones adicionales:</p>
<h5>method</h5>
<p>Tipo: <code>string</code><br />
Por defecto: <code>'get'</code></p>
<p>Método HTTP utilizado para realizar la solicitud.</p>
<p>Internamente, los métodos estándar (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>HEAD</code> y <code>DELETE</code>) se convierten a mayúsculas para evitar errores del servidor debido a la sensibilidad de mayúsculas y minúsculas.</p>
<h5>json</h5>
<p>Tipo: <code>object</code> y cualquier otro valor aceptado por <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a></p>
<p>Atajo para enviar JSON. Usa esto en lugar de la opción <code>body</code>. Acepta cualquier objeto plano o valor, que será convertido con <code>JSON.stringify()</code> y enviado en el cuerpo con la cabecera correcta establecida.</p>
<h5>searchParams</h5>
<p>Tipo: <code>string | object&lt;string, string | number | boolean&gt; | Array&lt;Array&lt;string | number | boolean&gt;&gt; | URLSearchParams</code><br />
Por defecto: <code>''</code></p>
<p>Parámetros de búsqueda para incluir en la URL de la solicitud. Establecer esto sobrescribirá todos los parámetros de búsqueda existentes en la URL de entrada.</p>
<p>Acepta cualquier valor soportado por <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams"><code>URLSearchParams()</code></a>.</p>
<h5>prefixUrl</h5>
<p>Tipo: <code>string | URL</code></p>
<p>Un prefijo para anteponer a la URL de <code>input</code> al realizar la solicitud. Puede ser cualquier URL válida, relativa o absoluta. Una barra final <code>/</code> es opcional y se añadirá automáticamente, si es necesario, cuando se combine con <code>input</code>. Solo tiene efecto cuando <code>input</code> es una cadena. El argumento <code>input</code> no puede comenzar con una barra <code>/</code> cuando se usa esta opción.</p>
<p>Útil cuando se usa con <a href="#kyextenddefaultoptions"><code>ky.extend()</code></a> para crear instancias de Ky específicas para un nicho.</p>
<pre><code class="language-js">import ky from 'ky';

// En https://example.com

const response = await ky('unicorn', {prefixUrl: '/api'});
//=&gt; 'https://example.com/api/unicorn'

const response2 = await ky('unicorn', {prefixUrl: 'https://cats.com'});
//=&gt; 'https://cats.com/unicorn'
</code></pre>
<p>Notas:</p>
<ul>
<li>Después de unir <code>prefixUrl</code> e <code>input</code>, el resultado se resuelve contra la <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/baseURI">URL base</a> de la página (si la hay).</li>
<li>No se permiten barras iniciales en <code>input</code> al usar esta opción para reforzar la consistencia y evitar confusiones sobre cómo se maneja la URL de <code>input</code>, dado que <code>input</code> no seguirá las reglas normales de resolución de URL cuando se utilice <code>prefixUrl</code>, lo que cambia el significado de una barra inicial.</li>
</ul>
<h5>retry</h5>
<p>Tipo: <code>object | number</code><br />
Por defecto:</p>
<ul>
<li><code>limit</code>: <code>2</code></li>
<li><code>methods</code>: <code>get</code> <code>put</code> <code>head</code> <code>delete</code> <code>options</code> <code>trace</code></li>
<li><code>statusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"><code>408</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"><code>500</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"><code>502</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"><code>504</code></a></li>
<li><code>afterStatusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a></li>
<li><code>maxRetryAfter</code>: <code>undefined</code></li>
<li><code>backoffLimit</code>: <code>undefined</code></li>
<li><code>delay</code>: <code>attemptCount =&gt; 0.3 * (2 ** (attemptCount - 1)) * 1000</code></li>
</ul>
<p>Un objeto que representa los campos <code>limit</code>, <code>methods</code>, <code>statusCodes</code>, <code>afterStatusCodes</code> y <code>maxRetryAfter</code> para el número máximo de reintentos, métodos permitidos, códigos de estado permitidos, códigos de estado permitidos para usar el tiempo de <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>, y el tiempo máximo de <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>.</p>
<p>Si <code>retry</code> es un número, se utilizará como <code>limit</code> y los demás valores predeterminados permanecerán.</p>
<p>Si la respuesta proporciona un código de estado HTTP contenido en <code>afterStatusCodes</code>, Ky esperará hasta la fecha, tiempo de espera o marca de tiempo indicada en la cabecera <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> antes de reintentar la solicitud. Si falta el encabezado <code>Retry-After</code>, se utiliza en su lugar la cabecera no estándar <a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-05.html#section-3.3"><code>RateLimit-Reset</code></a> como alternativa. Si el código de estado proporcionado no está en la lista, se ignorará la cabecera <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>.</p>
<p>Si <code>maxRetryAfter</code> se establece en <code>undefined</code>, utilizará <code>options.timeout</code>. Si el encabezado <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> es mayor que <code>maxRetryAfter</code>, se usará <code>maxRetryAfter</code>.</p>
<p>La opción <code>backoffLimit</code> es el límite superior del retraso por reintento en milisegundos.
Para limitar el retraso, establece <code>backoffLimit</code> en 1000, por ejemplo.
Por defecto, el retraso se calcula con <code>0.3 * (2 ** (attemptCount - 1)) * 1000</code>. El retraso aumenta exponencialmente.</p>
<p>La opción <code>delay</code> se puede utilizar para cambiar cómo se calcula el retraso entre reintentos. La función recibe un parámetro, el número de intento, comenzando en <code>1</code>.</p>
<p>Los reintentos no se activan tras un <a href="#timeout">timeout</a>.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky('https://example.com', {
	retry: {
		limit: 10,
		methods: ['get'],
		statusCodes: [413],
		backoffLimit: 3000
	}
}).json();
</code></pre>
<h5>timeout</h5>
<p>Tipo: <code>number | false</code><br />
Predeterminado: <code>10000</code></p>
<p>Tiempo de espera en milisegundos para obtener una respuesta, incluyendo cualquier reintento. No puede ser mayor que 2147483647.
Si se establece en <code>false</code>, no habrá límite de tiempo de espera.</p>
<h5>hooks</h5>
<p>Tipo: <code>object&lt;string, Function[]&gt;</code><br />
Predeterminado: <code>{beforeRequest: [], beforeRetry: [], afterResponse: []}</code></p>
<p>Los hooks permiten modificaciones durante el ciclo de vida de la solicitud. Las funciones hook pueden ser asíncronas y se ejecutan en serie.</p>
<h6>hooks.beforeRequest</h6>
<p>Tipo: <code>Function[]</code><br />
Predeterminado: <code>[]</code></p>
<p>Este hook te permite modificar la solicitud justo antes de que sea enviada. Ky no realizará más cambios en la solicitud después de esto. La función del hook recibe <code>request</code> y <code>options</code> como argumentos. Por ejemplo, podrías modificar aquí <code>request.headers</code>.</p>
<p>El hook puede devolver un <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> para reemplazar la solicitud saliente, o devolver un <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> para evitar completamente hacer una solicitud HTTP. Esto se puede usar para simular una solicitud, consultar una caché interna, etc. Una consideración <strong>importante</strong> al devolver una solicitud o respuesta desde este hook es que cualquier hook <code>beforeRequest</code> restante será omitido, por lo que puede que solo desees devolverlos desde el último hook.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.extend({
	hooks: {
		beforeRequest: [
			request =&gt; {
				request.headers.set('X-Requested-With', 'ky');
			}
		]
	}
});

const response = await api.get('https://example.com/api/users');
</code></pre>
<h6>hooks.beforeRetry</h6>
<p>Tipo: <code>Function[]</code><br />
Predeterminado: <code>[]</code></p>
<p>Este hook te permite modificar la solicitud justo antes del reintento. Ky no realizará más cambios en la solicitud después de esto. La función hook recibe un objeto con la solicitud y opciones normalizadas, una instancia de error y el número de reintento. Por ejemplo, podrías modificar aquí <code>request.headers</code>.</p>
<p>Si la solicitud recibió una respuesta, el error será de tipo <code>HTTPError</code> y el objeto <code>Response</code> estará disponible en <code>error.response</code>. Ten en cuenta que algunos tipos de errores, como errores de red, implican que no se recibió una respuesta. En ese caso, el error no será una instancia de <code>HTTPError</code>.</p>
<p>Puedes evitar que Ky reintente la solicitud lanzando un error. Ky no lo manejará de ninguna manera y el error será propagado al iniciador de la solicitud. El resto de los hooks <code>beforeRetry</code> no serán llamados en este caso. Alternativamente, puedes devolver el símbolo <a href="#kystop"><code>ky.stop</code></a> para hacer lo mismo pero sin propagar un error (esto tiene algunas limitaciones, consulta la documentación de <code>ky.stop</code> para más detalles).</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const token = await ky('https://example.com/refresh-token');
				request.headers.set('Authorization', `token ${token}`);
			}
		]
	}
});
</code></pre>
<h6>hooks.beforeError</h6>
<p>Tipo: <code>Function[]</code><br />
Predeterminado: <code>[]</code></p>
<p>Este hook te permite modificar el <code>HTTPError</code> justo antes de que sea lanzado. La función del hook recibe un <code>HTTPError</code> como argumento y debe devolver una instancia de <code>HTTPError</code>.</p>
<pre><code class="language-js">import ky from 'ky';

await ky('https://example.com', {
	hooks: {
		beforeError: [
			error =&gt; {
				const {response} = error;
				if (response &amp;&amp; response.body) {
					error.name = 'GitHubError';
					error.message = `${response.body.message} (${response.status})`;
				}

				return error;
			}
		]
	}
});
</code></pre>
<h6>hooks.afterResponse</h6>
<p>Tipo: <code>Function[]</code><br />
Predeterminado: <code>[]</code></p>
<p>Este hook te permite leer y, opcionalmente, modificar la respuesta. La función hook recibe la solicitud normalizada, las opciones y un clon de la respuesta como argumentos. El valor devuelto por la función hook será usado por Ky como el objeto de respuesta si es una instancia de <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a>.</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		afterResponse: [
			(_request, _options, response) =&gt; {
				// Podrías hacer algo con la respuesta, por ejemplo, registrar.
				log(response);

				// O devolver una instancia de `Response` para sobrescribir la respuesta.
				return new Response('Una respuesta diferente', {status: 200});
			},

			// O reintentar con un token nuevo ante un error 403
			async (request, options, response) =&gt; {
				if (response.status === 403) {
					// Obtener un token nuevo
					const token = await ky('https://example.com/token').text();

					// Reintentar con el token
					request.headers.set('Authorization', `token ${token}`);

					return ky(request);
				}
			}
		]
	}
});
</code></pre>
<h5>throwHttpErrors</h5>
<p>Tipo: <code>boolean</code><br />
Predeterminado: <code>true</code></p>
<p>Lanza un <code>HTTPError</code> cuando, después de seguir redirecciones, la respuesta tiene un código de estado que no es 2xx. Para lanzar también en caso de redirecciones en vez de seguirlas, establece la opción <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters"><code>redirect</code></a> en <code>'manual'</code>.</p>
<p>Poner esto en <code>false</code> puede ser útil si estás comprobando la disponibilidad de un recurso y esperas respuestas de error.</p>
<p>Nota: Si es <code>false</code>, las respuestas de error se consideran exitosas y la solicitud no se reintentará.</p>
<h5>onDownloadProgress</h5>
<p>Tipo: <code>Function</code></p>
<p>Manejador de eventos para el progreso de descarga.</p>
<p>La función recibe estos argumentos:</p>
<ul>
<li><code>progress</code> es un objeto con las siguientes propiedades:</li>
<li>
<ul>
<li><code>percent</code> es un número entre 0 y 1 que representa el porcentaje de progreso.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> es el número de bytes transferidos hasta el momento.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> es el número total de bytes a transferir. Esto es una estimación y puede ser 0 si no se puede determinar el tamaño total.</li>
</ul>
</li>
<li><code>chunk</code> es una instancia de <code>Uint8Array</code> que contiene los datos enviados. Nota: Está vacío en la primera llamada.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	onDownloadProgress: (progress, chunk) =&gt; {
		// Ejemplo de salida:
		// `0% - 0 de 1271 bytes`
		// `100% - 1271 de 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} de ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>onUploadProgress</h5>
<p>Tipo: <code>Function</code></p>
<p>Controlador de eventos de progreso de carga.</p>
<p>La función recibe estos argumentos:</p>
<ul>
<li><code>progress</code> es un objeto con las siguientes propiedades:</li>
<li>
<ul>
<li><code>percent</code> es un número entre 0 y 1 que representa el porcentaje de progreso.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> es el número de bytes transferidos hasta el momento.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> es el total de bytes que se van a transferir. Esto es una estimación y puede ser 0 si no se puede determinar el tamaño total.</li>
</ul>
</li>
<li><code>chunk</code> es una instancia de <code>Uint8Array</code> que contiene los datos que se enviaron. Nota: Está vacío en la última llamada.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky.post('https://example.com/upload', {
	body: largeFile,
	onUploadProgress: (progress, chunk) =&gt; {
		// Salida de ejemplo:
		// `0% - 0 de 1271 bytes`
		// `100% - 1271 de 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} de ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>parseJson</h5>
<p>Tipo: <code>Function</code><br />
Por defecto: <code>JSON.parse()</code></p>
<p>Función personalizada de análisis de JSON.</p>
<p>Casos de uso:</p>
<ol>
<li>Analizar JSON mediante el paquete <a href="https://github.com/hapijs/bourne"><code>bourne</code></a> para proteger contra la contaminación de prototipos.</li>
<li>Analizar JSON con la opción <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>reviver</code> de <code>JSON.parse()</code></a>.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import bourne from '@hapijs/bourne';

const json = await ky('https://example.com', {
	parseJson: text =&gt; bourne(text)
}).json();
</code></pre>
<h5>stringifyJson</h5>
<p>Tipo: <code>Function</code><br />
Por defecto: <code>JSON.stringify()</code></p>
<p>Función personalizada para convertir a JSON.</p>
<p>Casos de uso:</p>
<ol>
<li>Convertir a JSON con una función personalizada <code>replacer</code>.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import {DateTime} from 'luxon';

const json = await ky('https://example.com', {
	stringifyJson: data =&gt; JSON.stringify(data, (key, value) =&gt; {
		if (key.endsWith('_at')) {
			return DateTime.fromISO(value).toSeconds();
		}

		return value;
	})
}).json();
</code></pre>
<h5>fetch</h5>
<p>Tipo: <code>Function</code><br />
Por defecto: <code>fetch</code></p>
<p>Función <code>fetch</code> definida por el usuario.
Debe ser completamente compatible con el estándar de la <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>.</p>
<p>Casos de uso:</p>
<ol>
<li>Usar implementaciones personalizadas de <code>fetch</code> como <a href="https://www.npmjs.com/package/isomorphic-unfetch"><code>isomorphic-unfetch</code></a>.</li>
<li>Usar la función envoltorio de <code>fetch</code> proporcionada por algunos frameworks que usan renderizado del lado del servidor (SSR).</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import fetch from 'isomorphic-unfetch';

const json = await ky('https://example.com', {fetch}).json();
</code></pre>
<h3>ky.extend(defaultOptions)</h3>
<p>Crea una nueva instancia de <code>ky</code> con algunos valores por defecto sobrescritos por los tuyos.</p>
<p>A diferencia de <code>ky.create()</code>, <code>ky.extend()</code> hereda los valores por defecto de su padre.</p>
<p>Puedes pasar cabeceras como una instancia de <code>Headers</code> o como un objeto plano.</p>
<p>Puedes eliminar una cabecera con <code>.extend()</code> pasando la cabecera con un valor <code>undefined</code>.
Pasar <code>undefined</code> como cadena elimina la cabecera solo si proviene de una instancia de <code>Headers</code>.</p>
<p>De manera similar, puedes eliminar entradas existentes de <code>hooks</code> extendiendo el hook con un <code>undefined</code> explícito.</p>
<pre><code class="language-js">import ky from 'ky';

const url = 'https://sindresorhus.com';

const original = ky.create({
	headers: {
		rainbow: 'rainbow',
		unicorn: 'unicorn'
	},
	hooks: {
		beforeRequest: [ () =&gt; console.log('before 1') ],
		afterResponse: [ () =&gt; console.log('after 1') ],
	},
});

const extended = original.extend({
	headers: {
		rainbow: undefined
	},
	hooks: {
		beforeRequest: undefined,
		afterResponse: [ () =&gt; console.log('after 2') ],
	}
});

const response = await extended(url).json();
//=&gt; after 1
//=&gt; after 2

console.log('rainbow' in response);
//=&gt; false

console.log('unicorn' in response);
//=&gt; true
</code></pre>
<p>También puedes referenciar los valores por defecto del padre proporcionando una función a <code>.extend()</code>.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.create({prefixUrl: 'https://example.com/api'});

const usersApi = api.extend((options) =&gt; ({prefixUrl: `${options.prefixUrl}/users`}));

const response = await usersApi.get('123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('version');
//=&gt; 'https://example.com/api/version'
</code></pre>
<h3>ky.create(defaultOptions)</h3>
<p>Crea una nueva instancia de Ky con valores por defecto completamente nuevos.</p>
<pre><code class="language-js">import ky from 'ky';

// En https://my-site.com

const api = ky.create({prefixUrl: 'https://example.com/api'});

const response = await api.get('users/123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('/status', {prefixUrl: ''});
//=&gt; 'https://my-site.com/status'
</code></pre>
<h4>defaultOptions</h4>
<p>Tipo: <code>object</code></p>
<h3>ky.stop</h3>
<p>Un <code>Symbol</code> que puede ser retornado por un hook <code>beforeRetry</code> para detener el reintento. Esto también interrumpe los hooks <code>beforeRetry</code> restantes.</p>
<p>Nota: Retornar este símbolo hace que Ky aborte y devuelva una respuesta <code>undefined</code>. Asegúrate de comprobar la existencia de una respuesta antes de acceder a cualquiera de sus propiedades o utiliza <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a>. También es incompatible con los métodos del cuerpo, como <code>.json()</code> o <code>.text()</code>, ya que no hay respuesta para analizar. En general, recomendamos lanzar un error en lugar de retornar este símbolo, ya que eso hará que Ky aborte y luego lance una excepción, lo que evita estas limitaciones.</p>
<p>Un caso de uso válido para <code>ky.stop</code> es evitar reintentos al hacer solicitudes para efectos secundarios, donde los datos devueltos no son importantes. Por ejemplo, registrar la actividad del cliente en el servidor.</p>
<pre><code class="language-js">import ky from 'ky';

const options = {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const shouldStopRetry = await ky('https://example.com/api');
				if (shouldStopRetry) {
					return ky.stop;
				}
			}
		]
	}
};
</code></pre>
<pre><code class="language-markdown">// Ten en cuenta que la respuesta será `undefined` en caso de que se retorne `ky.stop`.
const response = await ky.post('https://example.com', options);

// No se admite el uso de `.text()` u otros métodos de cuerpo.
const text = await ky('https://example.com', options).text();
</code></pre>
<h3>HTTPError</h3>
<p>Expuesto para comprobaciones con <code>instanceof</code>. El error tiene una propiedad <code>response</code> con el <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">objeto <code>Response</code></a>, una propiedad <code>request</code> con el <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">objeto <code>Request</code></a>, y una propiedad <code>options</code> con las opciones normalizadas (ya sea pasadas a <code>ky</code> al crear una instancia con <code>ky.create()</code> o directamente al realizar la solicitud).</p>
<p>Ten en cuenta que algunos tipos de errores, como los errores de red, implican inherentemente que no se recibió una respuesta. En ese caso, el error no será una instancia de HTTPError y no contendrá una propiedad <code>response</code>.</p>
<p>Si necesitas leer la respuesta real cuando ha ocurrido un <code>HTTPError</code>, llama al método de análisis respectivo en el objeto response. Por ejemplo:</p>
<pre><code class="language-js">try {
	await ky('https://example.com').json();
} catch (error) {
	if (error.name === 'HTTPError') {
		const errorJson = await error.response.json();
	}
}
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> Acepta un <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">parámetro de tipo</a> opcional, que por defecto es <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>, y se pasa al tipo de retorno de <code>error.response.json()</code>.</p>
<h3>TimeoutError</h3>
<p>El error lanzado cuando la solicitud supera el tiempo de espera. Tiene una propiedad <code>request</code> con el <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">objeto <code>Request</code></a>.</p>
<h2>Consejos</h2>
<h3>Enviar datos de formulario</h3>
<p>Enviar datos de formulario en Ky es idéntico a <code>fetch</code>. Simplemente pasa una instancia de <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a> a la opción <code>body</code>. El encabezado <code>Content-Type</code> se establecerá automáticamente en <code>multipart/form-data</code>.</p>
<pre><code class="language-js">import ky from 'ky';

// `multipart/form-data`
const formData = new FormData();
formData.append('food', 'fries');
formData.append('drink', 'icetea');

const response = await ky.post(url, {body: formData});
</code></pre>
<p>Si deseas enviar los datos en formato <code>application/x-www-form-urlencoded</code>, deberás codificar los datos con <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a>.</p>
<pre><code class="language-js">import ky from 'ky';

// `application/x-www-form-urlencoded`
const searchParams = new URLSearchParams();
searchParams.set('food', 'fries');
searchParams.set('drink', 'icetea');

const response = await ky.post(url, {body: searchParams});
</code></pre>
<h3>Establecer un <code>Content-Type</code> personalizado</h3>
<p>Ky establece automáticamente un encabezado <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> apropiado para cada solicitud según los datos en el cuerpo de la solicitud. Sin embargo, algunas APIs requieren tipos de contenido personalizados o no estándar, como <code>application/x-amz-json-1.1</code>. Usando la opción <code>headers</code>, puedes sobrescribir manualmente el tipo de contenido.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {
	headers: {
		'content-type': 'application/json'
	},
	json: {
		foo: true
	},
}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<h3>Cancelación</h3>
<p>Fetch (y por lo tanto Ky) tiene soporte integrado para la cancelación de solicitudes mediante la <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController">API <code>AbortController</code></a>. <a href="https://developers.google.com/web/updates/2017/09/abortable-fetch">Leer más.</a></p>
<p>Ejemplo:</p>
<pre><code class="language-js">import ky from 'ky';

const controller = new AbortController();
const {signal} = controller;

setTimeout(() =&gt; {
	controller.abort();
}, 5000);

try {
	console.log(await ky(url, {signal}).text());
} catch (error) {
	if (error.name === 'AbortError') {
		console.log('Fetch abortado');
	} else {
		console.error('Error de fetch:', error);
	}
}
</code></pre>
<h2>Preguntas frecuentes (FAQ)</h2>
<h4>¿Cómo uso esto en Node.js?</h4>
<p>Node.js 18 y versiones posteriores soportan <code>fetch</code> de forma nativa, así que puedes usar este paquete directamente.</p>
<h4>¿Cómo uso esto con una aplicación web (React, Vue.js, etc.) que utiliza renderizado del lado del servidor (SSR)?</h4>
<p>Igual que lo anterior.</p>
<h4>¿Cómo pruebo una librería de navegador que usa esto?</h4>
<p>Usa un test runner que pueda ejecutarse en el navegador, como Mocha, o utiliza <a href="https://avajs.dev">AVA</a> con <code>ky-universal</code>. <a href="https://github.com/sindresorhus/ky-universal#faq">Leer más.</a></p>
<h4>¿Cómo uso esto sin un empaquetador como Webpack?</h4>
<p>Asegúrate de que tu código se esté ejecutando como un módulo de JavaScript (ESM), por ejemplo usando una etiqueta <code>&lt;script type=&quot;module&quot;&gt;</code> en tu documento HTML. Entonces Ky puede ser importado directamente por ese módulo sin un empaquetador u otras herramientas.</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
import ky from 'https://unpkg.com/ky/distribution/index.js';

const json = await ky('https://jsonplaceholder.typicode.com/todos/1').json();

console.log(json.title);
//=&gt; 'delectus aut autem'
&lt;/script&gt;
</code></pre>
<h4>¿En qué se diferencia de <a href="https://github.com/sindresorhus/got"><code>got</code></a>?</h4>
<p>Mira mi respuesta <a href="https://twitter.com/sindresorhus/status/1037406558945042432">aquí</a>. Got es mantenido por las mismas personas que Ky.</p>
<h4>¿En qué se diferencia de <a href="https://github.com/axios/axios"><code>axios</code></a>?</h4>
<p>Mira mi respuesta <a href="https://twitter.com/sindresorhus/status/1037763588826398720">aquí</a>.</p>
<h4>¿En qué se diferencia de <a href="https://github.com/mikeal/r2"><code>r2</code></a>?</h4>
<p>Mira mi respuesta en <a href="https://github.com/sindresorhus/ky/issues/10">#10</a>.</p>
<h4>¿Qué significa <code>ky</code>?</h4>
<p>Es solo un nombre corto aleatorio de paquete npm que logré conseguir. Sin embargo, sí tiene un significado en japonés:</p>
<blockquote>
<p>Una forma de jerga textual, KY es una abreviatura de 空気読めない (kuuki yomenai), que literalmente se traduce como “no puede leer el aire”. Es una frase que se aplica a alguien que no capta el significado implícito.</p>
</blockquote>
<h2>Compatibilidad con navegadores</h2>
<p>La última versión de Chrome, Firefox y Safari.</p>
<h2>Compatibilidad con Node.js</h2>
<p>Node.js 18 y posteriores.</p>
<h2>Relacionados</h2>
<ul>
<li><a href="https://github.com/sindresorhus/fetch-extras">fetch-extras</a> - Utilidades útiles para trabajar con Fetch</li>
<li><a href="https://github.com/alice-health/ky-hooks-change-case">ky-hooks-change-case</a> - Hooks de Ky para modificar los casos en solicitudes y respuestas de objetos</li>
</ul>
<h2>Mantenedores</h2>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a></li>
<li><a href="https://github.com/sholladay">Seth Holladay</a></li>
<li><a href="https://github.com/szmarczak">Szymon Marczak</a></li>
</ul>
<pre><code>

---


Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-11


---
</code></pre>

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Statcounter and other scripts can be added here -->
</body>
</html>