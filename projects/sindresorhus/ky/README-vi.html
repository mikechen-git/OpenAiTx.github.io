<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ky - sindresorhus/ky</title>
    <meta name="title" content="ky - sindresorhus/ky">
    <meta name="description" content="sindresorhus/ky - GitHub repository vi documentation and informationKy là một client HTTP nhỏ gọn và thanh lịch dựa trên Fetch API Ky hướng tới trình duyệt hiện đại, Node.js, Bun và Deno. Nó chỉ là một gói nhỏ gọn, không có phụ ...">
    <meta name="keywords" content="sindresorhus, ky, GitHub, repository, vi documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/sindresorhus/ky/README-vi.html">
    <meta property="og:title" content="ky - sindresorhus/ky">
    <meta property="og:description" content="sindresorhus/ky - GitHub repository vi documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/sindresorhus/ky" id="githubRepoLink" target="_blank">sindresorhus/ky</a>
<h1 style="display: none;">Ky là một client HTTP nhỏ gọn và thanh lịch dựa trên Fetch API Ky hướng tới trình duyệt hiện đại, Node.js, Bun và Deno. Nó chỉ là một gói nhỏ gọn, không có phụ ...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div align="center">
	<br>
	<div>
		<img width="600" height="600" src="https://raw.githubusercontent.com/sindresorhus/ky/main/media/logo.svg" alt="ky">
	</div>
	<br>
	<br>
	<br>
</div>
<blockquote>
<p>Ky là một client HTTP nhỏ gọn và thanh lịch dựa trên <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">Fetch API</a></p>
</blockquote>
<p><a href="https://codecov.io/gh/sindresorhus/ky"><img src="https://codecov.io/gh/sindresorhus/ky/branch/main/graph/badge.svg" alt="Coverage Status" /></a>
<a href="https://bundlephobia.com/result?p=ky"><img src="https://badgen.net/bundlephobia/minzip/ky" alt="" /></a></p>
<p>Ky hướng tới <a href="#browser-support">trình duyệt hiện đại</a>, Node.js, Bun và Deno.</p>
<p>Nó chỉ là một gói nhỏ gọn, không có phụ thuộc nào.</p>
<h2>Lợi ích so với <code>fetch</code> thuần túy</h2>
<ul>
<li>API đơn giản hơn</li>
<li>Các phương thức rút gọn (<code>ky.post()</code>)</li>
<li>Xử lý các mã trạng thái không phải 2xx là lỗi (sau khi chuyển hướng)</li>
<li>Tự động thử lại các yêu cầu thất bại</li>
<li>Tùy chọn JSON</li>
<li>Hỗ trợ timeout</li>
<li>Tùy chọn tiền tố URL</li>
<li>Các instance với mặc định tùy chỉnh</li>
<li>Hooks</li>
<li>Hỗ trợ TypeScript tốt (ví dụ: <code>.json()</code> hỗ trợ generics và mặc định là <code>unknown</code>, không phải <code>any</code>)</li>
</ul>
<h2>Cài đặt</h2>
<pre><code class="language-sh">npm install ky
</code></pre>
<h6>CDN</h6>
<ul>
<li><a href="https://cdn.jsdelivr.net/npm/ky/+esm">jsdelivr</a></li>
<li><a href="https://unpkg.com/ky">unpkg</a></li>
<li><a href="https://esm.sh/ky">esm.sh</a></li>
</ul>
<h2>Sử dụng</h2>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {json: {foo: true}}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Với <code>fetch</code> thuần túy, bạn sẽ làm như sau:</p>
<pre><code class="language-js">class HTTPError extends Error {}

const response = await fetch('https://example.com', {
	method: 'POST',
	body: JSON.stringify({foo: true}),
	headers: {
		'content-type': 'application/json'
	}
});

if (!response.ok) {
	throw new HTTPError(`Fetch error: ${response.statusText}`);
}

const json = await response.json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Nếu bạn đang sử dụng <a href="https://github.com/denoland/deno">Deno</a>, hãy import Ky từ một URL. Ví dụ, sử dụng CDN:</p>
<pre><code class="language-js">import ky from 'https://esm.sh/ky';
</code></pre>
<h2>API</h2>
<h3>ky(input, options?)</h3>
<p><code>input</code> và <code>options</code> giống như <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code></a>, với các tùy chọn bổ sung (xem bên dưới).</p>
<p>Trả về một <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Đối tượng Response</code></a> với các <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body">phương thức <code>Body</code></a> được bổ sung để tiện sử dụng. Vì vậy, bạn có thể gọi trực tiếp <code>ky.get(input).json()</code> mà không cần phải await <code>Response</code> trước. Khi gọi như vậy, một header <code>Accept</code> phù hợp sẽ được tự động thiết lập tùy thuộc vào phương thức body được sử dụng. Không giống như các phương thức <code>Body</code> của <code>window.Fetch</code>, các phương thức này sẽ ném ra <code>HTTPError</code> nếu trạng thái phản hồi không nằm trong khoảng <code>200...299</code>. Ngoài ra, <code>.json()</code> sẽ trả về chuỗi rỗng nếu body rỗng hoặc trạng thái phản hồi là <code>204</code> thay vì ném lỗi parse do body rỗng.</p>
<pre><code class="language-js">import ky from 'ky';

const user = await ky('/api/user').json();

console.log(user);
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> Nhận một <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">type parameter</a> tùy chọn, mặc định là <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>, và được truyền vào kiểu trả về của <code>.json()</code>.</p>
<pre><code class="language-ts">import ky from 'ky';

// user1 là unknown
const user1 = await ky('/api/users/1').json();
// user2 là User
const user2 = await ky&lt;User&gt;('/api/users/2').json();
// user3 là User
const user3 = await ky('/api/users/3').json&lt;User&gt;();

console.log([user1, user2, user3]);
</code></pre>
<h3>ky.get(input, options?)</h3>
<h3>ky.post(input, options?)</h3>
<h3>ky.put(input, options?)</h3>
<h3>ky.patch(input, options?)</h3>
<h3>ky.head(input, options?)</h3>
<h3>ky.delete(input, options?)</h3>
<p>Thiết lập <code>options.method</code> thành tên phương thức và thực hiện yêu cầu.</p>
<p>⌨️ <strong>TypeScript:</strong> Nhận một type parameter tùy chọn khi sử dụng với phản hồi JSON (xem <a href="#kyinput-options"><code>ky()</code></a>).</p>
<h4>input</h4>
<p>Kiểu: <code>string</code> | <code>URL</code> | <code>Request</code></p>
<p>Giống như <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#input">input của <code>fetch</code></a>.</p>
<p>Khi sử dụng một instance <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> làm <code>input</code>, mọi tùy chọn thay đổi URL (như <code>prefixUrl</code>) sẽ bị bỏ qua.</p>
<h4>options</h4>
<p>Kiểu: <code>object</code></p>
<p>Giống như <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch#options">options của <code>fetch</code></a>, cộng thêm các tùy chọn bổ sung sau:</p>
<h5>method</h5>
<p>Kiểu: <code>string</code><br />
Mặc định: <code>'get'</code></p>
<p>Phương thức HTTP dùng để thực hiện yêu cầu.</p>
<p>Bên trong, các phương thức chuẩn (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>HEAD</code> và <code>DELETE</code>) sẽ được chuyển thành chữ hoa để tránh lỗi máy chủ do phân biệt chữ hoa/thường.</p>
<h5>json</h5>
<p>Kiểu: <code>object</code> và bất kỳ giá trị nào được <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> chấp nhận</p>
<p>Lối tắt để gửi JSON. Sử dụng cái này thay cho tùy chọn <code>body</code>. Chấp nhận bất kỳ object thuần hoặc giá trị nào, sẽ được <code>JSON.stringify()</code> và gửi trong body với header chính xác được thiết lập.</p>
<h5>searchParams</h5>
<p>Kiểu: <code>string | object&lt;string, string | number | boolean&gt; | Array&lt;Array&lt;string | number | boolean&gt;&gt; | URLSearchParams</code><br />
Mặc định: <code>''</code></p>
<p>Các tham số tìm kiếm để thêm vào URL yêu cầu. Thiết lập cái này sẽ ghi đè tất cả tham số tìm kiếm hiện có trong URL input.</p>
<p>Chấp nhận mọi giá trị được <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams"><code>URLSearchParams()</code></a> hỗ trợ.</p>
<h5>prefixUrl</h5>
<p>Kiểu: <code>string | URL</code></p>
<p>Tiền tố để nối vào URL <code>input</code> khi thực hiện yêu cầu. Có thể là bất kỳ URL hợp lệ nào, tương đối hoặc tuyệt đối. Dấu gạch chéo <code>/</code> ở cuối là tùy chọn và sẽ được tự động thêm vào nếu cần khi nối với <code>input</code>. Chỉ có tác dụng khi <code>input</code> là chuỗi. Đối số <code>input</code> không được bắt đầu bằng dấu gạch chéo <code>/</code> khi sử dụng tùy chọn này.</p>
<p>Hữu ích khi dùng với <a href="#kyextenddefaultoptions"><code>ky.extend()</code></a> để tạo các instance Ky chuyên biệt cho từng mục đích.</p>
<pre><code class="language-js">import ky from 'ky';

// Tại https://example.com

const response = await ky('unicorn', {prefixUrl: '/api'});
//=&gt; 'https://example.com/api/unicorn'

const response2 = await ky('unicorn', {prefixUrl: 'https://cats.com'});
//=&gt; 'https://cats.com/unicorn'
</code></pre>
<p>Lưu ý:</p>
<ul>
<li>Sau khi <code>prefixUrl</code> và <code>input</code> được nối, kết quả sẽ được resolve dựa trên <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/baseURI">base URL</a> của trang (nếu có).</li>
<li>Không được phép có dấu gạch chéo đầu trong <code>input</code> khi sử dụng tùy chọn này để đảm bảo tính nhất quán và tránh nhầm lẫn về cách xử lý URL <code>input</code>, vì <code>input</code> sẽ không tuân theo quy tắc resolve URL thông thường khi dùng <code>prefixUrl</code>, điều này làm thay đổi ý nghĩa của dấu gạch chéo đầu.</li>
</ul>
<h5>retry</h5>
<p>Kiểu: <code>object | number</code><br />
Mặc định:</p>
<ul>
<li><code>limit</code>: <code>2</code></li>
<li><code>methods</code>: <code>get</code> <code>put</code> <code>head</code> <code>delete</code> <code>options</code> <code>trace</code></li>
<li><code>statusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"><code>408</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"><code>500</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"><code>502</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"><code>504</code></a></li>
<li><code>afterStatusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a></li>
<li><code>maxRetryAfter</code>: <code>undefined</code></li>
<li><code>backoffLimit</code>: <code>undefined</code></li>
<li><code>delay</code>: <code>attemptCount =&gt; 0.3 * (2 ** (attemptCount - 1)) * 1000</code></li>
</ul>
<p>Một đối tượng đại diện cho các trường <code>limit</code>, <code>methods</code>, <code>statusCodes</code>, <code>afterStatusCodes</code>, và <code>maxRetryAfter</code> dùng cho số lần thử lại tối đa, các phương thức được phép, các mã trạng thái được phép, các mã trạng thái được phép sử dụng thời gian <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>, và thời gian <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> tối đa.</p>
<p>Nếu <code>retry</code> là một số, nó sẽ được sử dụng làm <code>limit</code> và các giá trị mặc định khác sẽ giữ nguyên.</p>
<p>Nếu phản hồi trả về mã trạng thái HTTP nằm trong <code>afterStatusCodes</code>, Ky sẽ chờ đến ngày, thời gian chờ, hoặc dấu thời gian được cung cấp trong header <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> đã qua rồi mới thử lại yêu cầu. Nếu thiếu <code>Retry-After</code>, header không chuẩn <a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-05.html#section-3.3"><code>RateLimit-Reset</code></a> sẽ được dùng thay thế. Nếu mã trạng thái cung cấp không nằm trong danh sách, header <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> sẽ bị bỏ qua.</p>
<p>Nếu <code>maxRetryAfter</code> được đặt là <code>undefined</code>, nó sẽ sử dụng <code>options.timeout</code>. Nếu giá trị header <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> lớn hơn <code>maxRetryAfter</code>, nó sẽ dùng <code>maxRetryAfter</code>.</p>
<p>Tùy chọn <code>backoffLimit</code> là giới hạn trên của độ trễ cho mỗi lần thử lại tính bằng mili giây.
Để giới hạn độ trễ, ví dụ đặt <code>backoffLimit</code> là 1000.
Mặc định, độ trễ được tính bằng <code>0.3 * (2 ** (attemptCount - 1)) * 1000</code>. Độ trễ sẽ tăng theo hàm mũ.</p>
<p>Tùy chọn <code>delay</code> có thể được sử dụng để thay đổi cách tính độ trễ giữa các lần thử lại. Hàm này nhận một tham số là số lần thử, bắt đầu từ <code>1</code>.</p>
<p>Các lần thử lại sẽ không được kích hoạt sau một <a href="#timeout">timeout</a>.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky('https://example.com', {
	retry: {
		limit: 10,
		methods: ['get'],
		statusCodes: [413],
		backoffLimit: 3000
	}
}).json();
</code></pre>
<h5>timeout</h5>
<p>Kiểu: <code>number | false</code><br />
Mặc định: <code>10000</code></p>
<p>Thời gian chờ tính bằng mili giây để nhận được phản hồi, bao gồm cả các lần thử lại. Không được lớn hơn 2147483647.
Nếu đặt là <code>false</code>, sẽ không có timeout.</p>
<h5>hooks</h5>
<p>Kiểu: <code>object&lt;string, Function[]&gt;</code><br />
Mặc định: <code>{beforeRequest: [], beforeRetry: [], afterResponse: []}</code></p>
<p>Hooks cho phép chỉnh sửa trong suốt vòng đời của yêu cầu. Các hàm hook có thể là async và được thực thi tuần tự.</p>
<h6>hooks.beforeRequest</h6>
<p>Kiểu: <code>Function[]</code><br />
Mặc định: <code>[]</code></p>
<p>Hook này cho phép bạn chỉnh sửa yêu cầu ngay trước khi gửi đi. Ky sẽ không thay đổi gì thêm sau đó. Hàm hook nhận các đối số là <code>request</code> và <code>options</code>. Ví dụ, bạn có thể chỉnh sửa <code>request.headers</code> tại đây.</p>
<p>Hook có thể trả về một <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> để thay thế yêu cầu gửi đi, hoặc trả về một <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> để hoàn toàn không thực hiện yêu cầu HTTP. Điều này có thể dùng để giả lập một yêu cầu, kiểm tra bộ nhớ đệm nội bộ, v.v. Một lưu ý <strong>quan trọng</strong> khi trả về request hoặc response từ hook này là các hook <code>beforeRequest</code> còn lại sẽ bị bỏ qua, nên bạn chỉ nên trả về chúng ở hook cuối cùng.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.extend({
	hooks: {
		beforeRequest: [
			request =&gt; {
				request.headers.set('X-Requested-With', 'ky');
			}
		]
	}
});

const response = await api.get('https://example.com/api/users');
</code></pre>
<h6>hooks.beforeRetry</h6>
<p>Kiểu: <code>Function[]</code><br />
Mặc định: <code>[]</code></p>
<p>Hook này cho phép bạn chỉnh sửa yêu cầu ngay trước khi thử lại. Ky sẽ không thay đổi gì thêm sau đó. Hàm hook nhận một đối tượng gồm request và options đã được chuẩn hóa, một instance lỗi, và số lần thử lại. Ví dụ, bạn có thể chỉnh sửa <code>request.headers</code> tại đây.</p>
<p>Nếu yêu cầu nhận được phản hồi, lỗi sẽ là kiểu <code>HTTPError</code> và đối tượng <code>Response</code> sẽ có tại <code>error.response</code>. Lưu ý rằng một số loại lỗi, như lỗi mạng, bản chất là không có phản hồi. Khi đó, lỗi sẽ không phải là một instance của <code>HTTPError</code>.</p>
<p>Bạn có thể ngăn Ky thử lại bằng cách ném ra một lỗi. Ky sẽ không xử lý gì thêm và lỗi sẽ được trả về phía gọi yêu cầu. Các hook <code>beforeRetry</code> còn lại sẽ không được gọi trong trường hợp này. Ngoài ra, bạn có thể trả về ký hiệu <a href="#kystop"><code>ky.stop</code></a> để làm điều tương tự mà không cần ném ra lỗi (có một số hạn chế, xem tài liệu về <code>ky.stop</code> để biết chi tiết).</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const token = await ky('https://example.com/refresh-token');
				request.headers.set('Authorization', `token ${token}`);
			}
		]
	}
});
</code></pre>
<h6>hooks.beforeError</h6>
<p>Kiểu: <code>Function[]</code><br />
Mặc định: <code>[]</code></p>
<p>Hook này cho phép bạn chỉnh sửa <code>HTTPError</code> ngay trước khi nó được ném ra. Hàm hook nhận một đối số là <code>HTTPError</code> và nên trả về một instance của <code>HTTPError</code>.</p>
<pre><code class="language-js">import ky from 'ky';

await ky('https://example.com', {
	hooks: {
		beforeError: [
			error =&gt; {
				const {response} = error;
				if (response &amp;&amp; response.body) {
					error.name = 'GitHubError';
					error.message = `${response.body.message} (${response.status})`;
				}

				return error;
			}
		]
	}
});
</code></pre>
<h6>hooks.afterResponse</h6>
<p>Kiểu: <code>Function[]</code><br />
Mặc định: <code>[]</code></p>
<p>Hook này cho phép bạn đọc và tùy chọn chỉnh sửa phản hồi. Hàm hook nhận các đối số là request đã chuẩn hóa, options, và một bản sao của response. Giá trị trả về của hàm hook sẽ được Ky sử dụng làm đối tượng phản hồi nếu nó là instance của <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a>.</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		afterResponse: [
			(_request, _options, response) =&gt; {
				// Bạn có thể làm gì đó với phản hồi, ví dụ, ghi log.
				log(response);

				// Hoặc trả về một instance `Response` để ghi đè phản hồi.
				return new Response('A different response', {status: 200});
			},

			// Hoặc thử lại với token mới khi gặp lỗi 403
			async (request, options, response) =&gt; {
				if (response.status === 403) {
					// Lấy token mới
					const token = await ky('https://example.com/token').text();

					// Thử lại với token mới
					request.headers.set('Authorization', `token ${token}`);

					return ky(request);
				}
			}
		]
	}
});
</code></pre>
<h5>throwHttpErrors</h5>
<p>Kiểu: <code>boolean</code><br />
Mặc định: <code>true</code></p>
<p>Ném ra một <code>HTTPError</code> khi, sau khi theo dõi chuyển hướng, phản hồi có mã trạng thái không phải 2xx. Để cũng ném lỗi cho các chuyển hướng thay vì theo dõi chúng, hãy đặt tùy chọn <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters"><code>redirect</code></a> thành <code>'manual'</code>.</p>
<p>Đặt giá trị này là <code>false</code> có thể hữu ích nếu bạn kiểm tra sự tồn tại của tài nguyên và dự đoán các phản hồi lỗi.</p>
<p>Lưu ý: Nếu là <code>false</code>, các phản hồi lỗi được coi là thành công và yêu cầu sẽ không được thử lại.</p>
<h5>onDownloadProgress</h5>
<p>Kiểu: <code>Function</code></p>
<p>Trình xử lý sự kiện tiến trình tải xuống.</p>
<p>Hàm này nhận các đối số sau:</p>
<ul>
<li><code>progress</code> là một đối tượng với các thuộc tính:</li>
<li>
<ul>
<li><code>percent</code> là số nằm trong khoảng từ 0 đến 1 thể hiện phần trăm tiến trình.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> là số byte đã được truyền đến thời điểm hiện tại.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> là tổng số byte sẽ được truyền. Đây là giá trị ước tính và có thể là 0 nếu không xác định được tổng kích thước.</li>
</ul>
</li>
<li><code>chunk</code> là một instance của <code>Uint8Array</code> chứa dữ liệu đã gửi. Lưu ý: Lần gọi đầu tiên sẽ là rỗng.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	onDownloadProgress: (progress, chunk) =&gt; {
		// Ví dụ kết quả:
		// `0% - 0 of 1271 bytes`
		// `100% - 1271 of 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} of ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>onUploadProgress</h5>
<p>Kiểu: <code>Function</code>
Trình xử lý sự kiện tiến trình tải lên.</p>
<p>Hàm nhận các tham số sau:</p>
<ul>
<li><code>progress</code> là một đối tượng với các thuộc tính sau:</li>
<li>
<ul>
<li><code>percent</code> là một số nằm trong khoảng từ 0 đến 1 biểu thị phần trăm tiến trình.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> là số byte đã được truyền cho đến thời điểm hiện tại.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> là tổng số byte sẽ được truyền. Đây là một giá trị ước tính và có thể là 0 nếu không xác định được tổng kích thước.</li>
</ul>
</li>
<li><code>chunk</code> là một instance của <code>Uint8Array</code> chứa dữ liệu đã được gửi đi. Lưu ý: Ở lần gọi cuối cùng, nó sẽ rỗng.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky.post('https://example.com/upload', {
	body: largeFile,
	onUploadProgress: (progress, chunk) =&gt; {
		// Ví dụ kết quả xuất ra:
		// `0% - 0 of 1271 bytes`
		// `100% - 1271 of 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} of ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>parseJson</h5>
<p>Kiểu: <code>Function</code><br />
Mặc định: <code>JSON.parse()</code></p>
<p>Hàm phân tích JSON do người dùng định nghĩa.</p>
<p>Trường hợp sử dụng:</p>
<ol>
<li>Phân tích JSON thông qua gói <a href="https://github.com/hapijs/bourne"><code>bourne</code></a> để bảo vệ khỏi ô nhiễm prototype.</li>
<li>Phân tích JSON với tùy chọn <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>reviver</code> của <code>JSON.parse()</code></a>.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import bourne from '@hapijs/bourne';

const json = await ky('https://example.com', {
	parseJson: text =&gt; bourne(text)
}).json();
</code></pre>
<h5>stringifyJson</h5>
<p>Kiểu: <code>Function</code><br />
Mặc định: <code>JSON.stringify()</code></p>
<p>Hàm chuyển đổi JSON thành chuỗi do người dùng định nghĩa.</p>
<p>Trường hợp sử dụng:</p>
<ol>
<li>Chuyển đổi JSON với hàm <code>replacer</code> tùy chỉnh.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import {DateTime} from 'luxon';

const json = await ky('https://example.com', {
	stringifyJson: data =&gt; JSON.stringify(data, (key, value) =&gt; {
		if (key.endsWith('_at')) {
			return DateTime.fromISO(value).toSeconds();
		}

		return value;
	})
}).json();
</code></pre>
<h5>fetch</h5>
<p>Kiểu: <code>Function</code><br />
Mặc định: <code>fetch</code></p>
<p>Hàm <code>fetch</code> do người dùng định nghĩa.
Phải hoàn toàn tương thích với tiêu chuẩn <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>.</p>
<p>Trường hợp sử dụng:</p>
<ol>
<li>Sử dụng các triển khai <code>fetch</code> tùy chỉnh như <a href="https://www.npmjs.com/package/isomorphic-unfetch"><code>isomorphic-unfetch</code></a>.</li>
<li>Sử dụng hàm bọc <code>fetch</code> do một số framework cung cấp, sử dụng render phía server (SSR).</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import fetch from 'isomorphic-unfetch';

const json = await ky('https://example.com', {fetch}).json();
</code></pre>
<h3>ky.extend(defaultOptions)</h3>
<p>Tạo một instance <code>ky</code> mới với một số thiết lập mặc định được ghi đè bởi thiết lập của bạn.</p>
<p>Khác với <code>ky.create()</code>, <code>ky.extend()</code> kế thừa các thiết lập mặc định từ cha của nó.</p>
<p>Bạn có thể truyền headers dưới dạng một instance của <code>Headers</code> hoặc một đối tượng thông thường.</p>
<p>Bạn có thể xóa một header với <code>.extend()</code> bằng cách truyền header đó với giá trị là <code>undefined</code>.
Truyền <code>undefined</code> dưới dạng chuỗi chỉ xóa header nếu nó xuất phát từ một instance của <code>Headers</code>.</p>
<p>Tương tự, bạn cũng có thể xóa các entry <code>hooks</code> hiện có bằng cách mở rộng hook đó với giá trị <code>undefined</code> rõ ràng.</p>
<pre><code class="language-js">import ky from 'ky';

const url = 'https://sindresorhus.com';

const original = ky.create({
	headers: {
		rainbow: 'rainbow',
		unicorn: 'unicorn'
	},
	hooks: {
		beforeRequest: [ () =&gt; console.log('before 1') ],
		afterResponse: [ () =&gt; console.log('after 1') ],
	},
});

const extended = original.extend({
	headers: {
		rainbow: undefined
	},
	hooks: {
		beforeRequest: undefined,
		afterResponse: [ () =&gt; console.log('after 2') ],
	}
});

const response = await extended(url).json();
//=&gt; after 1
//=&gt; after 2

console.log('rainbow' in response);
//=&gt; false

console.log('unicorn' in response);
//=&gt; true
</code></pre>
<p>Bạn cũng có thể tham chiếu đến các thiết lập mặc định của cha bằng cách truyền một hàm cho <code>.extend()</code>.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.create({prefixUrl: 'https://example.com/api'});

const usersApi = api.extend((options) =&gt; ({prefixUrl: `${options.prefixUrl}/users`}));

const response = await usersApi.get('123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('version');
//=&gt; 'https://example.com/api/version'
</code></pre>
<h3>ky.create(defaultOptions)</h3>
<p>Tạo một instance Ky mới với bộ thiết lập mặc định hoàn toàn mới.</p>
<pre><code class="language-js">import ky from 'ky';

// Trên https://my-site.com

const api = ky.create({prefixUrl: 'https://example.com/api'});

const response = await api.get('users/123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('/status', {prefixUrl: ''});
//=&gt; 'https://my-site.com/status'
</code></pre>
<h4>defaultOptions</h4>
<p>Kiểu: <code>object</code></p>
<h3>ky.stop</h3>
<p>Một <code>Symbol</code> có thể được trả về bởi hook <code>beforeRetry</code> để dừng việc thử lại. Điều này cũng sẽ bỏ qua các hook <code>beforeRetry</code> còn lại.</p>
<p>Lưu ý: Trả về symbol này sẽ khiến Ky hủy bỏ và trả về phản hồi là <code>undefined</code>. Hãy chắc chắn kiểm tra phản hồi trước khi truy cập bất kỳ thuộc tính nào trên đó hoặc sử dụng <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional chaining</a>. Nó cũng không tương thích với các phương thức trên body như <code>.json()</code> hoặc <code>.text()</code>, vì không có phản hồi để phân tích. Nói chung, chúng tôi khuyến nghị nên ném lỗi thay vì trả về symbol này, vì việc đó sẽ khiến Ky hủy bỏ và ném lỗi, tránh được những hạn chế này.</p>
<p>Một trường hợp hợp lệ để sử dụng <code>ky.stop</code> là để ngăn việc thử lại khi thực hiện các request có tác dụng phụ, nơi dữ liệu trả về không quan trọng. Ví dụ, ghi nhật ký hoạt động của client lên server.</p>
<pre><code class="language-js">import ky from 'ky';

const options = {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const shouldStopRetry = await ky('https://example.com/api');
				if (shouldStopRetry) {
					return ky.stop;
				}
			}
		]
	}
};
</code></pre>
<pre><code class="language-js">// Lưu ý rằng response sẽ là `undefined` trong trường hợp `ky.stop` được trả về.
const response = await ky.post('https://example.com', options);

// Việc sử dụng `.text()` hoặc các phương thức body khác không được hỗ trợ.
const text = await ky('https://example.com', options).text();
</code></pre>
<h3>HTTPError</h3>
<p>Được xuất ra để kiểm tra với <code>instanceof</code>. Lỗi này có thuộc tính <code>response</code> với <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">đối tượng <code>Response</code></a>, thuộc tính <code>request</code> với <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">đối tượng <code>Request</code></a>, và thuộc tính <code>options</code> với các tùy chọn đã được chuẩn hóa (hoặc được truyền vào <code>ky</code> khi tạo instance với <code>ky.create()</code>, hoặc trực tiếp khi thực hiện request).</p>
<p>Lưu ý rằng một số loại lỗi, như lỗi mạng, vốn dĩ có nghĩa là không nhận được phản hồi. Trong trường hợp đó, lỗi sẽ không phải là một instance của HTTPError và sẽ không chứa thuộc tính <code>response</code>.</p>
<p>Nếu bạn cần đọc phản hồi thực tế khi xảy ra <code>HTTPError</code>, hãy gọi phương thức parser tương ứng trên đối tượng response. Ví dụ:</p>
<pre><code class="language-js">try {
	await ky('https://example.com').json();
} catch (error) {
	if (error.name === 'HTTPError') {
		const errorJson = await error.response.json();
	}
}
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> Chấp nhận một <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">tham số kiểu tùy chọn</a>, mặc định là <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>, và được truyền đến kiểu trả về của <code>error.response.json()</code>.</p>
<h3>TimeoutError</h3>
<p>Lỗi được ném ra khi yêu cầu vượt quá thời gian chờ. Nó có thuộc tính <code>request</code> với <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">đối tượng <code>Request</code></a>.</p>
<h2>Mẹo</h2>
<h3>Gửi dữ liệu biểu mẫu</h3>
<p>Việc gửi dữ liệu biểu mẫu trong Ky giống hệt như với <code>fetch</code>. Chỉ cần truyền một instance của <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a> vào tùy chọn <code>body</code>. Header <code>Content-Type</code> sẽ tự động được đặt là <code>multipart/form-data</code>.</p>
<pre><code class="language-js">import ky from 'ky';

// `multipart/form-data`
const formData = new FormData();
formData.append('food', 'fries');
formData.append('drink', 'icetea');

const response = await ky.post(url, {body: formData});
</code></pre>
<p>Nếu bạn muốn gửi dữ liệu ở định dạng <code>application/x-www-form-urlencoded</code>, bạn cần mã hóa dữ liệu bằng <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a>.</p>
<pre><code class="language-js">import ky from 'ky';

// `application/x-www-form-urlencoded`
const searchParams = new URLSearchParams();
searchParams.set('food', 'fries');
searchParams.set('drink', 'icetea');

const response = await ky.post(url, {body: searchParams});
</code></pre>
<h3>Thiết lập <code>Content-Type</code> tùy chỉnh</h3>
<p>Ky tự động thiết lập header <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> phù hợp cho mỗi request dựa vào dữ liệu trong body của request. Tuy nhiên, một số API yêu cầu các kiểu content-type tùy chỉnh, không chuẩn, ví dụ như <code>application/x-amz-json-1.1</code>. Sử dụng tùy chọn <code>headers</code>, bạn có thể ghi đè kiểu content-type thủ công.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {
	headers: {
		'content-type': 'application/json'
	},
	json: {
		foo: true
	},
}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<h3>Hủy yêu cầu</h3>
<p>Fetch (và cả Ky) có hỗ trợ sẵn việc hủy yêu cầu thông qua <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController">API <code>AbortController</code></a>. <a href="https://developers.google.com/web/updates/2017/09/abortable-fetch">Đọc thêm.</a></p>
<p>Ví dụ:</p>
<pre><code class="language-js">import ky from 'ky';

const controller = new AbortController();
const {signal} = controller;

setTimeout(() =&gt; {
	controller.abort();
}, 5000);

try {
	console.log(await ky(url, {signal}).text());
} catch (error) {
	if (error.name === 'AbortError') {
		console.log('Fetch aborted');
	} else {
		console.error('Fetch error:', error);
	}
}
</code></pre>
<h2>Câu hỏi thường gặp (FAQ)</h2>
<h4>Làm thế nào để sử dụng thư viện này trong Node.js?</h4>
<p>Node.js 18 trở lên đã hỗ trợ <code>fetch</code> gốc, vì vậy bạn có thể sử dụng package này trực tiếp.</p>
<h4>Làm thế nào để sử dụng với web app (React, Vue.js, v.v.) dùng server-side rendering (SSR)?</h4>
<p>Giống như trên.</p>
<h4>Làm sao để kiểm thử một thư viện trình duyệt sử dụng thư viện này?</h4>
<p>Hoặc sử dụng một test runner chạy được trên trình duyệt, như Mocha, hoặc sử dụng <a href="https://avajs.dev">AVA</a> với <code>ky-universal</code>. <a href="https://github.com/sindresorhus/ky-universal#faq">Đọc thêm.</a></p>
<h4>Làm thế nào để sử dụng mà không cần bundler như Webpack?</h4>
<p>Đảm bảo mã của bạn đang chạy như một module JavaScript (ESM), ví dụ bằng cách sử dụng thẻ <code>&lt;script type=&quot;module&quot;&gt;</code> trong tài liệu HTML của bạn. Sau đó Ky có thể được import trực tiếp bởi module đó mà không cần bundler hoặc công cụ khác.</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
import ky from 'https://unpkg.com/ky/distribution/index.js';

const json = await ky('https://jsonplaceholder.typicode.com/todos/1').json();

console.log(json.title);
//=&gt; 'delectus aut autem'
&lt;/script&gt;
</code></pre>
<h4>Khác biệt gì so với <a href="https://github.com/sindresorhus/got"><code>got</code></a></h4>
<p>Xem câu trả lời của tôi <a href="https://twitter.com/sindresorhus/status/1037406558945042432">ở đây</a>. Got được duy trì bởi cùng nhóm phát triển với Ky.</p>
<h4>Khác biệt gì so với <a href="https://github.com/axios/axios"><code>axios</code></a>?</h4>
<p>Xem câu trả lời của tôi <a href="https://twitter.com/sindresorhus/status/1037763588826398720">ở đây</a>.</p>
<h4>Khác biệt gì so với <a href="https://github.com/mikeal/r2"><code>r2</code></a>?</h4>
<p>Xem câu trả lời của tôi trong <a href="https://github.com/sindresorhus/ky/issues/10">#10</a>.</p>
<h4><code>ky</code> có nghĩa là gì?</h4>
<p>Đó chỉ là một tên package npm ngắn, ngẫu nhiên mà tôi lấy được. Tuy nhiên, nó có nghĩa trong tiếng Nhật:</p>
<blockquote>
<p>Một dạng tiếng lóng có thể viết tắt, KY là viết tắt của 空気読めない (kuuki yomenai), dịch sát nghĩa là “không thể đọc không khí.” Đây là câu nói dành cho người không hiểu ý ngầm.</p>
</blockquote>
<h2>Hỗ trợ trình duyệt</h2>
<p>Phiên bản mới nhất của Chrome, Firefox và Safari.</p>
<h2>Hỗ trợ Node.js</h2>
<p>Node.js 18 trở lên.</p>
<h2>Liên quan</h2>
<ul>
<li><a href="https://github.com/sindresorhus/fetch-extras">fetch-extras</a> - Các tiện ích hữu ích khi làm việc với Fetch</li>
<li><a href="https://github.com/alice-health/ky-hooks-change-case">ky-hooks-change-case</a> - Ky hooks để thay đổi kiểu chữ trên request và response của object</li>
</ul>
<h2>Người bảo trì</h2>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a></li>
<li><a href="https://github.com/sholladay">Seth Holladay</a></li>
<li><a href="https://github.com/szmarczak">Szymon Marczak</a></li>
</ul>
<pre><code>

---


Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-11


---
</code></pre>

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>