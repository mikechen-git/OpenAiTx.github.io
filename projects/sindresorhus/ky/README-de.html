<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ky - sindresorhus/ky de</title>
    <meta name="title" content="ky - sindresorhus/ky de | Ky ist ein kleines und elegantes HTTP-Client auf Basis der Fetch API Ky richtet sich an moderne Browser, Node.js, Bun und Deno. Es ist einfach ein kleines Paket...">
    <meta name="description" content="sindresorhus/ky - GitHub repository de documentation and information | Ky ist ein kleines und elegantes HTTP-Client auf Basis der Fetch API Ky richtet sich an moderne Browser, Node.js, Bun und Deno. Es ist einfach ein kleines Paket...">
    <meta name="keywords" content="sindresorhus, ky, GitHub, repository, de documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/sindresorhus/ky/README-de.html">
    <meta property="og:title" content="ky - sindresorhus/ky de | Ky ist ein kleines und elegantes HTTP-Client auf Basis der Fetch API Ky richtet sich an moderne Browser, Node.js, Bun und Deno. Es ist einfach ein kleines Paket...">
    <meta property="og:description" content="sindresorhus/ky - GitHub repository de documentation and information | Ky ist ein kleines und elegantes HTTP-Client auf Basis der Fetch API Ky richtet sich an moderne Browser, Node.js, Bun und Deno. Es ist einfach ein kleines Paket...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div style="position: fixed; top: 2px; left: 2px; z-index: 2000; background: rgba(255,255,255,0.95); border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); padding: 4px 14px; font-size: 15px; color: #222; font-family: 'Segoe UI', Arial, sans-serif; font-weight: 500; letter-spacing: 0.5px;">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank" style="color: #0366d6; text-decoration: none; font-weight: 600;">Open AI Tx</a>
    </div>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/sindresorhus/ky" id="githubRepoLink" target="_blank">sindresorhus/ky</a>
<h1 style="display: none;">Ky ist ein kleines und elegantes HTTP-Client auf Basis der Fetch API Ky richtet sich an moderne Browser, Node.js, Bun und Deno. Es ist einfach ein kleines Paket...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div align="center">
	<br>
	<div>
		<img width="600" height="600" src="https://raw.githubusercontent.com/sindresorhus/ky/main/media/logo.svg" alt="ky">
	</div>
	<br>
	<br>
	<br>
</div>
<blockquote>
<p>Ky ist ein kleines und elegantes HTTP-Client auf Basis der <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">Fetch API</a></p>
</blockquote>
<p><a href="https://codecov.io/gh/sindresorhus/ky"><img src="https://codecov.io/gh/sindresorhus/ky/branch/main/graph/badge.svg" alt="Coverage Status" /></a>
<a href="https://bundlephobia.com/result?p=ky"><img src="https://badgen.net/bundlephobia/minzip/ky" alt="" /></a></p>
<p>Ky richtet sich an <a href="#browser-support">moderne Browser</a>, Node.js, Bun und Deno.</p>
<p>Es ist einfach ein kleines Paket ohne Abhängigkeiten.</p>
<h2>Vorteile gegenüber einfachem <code>fetch</code></h2>
<ul>
<li>Einfachere API</li>
<li>Methoden-Kurzbefehle (<code>ky.post()</code>)</li>
<li>Behandelt Statuscodes außerhalb von 2xx als Fehler (nach Weiterleitungen)</li>
<li>Wiederholt fehlgeschlagene Anfragen</li>
<li>JSON-Option</li>
<li>Timeout-Unterstützung</li>
<li>URL-Präfix-Option</li>
<li>Instanzen mit benutzerdefinierten Standardwerten</li>
<li>Hooks</li>
<li>TypeScript-Annehmlichkeiten (z. B. <code>.json()</code> unterstützt Generics und verwendet standardmäßig <code>unknown</code> statt <code>any</code>)</li>
</ul>
<h2>Installation</h2>
<pre><code class="language-sh">npm install ky
</code></pre>
<h6>CDN</h6>
<ul>
<li><a href="https://cdn.jsdelivr.net/npm/ky/+esm">jsdelivr</a></li>
<li><a href="https://unpkg.com/ky">unpkg</a></li>
<li><a href="https://esm.sh/ky">esm.sh</a></li>
</ul>
<h2>Verwendung</h2>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {json: {foo: true}}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Mit einfachem <code>fetch</code> sähe das so aus:</p>
<pre><code class="language-js">class HTTPError extends Error {}

const response = await fetch('https://example.com', {
	method: 'POST',
	body: JSON.stringify({foo: true}),
	headers: {
		'content-type': 'application/json'
	}
});

if (!response.ok) {
	throw new HTTPError(`Fetch error: ${response.statusText}`);
}

const json = await response.json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Wenn du <a href="https://github.com/denoland/deno">Deno</a> verwendest, importiere Ky von einer URL. Zum Beispiel mit einem CDN:</p>
<pre><code class="language-js">import ky from 'https://esm.sh/ky';
</code></pre>
<h2>API</h2>
<h3>ky(input, options?)</h3>
<p>Die <code>input</code> und <code>options</code> sind die gleichen wie bei <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code></a>, mit zusätzlichen verfügbaren <code>options</code> (siehe unten).</p>
<p>Gibt ein <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code>-Objekt</a> mit hinzugefügten <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body"><code>Body</code>-Methoden</a> für den Komfort zurück. So kannst du zum Beispiel direkt <code>ky.get(input).json()</code> aufrufen, ohne vorher auf die <code>Response</code> zu warten. In diesem Fall wird je nach verwendeter Body-Methode ein entsprechender <code>Accept</code>-Header gesetzt. Anders als bei den <code>Body</code>-Methoden von <code>window.Fetch</code> werfen diese eine <code>HTTPError</code>, wenn der Antwortstatus nicht im Bereich von <code>200...299</code> liegt. Außerdem gibt <code>.json()</code> einen leeren String zurück, wenn der Body leer ist oder der Antwortstatus <code>204</code> ist, anstatt wegen eines leeren Bodys einen Parsing-Fehler zu werfen.</p>
<pre><code class="language-js">import ky from 'ky';

const user = await ky('/api/user').json();

console.log(user);
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> Akzeptiert einen optionalen <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">Type Parameter</a>, der standardmäßig auf <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a> gesetzt ist und an den Rückgabetyp von <code>.json()</code> weitergegeben wird.</p>
<pre><code class="language-ts">import ky from 'ky';

// user1 ist unknown
const user1 = await ky('/api/users/1').json();
// user2 ist ein User
const user2 = await ky&lt;User&gt;('/api/users/2').json();
// user3 ist ein User
const user3 = await ky('/api/users/3').json&lt;User&gt;();

console.log([user1, user2, user3]);
</code></pre>
<h3>ky.get(input, options?)</h3>
<h3>ky.post(input, options?)</h3>
<h3>ky.put(input, options?)</h3>
<h3>ky.patch(input, options?)</h3>
<h3>ky.head(input, options?)</h3>
<h3>ky.delete(input, options?)</h3>
<p>Setzt <code>options.method</code> auf den Methodennamen und führt eine Anfrage aus.</p>
<p>⌨️ <strong>TypeScript:</strong> Akzeptiert einen optionalen Type Parameter für die Verwendung mit JSON-Antworten (siehe <a href="#kyinput-options"><code>ky()</code></a>).</p>
<h4>input</h4>
<p>Typ: <code>string</code> | <code>URL</code> | <code>Request</code></p>
<p>Wie <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#input"><code>fetch</code> input</a>.</p>
<p>Wenn eine <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a>-Instanz als <code>input</code> verwendet wird, werden alle URL-verändernden Optionen (wie <code>prefixUrl</code>) ignoriert.</p>
<h4>options</h4>
<p>Typ: <code>object</code></p>
<p>Wie <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch#options"><code>fetch</code> options</a>, plus folgende zusätzliche Optionen:</p>
<h5>method</h5>
<p>Typ: <code>string</code><br />
Standard: <code>'get'</code></p>
<p>HTTP-Methode, die für die Anfrage verwendet wird.</p>
<p>Intern werden die Standardmethoden (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>HEAD</code> und <code>DELETE</code>) in Großbuchstaben umgewandelt, um Serverfehler aufgrund von Groß-/Kleinschreibung zu vermeiden.</p>
<h5>json</h5>
<p>Typ: <code>object</code> und jeder andere Wert, der von <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> akzeptiert wird</p>
<p>Kurzschreibweise zum Senden von JSON. Verwende dies anstelle der <code>body</code>-Option. Akzeptiert jedes einfache Objekt oder jeden Wert, der mit <code>JSON.stringify()</code> serialisiert und mit gesetztem korrektem Header im Body gesendet wird.</p>
<h5>searchParams</h5>
<p>Typ: <code>string | object&lt;string, string | number | boolean&gt; | Array&lt;Array&lt;string | number | boolean&gt;&gt; | URLSearchParams</code><br />
Standard: <code>''</code></p>
<p>Suchparameter, die in die Anfrage-URL aufgenommen werden. Wenn gesetzt, werden alle bestehenden Suchparameter in der Eingabe-URL überschrieben.</p>
<p>Akzeptiert jeden Wert, der von <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams"><code>URLSearchParams()</code></a> unterstützt wird.</p>
<h5>prefixUrl</h5>
<p>Typ: <code>string | URL</code></p>
<p>Ein Präfix, das der <code>input</code>-URL bei der Anfrage vorangestellt wird. Kann jede gültige URL sein, entweder relativ oder absolut. Ein abschließender Slash <code>/</code> ist optional und wird bei Bedarf automatisch hinzugefügt, wenn sie mit <code>input</code> verbunden wird. Wirkt nur, wenn <code>input</code> ein String ist. Das <code>input</code>-Argument darf bei Verwendung dieser Option nicht mit einem Slash <code>/</code> beginnen.</p>
<p>Nützlich in Verbindung mit <a href="#kyextenddefaultoptions"><code>ky.extend()</code></a>, um Ky-Instanzen für spezielle Anwendungsfälle zu erstellen.</p>
<pre><code class="language-js">import ky from 'ky';

// Auf https://example.com

const response = await ky('unicorn', {prefixUrl: '/api'});
//=&gt; 'https://example.com/api/unicorn'

const response2 = await ky('unicorn', {prefixUrl: 'https://cats.com'});
//=&gt; 'https://cats.com/unicorn'
</code></pre>
<p>Hinweise:</p>
<ul>
<li>Nachdem <code>prefixUrl</code> und <code>input</code> verbunden wurden, wird das Ergebnis relativ zur <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/baseURI">Basis-URL</a> der Seite (falls vorhanden) aufgelöst.</li>
<li>Führende Slashes in <code>input</code> sind bei Verwendung dieser Option nicht erlaubt, um Konsistenz zu erzwingen und Verwirrung darüber zu vermeiden, wie die <code>input</code>-URL behandelt wird, da <code>input</code> nicht den normalen URL-Auflösungsregeln folgt, wenn <code>prefixUrl</code> verwendet wird, was die Bedeutung eines führenden Slashes verändert.</li>
</ul>
<h5>retry</h5>
<p>Typ: <code>object | number</code><br />
Standard:</p>
<ul>
<li><code>limit</code>: <code>2</code></li>
<li><code>methods</code>: <code>get</code> <code>put</code> <code>head</code> <code>delete</code> <code>options</code> <code>trace</code></li>
<li><code>statusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"><code>408</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"><code>500</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"><code>502</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"><code>504</code></a></li>
<li><code>afterStatusCodes</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a></li>
<li><code>maxRetryAfter</code>: <code>undefined</code></li>
<li><code>backoffLimit</code>: <code>undefined</code></li>
<li><code>delay</code>: <code>attemptCount =&gt; 0.3 * (2 ** (attemptCount - 1)) * 1000</code></li>
</ul>
<p>Ein Objekt, das die Felder <code>limit</code>, <code>methods</code>, <code>statusCodes</code>, <code>afterStatusCodes</code> und <code>maxRetryAfter</code> für die maximale Anzahl der Wiederholungsversuche, erlaubte Methoden, erlaubte Statuscodes, Statuscodes, bei denen die <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>-Zeit verwendet werden darf, und maximale <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>-Zeit repräsentiert.</p>
<p>Wenn <code>retry</code> eine Zahl ist, wird sie als <code>limit</code> verwendet und andere Standardwerte bleiben erhalten.</p>
<p>Wenn die Antwort einen HTTP-Status enthält, der in <code>afterStatusCodes</code> enthalten ist, wartet Ky, bis das im <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>-Header angegebene Datum, der Timeout oder der Zeitstempel erreicht ist, bevor die Anfrage erneut gesendet wird. Fehlt <code>Retry-After</code>, wird der nicht standardisierte <a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-05.html#section-3.3"><code>RateLimit-Reset</code></a>-Header als Fallback verwendet. Ist der bereitgestellte Statuscode nicht in der Liste, wird der <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>-Header ignoriert.</p>
<p>Wenn <code>maxRetryAfter</code> auf <code>undefined</code> gesetzt ist, wird <code>options.timeout</code> verwendet. Ist der Wert des <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>-Headers größer als <code>maxRetryAfter</code>, wird <code>maxRetryAfter</code> verwendet.</p>
<p>Die Option <code>backoffLimit</code> ist das obere Limit für die Verzögerung pro Wiederholungsversuch in Millisekunden.
Um die Verzögerung zu begrenzen, setzen Sie zum Beispiel <code>backoffLimit</code> auf 1000.
Standardmäßig wird die Verzögerung mit <code>0.3 * (2 ** (attemptCount - 1)) * 1000</code> berechnet. Die Verzögerung steigt exponentiell an.</p>
<p>Die Option <code>delay</code> kann verwendet werden, um zu ändern, wie die Verzögerung zwischen Wiederholungsversuchen berechnet wird. Die Funktion erhält einen Parameter, den Versuchszähler, der bei <code>1</code> beginnt.</p>
<p>Wiederholungsversuche werden nach einem <a href="#timeout">Timeout</a> nicht ausgelöst.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky('https://example.com', {
	retry: {
		limit: 10,
		methods: ['get'],
		statusCodes: [413],
		backoffLimit: 3000
	}
}).json();
</code></pre>
<h5>timeout</h5>
<p>Typ: <code>number | false</code><br />
Standard: <code>10000</code></p>
<p>Timeout in Millisekunden für den Erhalt einer Antwort, einschließlich aller Wiederholungsversuche. Kann nicht größer als 2147483647 sein.
Wenn auf <code>false</code> gesetzt, gibt es keinen Timeout.</p>
<h5>hooks</h5>
<p>Typ: <code>object&lt;string, Function[]&gt;</code><br />
Standard: <code>{beforeRequest: [], beforeRetry: [], afterResponse: []}</code></p>
<p>Hooks ermöglichen Modifikationen während des Anfrage-Lebenszyklus. Hook-Funktionen können asynchron sein und werden seriell ausgeführt.</p>
<h6>hooks.beforeRequest</h6>
<p>Typ: <code>Function[]</code><br />
Standard: <code>[]</code></p>
<p>Mit diesem Hook können Sie die Anfrage direkt vor dem Absenden ändern. Ky nimmt danach keine weiteren Änderungen an der Anfrage vor. Die Hook-Funktion erhält <code>request</code> und <code>options</code> als Argumente. Sie könnten hier zum Beispiel die <code>request.headers</code> ändern.</p>
<p>Der Hook kann ein <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a>-Objekt zurückgeben, um die ausgehende Anfrage zu ersetzen, oder eine <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> zurückgeben, um das Absenden einer HTTP-Anfrage vollständig zu vermeiden. Dies kann genutzt werden, um eine Anfrage zu simulieren, einen internen Cache zu prüfen usw. Eine <strong>wichtige</strong> Überlegung beim Zurückgeben einer Anfrage oder Antwort aus diesem Hook ist, dass alle verbleibenden <code>beforeRequest</code>-Hooks übersprungen werden. Sie sollten sie also nur vom letzten Hook zurückgeben.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.extend({
	hooks: {
		beforeRequest: [
			request =&gt; {
				request.headers.set('X-Requested-With', 'ky');
			}
		]
	}
});

const response = await api.get('https://example.com/api/users');
</code></pre>
<h6>hooks.beforeRetry</h6>
<p>Typ: <code>Function[]</code><br />
Standard: <code>[]</code></p>
<p>Mit diesem Hook können Sie die Anfrage direkt vor dem Wiederholungsversuch ändern. Ky nimmt danach keine weiteren Änderungen an der Anfrage vor. Die Hook-Funktion erhält ein Objekt mit der normalisierten Anfrage und den Optionen, eine Fehlerinstanz sowie die Anzahl der Wiederholungen. Sie können hier zum Beispiel die <code>request.headers</code> ändern.</p>
<p>Wenn die Anfrage eine Antwort erhalten hat, ist der Fehler vom Typ <code>HTTPError</code> und das <code>Response</code>-Objekt ist unter <code>error.response</code> verfügbar. Beachten Sie, dass einige Fehlertypen, wie z. B. Netzwerkfehler, implizieren, dass keine Antwort erhalten wurde. In diesem Fall ist der Fehler keine Instanz von <code>HTTPError</code>.</p>
<p>Sie können verhindern, dass Ky die Anfrage wiederholt, indem Sie einen Fehler auslösen. Ky behandelt diesen Fehler nicht weiter und er wird an den Anfragestarter weitergegeben. Die restlichen <code>beforeRetry</code>-Hooks werden in diesem Fall nicht mehr aufgerufen. Alternativ können Sie das Symbol <a href="#kystop"><code>ky.stop</code></a> zurückgeben, um dasselbe zu erreichen, jedoch ohne einen Fehler weiterzugeben (dies hat einige Einschränkungen, siehe die Dokumentation zu <code>ky.stop</code> für Details).</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const token = await ky('https://example.com/refresh-token');
				request.headers.set('Authorization', `token ${token}`);
			}
		]
	}
});
</code></pre>
<h6>hooks.beforeError</h6>
<p>Typ: <code>Function[]</code><br />
Standard: <code>[]</code></p>
<p>Mit diesem Hook können Sie den <code>HTTPError</code> direkt vor dem Auslösen ändern. Die Hook-Funktion erhält einen <code>HTTPError</code> als Argument und sollte eine Instanz von <code>HTTPError</code> zurückgeben.</p>
<pre><code class="language-js">import ky from 'ky';

await ky('https://example.com', {
	hooks: {
		beforeError: [
			error =&gt; {
				const {response} = error;
				if (response &amp;&amp; response.body) {
					error.name = 'GitHubError';
					error.message = `${response.body.message} (${response.status})`;
				}

				return error;
			}
		]
	}
});
</code></pre>
<h6>hooks.afterResponse</h6>
<p>Typ: <code>Function[]</code><br />
Standard: <code>[]</code></p>
<p>Mit diesem Hook können Sie die Antwort lesen und optional ändern. Die Hook-Funktion erhält die normalisierte Anfrage, Optionen und einen Klon der Antwort als Argumente. Der Rückgabewert der Hook-Funktion wird von Ky als Antwortobjekt verwendet, wenn es sich um eine Instanz von <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> handelt.</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		afterResponse: [
			(_request, _options, response) =&gt; {
				// Sie könnten hier etwas mit der Antwort machen, z. B. Logging.
				log(response);

				// Oder eine `Response`-Instanz zurückgeben, um die Antwort zu überschreiben.
				return new Response('A different response', {status: 200});
			},

			// Oder bei einem 403-Fehler mit einem neuen Token erneut versuchen
			async (request, options, response) =&gt; {
				if (response.status === 403) {
					// Neues Token holen
					const token = await ky('https://example.com/token').text();

					// Mit Token erneut versuchen
					request.headers.set('Authorization', `token ${token}`);

					return ky(request);
				}
			}
		]
	}
});
</code></pre>
<h5>throwHttpErrors</h5>
<p>Typ: <code>boolean</code><br />
Standard: <code>true</code></p>
<p>Löst einen <code>HTTPError</code> aus, wenn nach dem Folgen von Weiterleitungen die Antwort keinen 2xx-Statuscode hat. Um auch bei Weiterleitungen einen Fehler auszulösen, anstatt ihnen zu folgen, setzen Sie die Option <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters"><code>redirect</code></a> auf <code>'manual'</code>.</p>
<p>Das Setzen auf <code>false</code> kann nützlich sein, wenn Sie die Verfügbarkeit einer Ressource prüfen und Fehlerantworten erwarten.</p>
<p>Hinweis: Wenn <code>false</code>, werden Fehlerantworten als erfolgreich betrachtet und die Anfrage wird nicht wiederholt.</p>
<h5>onDownloadProgress</h5>
<p>Typ: <code>Function</code></p>
<p>Event-Handler für den Download-Fortschritt.</p>
<p>Die Funktion erhält folgende Argumente:</p>
<ul>
<li><code>progress</code> ist ein Objekt mit diesen Eigenschaften:</li>
<li>
<ul>
<li><code>percent</code> ist eine Zahl zwischen 0 und 1 und repräsentiert den Fortschritt in Prozent.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> ist die Anzahl der bisher übertragenen Bytes.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> ist die Gesamtanzahl der zu übertragenden Bytes. Dies ist ein Schätzwert und kann 0 sein, wenn die Gesamtgröße nicht bestimmt werden kann.</li>
</ul>
</li>
<li><code>chunk</code> ist eine Instanz von <code>Uint8Array</code>, die die gesendeten Daten enthält. Hinweis: Beim ersten Aufruf ist sie leer.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	onDownloadProgress: (progress, chunk) =&gt; {
		// Beispielausgabe:
		// `0% - 0 von 1271 Bytes`
		// `100% - 1271 von 1271 Bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} von ${progress.totalBytes} Bytes`);
	}
});
</code></pre>
<h5>onUploadProgress</h5>
<p>Typ: <code>Function</code></p>
<p>Upload-Fortschritts-Ereignis-Handler.</p>
<p>Die Funktion erhält folgende Argumente:</p>
<ul>
<li><code>progress</code> ist ein Objekt mit diesen Eigenschaften:</li>
<li>
<ul>
<li><code>percent</code> ist eine Zahl zwischen 0 und 1, die den Fortschrittsprozentsatz darstellt.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> ist die Anzahl der bisher übertragenen Bytes.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> ist die Gesamtzahl der zu übertragenden Bytes. Dies ist ein Schätzwert und kann 0 sein, wenn die Gesamtgröße nicht bestimmt werden kann.</li>
</ul>
</li>
<li><code>chunk</code> ist eine Instanz von <code>Uint8Array</code>, die die gesendeten Daten enthält. Hinweis: Beim letzten Aufruf ist sie leer.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky.post('https://example.com/upload', {
	body: largeFile,
	onUploadProgress: (progress, chunk) =&gt; {
		// Beispielausgabe:
		// `0% - 0 von 1271 Bytes`
		// `100% - 1271 von 1271 Bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} von ${progress.totalBytes} Bytes`);
	}
});
</code></pre>
<h5>parseJson</h5>
<p>Typ: <code>Function</code><br />
Standard: <code>JSON.parse()</code></p>
<p>Benutzerdefinierte JSON-Parsing-Funktion.</p>
<p>Anwendungsfälle:</p>
<ol>
<li>JSON über das <a href="https://github.com/hapijs/bourne"><code>bourne</code>-Paket</a> parsen, um sich vor Prototype Pollution zu schützen.</li>
<li>JSON mit der <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>reviver</code>-Option von <code>JSON.parse()</code></a> parsen.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import bourne from '@hapijs/bourne';

const json = await ky('https://example.com', {
	parseJson: text =&gt; bourne(text)
}).json();
</code></pre>
<h5>stringifyJson</h5>
<p>Typ: <code>Function</code><br />
Standard: <code>JSON.stringify()</code></p>
<p>Benutzerdefinierte JSON-Stringify-Funktion.</p>
<p>Anwendungsfälle:</p>
<ol>
<li>JSON mit einer benutzerdefinierten <code>replacer</code>-Funktion serialisieren.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import {DateTime} from 'luxon';

const json = await ky('https://example.com', {
	stringifyJson: data =&gt; JSON.stringify(data, (key, value) =&gt; {
		if (key.endsWith('_at')) {
			return DateTime.fromISO(value).toSeconds();
		}

		return value;
	})
}).json();
</code></pre>
<h5>fetch</h5>
<p>Typ: <code>Function</code><br />
Standard: <code>fetch</code></p>
<p>Benutzerdefinierte <code>fetch</code>-Funktion.
Muss vollständig mit dem <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>-Standard kompatibel sein.</p>
<p>Anwendungsfälle:</p>
<ol>
<li>Verwendung von benutzerdefinierten <code>fetch</code>-Implementierungen wie <a href="https://www.npmjs.com/package/isomorphic-unfetch"><code>isomorphic-unfetch</code></a>.</li>
<li>Verwendung der von einigen Frameworks bereitgestellten <code>fetch</code>-Wrapper-Funktion, die serverseitiges Rendering (SSR) nutzen.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import fetch from 'isomorphic-unfetch';

const json = await ky('https://example.com', {fetch}).json();
</code></pre>
<h3>ky.extend(defaultOptions)</h3>
<p>Erstellt eine neue <code>ky</code>-Instanz mit einigen durch eigene Werte überschriebenen Standardwerten.</p>
<p>Im Gegensatz zu <code>ky.create()</code> erbt <code>ky.extend()</code> die Standardwerte vom Elternteil.</p>
<p>Du kannst Header als <code>Headers</code>-Instanz oder als einfaches Objekt übergeben.</p>
<p>Du kannst einen Header mit <code>.extend()</code> entfernen, indem du den Header mit dem Wert <code>undefined</code> übergibst.
Das Übergeben von <code>undefined</code> als String entfernt den Header nur, wenn er aus einer <code>Headers</code>-Instanz stammt.</p>
<p>Ebenso kannst du bestehende <code>hooks</code>-Einträge entfernen, indem du den Hook explizit mit <code>undefined</code> überschreibst.</p>
<pre><code class="language-js">import ky from 'ky';

const url = 'https://sindresorhus.com';

const original = ky.create({
	headers: {
		rainbow: 'rainbow',
		unicorn: 'unicorn'
	},
	hooks: {
		beforeRequest: [ () =&gt; console.log('before 1') ],
		afterResponse: [ () =&gt; console.log('after 1') ],
	},
});

const extended = original.extend({
	headers: {
		rainbow: undefined
	},
	hooks: {
		beforeRequest: undefined,
		afterResponse: [ () =&gt; console.log('after 2') ],
	}
});

const response = await extended(url).json();
//=&gt; after 1
//=&gt; after 2

console.log('rainbow' in response);
//=&gt; false

console.log('unicorn' in response);
//=&gt; true
</code></pre>
<p>Du kannst auch auf Elterndefaults verweisen, indem du eine Funktion an <code>.extend()</code> übergibst.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.create({prefixUrl: 'https://example.com/api'});

const usersApi = api.extend((options) =&gt; ({prefixUrl: `${options.prefixUrl}/users`}));

const response = await usersApi.get('123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('version');
//=&gt; 'https://example.com/api/version'
</code></pre>
<h3>ky.create(defaultOptions)</h3>
<p>Erstellt eine neue Ky-Instanz mit komplett neuen Standardwerten.</p>
<pre><code class="language-js">import ky from 'ky';

// Auf https://my-site.com

const api = ky.create({prefixUrl: 'https://example.com/api'});

const response = await api.get('users/123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('/status', {prefixUrl: ''});
//=&gt; 'https://my-site.com/status'
</code></pre>
<h4>defaultOptions</h4>
<p>Typ: <code>object</code></p>
<h3>ky.stop</h3>
<p>Ein <code>Symbol</code>, das von einem <code>beforeRetry</code>-Hook zurückgegeben werden kann, um das erneute Versuchen zu stoppen. Dies beendet auch die verbleibenden <code>beforeRetry</code>-Hooks.</p>
<p>Hinweis: Wenn dieses Symbol zurückgegeben wird, bricht Ky ab und gibt eine <code>undefined</code>-Antwort zurück. Stelle sicher, dass du auf eine Antwort prüfst, bevor du auf deren Eigenschaften zugreifst, oder verwende <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optionale Verkettung</a>. Es ist auch nicht kompatibel mit Body-Methoden wie <code>.json()</code> oder <code>.text()</code>, da keine Antwort zum Parsen vorhanden ist. Generell empfehlen wir, stattdessen einen Fehler auszulösen, da Ky dann abbricht und eine Ausnahme wirft, was diese Einschränkungen vermeidet.</p>
<p>Ein sinnvoller Anwendungsfall für <code>ky.stop</code> ist das Verhindern von Wiederholungsversuchen bei Anfragen, die Nebenwirkungen haben, bei denen die zurückgegebenen Daten nicht wichtig sind. Zum Beispiel, um Client-Aktivitäten an den Server zu protokollieren.</p>
<pre><code class="language-js">import ky from 'ky';

const options = {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const shouldStopRetry = await ky('https://example.com/api');
				if (shouldStopRetry) {
					return ky.stop;
				}
			}
		]
	}
};
</code></pre>
<pre><code class="language-markdown">// Beachten Sie, dass die Antwort `undefined` ist, falls `ky.stop` zurückgegeben wird.
const response = await ky.post('https://example.com', options);

// Die Verwendung von `.text()` oder anderen Body-Methoden wird nicht unterstützt.
const text = await ky('https://example.com', options).text();
</code></pre>
<h3>HTTPError</h3>
<p>Wird für <code>instanceof</code>-Prüfungen offengelegt. Der Fehler besitzt eine <code>response</code>-Eigenschaft mit dem <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code>-Objekt</a>, eine <code>request</code>-Eigenschaft mit dem <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code>-Objekt</a> und eine <code>options</code>-Eigenschaft mit normalisierten Optionen (entweder an <code>ky</code> beim Erstellen einer Instanz mit <code>ky.create()</code> übergeben oder direkt beim Ausführen der Anfrage).</p>
<p>Beachten Sie, dass einige Fehlertypen, wie Netzwerkfehler, grundsätzlich bedeuten, dass keine Antwort empfangen wurde. In diesem Fall ist der Fehler keine Instanz von HTTPError und enthält keine <code>response</code>-Eigenschaft.</p>
<p>Wenn Sie die tatsächliche Antwort lesen müssen, wenn ein <code>HTTPError</code> aufgetreten ist, rufen Sie die entsprechende Parser-Methode für das Response-Objekt auf. Zum Beispiel:</p>
<pre><code class="language-js">try {
	await ky('https://example.com').json();
} catch (error) {
	if (error.name === 'HTTPError') {
		const errorJson = await error.response.json();
	}
}
</code></pre>
<p>⌨️ <strong>TypeScript:</strong> Akzeptiert einen optionalen <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">Typparameter</a>, der standardmäßig auf <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a> gesetzt ist und an den Rückgabetyp von <code>error.response.json()</code> weitergegeben wird.</p>
<h3>TimeoutError</h3>
<p>Der Fehler, der ausgelöst wird, wenn die Anfrage abläuft. Er enthält eine <code>request</code>-Eigenschaft mit dem <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code>-Objekt</a>.</p>
<h2>Tipps</h2>
<h3>Senden von Formulardaten</h3>
<p>Das Senden von Formulardaten in Ky ist identisch zu <code>fetch</code>. Übergeben Sie einfach eine <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a>-Instanz an die Option <code>body</code>. Der <code>Content-Type</code>-Header wird automatisch auf <code>multipart/form-data</code> gesetzt.</p>
<pre><code class="language-js">import ky from 'ky';

// `multipart/form-data`
const formData = new FormData();
formData.append('food', 'fries');
formData.append('drink', 'icetea');

const response = await ky.post(url, {body: formData});
</code></pre>
<p>Wenn Sie die Daten im Format <code>application/x-www-form-urlencoded</code> senden möchten, müssen Sie die Daten mit <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a> kodieren.</p>
<pre><code class="language-js">import ky from 'ky';

// `application/x-www-form-urlencoded`
const searchParams = new URLSearchParams();
searchParams.set('food', 'fries');
searchParams.set('drink', 'icetea');

const response = await ky.post(url, {body: searchParams});
</code></pre>
<h3>Setzen eines eigenen <code>Content-Type</code></h3>
<p>Ky setzt für jede Anfrage automatisch einen passenden <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a>-Header basierend auf den Daten im Request-Body. Einige APIs erfordern jedoch benutzerdefinierte, nicht standardisierte Content-Types, wie zum Beispiel <code>application/x-amz-json-1.1</code>. Über die Option <code>headers</code> können Sie den Content-Type manuell überschreiben.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {
	headers: {
		'content-type': 'application/json'
	},
	json: {
		foo: true
	},
}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<h3>Abbrechen</h3>
<p>Fetch (und damit auch Ky) unterstützt das Abbrechen von Requests nativ über die <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code>-API</a>. <a href="https://developers.google.com/web/updates/2017/09/abortable-fetch">Mehr dazu.</a></p>
<p>Beispiel:</p>
<pre><code class="language-js">import ky from 'ky';

const controller = new AbortController();
const {signal} = controller;

setTimeout(() =&gt; {
	controller.abort();
}, 5000);

try {
	console.log(await ky(url, {signal}).text());
} catch (error) {
	if (error.name === 'AbortError') {
		console.log('Fetch abgebrochen');
	} else {
		console.error('Fetch-Fehler:', error);
	}
}
</code></pre>
<h2>FAQ</h2>
<h4>Wie verwende ich dies in Node.js?</h4>
<p>Node.js 18 und neuer unterstützt <code>fetch</code> nativ, Sie können dieses Paket also direkt verwenden.</p>
<h4>Wie verwende ich dies mit einer Web-App (React, Vue.js, etc.), die Server-Side-Rendering (SSR) nutzt?</h4>
<p>Genauso wie oben beschrieben.</p>
<h4>Wie teste ich eine Browser-Bibliothek, die dies nutzt?</h4>
<p>Verwenden Sie entweder einen Testrunner, der im Browser läuft, wie Mocha, oder nutzen Sie <a href="https://avajs.dev">AVA</a> mit <code>ky-universal</code>. <a href="https://github.com/sindresorhus/ky-universal#faq">Mehr dazu.</a></p>
<h4>Wie verwende ich dies ohne einen Bundler wie Webpack?</h4>
<p>Stellen Sie sicher, dass Ihr Code als JavaScript-Modul (ESM) ausgeführt wird, zum Beispiel durch die Verwendung eines <code>&lt;script type=&quot;module&quot;&gt;</code>-Tags in Ihrem HTML-Dokument. Dann kann Ky direkt von diesem Modul ohne Bundler oder andere Tools importiert werden.</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
import ky from 'https://unpkg.com/ky/distribution/index.js';

const json = await ky('https://jsonplaceholder.typicode.com/todos/1').json();

console.log(json.title);
//=&gt; 'delectus aut autem'
&lt;/script&gt;
</code></pre>
<h4>Wie unterscheidet es sich von <a href="https://github.com/sindresorhus/got"><code>got</code></a></h4>
<p>Siehe meine Antwort <a href="https://twitter.com/sindresorhus/status/1037406558945042432">hier</a>. Got wird von den gleichen Personen wie Ky gepflegt.</p>
<h4>Wie unterscheidet es sich von <a href="https://github.com/axios/axios"><code>axios</code></a>?</h4>
<p>Siehe meine Antwort <a href="https://twitter.com/sindresorhus/status/1037763588826398720">hier</a>.</p>
<h4>Wie unterscheidet es sich von <a href="https://github.com/mikeal/r2"><code>r2</code></a>?</h4>
<p>Siehe meine Antwort in <a href="https://github.com/sindresorhus/ky/issues/10">#10</a>.</p>
<h4>Was bedeutet <code>ky</code>?</h4>
<p>Es ist einfach ein zufällig kurzer npm-Paketname, den ich bekommen konnte. Allerdings hat es im Japanischen eine Bedeutung:</p>
<blockquote>
<p>Eine Form von textbarem Slang, KY ist eine Abkürzung für 空気読めない (kuuki yomenai), was wörtlich übersetzt „kann die Luft nicht lesen“ bedeutet. Es wird für Personen verwendet, die die implizite Bedeutung nicht erkennen.</p>
</blockquote>
<h2>Browser-Support</h2>
<p>Die jeweils aktuelle Version von Chrome, Firefox und Safari.</p>
<h2>Node.js-Support</h2>
<p>Node.js 18 und neuer.</p>
<h2>Verwandtes</h2>
<ul>
<li><a href="https://github.com/sindresorhus/fetch-extras">fetch-extras</a> – Nützliche Hilfsmittel für die Arbeit mit Fetch</li>
<li><a href="https://github.com/alice-health/ky-hooks-change-case">ky-hooks-change-case</a> – Ky-Hooks zur Modifikation von Schreibweisen bei Requests und Responses von Objekten</li>
</ul>
<h2>Maintainer</h2>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a></li>
<li><a href="https://github.com/sholladay">Seth Holladay</a></li>
<li><a href="https://github.com/szmarczak">Szymon Marczak</a></li>
</ul>
<pre><code>

---


Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-11


---
</code></pre>

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>