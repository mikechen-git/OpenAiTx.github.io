<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ky - sindresorhus/ky fr</title>
    <meta name="title" content="ky - sindresorhus/ky fr | Ky est un client HTTP minuscule et élégant basé sur l'API Fetch Ky cible les navigateurs modernes, Node.js, Bun et Deno. C'est juste un petit paquet sans dépend...">
    <meta name="description" content="sindresorhus/ky - GitHub repository fr documentation and information | Ky est un client HTTP minuscule et élégant basé sur l'API Fetch Ky cible les navigateurs modernes, Node.js, Bun et Deno. C'est juste un petit paquet sans dépend...">
    <meta name="keywords" content="sindresorhus, ky, GitHub, repository, fr documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/sindresorhus/ky/README-fr.html">
    <meta property="og:title" content="ky - sindresorhus/ky fr | Ky est un client HTTP minuscule et élégant basé sur l'API Fetch Ky cible les navigateurs modernes, Node.js, Bun et Deno. C'est juste un petit paquet sans dépend...">
    <meta property="og:description" content="sindresorhus/ky - GitHub repository fr documentation and information | Ky est un client HTTP minuscule et élégant basé sur l'API Fetch Ky cible les navigateurs modernes, Node.js, Bun et Deno. C'est juste un petit paquet sans dépend...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/sindresorhus/ky" id="githubRepoLink" target="_blank">sindresorhus/ky</a>
<h1 style="display: none;">Ky est un client HTTP minuscule et élégant basé sur l'API Fetch Ky cible les navigateurs modernes, Node.js, Bun et Deno. C'est juste un petit paquet sans dépend...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <div align="center">
	<br>
	<div>
		<img width="600" height="600" src="https://raw.githubusercontent.com/sindresorhus/ky/main/media/logo.svg" alt="ky">
	</div>
	<br>
	<br>
	<br>
</div>
<blockquote>
<p>Ky est un client HTTP minuscule et élégant basé sur l'<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch">API Fetch</a></p>
</blockquote>
<p><a href="https://codecov.io/gh/sindresorhus/ky"><img src="https://codecov.io/gh/sindresorhus/ky/branch/main/graph/badge.svg" alt="Coverage Status" /></a>
<a href="https://bundlephobia.com/result?p=ky"><img src="https://badgen.net/bundlephobia/minzip/ky" alt="" /></a></p>
<p>Ky cible les <a href="#browser-support">navigateurs modernes</a>, Node.js, Bun et Deno.</p>
<p>C'est juste un petit paquet sans dépendances.</p>
<h2>Avantages par rapport à <code>fetch</code> natif</h2>
<ul>
<li>API plus simple</li>
<li>Raccourcis de méthode (<code>ky.post()</code>)</li>
<li>Considère les codes de statut non 2xx comme des erreurs (après les redirections)</li>
<li>Relance les requêtes échouées</li>
<li>Option JSON</li>
<li>Prise en charge du timeout</li>
<li>Option de préfixe d’URL</li>
<li>Instances avec des valeurs par défaut personnalisées</li>
<li>Hooks</li>
<li>Fonctionnalités TypeScript agréables (par exemple, <code>.json()</code> prend en charge les génériques et a <code>unknown</code> comme valeur par défaut, pas <code>any</code>)</li>
</ul>
<h2>Installation</h2>
<pre><code class="language-sh">npm install ky
</code></pre>
<h6>CDN</h6>
<ul>
<li><a href="https://cdn.jsdelivr.net/npm/ky/+esm">jsdelivr</a></li>
<li><a href="https://unpkg.com/ky">unpkg</a></li>
<li><a href="https://esm.sh/ky">esm.sh</a></li>
</ul>
<h2>Utilisation</h2>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {json: {foo: true}}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Avec <code>fetch</code> natif, cela serait :</p>
<pre><code class="language-js">class HTTPError extends Error {}

const response = await fetch('https://example.com', {
	method: 'POST',
	body: JSON.stringify({foo: true}),
	headers: {
		'content-type': 'application/json'
	}
});

if (!response.ok) {
	throw new HTTPError(`Fetch error: ${response.statusText}`);
}

const json = await response.json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<p>Si vous utilisez <a href="https://github.com/denoland/deno">Deno</a>, importez Ky depuis une URL. Par exemple, via un CDN :</p>
<pre><code class="language-js">import ky from 'https://esm.sh/ky';
</code></pre>
<h2>API</h2>
<h3>ky(input, options?)</h3>
<p>Les paramètres <code>input</code> et <code>options</code> sont identiques à ceux de <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>fetch</code></a>, avec des <code>options</code> supplémentaires disponibles (voir ci-dessous).</p>
<p>Retourne un <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">objet <code>Response</code></a> avec des <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body">méthodes <code>Body</code></a> ajoutées pour plus de commodité. Vous pouvez ainsi, par exemple, appeler directement <code>ky.get(input).json()</code> sans avoir à attendre d’abord la <code>Response</code>. Lorsqu’on l’appelle ainsi, un en-tête <code>Accept</code> approprié sera défini en fonction de la méthode body utilisée. Contrairement aux méthodes <code>Body</code> de <code>window.Fetch</code>, celles-ci lanceront une exception <code>HTTPError</code> si le statut de la réponse n’est pas dans la plage <code>200...299</code>. De plus, <code>.json()</code> retournera une chaîne vide si le body est vide ou si le statut de la réponse est <code>204</code> au lieu de lancer une erreur de parsing en raison d’un corps vide.</p>
<pre><code class="language-js">import ky from 'ky';

const user = await ky('/api/user').json();

console.log(user);
</code></pre>
<p>⌨️ <strong>TypeScript :</strong> Accepte un <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">paramètre de type optionnel</a>, qui vaut par défaut <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>, et est transmis au type de retour de <code>.json()</code>.</p>
<pre><code class="language-ts">import ky from 'ky';

// user1 est unknown
const user1 = await ky('/api/users/1').json();
// user2 est un User
const user2 = await ky&lt;User&gt;('/api/users/2').json();
// user3 est un User
const user3 = await ky('/api/users/3').json&lt;User&gt;();

console.log([user1, user2, user3]);
</code></pre>
<h3>ky.get(input, options?)</h3>
<h3>ky.post(input, options?)</h3>
<h3>ky.put(input, options?)</h3>
<h3>ky.patch(input, options?)</h3>
<h3>ky.head(input, options?)</h3>
<h3>ky.delete(input, options?)</h3>
<p>Définit <code>options.method</code> sur le nom de la méthode et effectue la requête.</p>
<p>⌨️ <strong>TypeScript :</strong> Accepte un paramètre de type optionnel à utiliser avec les réponses JSON (voir <a href="#kyinput-options"><code>ky()</code></a>).</p>
<h4>input</h4>
<p>Type : <code>string</code> | <code>URL</code> | <code>Request</code></p>
<p>Identique à l’<a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#input">entrée de <code>fetch</code></a>.</p>
<p>Lorsque vous utilisez une instance <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> comme <code>input</code>, toutes les options modifiant l’URL (telles que <code>prefixUrl</code>) seront ignorées.</p>
<h4>options</h4>
<p>Type : <code>object</code></p>
<p>Identique aux <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch#options">options de <code>fetch</code></a>, plus les options supplémentaires suivantes :</p>
<h5>method</h5>
<p>Type : <code>string</code><br />
Valeur par défaut : <code>'get'</code></p>
<p>Méthode HTTP utilisée pour effectuer la requête.</p>
<p>En interne, les méthodes standard (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>HEAD</code> et <code>DELETE</code>) sont mises en majuscule afin d’éviter les erreurs côté serveur dues à la sensibilité à la casse.</p>
<h5>json</h5>
<p>Type : <code>object</code> et toute autre valeur acceptée par <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a></p>
<p>Raccourci pour l’envoi de JSON. À utiliser à la place de l’option <code>body</code>. Accepte tout objet ou valeur simple, qui sera converti en JSON via <code>JSON.stringify()</code> et envoyé dans le body avec l’en-tête approprié.</p>
<h5>searchParams</h5>
<p>Type : <code>string | object&lt;string, string | number | boolean&gt; | Array&lt;Array&lt;string | number | boolean&gt;&gt; | URLSearchParams</code><br />
Valeur par défaut : <code>''</code></p>
<p>Paramètres de recherche à inclure dans l’URL de la requête. Les définir écrasera tous les paramètres de recherche existants dans l’URL d’entrée.</p>
<p>Accepte toute valeur supportée par <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams"><code>URLSearchParams()</code></a>.</p>
<h5>prefixUrl</h5>
<p>Type : <code>string | URL</code></p>
<p>Un préfixe à ajouter à l’URL <code>input</code> lors de la requête. Cela peut être n’importe quelle URL valide, relative ou absolue. Un slash final <code>/</code> est optionnel et sera ajouté automatiquement, si besoin, lorsqu’il est combiné avec <code>input</code>. Prend effet uniquement lorsque <code>input</code> est une chaîne. L’argument <code>input</code> ne peut pas commencer par un slash <code>/</code> lors de l’utilisation de cette option.</p>
<p>Utile en combinaison avec <a href="#kyextenddefaultoptions"><code>ky.extend()</code></a> pour créer des instances Ky spécifiques à un usage particulier.</p>
<pre><code class="language-js">import ky from 'ky';

// Sur https://example.com

const response = await ky('unicorn', {prefixUrl: '/api'});
//=&gt; 'https://example.com/api/unicorn'

const response2 = await ky('unicorn', {prefixUrl: 'https://cats.com'});
//=&gt; 'https://cats.com/unicorn'
</code></pre>
<p>Notes :</p>
<ul>
<li>Après la combinaison de <code>prefixUrl</code> et <code>input</code>, le résultat est résolu par rapport à l’<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/baseURI">URL de base</a> de la page (si elle existe).</li>
<li>Les slashes initiaux dans <code>input</code> sont interdits lors de l’utilisation de cette option afin d’assurer la cohérence et d’éviter toute confusion sur la façon dont l’URL <code>input</code> est traitée, puisque <code>input</code> ne suivra pas les règles normales de résolution d’URL quand <code>prefixUrl</code> est utilisé, ce qui change la signification d’un slash initial.</li>
</ul>
<h5>retry</h5>
<p>Type : <code>object | number</code><br />
Valeur par défaut :</p>
<ul>
<li><code>limit</code> : <code>2</code></li>
<li><code>methods</code> : <code>get</code> <code>put</code> <code>head</code> <code>delete</code> <code>options</code> <code>trace</code></li>
<li><code>statusCodes</code> : <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"><code>408</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"><code>500</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"><code>502</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"><code>504</code></a></li>
<li><code>afterStatusCodes</code> : <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"><code>413</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"><code>429</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"><code>503</code></a></li>
<li><code>maxRetryAfter</code> : <code>undefined</code></li>
<li><code>backoffLimit</code> : <code>undefined</code></li>
<li><code>delay</code> : <code>attemptCount =&gt; 0.3 * (2 ** (attemptCount - 1)) * 1000</code></li>
</ul>
<p>Un objet représentant les champs <code>limit</code>, <code>methods</code>, <code>statusCodes</code>, <code>afterStatusCodes</code> et <code>maxRetryAfter</code> pour le nombre maximal de tentatives, les méthodes autorisées, les codes de statut autorisés, les codes de statut autorisés à utiliser le temps <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> et le temps maximal <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a>.</p>
<p>Si <code>retry</code> est un nombre, il sera utilisé comme <code>limit</code> et les autres valeurs par défaut resteront inchangées.</p>
<p>Si la réponse fournit un code HTTP contenu dans <code>afterStatusCodes</code>, Ky attendra que la date, le délai d'attente ou le timestamp donné dans l’en-tête <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> soit passé pour réessayer la requête. Si <code>Retry-After</code> est absent, l’en-tête non standard <a href="https://www.ietf.org/archive/id/draft-polli-ratelimit-headers-05.html#section-3.3"><code>RateLimit-Reset</code></a> est utilisé comme solution de repli. Si le code de statut fourni n'est pas dans la liste, l’en-tête <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> sera ignoré.</p>
<p>Si <code>maxRetryAfter</code> est défini sur <code>undefined</code>, il utilisera <code>options.timeout</code>. Si l’en-tête <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"><code>Retry-After</code></a> est supérieur à <code>maxRetryAfter</code>, il utilisera <code>maxRetryAfter</code>.</p>
<p>L'option <code>backoffLimit</code> est la limite supérieure du délai par tentative en millisecondes.
Pour limiter le délai, définissez <code>backoffLimit</code> à 1000, par exemple.
Par défaut, le délai est calculé avec <code>0.3 * (2 ** (attemptCount - 1)) * 1000</code>. Le délai augmente exponentiellement.</p>
<p>L’option <code>delay</code> peut être utilisée pour changer la façon dont le délai entre les tentatives est calculé. La fonction reçoit un paramètre, le nombre de tentatives, commençant à <code>1</code>.</p>
<p>Les tentatives ne sont pas déclenchées suite à un <a href="#timeout">timeout</a>.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky('https://example.com', {
	retry: {
		limit: 10,
		methods: ['get'],
		statusCodes: [413],
		backoffLimit: 3000
	}
}).json();
</code></pre>
<h5>timeout</h5>
<p>Type : <code>number | false</code><br />
Par défaut : <code>10000</code></p>
<p>Délai d'attente en millisecondes pour obtenir une réponse, y compris toutes les tentatives. Ne peut pas dépasser 2147483647.
Si défini à <code>false</code>, il n’y aura pas de délai d’attente.</p>
<h5>hooks</h5>
<p>Type : <code>object&lt;string, Function[]&gt;</code><br />
Par défaut : <code>{beforeRequest: [], beforeRetry: [], afterResponse: []}</code></p>
<p>Les hooks permettent des modifications pendant le cycle de vie de la requête. Les fonctions hook peuvent être asynchrones et sont exécutées en série.</p>
<h6>hooks.beforeRequest</h6>
<p>Type : <code>Function[]</code><br />
Par défaut : <code>[]</code></p>
<p>Ce hook permet de modifier la requête juste avant qu'elle ne soit envoyée. Ky n’apportera plus aucun changement à la requête après cela. La fonction hook reçoit <code>request</code> et <code>options</code> en arguments. Vous pouvez, par exemple, modifier ici les <code>request.headers</code>.</p>
<p>Le hook peut retourner un <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a> pour remplacer la requête sortante, ou retourner une <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> pour éviter complètement de faire une requête HTTP. Cela peut être utilisé pour simuler une requête, vérifier un cache interne, etc. Une considération <strong>importante</strong> lors du retour d'une requête ou d'une réponse depuis ce hook est que tous les hooks <code>beforeRequest</code> restants seront ignorés, il peut donc être préférable de ne les retourner que depuis le dernier hook.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.extend({
	hooks: {
		beforeRequest: [
			request =&gt; {
				request.headers.set('X-Requested-With', 'ky');
			}
		]
	}
});

const response = await api.get('https://example.com/api/users');
</code></pre>
<h6>hooks.beforeRetry</h6>
<p>Type : <code>Function[]</code><br />
Par défaut : <code>[]</code></p>
<p>Ce hook permet de modifier la requête juste avant la nouvelle tentative. Ky n’apportera plus aucun changement à la requête après cela. La fonction hook reçoit un objet avec la requête et les options normalisées, une instance d’erreur et le nombre de tentatives. Vous pouvez, par exemple, modifier ici les <code>request.headers</code>.</p>
<p>Si la requête a reçu une réponse, l’erreur sera de type <code>HTTPError</code> et l’objet <code>Response</code> sera disponible via <code>error.response</code>. Notez que certains types d’erreurs, comme les erreurs réseau, signifient par nature qu’aucune réponse n’a été reçue. Dans ce cas, l’erreur ne sera pas une instance de <code>HTTPError</code>.</p>
<p>Vous pouvez empêcher Ky de réessayer la requête en lançant une erreur. Ky ne la gérera d’aucune façon et l’erreur sera propagée à l’initiateur de la requête. Le reste des hooks <code>beforeRetry</code> ne sera pas appelé dans ce cas. Alternativement, vous pouvez retourner le symbole <a href="#kystop"><code>ky.stop</code></a> pour faire la même chose mais sans propager d’erreur (cela a quelques limitations, voir la documentation de <code>ky.stop</code> pour les détails).</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const token = await ky('https://example.com/refresh-token');
				request.headers.set('Authorization', `token ${token}`);
			}
		]
	}
});
</code></pre>
<h6>hooks.beforeError</h6>
<p>Type : <code>Function[]</code><br />
Par défaut : <code>[]</code></p>
<p>Ce hook permet de modifier le <code>HTTPError</code> juste avant qu’il ne soit levé. La fonction hook reçoit un <code>HTTPError</code> en argument et doit retourner une instance de <code>HTTPError</code>.</p>
<pre><code class="language-js">import ky from 'ky';

await ky('https://example.com', {
	hooks: {
		beforeError: [
			error =&gt; {
				const {response} = error;
				if (response &amp;&amp; response.body) {
					error.name = 'GitHubError';
					error.message = `${response.body.message} (${response.status})`;
				}

				return error;
			}
		]
	}
});
</code></pre>
<h6>hooks.afterResponse</h6>
<p>Type : <code>Function[]</code><br />
Par défaut : <code>[]</code></p>
<p>Ce hook permet de lire et éventuellement de modifier la réponse. La fonction hook reçoit la requête normalisée, les options et un clone de la réponse en arguments. La valeur de retour de la fonction hook sera utilisée par Ky comme objet réponse si c’est une instance de <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a>.</p>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	hooks: {
		afterResponse: [
			(_request, _options, response) =&gt; {
				// Vous pouvez faire quelque chose avec la réponse, par exemple, un log.
				log(response);

				// Ou retourner une instance de `Response` pour remplacer la réponse.
				return new Response('A different response', {status: 200});
			},

			// Ou refaire une tentative avec un nouveau token sur une erreur 403
			async (request, options, response) =&gt; {
				if (response.status === 403) {
					// Obtenir un nouveau token
					const token = await ky('https://example.com/token').text();

					// Réessayer avec le token
					request.headers.set('Authorization', `token ${token}`);

					return ky(request);
				}
			}
		]
	}
});
</code></pre>
<h5>throwHttpErrors</h5>
<p>Type : <code>boolean</code><br />
Par défaut : <code>true</code></p>
<p>Lève une <code>HTTPError</code> lorsque, après avoir suivi les redirections, la réponse a un code de statut non-2xx. Pour lever également pour les redirections au lieu de les suivre, définissez l’option <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters"><code>redirect</code></a> à <code>'manual'</code>.</p>
<p>Définir ceci à <code>false</code> peut être utile si vous vérifiez la disponibilité d'une ressource et attendez des réponses d’erreur.</p>
<p>Remarque : Si <code>false</code>, les réponses d’erreur sont considérées comme réussies et la requête ne sera pas réessayée.</p>
<h5>onDownloadProgress</h5>
<p>Type : <code>Function</code></p>
<p>Gestionnaire d’événement de progression du téléchargement.</p>
<p>La fonction reçoit les arguments suivants :</p>
<ul>
<li><code>progress</code> est un objet avec les propriétés suivantes :</li>
<li>
<ul>
<li><code>percent</code> est un nombre entre 0 et 1 représentant le pourcentage de progression.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> est le nombre d’octets transférés jusqu’à présent.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> est le nombre total d’octets à transférer. Il s’agit d’une estimation et peut être 0 si la taille totale ne peut pas être déterminée.</li>
</ul>
</li>
<li><code>chunk</code> est une instance de <code>Uint8Array</code> contenant les données envoyées. Remarque : Elle est vide lors du premier appel.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky('https://example.com', {
	onDownloadProgress: (progress, chunk) =&gt; {
		// Exemple d’affichage :
		// `0% - 0 of 1271 bytes`
		// `100% - 1271 of 1271 bytes`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} of ${progress.totalBytes} bytes`);
	}
});
</code></pre>
<h5>onUploadProgress</h5>
<p>Type : <code>Function</code>
Gestionnaire d'événement de progression de l’envoi.</p>
<p>La fonction reçoit les arguments suivants :</p>
<ul>
<li><code>progress</code> est un objet avec les propriétés suivantes :</li>
<li>
<ul>
<li><code>percent</code> est un nombre compris entre 0 et 1 représentant le pourcentage de progression.</li>
</ul>
</li>
<li>
<ul>
<li><code>transferredBytes</code> est le nombre d’octets transférés jusqu’à présent.</li>
</ul>
</li>
<li>
<ul>
<li><code>totalBytes</code> est le nombre total d’octets à transférer. Il s’agit d’une estimation et il peut être égal à 0 si la taille totale ne peut pas être déterminée.</li>
</ul>
</li>
<li><code>chunk</code> est une instance de <code>Uint8Array</code> contenant les données qui ont été envoyées. Remarque : Il est vide lors du dernier appel.</li>
</ul>
<pre><code class="language-js">import ky from 'ky';

const response = await ky.post('https://example.com/upload', {
	body: largeFile,
	onUploadProgress: (progress, chunk) =&gt; {
		// Exemple de sortie :
		// `0% - 0 sur 1271 octets`
		// `100% - 1271 sur 1271 octets`
		console.log(`${progress.percent * 100}% - ${progress.transferredBytes} sur ${progress.totalBytes} octets`);
	}
});
</code></pre>
<h5>parseJson</h5>
<p>Type : <code>Function</code><br />
Par défaut : <code>JSON.parse()</code></p>
<p>Fonction de parsing JSON définie par l’utilisateur.</p>
<p>Cas d’utilisation :</p>
<ol>
<li>Parser le JSON via le paquet <a href="https://github.com/hapijs/bourne"><code>bourne</code></a> pour se protéger contre la pollution du prototype.</li>
<li>Parser le JSON avec l’option <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>reviver</code> de <code>JSON.parse()</code></a>.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import bourne from '@hapijs/bourne';

const json = await ky('https://example.com', {
	parseJson: text =&gt; bourne(text)
}).json();
</code></pre>
<h5>stringifyJson</h5>
<p>Type : <code>Function</code><br />
Par défaut : <code>JSON.stringify()</code></p>
<p>Fonction de transformation JSON en chaîne définie par l’utilisateur.</p>
<p>Cas d’utilisation :</p>
<ol>
<li>Transformer le JSON avec une fonction <code>replacer</code> personnalisée.</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import {DateTime} from 'luxon';

const json = await ky('https://example.com', {
	stringifyJson: data =&gt; JSON.stringify(data, (key, value) =&gt; {
		if (key.endsWith('_at')) {
			return DateTime.fromISO(value).toSeconds();
		}

		return value;
	})
}).json();
</code></pre>
<h5>fetch</h5>
<p>Type : <code>Function</code><br />
Par défaut : <code>fetch</code></p>
<p>Fonction <code>fetch</code> définie par l’utilisateur.
Doit être entièrement compatible avec le standard <a href="https://developer.mozilla.org/fr/docs/Web/API/Fetch_API">Fetch API</a>.</p>
<p>Cas d’utilisation :</p>
<ol>
<li>Utiliser des implémentations personnalisées de <code>fetch</code> comme <a href="https://www.npmjs.com/package/isomorphic-unfetch"><code>isomorphic-unfetch</code></a>.</li>
<li>Utiliser la fonction wrapper <code>fetch</code> fournie par certains frameworks qui utilisent le rendu côté serveur (SSR).</li>
</ol>
<pre><code class="language-js">import ky from 'ky';
import fetch from 'isomorphic-unfetch';

const json = await ky('https://example.com', {fetch}).json();
</code></pre>
<h3>ky.extend(defaultOptions)</h3>
<p>Crée une nouvelle instance de <code>ky</code> avec certains paramètres par défaut remplacés par les vôtres.</p>
<p>Contrairement à <code>ky.create()</code>, <code>ky.extend()</code> hérite des valeurs par défaut de son parent.</p>
<p>Vous pouvez passer les en-têtes comme une instance de <code>Headers</code> ou comme un objet classique.</p>
<p>Vous pouvez supprimer un en-tête avec <code>.extend()</code> en passant l’en-tête avec une valeur <code>undefined</code>.
Passer <code>undefined</code> sous forme de chaîne supprime l’en-tête uniquement s’il provient d’une instance <code>Headers</code>.</p>
<p>De même, vous pouvez supprimer des entrées de <code>hooks</code> existantes en étendant le hook avec un <code>undefined</code> explicite.</p>
<pre><code class="language-js">import ky from 'ky';

const url = 'https://sindresorhus.com';

const original = ky.create({
	headers: {
		rainbow: 'rainbow',
		unicorn: 'unicorn'
	},
	hooks: {
		beforeRequest: [ () =&gt; console.log('before 1') ],
		afterResponse: [ () =&gt; console.log('after 1') ],
	},
});

const extended = original.extend({
	headers: {
		rainbow: undefined
	},
	hooks: {
		beforeRequest: undefined,
		afterResponse: [ () =&gt; console.log('after 2') ],
	}
});

const response = await extended(url).json();
//=&gt; after 1
//=&gt; after 2

console.log('rainbow' in response);
//=&gt; false

console.log('unicorn' in response);
//=&gt; true
</code></pre>
<p>Vous pouvez également référencer les valeurs par défaut du parent en fournissant une fonction à <code>.extend()</code>.</p>
<pre><code class="language-js">import ky from 'ky';

const api = ky.create({prefixUrl: 'https://example.com/api'});

const usersApi = api.extend((options) =&gt; ({prefixUrl: `${options.prefixUrl}/users`}));

const response = await usersApi.get('123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('version');
//=&gt; 'https://example.com/api/version'
</code></pre>
<h3>ky.create(defaultOptions)</h3>
<p>Crée une nouvelle instance Ky avec de nouveaux paramètres par défaut.</p>
<pre><code class="language-js">import ky from 'ky';

// Sur https://my-site.com

const api = ky.create({prefixUrl: 'https://example.com/api'});

const response = await api.get('users/123');
//=&gt; 'https://example.com/api/users/123'

const response = await api.get('/status', {prefixUrl: ''});
//=&gt; 'https://my-site.com/status'
</code></pre>
<h4>defaultOptions</h4>
<p>Type : <code>object</code></p>
<h3>ky.stop</h3>
<p>Un <code>Symbol</code> qui peut être retourné par un hook <code>beforeRetry</code> pour arrêter la nouvelle tentative. Cela court-circuite également les hooks <code>beforeRetry</code> restants.</p>
<p>Remarque : Retourner ce symbole fait que Ky s’arrête et retourne une réponse <code>undefined</code>. Assurez-vous de vérifier la présence d’une réponse avant d’accéder à ses propriétés ou utilisez le <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Operators/Optional_chaining">chaînage optionnel</a>. Il est également incompatible avec les méthodes de corps, telles que <code>.json()</code> ou <code>.text()</code>, car il n’y a pas de réponse à analyser. En général, nous recommandons de lever une erreur plutôt que de retourner ce symbole, car cela fera que Ky s’arrêtera puis lèvera une exception, ce qui évite ces limitations.</p>
<p>Un cas d’utilisation valide pour <code>ky.stop</code> est d’empêcher les nouvelles tentatives lors de requêtes à effet de bord, lorsque les données retournées ne sont pas importantes. Par exemple, la journalisation de l’activité client vers le serveur.</p>
<pre><code class="language-js">import ky from 'ky';

const options = {
	hooks: {
		beforeRetry: [
			async ({request, options, error, retryCount}) =&gt; {
				const shouldStopRetry = await ky('https://example.com/api');
				if (shouldStopRetry) {
					return ky.stop;
				}
			}
		]
	}
};
</code></pre>
<pre><code class="language-js">// Notez que la réponse sera `undefined` dans le cas où `ky.stop` est retourné.
const response = await ky.post('https://example.com', options);

// L'utilisation de `.text()` ou d'autres méthodes de corps n'est pas prise en charge.
const text = await ky('https://example.com', options).text();
</code></pre>
<h3>HTTPError</h3>
<p>Exposé pour les vérifications <code>instanceof</code>. L'erreur possède une propriété <code>response</code> avec l'objet <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a>, une propriété <code>request</code> avec l'objet <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a>, et une propriété <code>options</code> avec les options normalisées (soit passées à <code>ky</code> lors de la création d'une instance avec <code>ky.create()</code>, soit directement lors de l'exécution de la requête).</p>
<p>Sachez que certains types d'erreurs, comme les erreurs réseau, impliquent intrinsèquement qu'aucune réponse n'a été reçue. Dans ce cas, l'erreur ne sera pas une instance de HTTPError et ne contiendra pas de propriété <code>response</code>.</p>
<p>Si vous avez besoin de lire la réponse réelle lorsqu'une <code>HTTPError</code> s'est produite, appelez la méthode d'analyseur respective sur l'objet response. Par exemple :</p>
<pre><code class="language-js">try {
	await ky('https://example.com').json();
} catch (error) {
	if (error.name === 'HTTPError') {
		const errorJson = await error.response.json();
	}
}
</code></pre>
<p>⌨️ <strong>TypeScript :</strong> Accepte un <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">paramètre de type</a> optionnel, qui par défaut est <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown"><code>unknown</code></a>, et est transmis au type de retour de <code>error.response.json()</code>.</p>
<h3>TimeoutError</h3>
<p>L'erreur levée lorsque la requête expire. Elle possède une propriété <code>request</code> avec l'objet <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request"><code>Request</code></a>.</p>
<h2>Conseils</h2>
<h3>Envoi de données de formulaire</h3>
<p>L'envoi de données de formulaire dans Ky est identique à <code>fetch</code>. Il suffit de passer une instance <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData"><code>FormData</code></a> à l'option <code>body</code>. L'en-tête <code>Content-Type</code> sera automatiquement défini sur <code>multipart/form-data</code>.</p>
<pre><code class="language-js">import ky from 'ky';

// `multipart/form-data`
const formData = new FormData();
formData.append('food', 'fries');
formData.append('drink', 'icetea');

const response = await ky.post(url, {body: formData});
</code></pre>
<p>Si vous souhaitez envoyer les données au format <code>application/x-www-form-urlencoded</code>, vous devrez encoder les données avec <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams"><code>URLSearchParams</code></a>.</p>
<pre><code class="language-js">import ky from 'ky';

// `application/x-www-form-urlencoded`
const searchParams = new URLSearchParams();
searchParams.set('food', 'fries');
searchParams.set('drink', 'icetea');

const response = await ky.post(url, {body: searchParams});
</code></pre>
<h3>Définir un <code>Content-Type</code> personnalisé</h3>
<p>Ky définit automatiquement un en-tête <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> approprié pour chaque requête en fonction des données dans le corps de la requête. Cependant, certaines API nécessitent des types de contenu personnalisés ou non standards, comme <code>application/x-amz-json-1.1</code>. À l'aide de l'option <code>headers</code>, vous pouvez remplacer manuellement le type de contenu.</p>
<pre><code class="language-js">import ky from 'ky';

const json = await ky.post('https://example.com', {
	headers: {
		'content-type': 'application/json'
	},
	json: {
		foo: true
	},
}).json();

console.log(json);
//=&gt; {data: '🦄'}
</code></pre>
<h3>Annulation</h3>
<p>Fetch (et donc Ky) prend en charge nativement l'annulation de requête via l'API <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code></a>. <a href="https://developers.google.com/web/updates/2017/09/abortable-fetch">En savoir plus.</a></p>
<p>Exemple :</p>
<pre><code class="language-js">import ky from 'ky';

const controller = new AbortController();
const {signal} = controller;

setTimeout(() =&gt; {
	controller.abort();
}, 5000);

try {
	console.log(await ky(url, {signal}).text());
} catch (error) {
	if (error.name === 'AbortError') {
		console.log('Fetch annulé');
	} else {
		console.error('Erreur fetch :', error);
	}
}
</code></pre>
<h2>FAQ</h2>
<h4>Comment utiliser ceci dans Node.js ?</h4>
<p>Node.js 18 et versions ultérieures prennent en charge <code>fetch</code> nativement, vous pouvez donc utiliser ce package directement.</p>
<h4>Comment utiliser ceci avec une application web (React, Vue.js, etc.) qui utilise le rendu côté serveur (SSR) ?</h4>
<p>Comme ci-dessus.</p>
<h4>Comment tester une bibliothèque navigateur qui utilise ceci ?</h4>
<p>Utilisez soit un lanceur de tests qui peut s'exécuter dans le navigateur, comme Mocha, soit <a href="https://avajs.dev">AVA</a> avec <code>ky-universal</code>. <a href="https://github.com/sindresorhus/ky-universal#faq">En savoir plus.</a></p>
<h4>Comment utiliser ceci sans un bundler comme Webpack ?</h4>
<p>Assurez-vous que votre code s'exécute en tant que module JavaScript (ESM), par exemple en utilisant une balise <code>&lt;script type=&quot;module&quot;&gt;</code> dans votre document HTML. Ky peut alors être importé directement par ce module sans bundler ni autres outils.</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
import ky from 'https://unpkg.com/ky/distribution/index.js';

const json = await ky('https://jsonplaceholder.typicode.com/todos/1').json();

console.log(json.title);
//=&gt; 'delectus aut autem'
&lt;/script&gt;
</code></pre>
<h4>En quoi est-ce différent de <a href="https://github.com/sindresorhus/got"><code>got</code></a></h4>
<p>Voir ma réponse <a href="https://twitter.com/sindresorhus/status/1037406558945042432">ici</a>. Got est maintenu par les mêmes personnes que Ky.</p>
<h4>En quoi est-ce différent de <a href="https://github.com/axios/axios"><code>axios</code></a> ?</h4>
<p>Voir ma réponse <a href="https://twitter.com/sindresorhus/status/1037763588826398720">ici</a>.</p>
<h4>En quoi est-ce différent de <a href="https://github.com/mikeal/r2"><code>r2</code></a> ?</h4>
<p>Voir ma réponse dans <a href="https://github.com/sindresorhus/ky/issues/10">#10</a>.</p>
<h4>Que signifie <code>ky</code> ?</h4>
<p>C'est juste un nom de package npm court et aléatoire que j'ai réussi à obtenir. Cependant, il a une signification en japonais :</p>
<blockquote>
<p>Une forme d'argot textuel, KY est une abréviation de 空気読めない (kuuki yomenai), qui se traduit littéralement par « ne peut pas lire l'air ». C'est une expression appliquée à quelqu'un qui manque le sens implicite.</p>
</blockquote>
<h2>Compatibilité navigateur</h2>
<p>La dernière version de Chrome, Firefox et Safari.</p>
<h2>Compatibilité Node.js</h2>
<p>Node.js 18 et versions ultérieures.</p>
<h2>Liens connexes</h2>
<ul>
<li><a href="https://github.com/sindresorhus/fetch-extras">fetch-extras</a> - Utilitaires pratiques pour travailler avec Fetch</li>
<li><a href="https://github.com/alice-health/ky-hooks-change-case">ky-hooks-change-case</a> - Hooks Ky pour modifier les cas sur les requêtes et réponses des objets</li>
</ul>
<h2>Mainteneurs</h2>
<ul>
<li><a href="https://github.com/sindresorhus">Sindre Sorhus</a></li>
<li><a href="https://github.com/sholladay">Seth Holladay</a></li>
<li><a href="https://github.com/szmarczak">Szymon Marczak</a></li>
</ul>
<pre><code>

---


Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-11


---
</code></pre>

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>