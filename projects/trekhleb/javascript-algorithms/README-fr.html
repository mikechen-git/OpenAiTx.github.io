<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>javascript-algorithms - trekhleb/javascript-algorithms</title>
    <meta name="title" content="javascript-algorithms - trekhleb/javascript-algorithms">
    <meta name="description" content="trekhleb/javascript-algorithms - GitHub repository fr documentation and informationAlgorithmes et Structures de Données JavaScript 🇺🇦 L’UKRAINE EST ATTAQUÉE PAR L’ARMÉE RUSSE. DES CIVILS SONT TUÉS. DES ZONES RÉSIDENTIELLES SONT BOMBARDÉES. A...">
    <meta name="keywords" content="trekhleb, javascript-algorithms, GitHub, repository, fr documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/trekhleb/javascript-algorithms/README-fr.html">
    <meta property="og:title" content="javascript-algorithms - trekhleb/javascript-algorithms">
    <meta property="og:description" content="trekhleb/javascript-algorithms - GitHub repository fr documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/trekhleb/javascript-algorithms" id="githubRepoLink" target="_blank">trekhleb/javascript-algorithms</a>
<h1 style="display: none;">Algorithmes et Structures de Données JavaScript 🇺🇦 L’UKRAINE EST ATTAQUÉE PAR L’ARMÉE RUSSE. DES CIVILS SONT TUÉS. DES ZONES RÉSIDENTIELLES SONT BOMBARDÉES. A...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>Algorithmes et Structures de Données JavaScript</h1>
<blockquote>
<p>🇺🇦 L’UKRAINE <a href="https://war.ukraine.ua/">EST ATTAQUÉE</a> PAR L’ARMÉE RUSSE. DES CIVILS SONT TUÉS. DES ZONES RÉSIDENTIELLES SONT BOMBARDÉES.</p>
<ul>
<li>Aidez l’Ukraine via :
<ul>
<li><a href="https://prytulafoundation.org/en/">Fondation caritative Serhiy Prytula</a></li>
<li><a href="https://savelife.in.ua/en/donate-en/">Fondation caritative Come Back Alive</a></li>
<li><a href="https://bank.gov.ua/en/news/all/natsionalniy-bank-vidkriv-spetsrahunok-dlya-zboru-koshtiv-na-potrebi-armiyi">Banque Nationale d’Ukraine</a></li>
</ul>
</li>
<li>Plus d’informations sur <a href="https://war.ukraine.ua/">war.ukraine.ua</a> et <a href="https://twitter.com/MFA_Ukraine">MFA of Ukraine</a></li>
</ul>
</blockquote>
<hr/>
<p><a href="https://github.com/trekhleb/javascript-algorithms/actions?query=workflow%3ACI+branch%3Amaster"><img src="https://github.com/trekhleb/javascript-algorithms/workflows/CI/badge.svg" alt="CI" /></a>
<a href="https://codecov.io/gh/trekhleb/javascript-algorithms"><img src="https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg" alt="codecov" /></a>
<img src="https://img.shields.io/github/repo-size/trekhleb/javascript-algorithms.svg" alt="repo size" /></p>
<p>Ce dépôt contient des exemples d’algorithmes et de structures de données populaires
en JavaScript.</p>
<p>Chaque algorithme et structure de données dispose de son propre fichier README
avec des explications associées et des liens pour approfondir le sujet (y compris des liens
vers des vidéos YouTube).</p>
<p><em>Lire ceci dans d’autres langues :</em>
<a href="README.zh-CN.md"><em>简体中文</em></a>,
<a href="README.zh-TW.md"><em>繁體中文</em></a>,
<a href="README.ko-KR.md"><em>한국어</em></a>,
<a href="README.ja-JP.md"><em>日本語</em></a>,
<a href="README.pl-PL.md"><em>Polski</em></a>,
<a href="README.fr-FR.md"><em>Français</em></a>,
<a href="README.es-ES.md"><em>Español</em></a>,
<a href="README.pt-BR.md"><em>Português</em></a>,
<a href="README.ru-RU.md"><em>Русский</em></a>,
<a href="README.tr-TR.md"><em>Türkçe</em></a>,
<a href="README.it-IT.md"><em>Italiano</em></a>,
<a href="README.id-ID.md"><em>Bahasa Indonesia</em></a>,
<a href="README.uk-UA.md"><em>Українська</em></a>,
<a href="README.ar-AR.md"><em>Arabic</em></a>,
<a href="README.vi-VN.md"><em>Tiếng Việt</em></a>,
<a href="README.de-DE.md"><em>Deutsch</em></a>,
<a href="README.uz-UZ.md"><em>Uzbek</em></a>,
<a href="README.he-IL.md"><em>עברית</em></a></p>
<p><em>☝ Notez que ce projet est destiné uniquement à des fins d’apprentissage et de recherche,
et n’est <strong>pas</strong> destiné à un usage en production.</em></p>
<h2>Structures de Données</h2>
<p>Une structure de données est une manière particulière d’organiser et de stocker des données dans un ordinateur afin qu’elles puissent être
accédées et modifiées efficacement. Plus précisément, une structure de données est une collection de valeurs de données,
les relations entre elles, et les fonctions ou opérations qui peuvent être appliquées à ces données.</p>
<p>Rappelez-vous que chaque structure de données a ses propres compromis. Il est important de prêter attention à la raison pour laquelle vous choisissez une structure de données particulière plutôt qu’à la façon de l’implémenter.</p>
<p><code>B</code> - Débutant, <code>A</code> - Avancé</p>
<ul>
<li><code>B</code> <a href="src/data-structures/linked-list">Liste Chaînée</a></li>
<li><code>B</code> <a href="src/data-structures/doubly-linked-list">Liste Doubly Chaînée</a></li>
<li><code>B</code> <a href="src/data-structures/queue">File (Queue)</a></li>
<li><code>B</code> <a href="src/data-structures/stack">Pile (Stack)</a></li>
<li><code>B</code> <a href="src/data-structures/hash-table">Table de Hachage</a></li>
<li><code>B</code> <a href="src/data-structures/heap">Tas (Heap)</a> - versions max et min</li>
<li><code>B</code> <a href="src/data-structures/priority-queue">File de Priorité</a></li>
<li><code>A</code> <a href="src/data-structures/trie">Trie</a></li>
<li><code>A</code> <a href="src/data-structures/tree">Arbre (Tree)</a>
<ul>
<li><code>A</code> <a href="src/data-structures/tree/binary-search-tree">Arbre Binaire de Recherche</a></li>
<li><code>A</code> <a href="src/data-structures/tree/avl-tree">Arbre AVL</a></li>
<li><code>A</code> <a href="src/data-structures/tree/red-black-tree">Arbre Rouge-Noir</a></li>
<li><code>A</code> <a href="src/data-structures/tree/segment-tree">Arbre de Segments</a> - avec exemples de requêtes min/max/somme sur des intervalles</li>
<li><code>A</code> <a href="src/data-structures/tree/fenwick-tree">Arbre de Fenwick</a> (Arbre binaire indexé)</li>
</ul>
</li>
<li><code>A</code> <a href="src/data-structures/graph">Graphe</a> (orienté et non orienté)</li>
<li><code>A</code> <a href="src/data-structures/disjoint-set">Ensemble Disjoint</a> - structure union-find</li>
<li><code>A</code> <a href="src/data-structures/bloom-filter">Filtre de Bloom</a></li>
<li><code>A</code> <a href="src/data-structures/lru-cache/">Cache LRU</a> - cache Least Recently Used (LRU)</li>
</ul>
<h2>Algorithmes</h2>
<p>Un algorithme est une spécification non ambiguë de la façon de résoudre une classe de problèmes. C’est
un ensemble de règles qui définit précisément une séquence d’opérations.</p>
<p><code>B</code> - Débutant, <code>A</code> - Avancé</p>
<h3>Algorithmes par Thème</h3>
<ul>
<li><strong>Mathématiques</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/math/bits">Manipulation de Bits</a> - définir/obtenir/modifier/effacer des bits, multiplication/division par deux, rendre négatif, etc.</li>
<li><code>B</code> <a href="src/algorithms/math/binary-floating-point">Nombre Flottant Binaire</a> - représentation binaire des nombres flottants.</li>
<li><code>B</code> <a href="src/algorithms/math/factorial">Factorielle</a></li>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">Nombre de Fibonacci</a> - versions classique et forme fermée</li>
<li><code>B</code> <a href="src/algorithms/math/prime-factors">Facteurs Premiers</a> - recherche des facteurs premiers et leur comptage via le théorème de Hardy-Ramanujan</li>
<li><code>B</code> <a href="src/algorithms/math/primality-test">Test de Primalité</a> (méthode de division d’essai)</li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">Algorithme d’Euclide</a> - calcul du Plus Grand Commun Diviseur (PGCD)</li>
<li><code>B</code> <a href="src/algorithms/math/least-common-multiple">Plus Petit Commun Multiple</a> (PPCM)</li>
<li><code>B</code> <a href="src/algorithms/math/sieve-of-eratosthenes">Crible d’Ératosthène</a> - trouver tous les nombres premiers jusqu’à une limite donnée</li>
<li><code>B</code> <a href="src/algorithms/math/is-power-of-two">Puissance de Deux</a> - vérifier si un nombre est une puissance de deux (algorithmes naïf et bit à bit)</li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">Triangle de Pascal</a></li>
<li><code>B</code> <a href="src/algorithms/math/complex-number">Nombre Complexe</a> - nombres complexes et opérations de base</li>
<li><code>B</code> <a href="src/algorithms/math/radian">Radian &amp; Degré</a> - conversion radian/degré et inversement</li>
<li><code>B</code> <a href="src/algorithms/math/fast-powering">Puissance Rapide</a></li>
<li><code>B</code> <a href="src/algorithms/math/horner-method">Méthode de Horner</a> - évaluation de polynômes</li>
<li><code>B</code> <a href="src/algorithms/math/matrix">Matrices</a> - matrices et opérations basiques (multiplication, transposition, etc.)</li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-distance">Distance Euclidienne</a> - distance entre deux points/vecteurs/matrices</li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Partition d’Entier</a></li>
<li><code>A</code> <a href="src/algorithms/math/square-root">Racine Carrée</a> - méthode de Newton</li>
<li><code>A</code> <a href="src/algorithms/math/liu-hui">Algorithme de Liu Hui pour π</a> - approximation de π basée sur des polygones réguliers</li>
<li><code>A</code> <a href="src/algorithms/math/fourier-transform">Transformation de Fourier Discrète</a> - décomposition d’un signal dans ses fréquences</li>
</ul>
</li>
<li><strong>Ensembles</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sets/cartesian-product">Produit Cartésien</a> - produit de plusieurs ensembles</li>
<li><code>B</code> <a href="src/algorithms/sets/fisher-yates">Mélange de Fisher-Yates</a> - permutation aléatoire d’une séquence finie</li>
<li><code>A</code> <a href="src/algorithms/sets/power-set">Ensemble des Parties</a> - tous les sous-ensembles d’un ensemble (solutions bit à bit, backtracking et en cascade)</li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutations</a> (avec et sans répétitions)</li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Combinaisons</a> (avec et sans répétitions)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Plus Longue Sous-séquence Commune</a> (LCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Plus Longue Sous-séquence Croissante</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Plus Courte Super-séquence Commune</a> (SCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Problème du Sac à Dos</a> - versions &quot;0/1&quot; et &quot;non bornée&quot;</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Sous-tableau de Somme Maximale</a> - versions &quot;force brute&quot; et &quot;programmation dynamique&quot; (Kadane)</li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Somme de Combinaisons</a> - trouver toutes les combinaisons qui forment une somme donnée</li>
</ul>
</li>
<li><strong>Chaînes</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/string/hamming-distance">Distance de Hamming</a> - nombre de positions différentes entre deux chaînes</li>
<li><code>B</code> <a href="src/algorithms/string/palindrome">Palindrome</a> - vérifier si la chaîne est la même à l’envers</li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Distance de Levenshtein</a> - distance minimale d’édition entre deux séquences</li>
<li><code>A</code> <a href="src/algorithms/string/knuth-morris-pratt">Algorithme de Knuth-Morris-Pratt</a> (KMP) - recherche de sous-chaîne (reconnaissance de motif)</li>
<li><code>A</code> <a href="src/algorithms/string/z-algorithm">Algorithme Z</a> - recherche de sous-chaîne (reconnaissance de motif)</li>
<li><code>A</code> <a href="src/algorithms/string/rabin-karp">Algorithme de Rabin Karp</a> - recherche de sous-chaîne</li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Plus Longue Sous-chaîne Commune</a></li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Appariement d’Expressions Régulières</a></li>
</ul>
</li>
<li><strong>Recherches</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Recherche Linéaire</a></li>
<li><code>B</code> <a href="src/algorithms/search/jump-search">Recherche par Sauts</a> (ou recherche par blocs) - recherche dans un tableau trié</li>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Recherche Binaire</a> - recherche dans un tableau trié</li>
<li><code>B</code> <a href="src/algorithms/search/interpolation-search">Recherche par Interpolation</a> - recherche dans un tableau trié uniformément distribué</li>
</ul>
</li>
<li><strong>Tri</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sorting/bubble-sort">Tri à Bulles</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/selection-sort">Tri par Sélection</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/insertion-sort">Tri par Insertion</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/heap-sort">Tri par Tas</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Tri Fusion</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Tri Rapide (Quicksort)</a> - implémentations en place et non en place</li>
<li><code>B</code> <a href="src/algorithms/sorting/shell-sort">Tri de Shell</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/counting-sort">Tri par Comptage</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/radix-sort">Tri Radix</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/bucket-sort">Tri par Seaux (Bucket Sort)</a></li>
</ul>
</li>
<li><strong>Listes Chaînées</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/linked-list/traversal">Parcours Simple</a></li>
<li><code>B</code> <a href="src/algorithms/linked-list/reverse-traversal">Parcours Inversé</a></li>
</ul>
</li>
<li><strong>Arbres</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">Parcours en Profondeur</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/tree/breadth-first-search">Parcours en Largeur</a> (BFS)</li>
</ul>
</li>
<li><strong>Graphes</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">Parcours en Profondeur</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/breadth-first-search">Parcours en Largeur</a> (BFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/kruskal">Algorithme de Kruskal</a> - recherche de l’Arbre de Couverture Minimum (MST) pour un graphe non orienté pondéré</li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">Algorithme de Dijkstra</a> - recherche des plus courts chemins depuis un sommet</li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">Algorithme de Bellman-Ford</a> - recherche des plus courts chemins depuis un sommet</li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">Algorithme de Floyd-Warshall</a> - recherche des plus courts chemins entre toutes les paires de sommets</li>
<li><code>A</code> <a href="src/algorithms/graph/detect-cycle">Détection de Cycle</a> - pour graphes orientés et non orientés (versions DFS et Ensemble Disjoint)</li>
<li><code>A</code> <a href="src/algorithms/graph/prim">Algorithme de Prim</a> - recherche de l’Arbre de Couverture Minimum (MST)</li>
<li><code>A</code> <a href="src/algorithms/graph/topological-sorting">Tri Topologique</a> - méthode DFS</li>
<li><code>A</code> <a href="src/algorithms/graph/articulation-points">Points d’Articulation</a> - algorithme de Tarjan (basé sur DFS)</li>
<li><code>A</code> <a href="src/algorithms/graph/bridges">Ponts</a> - algorithme basé sur DFS</li>
<li><code>A</code> <a href="src/algorithms/graph/eulerian-path">Chemin et Circuit Eulérien</a> - algorithme de Fleury - visiter chaque arête une fois</li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Cycle Hamiltonien</a> - visiter chaque sommet une fois</li>
<li><code>A</code> <a href="src/algorithms/graph/strongly-connected-components">Composantes Fortement Connexes</a> - algorithme de Kosaraju</li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Problème du Voyageur de Commerce</a> - plus court chemin visitant chaque ville et revenant à l’origine</li>
</ul>
</li>
<li><strong>Cryptographie</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/cryptography/polynomial-hash">Hachage Polynomial</a> - fonction de hachage glissant basée sur un polynôme</li>
<li><code>B</code> <a href="src/algorithms/cryptography/rail-fence-cipher">Chiffre Rail Fence</a> - algorithme de chiffrement par transposition</li>
<li><code>B</code> <a href="src/algorithms/cryptography/caesar-cipher">Chiffre de César</a> - chiffrement par substitution simple</li>
<li><code>B</code> <a href="src/algorithms/cryptography/hill-cipher">Chiffre de Hill</a> - chiffrement basé sur l’algèbre linéaire</li>
</ul>
</li>
<li><strong>Apprentissage Automatique</strong>
<ul>
<li><code>B</code> <a href="https://github.com/trekhleb/nano-neuron">NanoNeuron</a> - 7 fonctions JS simples illustrant l’apprentissage machine (propagation avant/arrière)</li>
<li><code>B</code> <a href="src/algorithms/ml/knn">k-NN</a> - algorithme de classification des k plus proches voisins</li>
<li><code>B</code> <a href="src/algorithms/ml/k-means">k-Means</a> - algorithme de clustering k-Means</li>
</ul>
</li>
<li><strong>Traitement d’Images</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/image-processing/seam-carving">Seam Carving</a> - redimensionnement d’image intelligent</li>
</ul>
</li>
<li><strong>Statistiques</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/statistics/weighted-random">Aléatoire Pondéré</a> - sélectionner un élément au hasard en fonction de son poids</li>
</ul>
</li>
<li><strong>Algorithmes Évolutionnaires</strong>
<ul>
<li><code>A</code> <a href="https://github.com/trekhleb/self-parking-car-evolution">Algorithme Génétique</a> - exemple d’utilisation pour l’apprentissage de voitures autonomes</li>
</ul>
</li>
<li><strong>Non Classés</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">Tours de Hanoï</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/square-matrix-rotation">Rotation de Matrice Carrée</a> - algorithme en place</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jeu de Sauts (Jump Game)</a> - backtracking, programmation dynamique (top-down + bottom-up) et exemples gloutons</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Chemins Uniques</a> - backtracking, programmation dynamique et triangle de Pascal</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Terrasses de Pluie</a> - problème de piégeage d’eau (programmation dynamique et force brute)</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/recursive-staircase">Escalier Récursif</a> - compter le nombre de façons d’atteindre le sommet (4 solutions)</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/best-time-to-buy-sell-stocks">Meilleur Moment pour Acheter/Vendre des Actions</a> - exemples diviser pour régner et en un passage</li>
<li><code>B</code> <a href="src/algorithms/stack/valid-parentheses">Parenthèses Valides</a> - vérifier la validité d’une chaîne de parenthèses (pile)</li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">Problème des N-Reines</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Tour du Cavalier</a></li>
</ul>
</li>
</ul>
<h3>Algorithmes par Paradigme</h3>
<p>Un paradigme algorithmique est une méthode ou approche générique qui sous-tend la conception d’une classe
d’algorithmes. Il s’agit d’une abstraction supérieure à la notion d’algorithme, tout comme un algorithme est une abstraction supérieure à un programme informatique.</p>
<ul>
<li><strong>Force Brute</strong> – examine toutes les possibilités et sélectionne la meilleure solution
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Recherche Linéaire</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Terrasses de Pluie</a> - problème de piégeage d’eau</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/recursive-staircase">Escalier Récursif</a> - compter le nombre de façons d’atteindre le sommet</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Sous-tableau de Somme Maximale</a></li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Problème du Voyageur de Commerce</a></li>
<li><code>A</code> <a href="src/algorithms/math/fourier-transform">Transformation de Fourier Discrète</a></li>
</ul>
</li>
<li><strong>Glouton</strong> – choisit la meilleure option à l’instant présent, sans considération pour l’avenir
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jeu de Sauts (Jump Game)</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Problème du Sac à Dos non borné</a></li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">Algorithme de Dijkstra</a></li>
<li><code>A</code> <a href="src/algorithms/graph/prim">Algorithme de Prim</a></li>
<li><code>A</code> <a href="src/algorithms/graph/kruskal">Algorithme de Kruskal</a></li>
</ul>
</li>
<li><strong>Diviser pour Régner</strong> – divise le problème en sous-problèmes et résout ceux-ci
<ul>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Recherche Binaire</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">Tours de Hanoï</a></li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">Triangle de Pascal</a></li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">Algorithme d’Euclide</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Tri Fusion</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Tri Rapide</a></li>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">Parcours en Profondeur d’Arbre</a></li>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">Parcours en Profondeur de Graphe</a></li>
<li><code>B</code> <a href="src/algorithms/math/matrix">Matrices</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jeu de Sauts (Jump Game)</a></li>
<li><code>B</code> <a href="src/algorithms/math/fast-powering">Puissance Rapide</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/best-time-to-buy-sell-stocks">Meilleur Moment pour Acheter/Vendre des Actions</a></li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutations</a></li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Combinaisons</a></li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Sous-tableau de Somme Maximale</a></li>
</ul>
</li>
<li><strong>Programmation Dynamique</strong> – construit une solution à partir de sous-solutions déjà trouvées
<ul>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">Nombre de Fibonacci</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jeu de Sauts (Jump Game)</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Chemins Uniques</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Terrasses de Pluie</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/recursive-staircase">Escalier Récursif</a></li>
<li><code>B</code> <a href="src/algorithms/image-processing/seam-carving">Seam Carving</a></li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Distance de Levenshtein</a></li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Plus Longue Sous-séquence Commune</a></li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Plus Longue Sous-chaîne Commune</a></li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Plus Longue Sous-séquence Croissante</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Plus Courte Super-séquence Commune</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Problème du Sac à Dos 0/1</a></li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Partition d’Entier</a></li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Sous-tableau de Somme Maximale</a></li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">Algorithme de Bellman-Ford</a></li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">Algorithme de Floyd-Warshall</a></li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Appariement d’Expressions Régulières</a></li>
</ul>
</li>
<li><strong>Backtracking</strong> – de manière similaire à la force brute, essaie de générer toutes les solutions possibles, mais à chaque génération d’une nouvelle solution, teste
si elle satisfait toutes les conditions, puis continue ou revient en arrière pour explorer un autre chemin. En général, un parcours DFS de l’espace d’états est utilisé.
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jeu de Sauts (Jump Game)</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Chemins Uniques</a></li>
<li><code>B</code> <a href="src/algorithms/sets/power-set">Ensemble des Parties</a></li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Cycle Hamiltonien</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">Problème des N-Reines</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Tour du Cavalier</a></li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Somme de Combinaisons</a></li>
</ul>
</li>
<li><strong>Branch &amp; Bound</strong> – mémorise la solution de coût minimal trouvée à chaque étape du backtracking,
et utilise ce coût comme borne inférieure pour éliminer les solutions partielles ayant un coût supérieur. En général, un parcours BFS combiné à DFS sur l’arbre d’états est utilisé.</li>
</ul>
<h2>Comment utiliser ce dépôt</h2>
<p><strong>Installer toutes les dépendances</strong></p>
<pre><code>npm install
</code></pre>
<p><strong>Lancer ESLint</strong></p>
<p>Vous pouvez le lancer pour vérifier la qualité du code.</p>
<pre><code>npm run lint
</code></pre>
<p><strong>Lancer tous les tests</strong></p>
<pre><code>npm test
</code></pre>
<p><strong>Lancer les tests par nom</strong></p>
<pre><code>npm test -- 'LinkedList'
</code></pre>
<p><strong>Dépannage</strong></p>
<p>Si le linting ou les tests échouent, essayez de supprimer le dossier <code>node_modules</code> et de réinstaller les paquets npm :</p>
<pre><code>rm -rf ./node_modules
npm i
</code></pre>
<p>Vérifiez aussi que vous utilisez la bonne version de Node (<code>&gt;=16</code>). Si vous utilisez <a href="https://github.com/nvm-sh/nvm">nvm</a> pour la gestion de version Node, vous pouvez lancer <code>nvm use</code> depuis le dossier racine du projet et la bonne version sera sélectionnée.</p>
<p><strong>Aire de jeu (Playground)</strong></p>
<p>Vous pouvez expérimenter avec les structures de données et algorithmes dans le fichier <code>./src/playground/playground.js</code> et écrire
des tests dans <code>./src/playground/__test__/playground.test.js</code>.</p>
<p>Ensuite, lancez simplement la commande suivante pour tester votre code playground :</p>
<pre><code>npm test -- 'playground'
</code></pre>
<h2>Informations Utiles</h2>
<h3>Références</h3>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">▶ Structures de Données et Algorithmes sur YouTube</a></li>
<li><a href="https://okso.app/showcase/data-structures">✍🏻 Croquis de Structures de Données</a></li>
</ul>
<h3>Notation Big O</h3>
<p><em>La notation Big O</em> est utilisée pour classer les algorithmes selon la croissance de leur temps d’exécution ou de leur espace mémoire en fonction de la taille de l’entrée.
Sur le graphique ci-dessous, vous trouverez les ordres de croissance les plus courants d’algorithmes spécifiés en notation Big O.</p>
<p><img src="./assets/big-o-graph.png" alt="Graphiques Big O" /></p>
<p>Source : <a href="http://bigocheatsheet.com/">Big O Cheat Sheet</a>.</p>
<p>Voici la liste de quelques notations Big O les plus utilisées et leur comparaison de performance sur différentes tailles d’entrée.</p>
<p>| Notation Big O | Type        | Calculs pour 10 éléments | Calculs pour 100 éléments | Calculs pour 1000 éléments  |
| -------------- | ----------- | ------------------------ | ------------------------- | --------------------------- |
| <strong>O(1)</strong>       | Constant    | 1                        | 1                         | 1                           |
| <strong>O(log N)</strong>   | Logarithmique | 3                      | 6                         | 9                           |
| <strong>O(N)</strong>       | Linéaire    | 10                       | 100                       | 1000                        |
| <strong>O(N log N)</strong> | n log(n)    | 30                       | 600                       | 9000                        |
| <strong>O(N^2)</strong>     | Quadratique | 100                      | 10000                     | 1000000                     |
| <strong>O(2^N)</strong>     | Exponentielle | 1024                   | 1.26e+29                  | 1.07e+301                   |
| <strong>O(N!)</strong>      | Factorielle | 3628800                  | 9.3e+157                  | 4.02e+2567                  |</p>
<h3>Complexité des Opérations sur les Structures de Données</h3>
<p>| Structure de Données      | Accès   | Recherche | Insertion | Suppression | Commentaires |
| ------------------------- | :-----: | :-------: | :-------: | :---------: | :----------- |
| <strong>Tableau</strong>               | 1       | n         | n         | n           |              |
| <strong>Pile</strong>                  | n       | n         | 1         | 1           |              |
| <strong>File</strong>                  | n       | n         | 1         | 1           |              |
| <strong>Liste Chaînée</strong>         | n       | n         | 1         | n           |              |
| <strong>Table de Hachage</strong>      | -       | n         | n         | n           | En cas de fonction de hachage parfaite, le coût serait O(1) |
| <strong>Arbre Binaire de Recherche</strong> | n   | n         | n         | n           | En cas d’arbre équilibré, le coût est O(log(n)) |
| <strong>B-Tree</strong>                | log(n)  | log(n)    | log(n)    | log(n)      |              |
| <strong>Arbre Rouge-Noir</strong>      | log(n)  | log(n)    | log(n)    | log(n)      |              |
| <strong>Arbre AVL</strong>             | log(n)  | log(n)    | log(n)    | log(n)      |              |
| <strong>Filtre de Bloom</strong>       | -       | 1         | 1         | -           | Faux positifs possibles en recherche |</p>
<h3>Complexité des Algorithmes de Tri de Tableau</h3>
<p>| Nom                   | Meilleur        | Moyen               | Pire                | Mémoire    | Stable    | Commentaires |
| --------------------- | :-------------: | :-----------------: | :-----------------: | :--------: | :-------: | :----------- |
| <strong>Tri à Bulles</strong>      | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1          | Oui       |              |
| <strong>Tri par Insertion</strong> | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1          | Oui       |              |
| <strong>Tri par Sélection</strong> | n<sup>2</sup>   | n<sup>2</sup>       | n<sup>2</sup>       | 1          | Non       |              |
| <strong>Tri par Tas</strong>       | n log(n)   | n log(n)       | n log(n)       | 1          | Non       |              |
| <strong>Tri Fusion</strong>        | n log(n)   | n log(n)       | n log(n)       | n          | Oui       |              |
| <strong>Tri Rapide</strong>        | n log(n)   | n log(n)       | n<sup>2</sup>       | log(n)     | Non       | Habituellement en place avec O(log(n)) d’espace pile |
| <strong>Tri de Shell</strong>      | n log(n)   | dépend de la séquence de gaps | n (log(n))<sup>2</sup>  | 1          | Non        |              |
| <strong>Tri par Comptage</strong>  | n + r           | n + r               | n + r               | n + r      | Oui       | r – plus grand nombre du tableau |
| <strong>Tri Radix</strong>         | n * k           | n * k               | n * k               | n + k      | Oui       | k – longueur de la plus longue clé |</p>
<h2>Soutiens du Projet</h2>
<blockquote>
<p>Vous pouvez soutenir ce projet via ❤️️ <a href="https://github.com/sponsors/trekhleb">GitHub</a> ou ❤️️ <a href="https://www.patreon.com/trekhleb">Patreon</a>.</p>
</blockquote>
<p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/BACKERS.md">Les soutiens de ce projet</a> <code>∑ = 1</code></p>
<h2>Auteur</h2>
<p><a href="https://trekhleb.dev">@trekhleb</a></p>
<p>Encore plus de <a href="https://trekhleb.dev/projects/">projets</a> et <a href="https://trekhleb.dev/blog/">articles</a> sur JavaScript et les algorithmes sur <a href="https://trekhleb.dev">trekhleb.dev</a></p>
<hr />
<p><a href="https://github.com/OpenAiTx/OpenAiTx">Powered By OpenAiTx</a></p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>