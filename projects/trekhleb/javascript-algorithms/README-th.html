<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>javascript-algorithms - trekhleb/javascript-algorithms</title>
    <meta name="title" content="javascript-algorithms - trekhleb/javascript-algorithms">
    <meta name="description" content="trekhleb/javascript-algorithms - GitHub repository th documentation and informationอัลกอริทึมและโครงสร้างข้อมูลใน JavaScript 🇺🇦 ยูเครน กำลังถูกโจมตี โดยกองทัพรัสเซีย พลเรือนกำลังถูกสังหาร พื้นที่ที่อยู่อาศัยกำลังถูกทิ้งระเบิด ช่วยเหลือยูเครน...">
    <meta name="keywords" content="trekhleb, javascript-algorithms, GitHub, repository, th documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/trekhleb/javascript-algorithms/README-th.html">
    <meta property="og:title" content="javascript-algorithms - trekhleb/javascript-algorithms">
    <meta property="og:description" content="trekhleb/javascript-algorithms - GitHub repository th documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/trekhleb/javascript-algorithms" id="githubRepoLink" target="_blank">trekhleb/javascript-algorithms</a>
<h1 style="display: none;">อัลกอริทึมและโครงสร้างข้อมูลใน JavaScript 🇺🇦 ยูเครน กำลังถูกโจมตี โดยกองทัพรัสเซีย พลเรือนกำลังถูกสังหาร พื้นที่ที่อยู่อาศัยกำลังถูกทิ้งระเบิด ช่วยเหลือยูเครน...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>อัลกอริทึมและโครงสร้างข้อมูลใน JavaScript</h1>
<blockquote>
<p>🇺🇦 ยูเครน <a href="https://war.ukraine.ua/">กำลังถูกโจมตี</a> โดยกองทัพรัสเซีย พลเรือนกำลังถูกสังหาร พื้นที่ที่อยู่อาศัยกำลังถูกทิ้งระเบิด</p>
<ul>
<li>ช่วยเหลือยูเครนผ่าน:
<ul>
<li><a href="https://prytulafoundation.org/en/">มูลนิธิการกุศล Serhiy Prytula</a></li>
<li><a href="https://savelife.in.ua/en/donate-en/">มูลนิธิการกุศล Come Back Alive</a></li>
<li><a href="https://bank.gov.ua/en/news/all/natsionalniy-bank-vidkriv-spetsrahunok-dlya-zboru-koshtiv-na-potrebi-armiyi">ธนาคารแห่งชาติยูเครน</a></li>
</ul>
</li>
<li>ข้อมูลเพิ่มเติมที่ <a href="https://war.ukraine.ua/">war.ukraine.ua</a> และ <a href="https://twitter.com/MFA_Ukraine">MFA ของยูเครน</a></li>
</ul>
</blockquote>
<hr/>
<p><a href="https://github.com/trekhleb/javascript-algorithms/actions?query=workflow%3ACI+branch%3Amaster"><img src="https://github.com/trekhleb/javascript-algorithms/workflows/CI/badge.svg" alt="CI" /></a>
<a href="https://codecov.io/gh/trekhleb/javascript-algorithms"><img src="https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg" alt="codecov" /></a>
<img src="https://img.shields.io/github/repo-size/trekhleb/javascript-algorithms.svg" alt="repo size" /></p>
<p>คลังนี้ประกอบด้วยตัวอย่างอัลกอริทึมและโครงสร้างข้อมูลยอดนิยมมากมายที่ใช้ JavaScript</p>
<p>แต่ละอัลกอริทึมและโครงสร้างข้อมูลจะมี README แยกของตนเอง พร้อมคำอธิบายและลิงก์สำหรับอ่านเพิ่มเติม (รวมถึงลิงก์วิดีโอ YouTube)</p>
<p><em>อ่านหน้านี้ในภาษาอื่นๆ:</em>
<a href="README.zh-CN.md"><em>简体中文</em></a>,
<a href="README.zh-TW.md"><em>繁體中文</em></a>,
<a href="README.ko-KR.md"><em>한국어</em></a>,
<a href="README.ja-JP.md"><em>日本語</em></a>,
<a href="README.pl-PL.md"><em>Polski</em></a>,
<a href="README.fr-FR.md"><em>Français</em></a>,
<a href="README.es-ES.md"><em>Español</em></a>,
<a href="README.pt-BR.md"><em>Português</em></a>,
<a href="README.ru-RU.md"><em>Русский</em></a>,
<a href="README.tr-TR.md"><em>Türkçe</em></a>,
<a href="README.it-IT.md"><em>Italiano</em></a>,
<a href="README.id-ID.md"><em>Bahasa Indonesia</em></a>,
<a href="README.uk-UA.md"><em>Українська</em></a>,
<a href="README.ar-AR.md"><em>Arabic</em></a>,
<a href="README.vi-VN.md"><em>Tiếng Việt</em></a>,
<a href="README.de-DE.md"><em>Deutsch</em></a>,
<a href="README.uz-UZ.md"><em>Uzbek</em></a>,
<a href="README.he-IL.md"><em>עברית</em></a></p>
<p><em>☝ โปรดทราบว่าโปรเจกต์นี้มีไว้เพื่อการเรียนรู้และการวิจัยเท่านั้น และ <strong>ไม่</strong> เหมาะสำหรับใช้งานในระบบ production</em></p>
<h2>โครงสร้างข้อมูล (Data Structures)</h2>
<p>โครงสร้างข้อมูลคือวิธีการจัดระเบียบและจัดเก็บข้อมูลในคอมพิวเตอร์เพื่อให้สามารถเข้าถึงและแก้ไขได้อย่างมีประสิทธิภาพ โดยเฉพาะอย่างยิ่ง โครงสร้างข้อมูลคือกลุ่มของค่าข้อมูล ความสัมพันธ์ระหว่างข้อมูลเหล่านั้น และฟังก์ชันหรือการดำเนินการที่สามารถใช้กับข้อมูลได้</p>
<p>โปรดจำไว้ว่าทุกโครงสร้างข้อมูลต่างก็มีข้อดีข้อเสียของตนเอง และคุณควรให้ความสำคัญกับเหตุผลที่เลือกใช้โครงสร้างข้อมูลหนึ่งมากกว่าวิธีการนำไปใช้จริง</p>
<p><code>B</code> - เบื้องต้น, <code>A</code> - ขั้นสูง</p>
<ul>
<li><code>B</code> <a href="src/data-structures/linked-list">ลิงค์ลิสต์ (Linked List)</a></li>
<li><code>B</code> <a href="src/data-structures/doubly-linked-list">ดับเบิลลิงค์ลิสต์ (Doubly Linked List)</a></li>
<li><code>B</code> <a href="src/data-structures/queue">คิว (Queue)</a></li>
<li><code>B</code> <a href="src/data-structures/stack">สแตก (Stack)</a></li>
<li><code>B</code> <a href="src/data-structures/hash-table">ตารางแฮช (Hash Table)</a></li>
<li><code>B</code> <a href="src/data-structures/heap">ฮีป (Heap)</a> - มีทั้งแบบ max และ min heap</li>
<li><code>B</code> <a href="src/data-structures/priority-queue">Priority Queue</a></li>
<li><code>A</code> <a href="src/data-structures/trie">Trie</a></li>
<li><code>A</code> <a href="src/data-structures/tree">ต้นไม้ (Tree)</a>
<ul>
<li><code>A</code> <a href="src/data-structures/tree/binary-search-tree">ต้นไม้ค้นหาแบบทวิภาค (Binary Search Tree)</a></li>
<li><code>A</code> <a href="src/data-structures/tree/avl-tree">AVL Tree</a></li>
<li><code>A</code> <a href="src/data-structures/tree/red-black-tree">Red-Black Tree</a></li>
<li><code>A</code> <a href="src/data-structures/tree/segment-tree">Segment Tree</a> - ตัวอย่างการค้นหา min/max/sum ในช่วง</li>
<li><code>A</code> <a href="src/data-structures/tree/fenwick-tree">Fenwick Tree</a> (Binary Indexed Tree)</li>
</ul>
</li>
<li><code>A</code> <a href="src/data-structures/graph">กราฟ (Graph)</a> (ทั้งแบบมีทิศทางและไม่มีทิศทาง)</li>
<li><code>A</code> <a href="src/data-structures/disjoint-set">Disjoint Set</a> - โครงสร้างข้อมูล union–find หรือ merge–find set</li>
<li><code>A</code> <a href="src/data-structures/bloom-filter">Bloom Filter</a></li>
<li><code>A</code> <a href="src/data-structures/lru-cache/">LRU Cache</a> - แคชแบบ Least Recently Used (LRU)</li>
</ul>
<h2>อัลกอริทึม (Algorithms)</h2>
<p>อัลกอริทึมคือข้อกำหนดที่ชัดเจนในการแก้ปัญหาในกลุ่มหนึ่ง เป็นชุดของกฎที่กำหนดลำดับของการดำเนินการอย่างแม่นยำ</p>
<p><code>B</code> - เบื้องต้น, <code>A</code> - ขั้นสูง</p>
<h3>อัลกอริทึมตามหัวข้อ</h3>
<ul>
<li><strong>คณิตศาสตร์</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/math/bits">Bit Manipulation</a> - การตั้ง/อ่าน/อัปเดต/ลบ bit, คูณ/หารด้วยสอง, การแปลงค่าติดลบ ฯลฯ</li>
<li><code>B</code> <a href="src/algorithms/math/binary-floating-point">Binary Floating Point</a> - การแทนค่าเลขทศนิยมแบบฐานสอง</li>
<li><code>B</code> <a href="src/algorithms/math/factorial">แฟกทอเรียล (Factorial)</a></li>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">เลขฟีโบนักชี (Fibonacci Number)</a> - แบบคลาสสิกและแบบสูตรปิด</li>
<li><code>B</code> <a href="src/algorithms/math/prime-factors">ตัวประกอบเฉพาะ (Prime Factors)</a> - หาตัวประกอบเฉพาะและนับจำนวนโดยใช้ทฤษฎี Hardy-Ramanujan</li>
<li><code>B</code> <a href="src/algorithms/math/primality-test">การทดสอบจำนวนเฉพาะ (Primality Test)</a> (วิธี division)</li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">อัลกอริทึมยุคลิด (Euclidean Algorithm)</a> - คำนวณหาตัวหารร่วมมาก (GCD)</li>
<li><code>B</code> <a href="src/algorithms/math/least-common-multiple">ห.ร.ม. (Least Common Multiple)</a> (LCM)</li>
<li><code>B</code> <a href="src/algorithms/math/sieve-of-eratosthenes">Sieve of Eratosthenes</a> - หาจำนวนเฉพาะทั้งหมดจนถึงขีดจำกัดที่กำหนด</li>
<li><code>B</code> <a href="src/algorithms/math/is-power-of-two">Is Power of Two</a> - ตรวจสอบว่าค่าเป็นกำลังสองหรือไม่ (วิธี naive และ bitwise)</li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">สามเหลี่ยมปาสกาล (Pascal's Triangle)</a></li>
<li><code>B</code> <a href="src/algorithms/math/complex-number">จำนวนเชิงซ้อน (Complex Number)</a> - จำนวนเชิงซ้อนและการดำเนินการพื้นฐาน</li>
<li><code>B</code> <a href="src/algorithms/math/radian">Radian &amp; Degree</a> - แปลงระหว่างเรเดียนและองศา</li>
<li><code>B</code> <a href="src/algorithms/math/fast-powering">Fast Powering</a></li>
<li><code>B</code> <a href="src/algorithms/math/horner-method">Horner's method</a> - การคำนวณพหุนาม</li>
<li><code>B</code> <a href="src/algorithms/math/matrix">เมทริกซ์ (Matrices)</a> - เมทริกซ์และการดำเนินการพื้นฐาน (คูณ, ทรานสโพส ฯลฯ)</li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-distance">Euclidean Distance</a> - ระยะห่างระหว่างจุด/เวกเตอร์/เมทริกซ์</li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Integer Partition</a></li>
<li><code>A</code> <a href="src/algorithms/math/square-root">Square Root</a> - วิธีของนิวตัน</li>
<li><code>A</code> <a href="src/algorithms/math/liu-hui">Liu Hui π Algorithm</a> - ประมาณค่า π โดยใช้ N-gons</li>
<li><code>A</code> <a href="src/algorithms/math/fourier-transform">Discrete Fourier Transform</a> - แยกฟังก์ชันของเวลา (สัญญาณ) ออกเป็นความถี่ต่างๆ</li>
</ul>
</li>
<li><strong>เซต</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sets/cartesian-product">คาร์ทีเซียนโปรดักต์ (Cartesian Product)</a> - ผลคูณของเซตหลายชุด</li>
<li><code>B</code> <a href="src/algorithms/sets/fisher-yates">Fisher–Yates Shuffle</a> - การสุ่มลำดับของลำดับจำกัด</li>
<li><code>A</code> <a href="src/algorithms/sets/power-set">Power Set</a> - เซตย่อยทั้งหมดของเซตหนึ่ง (แบบ bitwise, backtracking, cascading)</li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutations</a> (แบบมีและไม่มีการทำซ้ำ)</li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Combinations</a> (แบบมีและไม่มีการทำซ้ำ)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Longest Common Subsequence</a> (LCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Longest Increasing Subsequence</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Shortest Common Supersequence</a> (SCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Knapsack Problem</a> - แบบ &quot;0/1&quot; และ &quot;Unbound&quot;</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximum Subarray</a> - แบบ &quot;Brute Force&quot; และ &quot;Dynamic Programming&quot; (Kadane's)</li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Combination Sum</a> - หาทุกชุดที่รวมกันได้ผลรวมที่กำหนด</li>
</ul>
</li>
<li><strong>สตริง</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/string/hamming-distance">Hamming Distance</a> - จำนวนตำแหน่งที่สัญลักษณ์ต่างกัน</li>
<li><code>B</code> <a href="src/algorithms/string/palindrome">Palindrome</a> - ตรวจสอบว่าสตริงเหมือนเดิมเมื่อกลับด้านหรือไม่</li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Levenshtein Distance</a> - ระยะทางแก้ไขน้อยสุดระหว่างสองลำดับ</li>
<li><code>A</code> <a href="src/algorithms/string/knuth-morris-pratt">Knuth–Morris–Pratt Algorithm</a> (KMP) - ค้นหาซับสตริง (Pattern Matching)</li>
<li><code>A</code> <a href="src/algorithms/string/z-algorithm">Z Algorithm</a> - ค้นหาซับสตริง (Pattern Matching)</li>
<li><code>A</code> <a href="src/algorithms/string/rabin-karp">Rabin Karp Algorithm</a> - ค้นหาซับสตริง</li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Longest Common Substring</a></li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Regular Expression Matching</a></li>
</ul>
</li>
<li><strong>ค้นหา</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Linear Search</a></li>
<li><code>B</code> <a href="src/algorithms/search/jump-search">Jump Search</a> (หรือ Block Search) - ค้นหาในอาร์เรย์เรียงลำดับ</li>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Binary Search</a> - ค้นหาในอาร์เรย์เรียงลำดับ</li>
<li><code>B</code> <a href="src/algorithms/search/interpolation-search">Interpolation Search</a> - ค้นหาในอาร์เรย์เรียงลำดับที่กระจายอย่างสม่ำเสมอ</li>
</ul>
</li>
<li><strong>เรียงลำดับ</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sorting/bubble-sort">Bubble Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/selection-sort">Selection Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/insertion-sort">Insertion Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/heap-sort">Heap Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Merge Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Quicksort</a> - แบบ in-place และ non-in-place</li>
<li><code>B</code> <a href="src/algorithms/sorting/shell-sort">Shellsort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/counting-sort">Counting Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/radix-sort">Radix Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/bucket-sort">Bucket Sort</a></li>
</ul>
</li>
<li><strong>ลิงค์ลิสต์</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/linked-list/traversal">Straight Traversal</a></li>
<li><code>B</code> <a href="src/algorithms/linked-list/reverse-traversal">Reverse Traversal</a></li>
</ul>
</li>
<li><strong>ต้นไม้</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">ค้นหาเชิงลึก (Depth-First Search)</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/tree/breadth-first-search">ค้นหาแบบกว้าง (Breadth-First Search)</a> (BFS)</li>
</ul>
</li>
<li><strong>กราฟ</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">ค้นหาเชิงลึก (Depth-First Search)</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/breadth-first-search">ค้นหาแบบกว้าง (Breadth-First Search)</a> (BFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/kruskal">อัลกอริทึม Kruskal</a> - หา Minimum Spanning Tree (MST) ในกราฟแบบไม่มีทิศทางถ่วงน้ำหนัก</li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">อัลกอริทึม Dijkstra</a> - หาเส้นทางสั้นที่สุดไปยังทุก vertex จาก vertex เดียว</li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">อัลกอริทึม Bellman-Ford</a> - หาเส้นทางสั้นที่สุดไปยังทุก vertex จาก vertex เดียว</li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">อัลกอริทึม Floyd-Warshall</a> - หาเส้นทางสั้นที่สุดระหว่างทุกคู่ vertex</li>
<li><code>A</code> <a href="src/algorithms/graph/detect-cycle">ตรวจจับวงจร (Detect Cycle)</a> - สำหรับกราฟทั้งแบบมีและไม่มีทิศทาง (DFS และ Disjoint Set)</li>
<li><code>A</code> <a href="src/algorithms/graph/prim">อัลกอริทึม Prim</a> - หา Minimum Spanning Tree (MST) ในกราฟแบบไม่มีทิศทางถ่วงน้ำหนัก</li>
<li><code>A</code> <a href="src/algorithms/graph/topological-sorting">การเรียงลำดับแบบทอปอโลยี (Topological Sorting)</a> - วิธี DFS</li>
<li><code>A</code> <a href="src/algorithms/graph/articulation-points">Articulation Points</a> - อัลกอริทึมของ Tarjan (DFS)</li>
<li><code>A</code> <a href="src/algorithms/graph/bridges">Bridges</a> - อัลกอริทึม DFS</li>
<li><code>A</code> <a href="src/algorithms/graph/eulerian-path">Eulerian Path และ Eulerian Circuit</a> - อัลกอริทึมของ Fleury - เยี่ยมชมทุก edge หนึ่งครั้ง</li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Hamiltonian Cycle</a> - เยี่ยมชมทุก vertex หนึ่งครั้ง</li>
<li><code>A</code> <a href="src/algorithms/graph/strongly-connected-components">Strongly Connected Components</a> - อัลกอริทึมของ Kosaraju</li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Travelling Salesman Problem</a> - เส้นทางสั้นที่สุดที่ผ่านทุกเมืองและกลับสู่ต้นทาง</li>
</ul>
</li>
<li><strong>คริปโตกราฟี</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/cryptography/polynomial-hash">Polynomial Hash</a> - ฟังก์ชันแฮชแบบ rolling</li>
<li><code>B</code> <a href="src/algorithms/cryptography/rail-fence-cipher">Rail Fence Cipher</a> - อัลกอริทึมเข้ารหัสแบบสลับตำแหน่ง</li>
<li><code>B</code> <a href="src/algorithms/cryptography/caesar-cipher">Caesar Cipher</a> - การเข้ารหัสแบบแทนที่ตัวอักษรง่ายๆ</li>
<li><code>B</code> <a href="src/algorithms/cryptography/hill-cipher">Hill Cipher</a> - การเข้ารหัสแบบใช้พีชคณิตเชิงเส้น</li>
</ul>
</li>
<li><strong>Machine Learning</strong>
<ul>
<li><code>B</code> <a href="https://github.com/trekhleb/nano-neuron">NanoNeuron</a> - ฟังก์ชัน JS 7 ตัวอย่างที่แสดงวิธีที่เครื่องสามารถเรียนรู้ได้ (forward/backward propagation)</li>
<li><code>B</code> <a href="src/algorithms/ml/knn">k-NN</a> - อัลกอริทึมการจัดประเภท k-nearest neighbors</li>
<li><code>B</code> <a href="src/algorithms/ml/k-means">k-Means</a> - อัลกอริทึมการจัดกลุ่ม k-Means</li>
</ul>
</li>
<li><strong>การประมวลผลภาพ</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/image-processing/seam-carving">Seam Carving</a> - อัลกอริทึมย่อขนาดภาพตามเนื้อหา</li>
</ul>
</li>
<li><strong>สถิติ</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/statistics/weighted-random">Weighted Random</a> - เลือกรายการแบบสุ่มตามน้ำหนัก</li>
</ul>
</li>
<li><strong>อัลกอริทึมวิวัฒนาการ</strong>
<ul>
<li><code>A</code> <a href="https://github.com/trekhleb/self-parking-car-evolution">อัลกอริทึมพันธุกรรม (Genetic algorithm)</a> - ตัวอย่างการนำอัลกอริทึมพันธุกรรมไปฝึกสอนรถจอดอัตโนมัติ</li>
</ul>
</li>
<li><strong>ไม่เข้าหมวด</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">หอคอยฮานอย (Tower of Hanoi)</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/square-matrix-rotation">หมุนเมทริกซ์จัตุรัส (Square Matrix Rotation)</a> - อัลกอริทึมแบบ in-place</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a> - ตัวอย่าง backtracking, dynamic programming (top-down + bottom-up), greedy</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Unique Paths</a> - ตัวอย่าง backtracking, dynamic programming, Pascal's Triangle</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Rain Terraces</a> - ปัญหาน้ำขัง (dynamic programming และ brute force)</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/recursive-staircase">Recursive Staircase</a> - นับจำนวนวิธีไปถึงยอดบันได (4 วิธี)</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/best-time-to-buy-sell-stocks">ช่วงเวลาซื้อขายหุ้นดีที่สุด (Best Time To Buy Sell Stocks)</a> - ตัวอย่าง divide and conquer และ one-pass</li>
<li><code>B</code> <a href="src/algorithms/stack/valid-parentheses">วงเล็บถูกต้อง (Valid Parentheses)</a> - ตรวจสอบว่าสตริงมีวงเล็บถูกต้องหรือไม่ (ใช้ stack)</li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">N-Queens Problem</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Knight's Tour</a></li>
</ul>
</li>
</ul>
<h3>อัลกอริทึมตามรูปแบบ (Paradigm)</h3>
<p>รูปแบบของอัลกอริทึม (Algorithmic paradigm) คือวิธีการทั่วไปหรือแนวทางที่อยู่เบื้องหลังการออกแบบอัลกอริทึมในกลุ่มหนึ่ง เป็นนามธรรมที่สูงกว่าความคิดของอัลกอริทึม เช่นเดียวกับที่อัลกอริทึมเป็นนามธรรมที่สูงกว่าคอมพิวเตอร์โปรแกรม</p>
<ul>
<li><strong>Brute Force</strong> - ตรวจสอบความเป็นไปได้ทั้งหมดและเลือกทางออกที่ดีที่สุด
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Linear Search</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Rain Terraces</a> - ปัญหาน้ำขัง</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/recursive-staircase">Recursive Staircase</a> - นับจำนวนวิธีไปถึงยอดบันได</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximum Subarray</a></li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Travelling Salesman Problem</a> - เส้นทางสั้นที่สุดที่ผ่านทุกเมืองและกลับสู่ต้นทาง</li>
<li><code>A</code> <a href="src/algorithms/math/fourier-transform">Discrete Fourier Transform</a> - แยกฟังก์ชันของเวลา (สัญญาณ) ออกเป็นความถี่ต่างๆ</li>
</ul>
</li>
<li><strong>Greedy</strong> - เลือกทางออกที่ดีที่สุดในขณะนั้นโดยไม่คำนึงถึงอนาคต
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Unbound Knapsack Problem</a></li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">Dijkstra Algorithm</a> - หาเส้นทางสั้นที่สุดไปยังทุก vertex</li>
<li><code>A</code> <a href="src/algorithms/graph/prim">Prim’s Algorithm</a> - หา Minimum Spanning Tree (MST) ในกราฟแบบไม่มีทิศทางถ่วงน้ำหนัก</li>
<li><code>A</code> <a href="src/algorithms/graph/kruskal">Kruskal’s Algorithm</a> - หา Minimum Spanning Tree (MST) ในกราฟแบบไม่มีทิศทางถ่วงน้ำหนัก</li>
</ul>
</li>
<li><strong>Divide and Conquer</strong> - แบ่งปัญหาออกเป็นส่วนย่อยแล้วแก้แต่ละส่วน
<ul>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Binary Search</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">Tower of Hanoi</a></li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">Pascal's Triangle</a></li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">Euclidean Algorithm</a> - คำนวณหาตัวหารร่วมมาก (GCD)</li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Merge Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Quicksort</a></li>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">Tree Depth-First Search</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">Graph Depth-First Search</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/math/matrix">Matrices</a> - สร้างและเดินเมทริกซ์รูปแบบต่างๆ</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/math/fast-powering">Fast Powering</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/best-time-to-buy-sell-stocks">Best Time To Buy Sell Stocks</a> - ตัวอย่าง divide and conquer และ one-pass</li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutations</a> (แบบมีและไม่มีการทำซ้ำ)</li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Combinations</a> (แบบมีและไม่มีการทำซ้ำ)</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximum Subarray</a></li>
</ul>
</li>
<li><strong>Dynamic Programming</strong> - สร้างคำตอบโดยใช้ผลลัพธ์ย่อยที่เคยคำนวณไว้แล้ว
<ul>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">Fibonacci Number</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Unique Paths</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Rain Terraces</a> - ปัญหาน้ำขัง</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/recursive-staircase">Recursive Staircase</a> - นับจำนวนวิธีไปถึงยอดบันได</li>
<li><code>B</code> <a href="src/algorithms/image-processing/seam-carving">Seam Carving</a> - อัลกอริทึมย่อขนาดภาพตามเนื้อหา</li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Levenshtein Distance</a> - ระยะทางแก้ไขน้อยสุดระหว่างสองลำดับ</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Longest Common Subsequence</a> (LCS)</li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Longest Common Substring</a></li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Longest Increasing Subsequence</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Shortest Common Supersequence</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">0/1 Knapsack Problem</a></li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Integer Partition</a></li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximum Subarray</a></li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">Bellman-Ford Algorithm</a> - หาเส้นทางสั้นที่สุดไปยังทุก vertex</li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">Floyd-Warshall Algorithm</a> - หาเส้นทางสั้นที่สุดระหว่างทุกคู่ vertex</li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Regular Expression Matching</a></li>
</ul>
</li>
<li><strong>Backtracking</strong> - คล้าย brute force โดยจะสร้างคำตอบที่เป็นไปได้ทั้งหมด แต่ทุกครั้งที่สร้างคำตอบใหม่จะตรวจสอบว่าตรงตามเงื่อนไขหรือไม่ ถ้าใช่จึงเดินหน้าต่อ มิฉะนั้นจะย้อนกลับ (backtrack) เพื่อหาคำตอบในเส้นทางอื่น ปกติใช้ DFS กับ state-space
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Unique Paths</a></li>
<li><code>B</code> <a href="src/algorithms/sets/power-set">Power Set</a> - เซตย่อยทั้งหมดของเซตหนึ่ง</li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Hamiltonian Cycle</a> - เยี่ยมชมทุก vertex หนึ่งครั้ง</li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">N-Queens Problem</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Knight's Tour</a></li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Combination Sum</a> - หาทุกชุดที่รวมกันได้ผลรวมที่กำหนด</li>
</ul>
</li>
<li><strong>Branch &amp; Bound</strong> - จดจำทางออกที่มีต้นทุนน้อยที่สุดในแต่ละขั้นของ backtracking และใช้ต้นทุนต่ำสุดนี้เป็นขอบเขตล่าง (lower bound) เพื่อคัดคำตอบย่อยที่ต้นทุนสูงกว่าออก ปกติจะใช้ BFS ผสม DFS กับ state-space tree</li>
</ul>
<h2>วิธีใช้งานคลังนี้</h2>
<p><strong>ติดตั้ง dependencies ทั้งหมด</strong></p>
<pre><code>npm install
</code></pre>
<p><strong>รัน ESLint</strong></p>
<p>คุณอาจต้องการรันเพื่อตรวจสอบคุณภาพโค้ด</p>
<pre><code>npm run lint
</code></pre>
<p><strong>รันเทสต์ทั้งหมด</strong></p>
<pre><code>npm test
</code></pre>
<p><strong>รันเทสต์เฉพาะชื่อ</strong></p>
<pre><code>npm test -- 'LinkedList'
</code></pre>
<p><strong>การแก้ปัญหาเบื้องต้น</strong></p>
<p>หาก linting หรือ testing ล้มเหลว ให้ลองลบโฟลเดอร์ <code>node_modules</code> และติดตั้ง npm packages ใหม่:</p>
<pre><code>rm -rf ./node_modules
npm i
</code></pre>
<p>และตรวจสอบว่าคุณใช้เวอร์ชัน Node ที่ถูกต้อง (<code>&gt;=16</code>) หากใช้ <a href="https://github.com/nvm-sh/nvm">nvm</a> สำหรับจัดการ Node version สามารถรัน <code>nvm use</code> จาก root ของโปรเจกต์เพื่อให้เลือกเวอร์ชันที่ถูกต้องโดยอัตโนมัติ</p>
<p><strong>Playground</strong></p>
<p>คุณสามารถทดลองเล่นกับโครงสร้างข้อมูลและอัลกอริทึมในไฟล์ <code>./src/playground/playground.js</code> และเขียนเทสต์ใน <code>./src/playground/__test__/playground.test.js</code></p>
<p>จากนั้นเพียงรันคำสั่งนี้เพื่อทดสอบว่าโค้ด playground ของคุณทำงานถูกต้องหรือไม่:</p>
<pre><code>npm test -- 'playground'
</code></pre>
<h2>ข้อมูลที่เป็นประโยชน์</h2>
<h3>แหล่งอ้างอิง</h3>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">▶ Data Structures and Algorithms on YouTube</a></li>
<li><a href="https://okso.app/showcase/data-structures">✍🏻 Data Structure Sketches</a></li>
</ul>
<h3>สัญลักษณ์ Big O (Big O Notation)</h3>
<p><em>Big O notation</em> ใช้สำหรับจัดประเภทอัลกอริทึมตามวิธีที่เวลาการทำงานหรือความต้องการหน่วยความจำเพิ่มขึ้นเมื่อขนาดข้อมูลขาเข้าเพิ่มขึ้น
ในแผนภูมิด้านล่าง คุณจะเห็นลำดับการเติบโตที่พบบ่อยที่สุดของอัลกอริทึมตาม Big O notation</p>
<p><img src="./assets/big-o-graph.png" alt="Big O graphs" /></p>
<p>ที่มา: <a href="http://bigocheatsheet.com/">Big O Cheat Sheet</a></p>
<p>ด้านล่างเป็นรายการ Big O ที่ใช้บ่อยที่สุด และเปรียบเทียบประสิทธิภาพกับขนาดข้อมูลขาเข้าต่างๆ</p>
<p>| Big O Notation | ประเภท         | การคำนวณสำหรับ 10 ตัว | การคำนวณสำหรับ 100 ตัว | การคำนวณสำหรับ 1000 ตัว  |
| -------------- | -------------- | --------------------- | ---------------------- | ------------------------- |
| <strong>O(1)</strong>       | คงที่          | 1                     | 1                      | 1                         |
| <strong>O(log N)</strong>   | ลอการิทึม      | 3                     | 6                      | 9                         |
| <strong>O(N)</strong>       | เส้นตรง        | 10                    | 100                    | 1000                      |
| <strong>O(N log N)</strong> | n log(n)       | 30                    | 600                    | 9000                      |
| <strong>O(N^2)</strong>     | กำลังสอง       | 100                   | 10000                  | 1000000                   |
| <strong>O(2^N)</strong>     | เอ็กซ์โพเนนเชียล | 1024                  | 1.26e+29               | 1.07e+301                 |
| <strong>O(N!)</strong>      | แฟกทอเรียล     | 3628800               | 9.3e+157               | 4.02e+2567                |</p>
<h3>ความซับซ้อนของการดำเนินการโครงสร้างข้อมูล</h3>
<p>| โครงสร้างข้อมูล        | เข้าถึง   | ค้นหา    | แทรก      | ลบ        | หมายเหตุ  |
| ---------------------- | :-------: | :-------:| :--------:| :--------:| :-------- |
| <strong>Array</strong>              | 1         | n        | n         | n         |           |
| <strong>Stack</strong>              | n         | n        | 1         | 1         |           |
| <strong>Queue</strong>              | n         | n        | 1         | 1         |           |
| <strong>Linked List</strong>        | n         | n        | 1         | n         |           |
| <strong>Hash Table</strong>         | -         | n        | n         | n         | ถ้าใช้แฮชฟังก์ชันที่สมบูรณ์จะเป็น O(1) |
| <strong>Binary Search Tree</strong> | n         | n        | n         | n         | ถ้าเป็นต้นไม้สมดุลจะเป็น O(log(n)) |
| <strong>B-Tree</strong>             | log(n)    | log(n)   | log(n)    | log(n)    |           |
| <strong>Red-Black Tree</strong>     | log(n)    | log(n)   | log(n)    | log(n)    |           |
| <strong>AVL Tree</strong>           | log(n)    | log(n)   | log(n)    | log(n)    |           |
| <strong>Bloom Filter</strong>       | -         | 1        | 1         | -         | อาจมี false positive ในการค้นหา |</p>
<h3>ความซับซ้อนของอัลกอริทึมการเรียงลำดับอาร์เรย์</h3>
<p>| ชื่อ                   | กรณีที่ดีที่สุด  | เฉลี่ย         | กรณีที่แย่ที่สุด   | หน่วยความจำ | เสถียร | หมายเหตุ  |
| ---------------------- | :-------------: | :------------: | :----------------: | :---------: | :----: | :-------- |
| <strong>Bubble sort</strong>        | n               | n<sup>2</sup>  | n<sup>2</sup>      | 1           | ใช่     |           |
| <strong>Insertion sort</strong>     | n               | n<sup>2</sup>  | n<sup>2</sup>      | 1           | ใช่     |           |
| <strong>Selection sort</strong>     | n<sup>2</sup>   | n<sup>2</sup>  | n<sup>2</sup>      | 1           | ไม่     |           |
| <strong>Heap sort</strong>          | n log(n)   | n log(n)  | n log(n)      | 1           | ไม่     |           |
| <strong>Merge sort</strong>         | n log(n)   | n log(n)  | n log(n)      | n           | ใช่     |           |
| <strong>Quick sort</strong>         | n log(n)   | n log(n)  | n<sup>2</sup>      | log(n)      | ไม่     | ปกติทำ in-place ใช้ stack O(log(n)) |
| <strong>Shell sort</strong>         | n log(n)   | ขึ้นกับ gap sequence | n (log(n))<sup>2</sup> | 1    | ไม่     |           |
| <strong>Counting sort</strong>      | n + r           | n + r          | n + r              | n + r       | ใช่     | r คือค่ามากที่สุดในอาร์เรย์ |
| <strong>Radix sort</strong>         | n * k           | n * k          | n * k              | n + k       | ใช่     | k คือความยาวของ key ยาวสุด |</p>
<h2>ผู้สนับสนุนโปรเจกต์</h2>
<blockquote>
<p>คุณสามารถสนับสนุนโปรเจกต์นี้ผ่าน ❤️️ <a href="https://github.com/sponsors/trekhleb">GitHub</a> หรือ ❤️️ <a href="https://www.patreon.com/trekhleb">Patreon</a></p>
</blockquote>
<p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/BACKERS.md">ผู้สนับสนุนโปรเจกต์นี้</a> <code>∑ = 1</code></p>
<h2>ผู้เขียน</h2>
<p><a href="https://trekhleb.dev">@trekhleb</a></p>
<p>โปรเจกต์และบทความเพิ่มเติมเกี่ยวกับ JavaScript และอัลกอริทึมที่ <a href="https://trekhleb.dev">trekhleb.dev</a></p>
<hr />
<p><a href="https://github.com/OpenAiTx/OpenAiTx">Powered By OpenAiTx</a></p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>