<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>javascript-algorithms - trekhleb/javascript-algorithms de</title>
    <meta name="title" content="javascript-algorithms - trekhleb/javascript-algorithms de | JavaScript-Algorithmen und Datenstrukturen 🇺🇦 DIE UKRAINE WIRD ANGEGRIFFEN VON DER RUSSISCHEN ARMEE. ZIVILISTEN WERDEN GETÖTET. WOHNGEBIETE WERDEN BOMBARDIERT...">
    <meta name="description" content="trekhleb/javascript-algorithms - GitHub repository de documentation and information | JavaScript-Algorithmen und Datenstrukturen 🇺🇦 DIE UKRAINE WIRD ANGEGRIFFEN VON DER RUSSISCHEN ARMEE. ZIVILISTEN WERDEN GETÖTET. WOHNGEBIETE WERDEN BOMBARDIERT...">
    <meta name="keywords" content="trekhleb, javascript-algorithms, GitHub, repository, de documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/trekhleb/javascript-algorithms/README-de.html">
    <meta property="og:title" content="javascript-algorithms - trekhleb/javascript-algorithms de | JavaScript-Algorithmen und Datenstrukturen 🇺🇦 DIE UKRAINE WIRD ANGEGRIFFEN VON DER RUSSISCHEN ARMEE. ZIVILISTEN WERDEN GETÖTET. WOHNGEBIETE WERDEN BOMBARDIERT...">
    <meta property="og:description" content="trekhleb/javascript-algorithms - GitHub repository de documentation and information | JavaScript-Algorithmen und Datenstrukturen 🇺🇦 DIE UKRAINE WIRD ANGEGRIFFEN VON DER RUSSISCHEN ARMEE. ZIVILISTEN WERDEN GETÖTET. WOHNGEBIETE WERDEN BOMBARDIERT...">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/trekhleb/javascript-algorithms" id="githubRepoLink" target="_blank">trekhleb/javascript-algorithms</a>
<h1 style="display: none;">JavaScript-Algorithmen und Datenstrukturen 🇺🇦 DIE UKRAINE WIRD ANGEGRIFFEN VON DER RUSSISCHEN ARMEE. ZIVILISTEN WERDEN GETÖTET. WOHNGEBIETE WERDEN BOMBARDIERT...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>JavaScript-Algorithmen und Datenstrukturen</h1>
<blockquote>
<p>🇺🇦 DIE UKRAINE <a href="https://war.ukraine.ua/">WIRD ANGEGRIFFEN</a> VON DER RUSSISCHEN ARMEE. ZIVILISTEN WERDEN GETÖTET. WOHNGEBIETE WERDEN BOMBARDIERT.</p>
<ul>
<li>Unterstützen Sie die Ukraine über:
<ul>
<li><a href="https://prytulafoundation.org/en/">Serhiy Prytula Charity Foundation</a></li>
<li><a href="https://savelife.in.ua/en/donate-en/">Come Back Alive Charity Foundation</a></li>
<li><a href="https://bank.gov.ua/en/news/all/natsionalniy-bank-vidkriv-spetsrahunok-dlya-zboru-koshtiv-na-potrebi-armiyi">Nationalbank der Ukraine</a></li>
</ul>
</li>
<li>Mehr Infos auf <a href="https://war.ukraine.ua/">war.ukraine.ua</a> und <a href="https://twitter.com/MFA_Ukraine">MFA of Ukraine</a></li>
</ul>
</blockquote>
<hr/>
<p><a href="https://github.com/trekhleb/javascript-algorithms/actions?query=workflow%3ACI+branch%3Amaster"><img src="https://github.com/trekhleb/javascript-algorithms/workflows/CI/badge.svg" alt="CI" /></a>
<a href="https://codecov.io/gh/trekhleb/javascript-algorithms"><img src="https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg" alt="codecov" /></a>
<img src="https://img.shields.io/github/repo-size/trekhleb/javascript-algorithms.svg" alt="repo size" /></p>
<p>Dieses Repository enthält JavaScript-basierte Beispiele vieler
bekannter Algorithmen und Datenstrukturen.</p>
<p>Jeder Algorithmus und jede Datenstruktur hat eine eigene README
mit zugehörigen Erklärungen und weiterführenden Links (einschließlich zu
YouTube-Videos).</p>
<p><em>Lesen Sie dies in anderen Sprachen:</em>
<a href="README.zh-CN.md"><em>简体中文</em></a>,
<a href="README.zh-TW.md"><em>繁體中文</em></a>,
<a href="README.ko-KR.md"><em>한국어</em></a>,
<a href="README.ja-JP.md"><em>日本語</em></a>,
<a href="README.pl-PL.md"><em>Polski</em></a>,
<a href="README.fr-FR.md"><em>Français</em></a>,
<a href="README.es-ES.md"><em>Español</em></a>,
<a href="README.pt-BR.md"><em>Português</em></a>,
<a href="README.ru-RU.md"><em>Русский</em></a>,
<a href="README.tr-TR.md"><em>Türkçe</em></a>,
<a href="README.it-IT.md"><em>Italiano</em></a>,
<a href="README.id-ID.md"><em>Bahasa Indonesia</em></a>,
<a href="README.uk-UA.md"><em>Українська</em></a>,
<a href="README.ar-AR.md"><em>Arabic</em></a>,
<a href="README.vi-VN.md"><em>Tiếng Việt</em></a>,
<a href="README.de-DE.md"><em>Deutsch</em></a>,
<a href="README.uz-UZ.md"><em>Uzbek</em></a>,
<a href="README.he-IL.md"><em>עברית</em></a></p>
<p><em>☝ Beachten Sie, dass dieses Projekt nur zu Lern- und Forschungszwecken
gedacht ist und <strong>nicht</strong> für den Produktionseinsatz vorgesehen ist.</em></p>
<h2>Datenstrukturen</h2>
<p>Eine Datenstruktur ist eine spezielle Art, Daten in einem Computer zu organisieren und zu speichern, damit sie effizient
abgerufen und verändert werden können. Genauer gesagt ist eine Datenstruktur eine Sammlung von Datenwerten,
deren Beziehungen untereinander sowie den Funktionen oder Operationen, die auf die Daten angewendet werden können.</p>
<p>Denken Sie daran, dass jede Datenstruktur ihre eigenen Vor- und Nachteile hat. Sie sollten mehr darauf achten, warum Sie eine bestimmte Datenstruktur wählen, als darauf, wie sie implementiert wird.</p>
<p><code>B</code> - Anfänger, <code>A</code> - Fortgeschritten</p>
<ul>
<li><code>B</code> <a href="src/data-structures/linked-list">Verkettete Liste</a></li>
<li><code>B</code> <a href="src/data-structures/doubly-linked-list">Doppelt verkettete Liste</a></li>
<li><code>B</code> <a href="src/data-structures/queue">Warteschlange (Queue)</a></li>
<li><code>B</code> <a href="src/data-structures/stack">Stapel (Stack)</a></li>
<li><code>B</code> <a href="src/data-structures/hash-table">Hashtabelle</a></li>
<li><code>B</code> <a href="src/data-structures/heap">Heap</a> - Max- und Min-Heap-Versionen</li>
<li><code>B</code> <a href="src/data-structures/priority-queue">Prioritätswarteschlange</a></li>
<li><code>A</code> <a href="src/data-structures/trie">Trie</a></li>
<li><code>A</code> <a href="src/data-structures/tree">Baum</a>
<ul>
<li><code>A</code> <a href="src/data-structures/tree/binary-search-tree">Binärer Suchbaum</a></li>
<li><code>A</code> <a href="src/data-structures/tree/avl-tree">AVL-Baum</a></li>
<li><code>A</code> <a href="src/data-structures/tree/red-black-tree">Rot-Schwarz-Baum</a></li>
<li><code>A</code> <a href="src/data-structures/tree/segment-tree">Segmentbaum</a> - mit Beispielen für Min/Max/Summenbereichsanfragen</li>
<li><code>A</code> <a href="src/data-structures/tree/fenwick-tree">Fenwick-Baum</a> (Binär-Index-Baum)</li>
</ul>
</li>
<li><code>A</code> <a href="src/data-structures/graph">Graph</a> (gerichtet und ungerichtet)</li>
<li><code>A</code> <a href="src/data-structures/disjoint-set">Disjoint Set</a> - Union-Find-Datenstruktur oder Merge-Find-Set</li>
<li><code>A</code> <a href="src/data-structures/bloom-filter">Bloom-Filter</a></li>
<li><code>A</code> <a href="src/data-structures/lru-cache/">LRU-Cache</a> - Least Recently Used (LRU) Cache</li>
</ul>
<h2>Algorithmen</h2>
<p>Ein Algorithmus ist eine eindeutige Spezifikation, wie eine Klasse von Problemen zu lösen ist.
Er ist eine Reihe von Regeln, die genau eine Abfolge von Operationen definieren.</p>
<p><code>B</code> - Anfänger, <code>A</code> - Fortgeschritten</p>
<h3>Algorithmen nach Thema</h3>
<ul>
<li><strong>Mathematik</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/math/bits">Bit-Manipulation</a> - Setzen/Lesen/Aktualisieren/Löschen von Bits, Multiplikation/Division durch zwei, Negation usw.</li>
<li><code>B</code> <a href="src/algorithms/math/binary-floating-point">Binäre Fließkommazahl</a> - binäre Darstellung von Fließkommazahlen</li>
<li><code>B</code> <a href="src/algorithms/math/factorial">Fakultät</a></li>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">Fibonacci-Zahl</a> - klassische und geschlossene Form</li>
<li><code>B</code> <a href="src/algorithms/math/prime-factors">Primfaktoren</a> - Primfaktorzerlegung und Zählen mittels Hardy-Ramanujan-Theorem</li>
<li><code>B</code> <a href="src/algorithms/math/primality-test">Primzahltest</a> (Teilerprüfung)</li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">Euklidischer Algorithmus</a> - Berechnung des größten gemeinsamen Teilers (ggT)</li>
<li><code>B</code> <a href="src/algorithms/math/least-common-multiple">Kleinstes gemeinsames Vielfaches</a> (kgV)</li>
<li><code>B</code> <a href="src/algorithms/math/sieve-of-eratosthenes">Siebe des Eratosthenes</a> - alle Primzahlen bis zu einem bestimmten Limit finden</li>
<li><code>B</code> <a href="src/algorithms/math/is-power-of-two">Ist Potenz von Zwei</a> - Überprüfung, ob eine Zahl eine Zweierpotenz ist (naiv und bitweise)</li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">Pascalsches Dreieck</a></li>
<li><code>B</code> <a href="src/algorithms/math/complex-number">Komplexe Zahl</a> - Komplexe Zahlen und Grundrechenarten</li>
<li><code>B</code> <a href="src/algorithms/math/radian">Bogenmaß &amp; Grad</a> - Umrechnung zwischen Bogenmaß und Grad</li>
<li><code>B</code> <a href="src/algorithms/math/fast-powering">Schnelles Potenzieren</a></li>
<li><code>B</code> <a href="src/algorithms/math/horner-method">Horner-Schema</a> - Polynomevaluation</li>
<li><code>B</code> <a href="src/algorithms/math/matrix">Matrizen</a> - Matrizen und Grundoperationen (Multiplikation, Transposition, usw.)</li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-distance">Euklidische Distanz</a> - Abstand zwischen zwei Punkten/Vektoren/Matrizen</li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Ganzzahlpartition</a></li>
<li><code>A</code> <a href="src/algorithms/math/square-root">Quadratwurzel</a> - Newtons Methode</li>
<li><code>A</code> <a href="src/algorithms/math/liu-hui">Liu Hui π Algorithmus</a> - Annäherung von π basierend auf N-Ecken</li>
<li><code>A</code> <a href="src/algorithms/math/fourier-transform">Diskrete Fourier-Transformation</a> - Zerlegung einer Zeitfunktion (Signal) in Frequenzen</li>
</ul>
</li>
<li><strong>Mengen</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sets/cartesian-product">Kartesisches Produkt</a> - Produkt mehrerer Mengen</li>
<li><code>B</code> <a href="src/algorithms/sets/fisher-yates">Fisher–Yates Shuffle</a> - Zufallspermutation einer endlichen Sequenz</li>
<li><code>A</code> <a href="src/algorithms/sets/power-set">Potenzmenge</a> - alle Teilmengen einer Menge (bitweise, Backtracking und Kaskadierung)</li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutationen</a> (mit und ohne Wiederholungen)</li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Kombinationen</a> (mit und ohne Wiederholungen)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Längste gemeinsame Teilfolge</a> (LCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Längste steigende Teilfolge</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Kürzeste gemeinsame Supersequenz</a> (SCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Rucksackproblem</a> - „0/1“ und „Ungebunden“</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximales Teilarray</a> - „Brute Force“ und „Dynamische Programmierung“ (Kadane’s Algorithmus)</li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Combination Sum</a> - alle Kombinationen finden, die eine bestimmte Summe ergeben</li>
</ul>
</li>
<li><strong>Zeichenketten</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/string/hamming-distance">Hamming-Distanz</a> - Anzahl der unterschiedlichen Zeichenpositionen</li>
<li><code>B</code> <a href="src/algorithms/string/palindrome">Palindrom</a> - Überprüfung, ob der String rückwärts gleich ist</li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Levenshtein-Distanz</a> - minimale Bearbeitungsdistanz zwischen zwei Sequenzen</li>
<li><code>A</code> <a href="src/algorithms/string/knuth-morris-pratt">Knuth–Morris–Pratt Algorithmus</a> (KMP-Algorithmus) - Teilstring-Suche (Mustervergleich)</li>
<li><code>A</code> <a href="src/algorithms/string/z-algorithm">Z-Algorithmus</a> - Teilstring-Suche (Mustervergleich)</li>
<li><code>A</code> <a href="src/algorithms/string/rabin-karp">Rabin-Karp Algorithmus</a> - Teilstring-Suche</li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Längster gemeinsamer Teilstring</a></li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Regulärer Ausdruck Vergleich</a></li>
</ul>
</li>
<li><strong>Suchen</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Lineare Suche</a></li>
<li><code>B</code> <a href="src/algorithms/search/jump-search">Jump Search</a> (Blocksuche) - Suche im sortierten Array</li>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Binäre Suche</a> - Suche im sortierten Array</li>
<li><code>B</code> <a href="src/algorithms/search/interpolation-search">Interpolationssuche</a> - Suche im gleichmäßig verteilten sortierten Array</li>
</ul>
</li>
<li><strong>Sortieren</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sorting/bubble-sort">Bubble Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/selection-sort">Selection Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/insertion-sort">Insertion Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/heap-sort">Heap Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Merge Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Quicksort</a> - In-Place und Nicht-In-Place-Implementierungen</li>
<li><code>B</code> <a href="src/algorithms/sorting/shell-sort">Shellsort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/counting-sort">Counting Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/radix-sort">Radix Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/bucket-sort">Bucket Sort</a></li>
</ul>
</li>
<li><strong>Verkettete Listen</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/linked-list/traversal">Vorwärts-Durchlauf</a></li>
<li><code>B</code> <a href="src/algorithms/linked-list/reverse-traversal">Rückwärts-Durchlauf</a></li>
</ul>
</li>
<li><strong>Bäume</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">Tiefensuche</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/tree/breadth-first-search">Breitensuche</a> (BFS)</li>
</ul>
</li>
<li><strong>Graphen</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">Tiefensuche</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/breadth-first-search">Breitensuche</a> (BFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/kruskal">Kruskal-Algorithmus</a> - Minimaler Spannbaum (MST) für gewichtete ungerichtete Graphen</li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">Dijkstra-Algorithmus</a> - Kürzeste Wege zu allen Knoten von einem Startknoten</li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">Bellman-Ford-Algorithmus</a> - Kürzeste Wege zu allen Knoten von einem Startknoten</li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">Floyd-Warshall-Algorithmus</a> - Kürzeste Wege zwischen allen Knotenpaaren</li>
<li><code>A</code> <a href="src/algorithms/graph/detect-cycle">Zyklus-Erkennung</a> - für gerichtete und ungerichtete Graphen (DFS und Disjoint Set)</li>
<li><code>A</code> <a href="src/algorithms/graph/prim">Prim-Algorithmus</a> - Minimaler Spannbaum (MST) für gewichtete ungerichtete Graphen</li>
<li><code>A</code> <a href="src/algorithms/graph/topological-sorting">Topologisches Sortieren</a> - DFS-Methode</li>
<li><code>A</code> <a href="src/algorithms/graph/articulation-points">Gelenkpunkte</a> - Tarjan-Algorithmus (DFS-basiert)</li>
<li><code>A</code> <a href="src/algorithms/graph/bridges">Brücken</a> - DFS-basierter Algorithmus</li>
<li><code>A</code> <a href="src/algorithms/graph/eulerian-path">Eulerweg und Eulerkreis</a> - Fleury-Algorithmus – Jede Kante genau einmal besuchen</li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Hamiltonkreis</a> - Jeden Knoten genau einmal besuchen</li>
<li><code>A</code> <a href="src/algorithms/graph/strongly-connected-components">Stark zusammenhängende Komponenten</a> - Kosaraju-Algorithmus</li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Handelsreisender-Problem</a> - Kürzeste Rundreise durch alle Städte</li>
</ul>
</li>
<li><strong>Kryptographie</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/cryptography/polynomial-hash">Polynom-Hash</a> - Rolling-Hash-Funktion basierend auf Polynom</li>
<li><code>B</code> <a href="src/algorithms/cryptography/rail-fence-cipher">Rail Fence Cipher</a> - Transpositionschiffre zum Verschlüsseln von Nachrichten</li>
<li><code>B</code> <a href="src/algorithms/cryptography/caesar-cipher">Caesar-Chiffre</a> - Einfache Substitutionschiffre</li>
<li><code>B</code> <a href="src/algorithms/cryptography/hill-cipher">Hill-Chiffre</a> - Substitutionschiffre basierend auf Linearer Algebra</li>
</ul>
</li>
<li><strong>Maschinelles Lernen</strong>
<ul>
<li><code>B</code> <a href="https://github.com/trekhleb/nano-neuron">NanoNeuron</a> - 7 einfache JS-Funktionen, die illustrieren, wie Maschinen lernen können (Vorwärts-/Rückwärtsausbreitung)</li>
<li><code>B</code> <a href="src/algorithms/ml/knn">k-NN</a> - k-nächste Nachbarn Klassifikationsalgorithmus</li>
<li><code>B</code> <a href="src/algorithms/ml/k-means">k-Means</a> - k-Means Clustering-Algorithmus</li>
</ul>
</li>
<li><strong>Bildverarbeitung</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/image-processing/seam-carving">Seam Carving</a> - inhaltsbasiertes Bildskalierungsverfahren</li>
</ul>
</li>
<li><strong>Statistik</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/statistics/weighted-random">Gewichtetes Zufallsauswahl</a> - zufällige Auswahl eines Elements basierend auf Gewichtung</li>
</ul>
</li>
<li><strong>Evolutionäre Algorithmen</strong>
<ul>
<li><code>A</code> <a href="https://github.com/trekhleb/self-parking-car-evolution">Genetischer Algorithmus</a> - Beispiel für die Anwendung eines genetischen Algorithmus zum Trainieren von selbstparkenden Autos</li>
</ul>
</li>
<li><strong>Nicht kategorisiert</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">Türme von Hanoi</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/square-matrix-rotation">Quadratische Matrixrotation</a> - In-Place-Algorithmus</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a> - Backtracking, dynamische Programmierung (Top-down + Bottom-up) und Greedy-Ansätze</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Eindeutige Pfade</a> - Backtracking, dynamische Programmierung und Pascalsches Dreieck</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Regen-Terrassen</a> - Problem der Regenwassersammlung (dynamische Programmierung und Brute Force)</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/recursive-staircase">Rekursive Treppe</a> - Anzahl der Wege zum Erreichen der obersten Stufe (4 Lösungen)</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/best-time-to-buy-sell-stocks">Bester Zeitpunkt zum Aktienkauf/-verkauf</a> - Divide-and-Conquer und One-Pass-Beispiele</li>
<li><code>B</code> <a href="src/algorithms/stack/valid-parentheses">Gültige Klammern</a> - Überprüfung, ob ein String gültige Klammern enthält (mithilfe eines Stacks)</li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">N-Damen-Problem</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Springerproblem</a></li>
</ul>
</li>
</ul>
<h3>Algorithmen nach Paradigma</h3>
<p>Ein algorithmisches Paradigma ist eine allgemeine Methode oder Herangehensweise, die dem Entwurf einer Klasse
von Algorithmen zugrunde liegt. Es ist eine Abstraktion über dem Begriff des Algorithmus, so wie ein
Algorithmus eine Abstraktion über einem Computerprogramm ist.</p>
<ul>
<li><strong>Brute Force</strong> – betrachtet alle Möglichkeiten und wählt die beste Lösung
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Lineare Suche</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Regen-Terrassen</a> - Problem der Regenwassersammlung</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/recursive-staircase">Rekursive Treppe</a> - Anzahl der Wege zur obersten Stufe</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximales Teilarray</a></li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Handelsreisender-Problem</a> - Kürzeste Rundreise durch alle Städte</li>
<li><code>A</code> <a href="src/algorithms/math/fourier-transform">Diskrete Fourier-Transformation</a> - Zerlegung einer Zeitfunktion in Frequenzen</li>
</ul>
</li>
<li><strong>Greedy</strong> – wählt zum jeweiligen Zeitpunkt die beste Option, ohne Rücksicht auf die Zukunft
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Ungebundenes Rucksackproblem</a></li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">Dijkstra-Algorithmus</a> - Kürzeste Wege zu allen Knoten</li>
<li><code>A</code> <a href="src/algorithms/graph/prim">Prim-Algorithmus</a> - Minimaler Spannbaum</li>
<li><code>A</code> <a href="src/algorithms/graph/kruskal">Kruskal-Algorithmus</a> - Minimaler Spannbaum</li>
</ul>
</li>
<li><strong>Divide and Conquer</strong> – zerlegt das Problem in kleinere Teile und löst diese
<ul>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Binäre Suche</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">Türme von Hanoi</a></li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">Pascalsches Dreieck</a></li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">Euklidischer Algorithmus</a> - ggT</li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Merge Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Quicksort</a></li>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">Baum-Tiefensuche</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">Graph-Tiefensuche</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/math/matrix">Matrizen</a> - Erzeugung und Durchlauf verschiedener Matrizenformen</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/math/fast-powering">Schnelles Potenzieren</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/best-time-to-buy-sell-stocks">Bester Zeitpunkt zum Aktienkauf/-verkauf</a></li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutationen</a></li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Kombinationen</a></li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximales Teilarray</a></li>
</ul>
</li>
<li><strong>Dynamische Programmierung</strong> – baut eine Lösung mithilfe bereits gefundener Teillösungen auf
<ul>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">Fibonacci-Zahl</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Eindeutige Pfade</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Regen-Terrassen</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/recursive-staircase">Rekursive Treppe</a></li>
<li><code>B</code> <a href="src/algorithms/image-processing/seam-carving">Seam Carving</a></li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Levenshtein-Distanz</a></li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Längste gemeinsame Teilfolge</a> (LCS)</li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Längster gemeinsamer Teilstring</a></li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Längste steigende Teilfolge</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Kürzeste gemeinsame Supersequenz</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">0/1-Rucksackproblem</a></li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Ganzzahlpartition</a></li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximales Teilarray</a></li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">Bellman-Ford-Algorithmus</a></li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">Floyd-Warshall-Algorithmus</a></li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Regulärer Ausdruck Vergleich</a></li>
</ul>
</li>
<li><strong>Backtracking</strong> – ähnlich wie Brute Force, versucht alle möglichen Lösungen zu generieren, prüft aber bei jeder neuen Lösung, ob alle Bedingungen erfüllt sind, und geht nur dann weiter. Andernfalls Backtracking und einen anderen Lösungsweg suchen. Normalerweise wird die DFS-Durchquerung des Zustandsraums verwendet.
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Eindeutige Pfade</a></li>
<li><code>B</code> <a href="src/algorithms/sets/power-set">Potenzmenge</a></li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Hamiltonkreis</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">N-Damen-Problem</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Springerproblem</a></li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Combination Sum</a></li>
</ul>
</li>
<li><strong>Branch &amp; Bound</strong> – merkt sich die bisher günstigste Lösung bei jedem Schritt des Backtracking-Suchvorgangs und verwirft Teillösungen, deren Kosten die der bisher besten Lösung überschreiten. Meist wird BFS kombiniert mit DFS im Zustandsraum-Baum eingesetzt.</li>
</ul>
<h2>Verwendung dieses Repositories</h2>
<p><strong>Alle Abhängigkeiten installieren</strong></p>
<pre><code>npm install
</code></pre>
<p><strong>ESLint ausführen</strong></p>
<p>Sie können ESLint ausführen, um die Codequalität zu überprüfen.</p>
<pre><code>npm run lint
</code></pre>
<p><strong>Alle Tests ausführen</strong></p>
<pre><code>npm test
</code></pre>
<p><strong>Tests nach Name ausführen</strong></p>
<pre><code>npm test -- 'LinkedList'
</code></pre>
<p><strong>Fehlerbehebung</strong></p>
<p>Falls Linting oder Tests fehlschlagen, löschen Sie den <code>node_modules</code>-Ordner und installieren Sie die Pakete erneut:</p>
<pre><code>rm -rf ./node_modules
npm i
</code></pre>
<p>Stellen Sie außerdem sicher, dass Sie die richtige Node-Version (<code>&gt;=16</code>) verwenden. Wenn Sie <a href="https://github.com/nvm-sh/nvm">nvm</a> zur Node-Version-Verwaltung nutzen, können Sie im Projektverzeichnis <code>nvm use</code> ausführen, damit die richtige Version verwendet wird.</p>
<p><strong>Playground</strong></p>
<p>Sie können im <code>./src/playground/playground.js</code> mit Datenstrukturen und Algorithmen experimentieren und dazu Tests in <code>./src/playground/__test__/playground.test.js</code> schreiben.</p>
<p>Führen Sie dann einfach den folgenden Befehl aus, um zu testen, ob Ihr Playground-Code wie erwartet funktioniert:</p>
<pre><code>npm test -- 'playground'
</code></pre>
<h2>Nützliche Informationen</h2>
<h3>Quellen</h3>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">▶ Datenstrukturen und Algorithmen auf YouTube</a></li>
<li><a href="https://okso.app/showcase/data-structures">✍🏻 Data Structure Sketches</a></li>
</ul>
<h3>Big O-Notation</h3>
<p><em>Big O-Notation</em> wird verwendet, um Algorithmen nach dem Wachstum ihres Zeit- oder Speicherbedarfs in Abhängigkeit von der Eingabegröße zu klassifizieren.
Im folgenden Diagramm sehen Sie die häufigsten Wachstumsordnungen von Algorithmen in Big O-Notation.</p>
<p><img src="./assets/big-o-graph.png" alt="Big O graphs" /></p>
<p>Quelle: <a href="http://bigocheatsheet.com/">Big O Cheat Sheet</a>.</p>
<p>Nachfolgend finden Sie die gebräuchlichsten Big O-Notationen und deren Leistungsvergleich bei unterschiedlichen Eingabemengen.</p>
<p>| Big O Notation | Typ         | Berechnungen für 10 Elemente | Berechnungen für 100 Elemente | Berechnungen für 1000 Elemente  |
| -------------- | ----------- | ---------------------------- | ----------------------------- | ------------------------------- |
| <strong>O(1)</strong>       | Konstant    | 1                            | 1                             | 1                               |
| <strong>O(log N)</strong>   | Logarithmisch| 3                           | 6                             | 9                               |
| <strong>O(N)</strong>       | Linear      | 10                           | 100                           | 1000                            |
| <strong>O(N log N)</strong> | n log(n)    | 30                           | 600                           | 9000                            |
| <strong>O(N^2)</strong>     | Quadratisch | 100                          | 10000                         | 1000000                         |
| <strong>O(2^N)</strong>     | Exponentiell| 1024                         | 1,26e+29                      | 1,07e+301                       |
| <strong>O(N!)</strong>      | Fakultativ  | 3628800                      | 9,3e+157                      | 4,02e+2567                      |</p>
<h3>Komplexität von Datenstruktur-Operationen</h3>
<p>| Datenstruktur          | Zugriff   | Suche     | Einfügen   | Löschen    | Kommentare  |
| ---------------------- | :-------: | :-------: | :--------: | :--------: | :---------- |
| <strong>Array</strong>              | 1         | n         | n          | n          |             |
| <strong>Stack</strong>              | n         | n         | 1          | 1          |             |
| <strong>Queue</strong>              | n         | n         | 1          | 1          |             |
| <strong>Verkettete Liste</strong>   | n         | n         | 1          | n          |             |
| <strong>Hashtabelle</strong>        | -         | n         | n          | n          | Bei perfekter Hashfunktion O(1) |
| <strong>Binärer Suchbaum</strong>   | n         | n         | n          | n          | Bei balanciertem Baum O(log(n)) |
| <strong>B-Baum</strong>             | log(n)    | log(n)    | log(n)     | log(n)     |             |
| <strong>Rot-Schwarz-Baum</strong>   | log(n)    | log(n)    | log(n)     | log(n)     |             |
| <strong>AVL-Baum</strong>           | log(n)    | log(n)    | log(n)     | log(n)     |             |
| <strong>Bloom-Filter</strong>       | -         | 1         | 1          | -          | False Positives beim Suchen möglich |</p>
<h3>Komplexität der Array-Sortieralgorithmen</h3>
<p>| Name                  | Best            | Durchschnitt        | Schlechtester Fall     | Speicher   | Stabil     | Kommentare  |
| --------------------- | :-------------: | :-----------------:| :--------------------: | :--------: | :--------: | :---------- |
| <strong>Bubble Sort</strong>       | n               | n<sup>2</sup>      | n<sup>2</sup>         | 1          | Ja         |             |
| <strong>Insertion Sort</strong>    | n               | n<sup>2</sup>      | n<sup>2</sup>         | 1          | Ja         |             |
| <strong>Selection Sort</strong>    | n<sup>2</sup>   | n<sup>2</sup>      | n<sup>2</sup>         | 1          | Nein       |             |
| <strong>Heap Sort</strong>         | n log(n)   | n log(n)      | n log(n)         | 1          | Nein       |             |
| <strong>Merge Sort</strong>        | n log(n)   | n log(n)      | n log(n)         | n          | Ja         |             |
| <strong>Quick Sort</strong>        | n log(n)   | n log(n)      | n<sup>2</sup>         | log(n)     | Nein       | Meist In-Place mit O(log(n)) Stack-Speicher |
| <strong>Shell Sort</strong>        | n log(n)   | abhängig von Gap-Sequenz | n (log(n))<sup>2</sup> | 1 | Nein  |             |
| <strong>Counting Sort</strong>     | n + r           | n + r              | n + r                 | n + r      | Ja         | r = größte Zahl im Array |
| <strong>Radix Sort</strong>        | n * k           | n * k              | n * k                 | n + k      | Ja         | k = Länge des längsten Schlüssels |</p>
<h2>Unterstützer des Projekts</h2>
<blockquote>
<p>Sie können dieses Projekt unterstützen über ❤️️ <a href="https://github.com/sponsors/trekhleb">GitHub</a> oder ❤️️ <a href="https://www.patreon.com/trekhleb">Patreon</a>.</p>
</blockquote>
<p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/BACKERS.md">Personen, die dieses Projekt unterstützen</a> <code>∑ = 1</code></p>
<h2>Autor</h2>
<p><a href="https://trekhleb.dev">@trekhleb</a></p>
<p>Weitere <a href="https://trekhleb.dev/projects/">Projekte</a> und <a href="https://trekhleb.dev/blog/">Artikel</a> zu JavaScript und Algorithmen auf <a href="https://trekhleb.dev">trekhleb.dev</a></p>
<hr />
<p><a href="https://github.com/OpenAiTx/OpenAiTx">Powered By OpenAiTx</a></p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>