<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>expr_codegen - wukan1986/expr_codegen</title>
    <meta name="title" content="expr_codegen - wukan1986/expr_codegen">
    <meta name="description" content="wukan1986/expr_codegen - GitHub repository hi documentation and informationexpr_codegen अभिव्यक्ति ट्रांसलेटर परियोजना पृष्ठभूमि मेरे नए जारी किए गए polars_ta लाइब्रेरी के बाद, जब मैं वापस देखता हूँ कि expr_codegen क्या है। expr_codege...">
    <meta name="keywords" content="wukan1986, expr_codegen, GitHub, repository, hi documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/wukan1986/expr_codegen/README-hi.html">
    <meta property="og:title" content="expr_codegen - wukan1986/expr_codegen">
    <meta property="og:description" content="wukan1986/expr_codegen - GitHub repository hi documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/wukan1986/expr_codegen" id="githubRepoLink" target="_blank">wukan1986/expr_codegen</a>
<h1 style="display: none;">expr_codegen अभिव्यक्ति ट्रांसलेटर परियोजना पृष्ठभूमि मेरे नए जारी किए गए polars_ta लाइब्रेरी के बाद, जब मैं वापस देखता हूँ कि expr_codegen क्या है। expr_codege...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>expr_codegen अभिव्यक्ति ट्रांसलेटर</h1>
<h2>परियोजना पृष्ठभूमि</h2>
<p>मेरे नए जारी किए गए <a href="https://github.com/wukan1986/polars_ta">polars_ta</a> लाइब्रेरी के बाद, जब मैं वापस देखता हूँ कि <code>expr_codegen</code> क्या है।</p>
<blockquote>
<p><code>expr_codegen</code> मूल रूप से एक <code>DSL</code> है, अर्थात् डोमेन-विशिष्ट भाषा (Domain Specific Language)। लेकिन इसमें कोई नई सिंटैक्स परिभाषित नहीं की गई है।</p>
</blockquote>
<p>यह दो समस्याओं का समाधान करता है:</p>
<ol>
<li><code>polars_ta</code> पहले ही फीचर गणना अभिव्यक्तियाँ लिखने में बहुत आसान है, लेकिन जब आप 'सीरीज और क्रॉस-सेक्शन' को मिलाकर अभिव्यक्तियाँ बनाते हैं, तो <code>expr_codegen</code> का उपयोग करके स्वतः ग्रुपिंग करके बहुत सारा काम बचाया जा सकता है।</li>
<li><code>expr_codegen</code> <code>Common Subexpression Elimination</code> (सामान्य उप-अभिव्यक्ति उन्मूलन) का उपयोग करता है, जिससे बार-बार की गणना बहुत कम हो जाती है और दक्षता बढ़ती है।</li>
</ol>
<p>भले ही क्वांटिटेटिव क्षेत्र में, शुरुआती शोधकर्ता केवल सीरीज संकेतकों तक सीमित हैं, केवल <code>polars_ta</code> पर्याप्त है; मध्यम और वरिष्ठ शोधकर्ता जब क्रॉस-सेक्शन संकेतकों का उपयोग करते हैं, तो <code>expr_codegen</code> की सिफारिश की जाती है।</p>
<p>हालांकि इस समय यह परियोजना और <code>polars_ta</code> बहुत करीब से जुड़ी हैं, फिर भी यह अन्य लाइब्रेरीज़ जैसे <code>pandas / cudf.pandas</code> में ट्रांसलेट करने को भी सपोर्ट करती है, बस फिलहाल एक सरल लाइब्रेरी की कमी है।</p>
<h2>ऑनलाइन डेमो</h2>
<p>https://exprcodegen.streamlit.app</p>
<p>प्रारंभिक उपयोगकर्ता सीधे इस लिंक पर जाकर अभिव्यक्ति ट्रांसलेट कर सकते हैं, अलग से सॉफ़्टवेयर इंस्टॉल करने की आवश्यकता नहीं है। (यह टूल विदेश में फ्री में डिप्लॉय किया गया है, इसलिए खुलने में थोड़ा समय लग सकता है)</p>
<p>और अधिक संपूर्ण उदाहरणों के लिए देखें <a href="https://github.com/wukan1986/alpha_examples">alpha_examples</a></p>
<h2>उपयोग उदाहरण</h2>
<pre><code class="language-python">import sys
from io import StringIO

import polars as pl

from expr_codegen import codegen_exec


def _code_block_1():
    # फैक्टर एडिटिंग एरिया, यहाँ पर फैक्टर एडिट कर सकते हैं, IDE की स्मार्ट सजेशन का लाभ लें
    LOG_MC_ZS = cs_mad_zscore(log1p(market_cap))


def _code_block_2():
    # टेम्प्लेट में पहले से ही polars_ta.prefix के बहुत सारे ऑपरेटर इम्पोर्ट किए गए हैं,
    # लेकिन talib डिफ़ॉल्ट रूप से इम्पोर्ट नहीं किया गया है। इस तरह की राइटिंग से जनरेटेड कोड में इम्पोर्ट हो जाएगा
    from polars_ta.prefix.talib import ts_LINEARREG_SLOPE  # noqa

    # def और class को भी वैसे ही इम्पोर्ट किया जा सकता है
    def cs_rank_if(condition, factor):
        return cs_rank(if_else(condition, factor, None))

    class Clazz:
        pass

    # 1. अंडरस्कोर से शुरू होने वाले वेरिएबल केवल इंटरमीडिएट वेरिएबल हैं, इन्हें ऑटो-रीनेम किया जाएगा और फाइनल आउटपुट में हटा दिया जाएगा
    # 2. अंडरस्कोर से शुरू होने वाले वेरिएबल दोबारा इस्तेमाल किए जा सकते हैं। कई जटिल फैक्टर मल्टीपल लाइनों में लिखते समय इंटरमीडिएट वेरिएबल्स में कोई कॉन्फ्लिक्ट नहीं होगा
    _avg = ts_mean(corr, 20)
    _std = ts_std_dev(corr, 20)
    _beta = ts_LINEARREG_SLOPE(corr, 20)

    # 3. अंडरस्कोर से शुरू वेरिएबल्स में सर्कुलर असाइनमेंट हो सकता है। डिबगिंग के दौरान कमेंट से जल्दी स्विच कर सकते हैं
    _avg = cs_mad_zscore_resid(_avg, LOG_MC_ZS, ONE)
    _std = cs_mad_zscore_resid(_std, LOG_MC_ZS, ONE)
    # _beta = cs_mad_zscore_resid(_beta, LOG_MC_ZS, ONE)

    _corr = cs_zscore(_avg) + cs_zscore(_std)
    CPV = cs_zscore(_corr) + cs_zscore(_beta)


code = codegen_exec(None, _code_block_1, _code_block_2, over_null='partition_by', output_file=sys.stdout)  # कोड प्रिंट करें
code = codegen_exec(None, _code_block_1, _code_block_2, over_null='partition_by', output_file=&quot;output.py&quot;)  # फाइल में सेव करें
code = codegen_exec(None, _code_block_1, _code_block_2, over_null='partition_by')  # केवल एक्जीक्यूट करें, कोड सेव नहीं होगा

code = StringIO()
codegen_exec(None, _code_block_1, _code_block_2, over_null='partition_by', output_file=code)  # स्ट्रिंग में सेव करें
code.seek(0)
code.read()  # कोड पढ़ें

# TODO: उपयुक्त डेटा से बदलें
df = pl.DataFrame()
df = codegen_exec(df.lazy(), _code_block_1, _code_block_2, over_null='partition_by').collect()  # Lazy CPU
df = codegen_exec(df.lazy(), _code_block_1, _code_block_2, over_null='partition_by').collect(engine=&quot;gpu&quot;)  # Lazy GPU

</code></pre>
<h2>डायरेक्टरी संरचना</h2>
<pre><code class="language-commandline">│  requirements.txt # `pip install -r requirements.txt` से डिपेंडेंसी इंस्टॉल करें
├─data
│      prepare_date.py # डेटा तैयार करें
├─examples
│      demo_express.py # फास्ट-ट्रैक उदाहरण। दिखाता है कैसे एक्सप्रेशन को कोड में बदलें
│      demo_exec_pl.py # ट्रांसलेटेड कोड को कॉल कर प्लॉटिंग का डेमो
│      demo_transformer.py # थर्ड पार्टी एक्सप्रेशन को इंटरनल एक्सप्रेशन में बदलें
│      output.py # रिजल्ट आउटपुट। कोड बदले बिना, अन्य प्रोजेक्ट्स में डायरेक्ट इम्पोर्ट किया जा सकता है
│      show_tree.py # एक्सप्रेशन ट्री ड्रा करें। ऑप्टिमाइजेशन रिजल्ट के विश्लेषण के लिए
│      sympy_define.py # सिंबल डिफ़ाइन, बहुत जगह इस्तेमाल होता है, इसलिए इसे अलग किया गया है
├─expr_codegen
│   │  expr.py # एक्सप्रेशन प्रोसेसिंग के बेसिक फंक्शन्स
│   │  tool.py # कोर टूल कोड
│   ├─polars
│   │  │  code.py # polars सिंटैक्स के लिए कोड जनरेशन
│   │  │  template.py.j2 # `Jinja2` टेम्प्लेट। py फाइल जनरेट करने के लिए, आमतौर पर एडिट करने की ज़रूरत नहीं
│   │  │  printer.py # `Sympy` के `StrPrinter` से इनहेरिटेड, नया फंक्शन जोड़ने पर फाइल एडिट करनी पड़ सकती है
</code></pre>
<h2>कार्यप्रणाली</h2>
<p>यह परियोजना <code>sympy</code> प्रोजेक्ट पर आधारित है। इस्तेमाल किए गए प्रमुख फंक्शन निम्नलिखित हैं:</p>
<ol>
<li><code>simplify</code>: जटिल अभिव्यक्तियों को सरल बनाना</li>
<li><code>cse</code>: <code>Common Subexpression Elimination</code> (सामान्य उप-अभिव्यक्ति उन्मूलन)</li>
<li><code>StrPrinter</code>: अलग-अलग फंक्शन के अनुसार अलग-अलग स्ट्रिंग आउटपुट। इसे कस्टमाइज कर अन्य भाषाओं या लाइब्रेरीज़ को सपोर्ट किया जा सकता है</li>
</ol>
<p>क्योंकि <code>groupby</code>, <code>sort</code> दोनों ही समय लेने वाले ऑपरेशन हैं। अगर पहले से ही फॉर्मूला को वर्गीकृत कर लें और अलग-अलग कैटेगरी के लिए अलग-अलग <code>groupby</code> करें, तो गणना का समय कम हो जाएगा।</p>
<ol>
<li><code>ts_xxx(ts_xxx)</code>: एक ही <code>groupby</code> में गणना की जा सकती है</li>
<li><code>cs_xxx(cs_xxx)</code>: एक ही <code>groupby</code> में गणना की जा सकती है</li>
<li><code>ts_xxx(cs_xxx)</code>: अलग-अलग <code>groupby</code> में गणना करनी होगी</li>
<li><code>cs_xxx(ts_xxx(cs_xxx))</code>: तीन अलग-अलग <code>groupby</code> में गणना करनी होगी</li>
<li><code>gp_xxx(aa, )+gp_xxx(bb, )</code>: क्योंकि <code>aa</code>, <code>bb</code> अलग हैं, दो अलग-अलग <code>groupby</code> में गणना करनी होगी</li>
</ol>
<p>इसलिए</p>
<ol>
<li>एक फंक्शन होना चाहिए जो वर्तमान एक्सप्रेशन की कैटेगरी (<code>get_current</code>) और सब-एक्सप्रेशन की कैटेगरी (<code>get_children</code>) निकाल सके</li>
<li>अगर वर्तमान कैटेगरी और चाइल्ड कैटेगरी अलग है, तो शॉर्ट फॉर्मूला (<code>extract</code>) निकाला जा सकता है। अलग-अलग लेयर के एक ही कैटेगरी के एक्सप्रेशन्स में ऑर्डर महत्वपूर्ण है, एक ही <code>groupby</code> में नहीं रखा जा सकता</li>
<li><code>cse</code> के गुणों का उपयोग करते हुए, लंबे एक्सप्रेशन को पहले निकाले गए शॉर्ट एक्सप्रेशन से बदलें। फिर इसे डायरेक्टेड एसाइक्लिक ग्राफ (<code>DAG</code>) में डाल दें</li>
<li>DAG की स्ट्रीमिंग का उपयोग कर लेयरिंग करें। एक ही लेयर के <code>ts</code>, <code>cs</code>, <code>gp</code> का ऑर्डर कोई मायने नहीं रखता</li>
<li>एक ही लेयर पर <code>ts</code>, <code>cs</code>, <code>gp</code> को ग्रुप करें, फिर कोड जनरेट (<code>codegen</code>) करें</li>
</ol>
<p>इनफॉर्मेशन छिपी हुई:</p>
<ol>
<li><code>ts</code>: sort(by=[ASSET, DATE]).groupby(by=[ASSET], maintain_order=True)</li>
<li><code>cs</code>: sort(by=[DATE]).groupby(by=[DATE], maintain_order=False)</li>
<li><code>gp</code>: sort(by=[DATE, GROUP]).groupby(by=[DATE, GROUP], maintain_order=False)</li>
</ol>
<p>अर्थात्</p>
<ol>
<li>सीरीज फंक्शन में दो फील्ड्स <code>ASSET, DATE</code> छिपे होते हैं, क्रॉस-सेक्शन फंक्शन में एक फील्ड <code>DATE</code> छिपा होता है</li>
<li>ग्रुप फंक्शन में एक फील्ड <code>GROUP</code> जोड़ता है, और एक फील्ड <code>DATE</code> छुपा रहता है</li>
</ol>
<p>दो वर्गीकरण विधियाँ</p>
<ol>
<li>ऑपरेटर प्रीफिक्स के अनुसार (<code>get_current_by_prefix</code>), ऑपरेटर को <code>ts_</code>, <code>cs_</code>, <code>gp_</code> से शुरू करना जरूरी है</li>
<li>ऑपरेटर के पूरे नाम के अनुसार (<code>get_current_by_name</code>), ऑपरेटर नाम की कोई पाबंदी नहीं। जैसे <code>cs_rank</code> को <code>rank</code> भी कहा जा सकता है</li>
</ol>
<h2>Null प्रबंधन</h2>
<p><code>null</code> कैसे उत्पन्न होता है?</p>
<ol>
<li>सस्पेंशन के कारण। गणना से पहले फिल्टर कर देते हैं, आगे की गणना पर असर नहीं पड़ता</li>
<li>अलग-अलग इंस्ट्रूमेंट्स के ट्रेडिंग टाइम अलग होते हैं</li>
<li>गणना से उत्पन्न। सीरीज के दोनों सिरों पर <code>null</code> का असर नहीं, लेकिन बीच में आने पर असर पड़ता है। उदाहरण: <code>if_else(close&lt;2, None, close)</code></li>
</ol>
<p>https://github.com/pola-rs/polars/issues/12925#issuecomment-2552764629</p>
<p>बहुत अच्छा आइडिया, इसका सारांश दो प्रकार से किया जा सकता है:</p>
<ol>
<li><code>null</code> को एक ग्रुप में, <code>not_null</code> को एक और ग्रुप में। दो बार कॉल करना होगा</li>
<li>केवल एक ग्रुप, लेकिन मिश्रित सॉर्टिंग, <code>null</code> आगे, <code>not_null</code> बाद में। एक बार कॉल करें, थोड़ा तेज</li>
</ol>
<pre><code class="language-python">X1 = (ts_returns(CLOSE, 3)).over(CLOSE.is_not_null(), _ASSET_, order_by=_DATE_),
X2 = (ts_returns(CLOSE, 3)).over(_ASSET_, order_by=[CLOSE.is_not_null(), _DATE_]),
X3 = (ts_returns(CLOSE, 3)).over(_ASSET_, order_by=_DATE_),
</code></pre>
<p>दूसरे तरीके में शुरू के <code>null</code> क्षेत्र का असर ऑपरेटर पर निर्भर करता है, खासकर जब मल्टीपल कॉलम्स इनपुट हों, तो <code>null</code> क्षेत्र में भी डेटा हो सकता है</p>
<ol>
<li><code>over_null='partition_by'</code>। दो क्षेत्रों में विभाजित करें</li>
<li><code>over_null='order_by'</code>। एक क्षेत्र, <code>null</code> आगे</li>
<li><code>over_null=None</code>। कोई प्रोसेसिंग नहीं, डायरेक्ट कॉल करें, तेज। अगर निश्चित है कि बीच में <code>null</code> नहीं बनेगा तो यह पैरामीटर इस्तेमाल करें</li>
</ol>
<p><code>codegen_exec(over_null='partition_by')</code> से ग्लोबली <code>partition_by</code> का उपयोग होता है। लेकिन <code>ts_count_nulls</code> जैसे <code>null</code> फंक्शन पर <code>over_null=None</code> देना पड़ता है, इसलिए इस टूल में सिंगल-लाइन एक्सप्रेशन पैरामीटर के लिए कमेंट फंक्शन भी है</p>
<ol>
<li><code># --over_null partition_by</code>। सिंगल लाइन में <code>over_null='partition_by'</code></li>
<li><code># --over_null=order_by</code>। सिंगल लाइन में <code>over_null='order_by'</code></li>
<li><code># --over_null</code>। सिंगल लाइन में <code>over_null=None</code></li>
<li><code># </code>। <code>codegen_exec</code> से आए पैरामीटर का मान लें</li>
</ol>
<p>ध्यान दें:</p>
<ol>
<li><p><code># --over_null</code> कमेंट केवल सिंगल-लाइन एक्सप्रेशन के आखिर में होनी चाहिए, अलग लाइन पर न लिखें, वरना इग्नोर हो जाएगा</p>
</li>
<li><p><code># --over_null # --over_null=order_by</code> जैसे एक से ज्यादा <code>#</code> हों, तो केवल पहला वैलिड होगा</p>
</li>
<li><p>केवल सबसे बाहरी <code>ts</code> फंक्शन पर असर होगा। अगर <code>ts</code> बाहर नहीं है, तो मैन्युअली निकालें। उदाहरण:</p>
<pre><code class="language-python">X1 = cs_rank(ts_mean(CLOSE, 3)) # --over_null=order_by # cs_rank पर लागू होगा, कोई मतलब नहीं
X2 = ts_rank(ts_mean(CLOSE, 3), 5) # --over_null=order_by # सोचा था ts_rank(ts_mean) पर लागू होगा, लेकिन cse के कारण असल में ts_rank(_x_0) पर लागू होता है
</code></pre>
<p>इसे ऐसे लिखें:</p>
<pre><code class="language-python">_x_0 = ts_mean(CLOSE, 3)  # --over_null=order_by 
X1 = cs_rank(_x_0)
X2 = ts_rank(_x_0, 5)
</code></pre>
</li>
<li><p>चूंकि गड़बड़ी की संभावना रहती है, <code>output_file</code> जनरेट करने की सिफारिश की जाती है, ताकि जनरेटेड कोड सही है या नहीं, जांच सकें</p>
</li>
</ol>
<h2><code>expr_codegen</code> की सीमाएँ</h2>
<ol>
<li><code>DAG</code> केवल कॉलम जोड़ सकता है, डिलीट नहीं कर सकता। एक ही नाम के कॉलम होने पर नया वाला ओवरराइट कर देता है</li>
<li><code>रो डिलीट</code> सपोर्ट नहीं, लेकिन डिलीट मार्कर कॉलम जोड़ सकते हैं, बाद में बाहर से रो डिलीट कर सकते हैं। डिलीट से सभी कॉलम प्रभावित होते हैं, <code>DAG</code> के साथ मेल नहीं खाता</li>
<li><code>रीसैंपलिंग</code> सपोर्ट नहीं, कारण वही है कि रो डिलीट सपोर्ट नहीं। बाहर से करना होगा</li>
<li><code>रो डिलीट</code> और <code>रीसैंपलिंग</code> को विभाजक के रूप में मान सकते हैं, एक बड़ा कोड ब्लॉक कई <code>DAG</code> से जोड़ सकते हैं। जटिल और समझना मुश्किल, इसलिए इम्प्लीमेंट नहीं किया गया</li>
</ol>
<h2>विशेष सिंटैक्स</h2>
<ol>
<li><code>C?T:F</code> टर्नरी एक्सप्रेशन सपोर्ट (सिर्फ स्ट्रिंग में), यह बेस में <code>C or True if( T )else F</code> में बदलेगा, फिर <code>T if C else F</code> में बदलेगा, अंत में <code>if_else(C,T,F)</code> में। <code>if else</code> के साथ मिक्स कर सकते हैं</li>
<li><code>(A&lt;B)*-1</code>, बेस में <code>int_(A&lt;B)*-1</code> में बदला जाएगा</li>
<li><code>A==B</code> को <code>sympy</code> द्वारा <code>False</code> में बदलने से बचाने के लिए, बेस में इसे <code>Eq(A,B)</code> में बदला जाएगा</li>
<li><code>A^B</code> का अर्थ <code>convert_xor</code> पैरामीटर पर निर्भर, <code>convert_xor=True</code> हो तो <code>Pow(A,B)</code> में बदलेगा, वरना <code>Xor(A,B)</code> में। डिफ़ॉल्ट <code>False</code>, पावर के लिए <code>**</code> का इस्तेमाल करें</li>
<li><code>A&amp;B&amp;C</code> सपोर्टेड, लेकिन <code>A==B==C</code> सपोर्टेड नहीं। अगर C बूलियन है, AB वैल्यू है, तो मैन्युअली <code>(A==B)==C</code> में बदलें। अगर ABC सभी वैल्यू हैं, तो <code>(A==B)&amp;(B==C)</code> में बदलें</li>
<li><code>A&lt;=B&lt;=C</code> सपोर्ट नहीं, मैन्युअली <code>(A&lt;=B)&amp;(B&lt;=C)</code> में बदलें</li>
<li><code>A[0]+B[1]+C[2]</code> सपोर्टेड, बेस में <code>A+ts_delay(B,1)+ts_delay(C,2)</code> में बदलेगा</li>
<li><code>~A</code> सपोर्टेड, बेस में <code>Not(A)</code> में बदलेगा</li>
<li><code>gp_</code> से शुरू फंक्शन हमेशा संबंधित <code>cs_</code> फंक्शन लौटाएंगे। जैसे <code>gp_func(A,B,C)</code> को <code>cs_func(B,C)</code> में बदला जाएगा, जहाँ <code>A</code> का उपयोग <code>groupby([date, A])</code> में होगा</li>
<li><code>A,B,C=MACD()</code> ट्यूपल अनपैकिंग सपोर्टेड, बेस में बदलेगा</li>
</ol>
<pre><code class="language-python">_x_0 = MACD()
A = unpack(_x_0, 0)
B = unpack(_x_0, 1)
C = unpack(_x_0, 2)
</code></pre>
<ol start="11">
<li>सिंगल लाइन कमेंट में पैरामीटर इनपुट सपोर्ट, जैसे: <code># --over_null</code>, <code># --over_null=order_by</code>, <code># --over_null=partition_by</code></li>
<li>कोड ब्लॉक में, <code>import</code>, <code>def</code>, <code>class</code> सिंटैक्स ऑटोमेटिकली वैसे के वैसे जनरेटेड कोड में इन्सर्ट हो जाते हैं</li>
</ol>
<h2>अंडरस्कोर से शुरू वेरिएबल्स</h2>
<ol>
<li>आउटपुट डेटा में, सभी <code>_</code> से शुरू कॉलम्स अंत में ऑटो डिलीट कर दिए जाएंगे। इसलिए जो वैरिएबल रखना है, उसका नाम <code>_</code> से शुरू न करें</li>
<li>रिपीटेड कैलकुलेशन कम करने के लिए, इंटरमीडिएट वेरिएबल्स ऑटो ऐड किए जाते हैं, <code>_x_</code> से शुरू, जैसे <code>_x_0</code>, <code>_x_1</code> आदि। ये भी अंत में डिलीट हो जाएंगे</li>
<li>सिंगल लाइन एक्सप्रेशन बहुत लंबा हो या रिपीटेड कैलकुलेशन हो, तो इंटरमीडिएट वेरिएबल्स से मल्टी-लाइन बना सकते हैं। अगर इंटरमीडिएट वेरिएबल <code>_</code> से शुरू है, तो ऑटो नंबरिंग होगी, जैसे <code>_A</code> को <code>_A_0_</code>, <code>_A_1_</code> आदि में बदल दिया जाएगा। इस्तेमाल के मामले:
<ol>
<li>एक ही नाम का वेरिएबल दोबारा इस्तेमाल, असल में अलग-अलग वेरिएबल्स</li>
<li>सर्कुलर असाइनमेंट, लेकिन <code>DAG</code> में सर्कल नहीं होता। <code>=</code> के दोनों तरफ एक ही नाम, लेकिन असल में अलग वेरिएबल्स</li>
</ol>
</li>
</ol>
<h2>ट्रांसलेटेड आउटपुट उदाहरण</h2>
<p>ट्रांसलेटेड कोड का एक स्निपेट, पूरा कोड <a href="examples/output_polars.py">Polars वर्शन</a> देखें</p>
<pre><code class="language-python">def func_0_ts__asset(df: pl.DataFrame) -&gt; pl.DataFrame:
    df = df.sort(by=[_DATE_])
    # ========================================
    df = df.with_columns(
        _x_0=1 / ts_delay(OPEN, -1),
        LABEL_CC_1=(-CLOSE + ts_delay(CLOSE, -1)) / CLOSE,
    )
    # ========================================
    df = df.with_columns(
        LABEL_OO_1=_x_0 * ts_delay(OPEN, -2) - 1,
        LABEL_OO_2=_x_0 * ts_delay(OPEN, -3) - 1,
    )
    return df
</code></pre>
<p>ट्रांसलेटेड कोड का एक स्निपेट, पूरा कोड <a href="examples/output_pandas.py">Pandas वर्शन</a> देखें</p>
<pre><code class="language-python">def func_2_cs__date(df: pd.DataFrame) -&gt; pd.DataFrame:
    # expr_4 = cs_rank(x_7)
    df[&quot;expr_4&quot;] = (df[&quot;x_7&quot;]).rank(pct=True)
    return df


def func_3_ts__asset__date(df: pd.DataFrame) -&gt; pd.DataFrame:
    # expr_5 = -ts_corr(OPEN, CLOSE, 10)
    df[&quot;expr_5&quot;] = -(df[&quot;OPEN&quot;]).rolling(10).corr(df[&quot;CLOSE&quot;])
    # expr_6 = ts_delta(OPEN, 10)
    df[&quot;expr_6&quot;] = df[&quot;OPEN&quot;].diff(10)
    return df

</code></pre>
<h2>लोकल डिप्लॉयमेंट इंटरएक्टिव वेबपेज</h2>
<p>सिर्फ <code>streamlit run streamlit_app.py</code> चलाएँ</p>
<hr />
<p><a href="https://github.com/OpenAiTx/OpenAiTx">Powered By OpenAiTx</a> - 2025-06-07</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>