<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>storm - asdine/storm</title>
    <meta name="title" content="storm - asdine/storm">
    <meta name="description" content="asdine/storm - GitHub repository de documentation and informationStorm Storm ist ein einfaches und leistungsfähiges Toolkit für BoltDB. Im Wesentlichen bietet Storm Indizes, eine Vielzahl von Methoden zum Speichern und Abrufen von Daten, ein fortschrittliches Abfragesystem und vieles mehr. Zusätzlich zu den untenstehenden Beispielen siehe auch die Beispiele im GoDoc. Für erweiterte Abfragen und Unterstützung für Badger, siehe auch Genji Inhaltsverzeichnis Erste Schritte Storm importieren Eine Datenbank öffnen Einfaches CRUD-System Strukturen deklarieren Objekt speichern Auto-Inkrement Einfache Abfragen Ein Objekt abrufen Mehrere Objekte abrufen Alle Objekte abrufen Alle Objekte nach Index sortiert abrufen Einen Bereich von Objekten abrufen Objekte nach Präfix abrufen Überspringen, Limit und Umkehren Ein Objekt löschen Ein Objekt aktualisieren Buckets und Indizes initialisieren, bevor ein Objekt gespeichert wird Einen Bucket löschen Einen Bucket neu indexieren Erweiterte Abfragen Transaktionen Optionen BoltOptions MarshalUnmarshaler Bereitgestellte Codecs Vorhandene Bolt-Verbindung verwenden Batch-Modus Nodes und verschachtelte Buckets Node-Optionen Einfacher Key/Value-Store BoltDB Lizenz Credits Erste Schritte GO111MODULE=on go get -u github.com/asdine/storm/v3 Storm importieren...">
    <meta name="keywords" content="asdine, storm, GitHub, repository, de documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/asdine/storm/README-de.html">
    <meta property="og:title" content="storm - asdine/storm">
    <meta property="og:description" content="asdine/storm - GitHub repository de documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/asdine/storm" id="githubRepoLink" target="_blank">asdine/storm</a>
<br>
<h1 style="display: none;">Storm Storm ist ein einfaches und leistungsfähiges Toolkit für BoltDB. Im Wesentlichen bietet Storm Indizes, eine Vielzahl von Methoden zum Speichern und Abrufen von Daten, ein fortschrittliches Abfragesystem und vieles mehr. Zusätzlich zu den untenstehenden Beispielen siehe auch die Beispiele im GoDoc. Für erweiterte Abfragen und Unterstützung für Badger, siehe auch Genji Inhaltsverzeichnis Erste Schritte Storm importieren Eine Datenbank öffnen Einfaches CRUD-System Strukturen deklarieren Objekt speichern Auto-Inkrement Einfache Abfragen Ein Objekt abrufen Mehrere Objekte abrufen Alle Objekte abrufen Alle Objekte nach Index sortiert abrufen Einen Bereich von Objekten abrufen Objekte nach Präfix abrufen Überspringen, Limit und Umkehren Ein Objekt löschen Ein Objekt aktualisieren Buckets und Indizes initialisieren, bevor ein Objekt gespeichert wird Einen Bucket löschen Einen Bucket neu indexieren Erweiterte Abfragen Transaktionen Optionen BoltOptions MarshalUnmarshaler Bereitgestellte Codecs Vorhandene Bolt-Verbindung verwenden Batch-Modus Nodes und verschachtelte Buckets Node-Optionen Einfacher Key/Value-Store BoltDB Lizenz Credits Erste Schritte GO111MODULE=on go get -u github.com/asdine/storm/v3 Storm importieren...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>Storm</h1>
<p><a href="https://travis-ci.org/asdine/storm"><img src="https://travis-ci.org/asdine/storm.svg" alt="Build Status" /></a>
<a href="https://godoc.org/github.com/asdine/storm"><img src="https://godoc.org/github.com/asdine/storm?status.svg" alt="GoDoc" /></a></p>
<p>Storm ist ein einfaches und leistungsfähiges Toolkit für <a href="https://github.com/coreos/bbolt">BoltDB</a>. Im Wesentlichen bietet Storm Indizes, eine Vielzahl von Methoden zum Speichern und Abrufen von Daten, ein fortschrittliches Abfragesystem und vieles mehr.</p>
<p>Zusätzlich zu den untenstehenden Beispielen siehe auch die <a href="https://godoc.org/github.com/asdine/storm#pkg-examples">Beispiele im GoDoc</a>.</p>
<p><em>Für erweiterte Abfragen und Unterstützung für <a href="https://github.com/dgraph-io/badger">Badger</a>, siehe auch <a href="https://github.com/asdine/genji">Genji</a></em></p>
<h2>Inhaltsverzeichnis</h2>
<ul>
<li><a href="#getting-started">Erste Schritte</a></li>
<li><a href="#import-storm">Storm importieren</a></li>
<li><a href="#open-a-database">Eine Datenbank öffnen</a></li>
<li><a href="#simple-crud-system">Einfaches CRUD-System</a>
<ul>
<li><a href="#declare-your-structures">Strukturen deklarieren</a></li>
<li><a href="#save-your-object">Objekt speichern</a>
<ul>
<li><a href="#auto-increment">Auto-Inkrement</a></li>
</ul>
</li>
<li><a href="#simple-queries">Einfache Abfragen</a>
<ul>
<li><a href="#fetch-one-object">Ein Objekt abrufen</a></li>
<li><a href="#fetch-multiple-objects">Mehrere Objekte abrufen</a></li>
<li><a href="#fetch-all-objects">Alle Objekte abrufen</a></li>
<li><a href="#fetch-all-objects-sorted-by-index">Alle Objekte nach Index sortiert abrufen</a></li>
<li><a href="#fetch-a-range-of-objects">Einen Bereich von Objekten abrufen</a></li>
<li><a href="#fetch-objects-by-prefix">Objekte nach Präfix abrufen</a></li>
<li><a href="#skip-limit-and-reverse">Überspringen, Limit und Umkehren</a></li>
<li><a href="#delete-an-object">Ein Objekt löschen</a></li>
<li><a href="#update-an-object">Ein Objekt aktualisieren</a></li>
<li><a href="#initialize-buckets-and-indexes-before-saving-an-object">Buckets und Indizes initialisieren, bevor ein Objekt gespeichert wird</a></li>
<li><a href="#drop-a-bucket">Einen Bucket löschen</a></li>
<li><a href="#re-index-a-bucket">Einen Bucket neu indexieren</a></li>
</ul>
</li>
<li><a href="#advanced-queries">Erweiterte Abfragen</a></li>
<li><a href="#transactions">Transaktionen</a></li>
<li><a href="#options">Optionen</a>
<ul>
<li><a href="#boltoptions">BoltOptions</a></li>
<li><a href="#marshalunmarshaler">MarshalUnmarshaler</a>
<ul>
<li><a href="#provided-codecs">Bereitgestellte Codecs</a></li>
</ul>
</li>
<li><a href="#use-existing-bolt-connection">Vorhandene Bolt-Verbindung verwenden</a></li>
<li><a href="#batch-mode">Batch-Modus</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#nodes-and-nested-buckets">Nodes und verschachtelte Buckets</a>
<ul>
<li><a href="#node-options">Node-Optionen</a></li>
</ul>
</li>
<li><a href="#simple-keyvalue-store">Einfacher Key/Value-Store</a></li>
<li><a href="#boltdb">BoltDB</a></li>
<li><a href="#license">Lizenz</a></li>
<li><a href="#credits">Credits</a></li>
</ul>
<h2>Erste Schritte</h2>
<pre><code class="language-bash">GO111MODULE=on go get -u github.com/asdine/storm/v3
</code></pre>
<h2>Storm importieren</h2>
<pre><code class="language-go">import &quot;github.com/asdine/storm/v3&quot;
</code></pre>
<h2>Eine Datenbank öffnen</h2>
<p>Schneller Weg, eine Datenbank zu öffnen</p>
<pre><code class="language-go">db, err := storm.Open(&quot;my.db&quot;)

defer db.Close()
</code></pre>
<p><code>Open</code> kann mehrere Optionen erhalten, um das Verhalten anzupassen. Siehe <a href="#options">Optionen</a> unten.</p>
<h2>Einfaches CRUD-System</h2>
<h3>Strukturen deklarieren</h3>
<pre><code class="language-go">type User struct {
  ID int // Primärschlüssel
  Group string `storm:&quot;index&quot;` // dieses Feld wird indexiert
  Email string `storm:&quot;unique&quot;` // dieses Feld wird mit einem Unique-Constraint indexiert
  Name string // dieses Feld wird nicht indexiert
  Age int `storm:&quot;index&quot;`
}
</code></pre>
<p>Der Primärschlüssel kann jeden Typ haben, solange er keinen Nullwert hat. Storm sucht nach dem Tag <code>id</code>, falls nicht vorhanden, sucht Storm nach einem Feld mit dem Namen <code>ID</code>.</p>
<pre><code class="language-go">type User struct {
  ThePrimaryKey string `storm:&quot;id&quot;`// Primärschlüssel
  Group string `storm:&quot;index&quot;` // dieses Feld wird indexiert
  Email string `storm:&quot;unique&quot;` // dieses Feld wird mit einem Unique-Constraint indexiert
  Name string // dieses Feld wird nicht indexiert
}
</code></pre>
<p>Storm verarbeitet Tags in verschachtelten Strukturen mit dem Tag <code>inline</code>.</p>
<pre><code class="language-go">type Base struct {
  Ident bson.ObjectId `storm:&quot;id&quot;`
}

type User struct {
  Base      `storm:&quot;inline&quot;`
  Group     string `storm:&quot;index&quot;`
  Email     string `storm:&quot;unique&quot;`
  Name      string
  CreatedAt time.Time `storm:&quot;index&quot;`
}
</code></pre>
<h3>Objekt speichern</h3>
<pre><code class="language-go">user := User{
  ID: 10,
  Group: &quot;staff&quot;,
  Email: &quot;john@provider.com&quot;,
  Name: &quot;John&quot;,
  Age: 21,
  CreatedAt: time.Now(),
}

err := db.Save(&amp;user)
// err == nil

user.ID++
err = db.Save(&amp;user)
// err == storm.ErrAlreadyExists
</code></pre>
<p>Das war's.</p>
<p><code>Save</code> erstellt oder aktualisiert alle erforderlichen Indizes und Buckets, prüft die Unique-Constraints und speichert das Objekt im Store.</p>
<h4>Auto-Inkrement</h4>
<p>Storm kann Integer-Werte automatisch inkrementieren, sodass Sie sich beim Speichern Ihrer Objekte darum nicht kümmern müssen. Der neue Wert wird auch automatisch in Ihr Feld eingetragen.</p>
<pre><code class="language-go">
type Product struct {
  Pk                  int `storm:&quot;id,increment&quot;` // Primärschlüssel mit Auto-Inkrement
  Name                string
  IntegerField        uint64 `storm:&quot;increment&quot;`
  IndexedIntegerField uint32 `storm:&quot;index,increment&quot;`
  UniqueIntegerField  int16  `storm:&quot;unique,increment=100&quot;` // Startwert kann gesetzt werden
}

p := Product{Name: &quot;Vaccum Cleaner&quot;}

fmt.Println(p.Pk)
fmt.Println(p.IntegerField)
fmt.Println(p.IndexedIntegerField)
fmt.Println(p.UniqueIntegerField)
// 0
// 0
// 0
// 0

_ = db.Save(&amp;p)

fmt.Println(p.Pk)
fmt.Println(p.IntegerField)
fmt.Println(p.IndexedIntegerField)
fmt.Println(p.UniqueIntegerField)
// 1
// 1
// 1
// 100

</code></pre>
<h3>Einfache Abfragen</h3>
<p>Jedes Objekt kann abgerufen werden, egal ob indexiert oder nicht. Storm verwendet Indizes, wenn verfügbar, andernfalls das <a href="#advanced-queries">Abfragesystem</a>.</p>
<h4>Ein Objekt abrufen</h4>
<pre><code class="language-go">var user User
err := db.One(&quot;Email&quot;, &quot;john@provider.com&quot;, &amp;user)
// err == nil

err = db.One(&quot;Name&quot;, &quot;John&quot;, &amp;user)
// err == nil

err = db.One(&quot;Name&quot;, &quot;Jack&quot;, &amp;user)
// err == storm.ErrNotFound
</code></pre>
<h4>Mehrere Objekte abrufen</h4>
<pre><code class="language-go">var users []User
err := db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users)
</code></pre>
<h4>Alle Objekte abrufen</h4>
<pre><code class="language-go">var users []User
err := db.All(&amp;users)
</code></pre>
<h4>Alle Objekte sortiert nach Index abrufen</h4>
<pre><code class="language-go">var users []User
err := db.AllByIndex(&quot;CreatedAt&quot;, &amp;users)
</code></pre>
<h4>Einen Bereich von Objekten abrufen</h4>
<pre><code class="language-go">var users []User
err := db.Range(&quot;Age&quot;, 10, 21, &amp;users)
</code></pre>
<h4>Objekte nach Präfix abrufen</h4>
<pre><code class="language-go">var users []User
err := db.Prefix(&quot;Name&quot;, &quot;Jo&quot;, &amp;users)
</code></pre>
<h4>Skip, Limit und Reverse</h4>
<pre><code class="language-go">var users []User
err := db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Skip(10))
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Limit(10))
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Reverse())
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())

err = db.All(&amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
err = db.AllByIndex(&quot;CreatedAt&quot;, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
err = db.Range(&quot;Age&quot;, 10, 21, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
</code></pre>
<h4>Ein Objekt löschen</h4>
<pre><code class="language-go">err := db.DeleteStruct(&amp;user)
</code></pre>
<h4>Ein Objekt aktualisieren</h4>
<pre><code class="language-go">// Mehrere Felder aktualisieren
// Funktioniert nur für Felder mit Nicht-Null-Werten (z.B. Name darf nicht &quot;&quot;, Alter darf nicht 0 sein)
err := db.Update(&amp;User{ID: 10, Name: &quot;Jack&quot;, Age: 45})

// Ein einzelnes Feld aktualisieren
// Funktioniert auch für Nullwerte (0, false, &quot;&quot;, ...)
err := db.UpdateField(&amp;User{ID: 10}, &quot;Age&quot;, 0)
</code></pre>
<h4>Buckets und Indizes initialisieren, bevor ein Objekt gespeichert wird</h4>
<pre><code class="language-go">err := db.Init(&amp;User{})
</code></pre>
<p>Nützlich beim Starten Ihrer Anwendung</p>
<h4>Einen Bucket löschen</h4>
<p>Mit der Struct</p>
<pre><code class="language-go">err := db.Drop(&amp;User)
</code></pre>
<p>Mit dem Bucket-Namen</p>
<pre><code class="language-go">err := db.Drop(&quot;User&quot;)
</code></pre>
<h4>Einen Bucket neu indexieren</h4>
<pre><code class="language-go">err := db.ReIndex(&amp;User{})
</code></pre>
<p>Nützlich, wenn sich die Struktur geändert hat</p>
<h3>Erweiterte Abfragen</h3>
<p>Für komplexere Abfragen können Sie die Methode <code>Select</code> verwenden.
<code>Select</code> nimmt eine beliebige Anzahl von <a href="https://godoc.org/github.com/asdine/storm/q#Matcher"><code>Matcher</code></a> aus dem <a href="https://godoc.org/github.com/asdine/storm/q"><code>q</code></a>-Paket entgegen.</p>
<p>Hier sind einige gängige Matcher:</p>
<pre><code class="language-go">// Gleichheit
q.Eq(&quot;Name&quot;, John)

// Streng größer als
q.Gt(&quot;Age&quot;, 7)

// Kleiner oder gleich
q.Lte(&quot;Age&quot;, 77)

// Regex mit Namen, der mit dem Buchstaben D beginnt
q.Re(&quot;Name&quot;, &quot;^D&quot;)

// In der angegebenen Slice von Werten
q.In(&quot;Group&quot;, []string{&quot;Staff&quot;, &quot;Admin&quot;})

// Felder vergleichen
q.EqF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.LtF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.GtF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.LteF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.GteF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
</code></pre>
<p>Matcher können auch mit <code>And</code>, <code>Or</code> und <code>Not</code> kombiniert werden:</p>
<pre><code class="language-go">
// Treffer, wenn alle zutreffen
q.And(
  q.Gt(&quot;Age&quot;, 7),
  q.Re(&quot;Name&quot;, &quot;^D&quot;)
)

// Treffer, wenn einer zutrifft
q.Or(
  q.Re(&quot;Name&quot;, &quot;^A&quot;),
  q.Not(
    q.Re(&quot;Name&quot;, &quot;^B&quot;)
  ),
  q.Re(&quot;Name&quot;, &quot;^C&quot;),
  q.In(&quot;Group&quot;, []string{&quot;Staff&quot;, &quot;Admin&quot;}),
  q.And(
    q.StrictEq(&quot;Password&quot;, []byte(password)),
    q.Eq(&quot;Registered&quot;, true)
  )
)
</code></pre>
<p>Die vollständige Liste finden Sie in der <a href="https://godoc.org/github.com/asdine/storm/q#Matcher">Dokumentation</a>.</p>
<p><code>Select</code> nimmt beliebig viele Matcher und fasst sie in einem <code>q.And()</code> zusammen, daher ist es nicht notwendig, dies explizit anzugeben. Es gibt einen <a href="https://godoc.org/github.com/asdine/storm#Query"><code>Query</code></a>-Typ zurück.</p>
<pre><code class="language-go">query := db.Select(q.Gte(&quot;Age&quot;, 7), q.Lte(&quot;Age&quot;, 77))
</code></pre>
<p>Der <code>Query</code>-Typ enthält Methoden zum Filtern und Sortieren der Datensätze.</p>
<pre><code class="language-go">// Limit
query = query.Limit(10)

// Skip
query = query.Skip(20)

// Aufrufe können auch verkettet werden
query = query.Limit(10).Skip(20).OrderBy(&quot;Age&quot;).Reverse()
</code></pre>
<p>Aber auch, um festzulegen, wie sie abgerufen werden.</p>
<pre><code class="language-go">var users []User
err = query.Find(&amp;users)

var user User
err = query.First(&amp;user)
</code></pre>
<p>Beispiele mit <code>Select</code>:</p>
<pre><code class="language-go">// Alle Benutzer mit einer ID zwischen 10 und 100 finden
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Find(&amp;users)

// Verschachtelte Matcher
err = db.Select(q.Or(
  q.Gt(&quot;ID&quot;, 50),
  q.Lt(&quot;Age&quot;, 21),
  q.And(
    q.Eq(&quot;Group&quot;, &quot;admin&quot;),
    q.Gte(&quot;Age&quot;, 21),
  ),
)).Find(&amp;users)

query := db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;)

// Mehrere Datensätze finden
err = query.Find(&amp;users)
// oder
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;).Find(&amp;users)
</code></pre>
<p>// Ersten Datensatz finden
err = query.First(&amp;user)
// oder
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;).First(&amp;user)</p>
<p>// Alle passenden Datensätze löschen
err = query.Delete(new(User))</p>
<p>// Datensätze einzeln abrufen (nützlich, wenn der Bucket viele Datensätze enthält)
query = db.Select(q.Gte(&quot;ID&quot;, 10),q.Lte(&quot;ID&quot;, 100)).OrderBy(&quot;Age&quot;, &quot;Name&quot;)</p>
<p>err = query.Each(new(User), func(record interface{}) error) {
u := record.(*User)
...
return nil
}</p>
<pre><code>
Siehe die [Dokumentation](https://godoc.org/github.com/asdine/storm#Query) für eine vollständige Liste der Methoden.

### Transaktionen

```go
tx, err := db.Begin(true)
if err != nil {
  return err
}
defer tx.Rollback()

accountA.Amount -= 100
accountB.Amount += 100

err = tx.Save(accountA)
if err != nil {
  return err
}

err = tx.Save(accountB)
if err != nil {
  return err
}

return tx.Commit()
</code></pre>
<h3>Optionen</h3>
<p>Storm-Optionen sind Funktionen, die beim Erstellen einer Storm-Instanz übergeben werden können. Sie können beliebig viele Optionen übergeben.</p>
<h4>BoltOptions</h4>
<p>Standardmäßig öffnet Storm eine Datenbank mit dem Modus <code>0600</code> und einem Timeout von einer Sekunde.
Dieses Verhalten kann mit <code>BoltOptions</code> geändert werden.</p>
<pre><code class="language-go">db, err := storm.Open(&quot;my.db&quot;, storm.BoltOptions(0600, &amp;bolt.Options{Timeout: 1 * time.Second}))
</code></pre>
<h4>MarshalUnmarshaler</h4>
<p>Um die Daten in BoltDB zu speichern, marshalt Storm sie standardmäßig im JSON-Format. Falls Sie dieses Verhalten ändern möchten, können Sie einen Codec übergeben, der <a href="https://godoc.org/github.com/asdine/storm/codec#MarshalUnmarshaler"><code>codec.MarshalUnmarshaler</code></a> implementiert, mittels der Option <a href="https://godoc.org/github.com/asdine/storm#Codec"><code>storm.Codec</code></a>:</p>
<pre><code class="language-go">db := storm.Open(&quot;my.db&quot;, storm.Codec(myCodec))
</code></pre>
<h5>Vorgefertigte Codecs</h5>
<p>Sie können Ihren eigenen <code>MarshalUnmarshaler</code> einfach implementieren, aber Storm bietet eingebaute Unterstützung für <a href="https://godoc.org/github.com/asdine/storm/codec/json">JSON</a> (Standard), <a href="https://godoc.org/github.com/asdine/storm/codec/gob">GOB</a>, <a href="https://godoc.org/github.com/asdine/storm/codec/sereal">Sereal</a>, <a href="https://godoc.org/github.com/asdine/storm/codec/protobuf">Protocol Buffers</a> und <a href="https://godoc.org/github.com/asdine/storm/codec/msgpack">MessagePack</a>.</p>
<p>Diese können verwendet werden, indem das jeweilige Paket importiert und dieser Codec zur Konfiguration von Storm genutzt wird. Das folgende Beispiel zeigt alle Varianten (ohne Fehlerbehandlung):</p>
<pre><code class="language-go">import (
  &quot;github.com/asdine/storm/v3&quot;
  &quot;github.com/asdine/storm/v3/codec/gob&quot;
  &quot;github.com/asdine/storm/v3/codec/json&quot;
  &quot;github.com/asdine/storm/v3/codec/sereal&quot;
  &quot;github.com/asdine/storm/v3/codec/protobuf&quot;
  &quot;github.com/asdine/storm/v3/codec/msgpack&quot;
)

var gobDb, _ = storm.Open(&quot;gob.db&quot;, storm.Codec(gob.Codec))
var jsonDb, _ = storm.Open(&quot;json.db&quot;, storm.Codec(json.Codec))
var serealDb, _ = storm.Open(&quot;sereal.db&quot;, storm.Codec(sereal.Codec))
var protobufDb, _ = storm.Open(&quot;protobuf.db&quot;, storm.Codec(protobuf.Codec))
var msgpackDb, _ = storm.Open(&quot;msgpack.db&quot;, storm.Codec(msgpack.Codec))
</code></pre>
<p><strong>Tipp</strong>: Das Hinzufügen von Storm-Tags zu generierten Protobuf-Dateien kann schwierig sein. Eine gute Lösung ist die Verwendung von <a href="https://github.com/favadi/protoc-go-inject-tag">diesem Tool</a>, um die Tags während der Kompilierung zu injizieren.</p>
<h4>Bestehende Bolt-Verbindung verwenden</h4>
<p>Sie können eine bestehende Verbindung verwenden und an Storm übergeben</p>
<pre><code class="language-go">bDB, _ := bolt.Open(filepath.Join(dir, &quot;bolt.db&quot;), 0600, &amp;bolt.Options{Timeout: 10 * time.Second})
db := storm.Open(&quot;my.db&quot;, storm.UseDB(bDB))
</code></pre>
<h4>Batch-Modus</h4>
<p>Der Batch-Modus kann aktiviert werden, um gleichzeitige Schreibvorgänge zu beschleunigen (siehe <a href="https://github.com/coreos/bbolt#batch-read-write-transactions">Batch read-write transactions</a>)</p>
<pre><code class="language-go">db := storm.Open(&quot;my.db&quot;, storm.Batch())
</code></pre>
<h2>Nodes und verschachtelte Buckets</h2>
<p>Storm nutzt das Feature der verschachtelten Buckets von BoltDB mittels <code>storm.Node</code>.
Ein <code>storm.Node</code> ist das zugrundeliegende Objekt, das von <code>storm.DB</code> verwendet wird, um einen Bucket zu manipulieren.
Um einen verschachtelten Bucket zu erstellen und die gleiche API wie <code>storm.DB</code> zu verwenden, kann die Methode <code>DB.From</code> genutzt werden.</p>
<pre><code class="language-go">repo := db.From(&quot;repo&quot;)

err := repo.Save(&amp;Issue{
  Title: &quot;I want more features&quot;,
  Author: user.ID,
})

err = repo.Save(newRelease(&quot;0.10&quot;))

var issues []Issue
err = repo.Find(&quot;Author&quot;, user.ID, &amp;issues)

var release Release
err = repo.One(&quot;Tag&quot;, &quot;0.10&quot;, &amp;release)
</code></pre>
<p>Nodes können auch verkettet werden, um eine Hierarchie zu erstellen</p>
<pre><code class="language-go">chars := db.From(&quot;characters&quot;)
heroes := chars.From(&quot;heroes&quot;)
enemies := chars.From(&quot;enemies&quot;)

items := db.From(&quot;items&quot;)
potions := items.From(&quot;consumables&quot;).From(&quot;medicine&quot;).From(&quot;potions&quot;)
</code></pre>
<p>Es ist sogar möglich, die gesamte Hierarchie als Argumente an <code>From</code> zu übergeben:</p>
<pre><code class="language-go">privateNotes := db.From(&quot;notes&quot;, &quot;private&quot;)
workNotes :=  db.From(&quot;notes&quot;, &quot;work&quot;)
</code></pre>
<h3>Node-Optionen</h3>
<p>Ein Node kann ebenfalls konfiguriert werden. Das Aktivieren einer Option auf einem Node erzeugt eine Kopie, sodass ein Node immer thread-sicher ist.</p>
<pre><code class="language-go">n := db.From(&quot;my-node&quot;)
</code></pre>
<p>Einer Node eine bolt.Tx-Transaktion geben</p>
<pre><code class="language-go">n = n.WithTransaction(tx)
</code></pre>
<p>Batch-Modus aktivieren</p>
<pre><code class="language-go">n = n.WithBatch(true)
</code></pre>
<p>Einen Codec verwenden</p>
<pre><code class="language-go">n = n.WithCodec(gob.Codec)
</code></pre>
<h2>Einfacher Key/Value Store</h2>
<p>Storm kann als einfacher, robuster Key/Value Store verwendet werden, der beliebige Daten speichern kann.
Der Schlüssel und der Wert können beliebige Typen haben, solange der Schlüssel kein Zero-Value ist.</p>
<p>Daten speichern:</p>
<pre><code class="language-go">db.Set(&quot;logs&quot;, time.Now(), &quot;I'm eating my breakfast man&quot;)
db.Set(&quot;sessions&quot;, bson.NewObjectId(), &amp;someUser)
db.Set(&quot;weird storage&quot;, &quot;754-3010&quot;, map[string]interface{}{
  &quot;hair&quot;: &quot;blond&quot;,
  &quot;likes&quot;: []string{&quot;cheese&quot;, &quot;star wars&quot;},
})
</code></pre>
<p>Daten abrufen:</p>
<pre><code class="language-go">user := User{}
db.Get(&quot;sessions&quot;, someObjectId, &amp;user)

var details map[string]interface{}
db.Get(&quot;weird storage&quot;, &quot;754-3010&quot;, &amp;details)
</code></pre>
<p>db.Get(&quot;sessions&quot;, someObjectId, &amp;details)</p>
<pre><code>
Daten löschen :

```go
db.Delete(&quot;sessions&quot;, someObjectId)
db.Delete(&quot;weird storage&quot;, &quot;754-3010&quot;)
</code></pre>
<p>Weitere nützliche Methoden finden Sie in der <a href="https://godoc.org/github.com/asdine/storm#KeyValueStore">Dokumentation</a>.</p>
<h2>BoltDB</h2>
<p>BoltDB ist weiterhin problemlos zugänglich und kann wie gewohnt verwendet werden</p>
<pre><code class="language-go">db.Bolt.View(func(tx *bolt.Tx) error {
  bucket := tx.Bucket([]byte(&quot;my bucket&quot;))
  val := bucket.Get([]byte(&quot;any id&quot;))
  fmt.Println(string(val))
  return nil
})
</code></pre>
<p>Eine Transaktion kann ebenfalls an Storm übergeben werden</p>
<pre><code class="language-go">db.Bolt.Update(func(tx *bolt.Tx) error {
  ...
  dbx := db.WithTransaction(tx)
  err = dbx.Save(&amp;user)
  ...
  return nil
})
</code></pre>
<h2>Lizenz</h2>
<p>MIT</p>
<h2>Credits</h2>
<ul>
<li><a href="https://github.com/asdine">Asdine El Hrychy</a></li>
<li><a href="https://github.com/bep">Bjørn Erik Pedersen</a></li>
</ul>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-11</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Statcounter and other scripts can be added here -->
</body>
</html>