<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>storm - asdine/storm</title>
    <meta name="title" content="storm - asdine/storm">
    <meta name="description" content="asdine/storm - GitHub repository hi documentation and informationStorm Storm BoltDB के लिए एक सरल और शक्तिशाली टूलकिट है। मूल रूप से, Storm इंडेक्स प्रदान करता है, डेटा को संग्रहित और प्राप्त करने के लिए कई विधियाँ देता है, ए...">
    <meta name="keywords" content="asdine, storm, GitHub, repository, hi documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/asdine/storm/README-hi.html">
    <meta property="og:title" content="storm - asdine/storm">
    <meta property="og:description" content="asdine/storm - GitHub repository hi documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/asdine/storm" id="githubRepoLink" target="_blank">asdine/storm</a>
<h1 style="display: none;">Storm Storm BoltDB के लिए एक सरल और शक्तिशाली टूलकिट है। मूल रूप से, Storm इंडेक्स प्रदान करता है, डेटा को संग्रहित और प्राप्त करने के लिए कई विधियाँ देता है, ए...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>Storm</h1>
<p><a href="https://travis-ci.org/asdine/storm"><img src="https://travis-ci.org/asdine/storm.svg" alt="Build Status" /></a>
<a href="https://godoc.org/github.com/asdine/storm"><img src="https://godoc.org/github.com/asdine/storm?status.svg" alt="GoDoc" /></a></p>
<p>Storm <a href="https://github.com/coreos/bbolt">BoltDB</a> के लिए एक सरल और शक्तिशाली टूलकिट है। मूल रूप से, Storm इंडेक्स प्रदान करता है, डेटा को संग्रहित और प्राप्त करने के लिए कई विधियाँ देता है, एक उन्नत क्वेरी सिस्टम देता है, और भी बहुत कुछ।</p>
<p>नीचे दिए गए उदाहरणों के अलावा, <a href="https://godoc.org/github.com/asdine/storm#pkg-examples">GoDoc में उदाहरण</a> भी देखें।</p>
<p><em>विस्तृत क्वेरी और <a href="https://github.com/dgraph-io/badger">Badger</a> के लिए सपोर्ट हेतु <a href="https://github.com/asdine/genji">Genji</a> भी देखें</em></p>
<h2>सामग्री सूची</h2>
<ul>
<li><a href="#getting-started">शुरुआत करें</a></li>
<li><a href="#import-storm">Storm आयात करें</a></li>
<li><a href="#open-a-database">डेटाबेस खोलें</a></li>
<li><a href="#simple-crud-system">सरल CRUD सिस्टम</a>
<ul>
<li><a href="#declare-your-structures">अपनी संरचनाएँ घोषित करें</a></li>
<li><a href="#save-your-object">अपनी वस्तु सहेजें</a>
<ul>
<li><a href="#auto-increment">ऑटो इन्क्रीमेंट</a></li>
</ul>
</li>
<li><a href="#simple-queries">सरल क्वेरीज़</a>
<ul>
<li><a href="#fetch-one-object">एक वस्तु प्राप्त करें</a></li>
<li><a href="#fetch-multiple-objects">कई वस्तुएँ प्राप्त करें</a></li>
<li><a href="#fetch-all-objects">सभी वस्तुएँ प्राप्त करें</a></li>
<li><a href="#fetch-all-objects-sorted-by-index">इंडेक्स के अनुसार सभी वस्तुएँ प्राप्त करें</a></li>
<li><a href="#fetch-a-range-of-objects">ऑब्जेक्ट्स की एक रेंज प्राप्त करें</a></li>
<li><a href="#fetch-objects-by-prefix">प्रिफिक्स द्वारा ऑब्जेक्ट्स प्राप्त करें</a></li>
<li><a href="#skip-limit-and-reverse">Skip, Limit और Reverse</a></li>
<li><a href="#delete-an-object">एक वस्तु हटाएँ</a></li>
<li><a href="#update-an-object">एक वस्तु अपडेट करें</a></li>
<li><a href="#initialize-buckets-and-indexes-before-saving-an-object">एक वस्तु सहेजने से पहले बकेट्स और इंडेक्स प्रारंभ करें</a></li>
<li><a href="#drop-a-bucket">एक बकेट हटाएँ</a></li>
<li><a href="#re-index-a-bucket">एक बकेट का पुनः इंडेक्स करें</a></li>
</ul>
</li>
<li><a href="#advanced-queries">एडवांस्ड क्वेरीज़</a></li>
<li><a href="#transactions">लेनदेन (Transactions)</a></li>
<li><a href="#options">विकल्प (Options)</a>
<ul>
<li><a href="#boltoptions">BoltOptions</a></li>
<li><a href="#marshalunmarshaler">MarshalUnmarshaler</a>
<ul>
<li><a href="#provided-codecs">प्रदत्त कोडेक्स</a></li>
</ul>
</li>
<li><a href="#use-existing-bolt-connection">मौजूदा Bolt कनेक्शन का उपयोग करें</a></li>
<li><a href="#batch-mode">बैच मोड</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#nodes-and-nested-buckets">नोड्स और नेस्टेड बकेट्स</a>
<ul>
<li><a href="#node-options">नोड विकल्प</a></li>
</ul>
</li>
<li><a href="#simple-keyvalue-store">सरल Key/Value स्टोर</a></li>
<li><a href="#boltdb">BoltDB</a></li>
<li><a href="#license">लाइसेंस</a></li>
<li><a href="#credits">श्रेय</a></li>
</ul>
<h2>शुरुआत करें</h2>
<pre><code class="language-bash">GO111MODULE=on go get -u github.com/asdine/storm/v3
</code></pre>
<h2>Storm आयात करें</h2>
<pre><code class="language-go">import &quot;github.com/asdine/storm/v3&quot;
</code></pre>
<h2>डेटाबेस खोलें</h2>
<p>डेटाबेस खोलने का तेज़ तरीका</p>
<pre><code class="language-go">db, err := storm.Open(&quot;my.db&quot;)

defer db.Close()
</code></pre>
<p><code>Open</code> को कई विकल्प दिए जा सकते हैं ताकि इसकी कार्यप्रणाली को अनुकूलित किया जा सके। नीचे <a href="#options">विकल्प</a> देखें</p>
<h2>सरल CRUD सिस्टम</h2>
<h3>अपनी संरचनाएँ घोषित करें</h3>
<pre><code class="language-go">type User struct {
  ID int // प्राथमिक कुंजी
  Group string `storm:&quot;index&quot;` // यह फ़ील्ड इंडेक्स की जाएगी
  Email string `storm:&quot;unique&quot;` // यह फ़ील्ड यूनिक कंस्ट्रेंट के साथ इंडेक्स की जाएगी
  Name string // यह फ़ील्ड इंडेक्स नहीं होगी
  Age int `storm:&quot;index&quot;`
}
</code></pre>
<p>प्राथमिक कुंजी किसी भी प्रकार की हो सकती है जब तक कि यह शून्य मान (zero value) न हो। Storm टैग <code>id</code> को खोजेगा, यदि वह मौजूद नहीं है तो Storm <code>ID</code> नामक फ़ील्ड को खोजेगा।</p>
<pre><code class="language-go">type User struct {
  ThePrimaryKey string `storm:&quot;id&quot;`// प्राथमिक कुंजी
  Group string `storm:&quot;index&quot;` // यह फ़ील्ड इंडेक्स की जाएगी
  Email string `storm:&quot;unique&quot;` // यह फ़ील्ड यूनिक कंस्ट्रेंट के साथ इंडेक्स की जाएगी
  Name string // यह फ़ील्ड इंडेक्स नहीं होगी
}
</code></pre>
<p>Storm नेस्टेड संरचनाओं में <code>inline</code> टैग के साथ टैग को संभालता है</p>
<pre><code class="language-go">type Base struct {
  Ident bson.ObjectId `storm:&quot;id&quot;`
}

type User struct {
  Base      `storm:&quot;inline&quot;`
  Group     string `storm:&quot;index&quot;`
  Email     string `storm:&quot;unique&quot;`
  Name      string
  CreatedAt time.Time `storm:&quot;index&quot;`
}
</code></pre>
<h3>अपनी वस्तु सहेजें</h3>
<pre><code class="language-go">user := User{
  ID: 10,
  Group: &quot;staff&quot;,
  Email: &quot;john@provider.com&quot;,
  Name: &quot;John&quot;,
  Age: 21,
  CreatedAt: time.Now(),
}

err := db.Save(&amp;user)
// err == nil

user.ID++
err = db.Save(&amp;user)
// err == storm.ErrAlreadyExists
</code></pre>
<p>बस इतना ही।</p>
<p><code>Save</code> सभी आवश्यक इंडेक्स और बकेट्स बनाता या अपडेट करता है, यूनिक कंस्ट्रेंट्स की जांच करता है और ऑब्जेक्ट को स्टोर में सहेजता है।</p>
<h4>ऑटो इन्क्रीमेंट</h4>
<p>Storm पूर्णांक (integer) मानों को स्वतः बढ़ा सकता है ताकि आपको अपने ऑब्जेक्ट सहेजते समय उसकी चिंता न करनी पड़े। साथ ही, नया मान आपके फ़ील्ड में स्वतः ही डाल दिया जाता है।</p>
<pre><code class="language-go">
type Product struct {
  Pk                  int `storm:&quot;id,increment&quot;` // ऑटो इन्क्रीमेंट के साथ प्राथमिक कुंजी
  Name                string
  IntegerField        uint64 `storm:&quot;increment&quot;`
  IndexedIntegerField uint32 `storm:&quot;index,increment&quot;`
  UniqueIntegerField  int16  `storm:&quot;unique,increment=100&quot;` // प्रारंभिक मान सेट किया जा सकता है
}

p := Product{Name: &quot;Vaccum Cleaner&quot;}

fmt.Println(p.Pk)
fmt.Println(p.IntegerField)
fmt.Println(p.IndexedIntegerField)
fmt.Println(p.UniqueIntegerField)
// 0
// 0
// 0
// 0

_ = db.Save(&amp;p)

fmt.Println(p.Pk)
fmt.Println(p.IntegerField)
fmt.Println(p.IndexedIntegerField)
fmt.Println(p.UniqueIntegerField)
// 1
// 1
// 1
// 100

</code></pre>
<h3>सरल क्वेरीज़</h3>
<p>कोई भी ऑब्जेक्ट प्राप्त किया जा सकता है, चाहे इंडेक्स किया गया हो या नहीं। Storm उपलब्ध होने पर इंडेक्स का उपयोग करता है, अन्यथा यह <a href="#advanced-queries">क्वेरी सिस्टम</a> का उपयोग करता है।</p>
<h4>एक वस्तु प्राप्त करें</h4>
<pre><code class="language-go">var user User
err := db.One(&quot;Email&quot;, &quot;john@provider.com&quot;, &amp;user)
// err == nil

err = db.One(&quot;Name&quot;, &quot;John&quot;, &amp;user)
// err == nil

err = db.One(&quot;Name&quot;, &quot;Jack&quot;, &amp;user)
// err == storm.ErrNotFound
</code></pre>
<h4>कई वस्तुएँ प्राप्त करें</h4>
<pre><code class="language-go">var users []User
err := db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users)
</code></pre>
<h4>सभी ऑब्जेक्ट प्राप्त करें</h4>
<pre><code class="language-go">var users []User
err := db.All(&amp;users)
</code></pre>
<h4>इंडेक्स द्वारा सभी ऑब्जेक्ट प्राप्त करें</h4>
<pre><code class="language-go">var users []User
err := db.AllByIndex(&quot;CreatedAt&quot;, &amp;users)
</code></pre>
<h4>ऑब्जेक्ट की एक रेंज प्राप्त करें</h4>
<pre><code class="language-go">var users []User
err := db.Range(&quot;Age&quot;, 10, 21, &amp;users)
</code></pre>
<h4>प्रीफिक्स द्वारा ऑब्जेक्ट प्राप्त करें</h4>
<pre><code class="language-go">var users []User
err := db.Prefix(&quot;Name&quot;, &quot;Jo&quot;, &amp;users)
</code></pre>
<h4>स्किप, लिमिट और रिवर्स</h4>
<pre><code class="language-go">var users []User
err := db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Skip(10))
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Limit(10))
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Reverse())
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())

err = db.All(&amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
err = db.AllByIndex(&quot;CreatedAt&quot;, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
err = db.Range(&quot;Age&quot;, 10, 21, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
</code></pre>
<h4>एक ऑब्जेक्ट हटाएँ</h4>
<pre><code class="language-go">err := db.DeleteStruct(&amp;user)
</code></pre>
<h4>एक ऑब्जेक्ट अपडेट करें</h4>
<pre><code class="language-go">// एक से अधिक फ़ील्ड अपडेट करें
// केवल नॉन ज़ीरो-वैल्यू फ़ील्ड के लिए काम करता है (जैसे Name &quot;&quot; नहीं हो सकता, Age 0 नहीं हो सकता)
err := db.Update(&amp;User{ID: 10, Name: &quot;Jack&quot;, Age: 45})

// एक सिंगल फ़ील्ड अपडेट करें
// यह ज़ीरो-वैल्यू फ़ील्ड (0, false, &quot;&quot;, ...) के लिए भी काम करता है
err := db.UpdateField(&amp;User{ID: 10}, &quot;Age&quot;, 0)
</code></pre>
<h4>ऑब्जेक्ट सेव करने से पहले बकेट और इंडेक्स इनिशियलाइज़ करें</h4>
<pre><code class="language-go">err := db.Init(&amp;User{})
</code></pre>
<p>अपने एप्लिकेशन की शुरुआत में उपयोगी</p>
<h4>एक बकेट ड्रॉप करें</h4>
<p>स्ट्रक्चर का उपयोग करके</p>
<pre><code class="language-go">err := db.Drop(&amp;User)
</code></pre>
<p>बकेट नाम का उपयोग करके</p>
<pre><code class="language-go">err := db.Drop(&quot;User&quot;)
</code></pre>
<h4>एक बकेट को री-इंडेक्स करें</h4>
<pre><code class="language-go">err := db.ReIndex(&amp;User{})
</code></pre>
<p>जब स्ट्रक्चर बदल गया हो तो उपयोगी</p>
<h3>एडवांस्ड क्वेरीज</h3>
<p>अधिक जटिल क्वेरीज के लिए, आप <code>Select</code> मेथड का उपयोग कर सकते हैं।
<code>Select</code> किसी भी संख्या में <a href="https://godoc.org/github.com/asdine/storm/q#Matcher"><code>Matcher</code></a> लेता है <a href="https://godoc.org/github.com/asdine/storm/q"><code>q</code></a> पैकेज से।</p>
<p>यहाँ कुछ सामान्य Matcher दिए गए हैं:</p>
<pre><code class="language-go">// समानता
q.Eq(&quot;Name&quot;, John)

// सख्ती से बड़ा
q.Gt(&quot;Age&quot;, 7)

// छोटा या बराबर
q.Lte(&quot;Age&quot;, 77)

// नाम के लिए रेगुलर एक्सप्रेशन, जो D अक्षर से शुरू होता है
q.Re(&quot;Name&quot;, &quot;^D&quot;)

// दिए गए वैल्यू स्लाइस में
q.In(&quot;Group&quot;, []string{&quot;Staff&quot;, &quot;Admin&quot;})

// फ़ील्ड की तुलना
q.EqF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.LtF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.GtF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.LteF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.GteF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
</code></pre>
<p>Matchers को <code>And</code>, <code>Or</code> और <code>Not</code> के साथ भी जोड़ा जा सकता है:</p>
<pre><code class="language-go">
// यदि सभी मैच हों तो मैच करें
q.And(
  q.Gt(&quot;Age&quot;, 7),
  q.Re(&quot;Name&quot;, &quot;^D&quot;)
)

// यदि एक भी मैच हो तो मैच करें
q.Or(
  q.Re(&quot;Name&quot;, &quot;^A&quot;),
  q.Not(
    q.Re(&quot;Name&quot;, &quot;^B&quot;)
  ),
  q.Re(&quot;Name&quot;, &quot;^C&quot;),
  q.In(&quot;Group&quot;, []string{&quot;Staff&quot;, &quot;Admin&quot;}),
  q.And(
    q.StrictEq(&quot;Password&quot;, []byte(password)),
    q.Eq(&quot;Registered&quot;, true)
  )
)
</code></pre>
<p>आप पूरी सूची <a href="https://godoc.org/github.com/asdine/storm/q#Matcher">डॉक्यूमेंटेशन</a> में देख सकते हैं।</p>
<p><code>Select</code> किसी भी संख्या में matchers लेता है और उन्हें <code>q.And()</code> में लपेटता है, इसलिए इसे अलग से स्पेसिफाई करना जरूरी नहीं है। यह <a href="https://godoc.org/github.com/asdine/storm#Query"><code>Query</code></a> टाइप लौटाता है।</p>
<pre><code class="language-go">query := db.Select(q.Gte(&quot;Age&quot;, 7), q.Lte(&quot;Age&quot;, 77))
</code></pre>
<p><code>Query</code> टाइप में रिकॉर्ड्स को फ़िल्टर और ऑर्डर करने के तरीके होते हैं।</p>
<pre><code class="language-go">// लिमिट
query = query.Limit(10)

// स्किप
query = query.Skip(20)

// कॉल्स को चेन भी किया जा सकता है
query = query.Limit(10).Skip(20).OrderBy(&quot;Age&quot;).Reverse()
</code></pre>
<p>साथ ही यह भी तय कर सकते हैं कि उन्हें कैसे फ़ेच करना है।</p>
<pre><code class="language-go">var users []User
err = query.Find(&amp;users)

var user User
err = query.First(&amp;user)
</code></pre>
<p><code>Select</code> के साथ उदाहरण:</p>
<pre><code class="language-go">// सभी यूज़र्स खोजें जिनकी ID 10 और 100 के बीच है
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Find(&amp;users)

// नेस्टेड मैचर्स
err = db.Select(q.Or(
  q.Gt(&quot;ID&quot;, 50),
  q.Lt(&quot;Age&quot;, 21),
  q.And(
    q.Eq(&quot;Group&quot;, &quot;admin&quot;),
    q.Gte(&quot;Age&quot;, 21),
  ),
)).Find(&amp;users)

query := db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;)

// कई रिकॉर्ड्स खोजें
err = query.Find(&amp;users)
// या
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;).Find(&amp;users)
</code></pre>
<pre><code class="language-go">// पहला रिकॉर्ड खोजें
err = query.First(&amp;user)
// या
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;).First(&amp;user)

// सभी मिलते-जुलते रिकॉर्ड्स हटाएँ
err = query.Delete(new(User))

// रिकॉर्ड्स को एक-एक कर लाना (जब बकेट में बहुत सारे रिकॉर्ड्स हों तब उपयोगी)
query = db.Select(q.Gte(&quot;ID&quot;, 10),q.Lte(&quot;ID&quot;, 100)).OrderBy(&quot;Age&quot;, &quot;Name&quot;)

err = query.Each(new(User), func(record interface{}) error) {
  u := record.(*User)
  ...
  return nil
}
</code></pre>
<p>पूरा मेथड्स की सूची के लिए <a href="https://godoc.org/github.com/asdine/storm#Query">डॉक्यूमेंटेशन</a> देखें।</p>
<h3>ट्रांज़ेक्शन</h3>
<pre><code class="language-go">tx, err := db.Begin(true)
if err != nil {
  return err
}
defer tx.Rollback()

accountA.Amount -= 100
accountB.Amount += 100

err = tx.Save(accountA)
if err != nil {
  return err
}

err = tx.Save(accountB)
if err != nil {
  return err
}

return tx.Commit()
</code></pre>
<h3>विकल्प (Options)</h3>
<p>Storm विकल्प वे फंक्शन्स हैं जिन्हें आप अपने Storm इंस्टांस को बनाते समय पास कर सकते हैं। आप कितने भी विकल्प दे सकते हैं।</p>
<h4>BoltOptions</h4>
<p>डिफ़ॉल्ट रूप से, Storm डेटाबेस को <code>0600</code> मोड और एक सेकंड के टाइमआउट के साथ खोलता है।
आप इस व्यवहार को <code>BoltOptions</code> का उपयोग करके बदल सकते हैं।</p>
<pre><code class="language-go">db, err := storm.Open(&quot;my.db&quot;, storm.BoltOptions(0600, &amp;bolt.Options{Timeout: 1 * time.Second}))
</code></pre>
<h4>MarshalUnmarshaler</h4>
<p>BoltDB में डेटा स्टोर करने के लिए, Storm डिफ़ॉल्ट रूप से इसे JSON में मार्शल करता है। यदि आप इस व्यवहार को बदलना चाहते हैं तो आप एक ऐसा कोडेक पास कर सकते हैं जो <a href="https://godoc.org/github.com/asdine/storm/codec#MarshalUnmarshaler"><code>codec.MarshalUnmarshaler</code></a> को इम्प्लीमेंट करता हो, <a href="https://godoc.org/github.com/asdine/storm#Codec"><code>storm.Codec</code></a> विकल्प के माध्यम से:</p>
<pre><code class="language-go">db := storm.Open(&quot;my.db&quot;, storm.Codec(myCodec))
</code></pre>
<h5>उपलब्ध कोडेक्स</h5>
<p>आप अपना खुद का <code>MarshalUnmarshaler</code> आसानी से इम्प्लीमेंट कर सकते हैं, लेकिन Storm में <a href="https://godoc.org/github.com/asdine/storm/codec/json">JSON</a> (डिफ़ॉल्ट), <a href="https://godoc.org/github.com/asdine/storm/codec/gob">GOB</a>, <a href="https://godoc.org/github.com/asdine/storm/codec/sereal">Sereal</a>, <a href="https://godoc.org/github.com/asdine/storm/codec/protobuf">Protocol Buffers</a> और <a href="https://godoc.org/github.com/asdine/storm/codec/msgpack">MessagePack</a> के लिए बिल्ट-इन सपोर्ट है।</p>
<p>इन्हें उपयोग करने के लिए संबंधित पैकेज को इम्पोर्ट करें और Storm को उस कोडेक से कॉन्फ़िगर करें। नीचे दिए गए उदाहरण में सभी वेरिएंट्स दिखाए गए हैं (बिना एरर हैंडलिंग के):</p>
<pre><code class="language-go">import (
  &quot;github.com/asdine/storm/v3&quot;
  &quot;github.com/asdine/storm/v3/codec/gob&quot;
  &quot;github.com/asdine/storm/v3/codec/json&quot;
  &quot;github.com/asdine/storm/v3/codec/sereal&quot;
  &quot;github.com/asdine/storm/v3/codec/protobuf&quot;
  &quot;github.com/asdine/storm/v3/codec/msgpack&quot;
)

var gobDb, _ = storm.Open(&quot;gob.db&quot;, storm.Codec(gob.Codec))
var jsonDb, _ = storm.Open(&quot;json.db&quot;, storm.Codec(json.Codec))
var serealDb, _ = storm.Open(&quot;sereal.db&quot;, storm.Codec(sereal.Codec))
var protobufDb, _ = storm.Open(&quot;protobuf.db&quot;, storm.Codec(protobuf.Codec))
var msgpackDb, _ = storm.Open(&quot;msgpack.db&quot;, storm.Codec(msgpack.Codec))
</code></pre>
<p><strong>टिप</strong>: जेनरेटेड Protobuf फ़ाइलों में Storm टैग्स जोड़ना मुश्किल हो सकता है। एक अच्छा समाधान है <a href="https://github.com/favadi/protoc-go-inject-tag">यह टूल</a> उपयोग करना, जिससे टैग्स को कम्पाइलिंग के दौरान इन्जेक्ट किया जा सकता है।</p>
<h4>मौजूदा Bolt कनेक्शन का उपयोग करें</h4>
<p>आप मौजूदा कनेक्शन का उपयोग कर सकते हैं और उसे Storm को पास कर सकते हैं</p>
<pre><code class="language-go">bDB, _ := bolt.Open(filepath.Join(dir, &quot;bolt.db&quot;), 0600, &amp;bolt.Options{Timeout: 10 * time.Second})
db := storm.Open(&quot;my.db&quot;, storm.UseDB(bDB))
</code></pre>
<h4>बैच मोड</h4>
<p>Concurrent लिखने को तेज़ करने के लिए बैच मोड सक्षम किया जा सकता है (देखें <a href="https://github.com/coreos/bbolt#batch-read-write-transactions">Batch read-write transactions</a>)</p>
<pre><code class="language-go">db := storm.Open(&quot;my.db&quot;, storm.Batch())
</code></pre>
<h2>नोड्स और नेस्टेड बकेट्स</h2>
<p>Storm, BoltDB के नेस्टेड बकेट्स फीचर का लाभ <code>storm.Node</code> का उपयोग करके उठाता है।
एक <code>storm.Node</code> वह ऑब्जेक्ट है जिसका उपयोग <code>storm.DB</code> द्वारा किसी बकेट को नियंत्रित करने के लिए किया जाता है।
नेस्टेड बकेट बनाने और <code>storm.DB</code> जैसी ही API उपयोग करने के लिए, आप <code>DB.From</code> मेथड का उपयोग कर सकते हैं।</p>
<pre><code class="language-go">repo := db.From(&quot;repo&quot;)

err := repo.Save(&amp;Issue{
  Title: &quot;I want more features&quot;,
  Author: user.ID,
})

err = repo.Save(newRelease(&quot;0.10&quot;))

var issues []Issue
err = repo.Find(&quot;Author&quot;, user.ID, &amp;issues)

var release Release
err = repo.One(&quot;Tag&quot;, &quot;0.10&quot;, &amp;release)
</code></pre>
<p>आप नोड्स को चेन करके भी हाइरार्की बना सकते हैं</p>
<pre><code class="language-go">chars := db.From(&quot;characters&quot;)
heroes := chars.From(&quot;heroes&quot;)
enemies := chars.From(&quot;enemies&quot;)

items := db.From(&quot;items&quot;)
potions := items.From(&quot;consumables&quot;).From(&quot;medicine&quot;).From(&quot;potions&quot;)
</code></pre>
<p>आप पूरी हाइरार्की को <code>From</code> के आर्ग्युमेंट्स के रूप में भी पास कर सकते हैं:</p>
<pre><code class="language-go">privateNotes := db.From(&quot;notes&quot;, &quot;private&quot;)
workNotes :=  db.From(&quot;notes&quot;, &quot;work&quot;)
</code></pre>
<h3>नोड विकल्प</h3>
<p>एक Node को भी कॉन्फ़िगर किया जा सकता है। किसी Node पर विकल्प सक्रिय करने से एक कॉपी बनती है, इसलिए Node हमेशा थ्रेड-सेफ होता है।</p>
<pre><code class="language-go">n := db.From(&quot;my-node&quot;)
</code></pre>
<p>Node को bolt.Tx ट्रांजैक्शन दें</p>
<pre><code class="language-go">n = n.WithTransaction(tx)
</code></pre>
<p>बैच मोड सक्षम करें</p>
<pre><code class="language-go">n = n.WithBatch(true)
</code></pre>
<p>Codec का उपयोग करें</p>
<pre><code class="language-go">n = n.WithCodec(gob.Codec)
</code></pre>
<h2>सिंपल की/वैल्यू स्टोर</h2>
<p>Storm को एक सिंपल, मजबूत, की/वैल्यू स्टोर की तरह इस्तेमाल किया जा सकता है जिसमें कुछ भी स्टोर किया जा सकता है।
की और वैल्यू किसी भी प्रकार की हो सकती है, बस की जीरो वैल्यू नहीं होनी चाहिए।</p>
<p>डेटा सेव करना :</p>
<pre><code class="language-go">db.Set(&quot;logs&quot;, time.Now(), &quot;I'm eating my breakfast man&quot;)
db.Set(&quot;sessions&quot;, bson.NewObjectId(), &amp;someUser)
db.Set(&quot;weird storage&quot;, &quot;754-3010&quot;, map[string]interface{}{
  &quot;hair&quot;: &quot;blonde&quot;,
  &quot;likes&quot;: []string{&quot;cheese&quot;, &quot;star wars&quot;},
})
</code></pre>
<p>डेटा प्राप्त करना :</p>
<pre><code class="language-go">user := User{}
db.Get(&quot;sessions&quot;, someObjectId, &amp;user)

var details map[string]interface{}
db.Get(&quot;weird storage&quot;, &quot;754-3010&quot;, &amp;details)
</code></pre>
<p>db.Get(&quot;sessions&quot;, someObjectId, &amp;details)</p>
<pre><code>
डेटा हटाना :

```go
db.Delete(&quot;sessions&quot;, someObjectId)
db.Delete(&quot;weird storage&quot;, &quot;754-3010&quot;)
</code></pre>
<p>आप अन्य उपयोगी विधियाँ <a href="https://godoc.org/github.com/asdine/storm#KeyValueStore">documentation</a> में देख सकते हैं।</p>
<h2>BoltDB</h2>
<p>BoltDB अभी भी आसानी से उपलब्ध है और सामान्य रूप से उपयोग किया जा सकता है</p>
<pre><code class="language-go">db.Bolt.View(func(tx *bolt.Tx) error {
  bucket := tx.Bucket([]byte(&quot;my bucket&quot;))
  val := bucket.Get([]byte(&quot;any id&quot;))
  fmt.Println(string(val))
  return nil
})
</code></pre>
<p>एक ट्रांजेक्शन को Storm में भी पास किया जा सकता है</p>
<pre><code class="language-go">db.Bolt.Update(func(tx *bolt.Tx) error {
  ...
  dbx := db.WithTransaction(tx)
  err = dbx.Save(&amp;user)
  ...
  return nil
})
</code></pre>
<h2>लाइसेंस</h2>
<p>MIT</p>
<h2>श्रेय</h2>
<ul>
<li><a href="https://github.com/asdine">Asdine El Hrychy</a></li>
<li><a href="https://github.com/bep">Bjørn Erik Pedersen</a></li>
</ul>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-11</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>