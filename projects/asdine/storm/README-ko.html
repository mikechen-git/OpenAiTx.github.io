<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>storm - asdine/storm</title>
    <meta name="title" content="storm - asdine/storm">
    <meta name="description" content="asdine/storm - GitHub repository ko documentation and informationStorm Storm은 BoltDB를 위한 간단하고 강력한 툴킷입니다. 기본적으로 Storm은 인덱스, 데이터를 저장하고 가져오는 다양한 메서드, 고급 쿼리 시스템 등 많은 기능을 제공합니다. 아래 예제 외에도 GoDoc의 예제도 참고하세요. 확장된 쿼리와 Badger 지원이 필요하다면...">
    <meta name="keywords" content="asdine, storm, GitHub, repository, ko documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/asdine/storm/README-ko.html">
    <meta property="og:title" content="storm - asdine/storm">
    <meta property="og:description" content="asdine/storm - GitHub repository ko documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/asdine/storm" id="githubRepoLink" target="_blank">asdine/storm</a>
<h1 style="display: none;">Storm Storm은 BoltDB를 위한 간단하고 강력한 툴킷입니다. 기본적으로 Storm은 인덱스, 데이터를 저장하고 가져오는 다양한 메서드, 고급 쿼리 시스템 등 많은 기능을 제공합니다. 아래 예제 외에도 GoDoc의 예제도 참고하세요. 확장된 쿼리와 Badger 지원이 필요하다면...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>Storm</h1>
<p><a href="https://travis-ci.org/asdine/storm"><img src="https://travis-ci.org/asdine/storm.svg" alt="Build Status" /></a>
<a href="https://godoc.org/github.com/asdine/storm"><img src="https://godoc.org/github.com/asdine/storm?status.svg" alt="GoDoc" /></a></p>
<p>Storm은 <a href="https://github.com/coreos/bbolt">BoltDB</a>를 위한 간단하고 강력한 툴킷입니다. 기본적으로 Storm은 인덱스, 데이터를 저장하고 가져오는 다양한 메서드, 고급 쿼리 시스템 등 많은 기능을 제공합니다.</p>
<p>아래 예제 외에도 <a href="https://godoc.org/github.com/asdine/storm#pkg-examples">GoDoc의 예제</a>도 참고하세요.</p>
<p><em>확장된 쿼리와 <a href="https://github.com/dgraph-io/badger">Badger</a> 지원이 필요하다면 <a href="https://github.com/asdine/genji">Genji</a>도 참고하세요.</em></p>
<h2>목차</h2>
<ul>
<li><a href="#getting-started">시작하기</a></li>
<li><a href="#import-storm">Storm 임포트하기</a></li>
<li><a href="#open-a-database">데이터베이스 열기</a></li>
<li><a href="#simple-crud-system">간단한 CRUD 시스템</a>
<ul>
<li><a href="#declare-your-structures">구조체 선언하기</a></li>
<li><a href="#save-your-object">객체 저장하기</a>
<ul>
<li><a href="#auto-increment">자동 증가</a></li>
</ul>
</li>
<li><a href="#simple-queries">간단한 쿼리</a>
<ul>
<li><a href="#fetch-one-object">단일 객체 가져오기</a></li>
<li><a href="#fetch-multiple-objects">여러 객체 가져오기</a></li>
<li><a href="#fetch-all-objects">모든 객체 가져오기</a></li>
<li><a href="#fetch-all-objects-sorted-by-index">인덱스로 정렬된 모든 객체 가져오기</a></li>
<li><a href="#fetch-a-range-of-objects">범위로 객체 가져오기</a></li>
<li><a href="#fetch-objects-by-prefix">접두사로 객체 가져오기</a></li>
<li><a href="#skip-limit-and-reverse">Skip, Limit 및 Reverse</a></li>
<li><a href="#delete-an-object">객체 삭제</a></li>
<li><a href="#update-an-object">객체 업데이트</a></li>
<li><a href="#initialize-buckets-and-indexes-before-saving-an-object">객체 저장 전 버킷 및 인덱스 초기화</a></li>
<li><a href="#drop-a-bucket">버킷 삭제</a></li>
<li><a href="#re-index-a-bucket">버킷 재인덱싱</a></li>
</ul>
</li>
<li><a href="#advanced-queries">고급 쿼리</a></li>
<li><a href="#transactions">트랜잭션</a></li>
<li><a href="#options">옵션</a>
<ul>
<li><a href="#boltoptions">BoltOptions</a></li>
<li><a href="#marshalunmarshaler">MarshalUnmarshaler</a>
<ul>
<li><a href="#provided-codecs">제공되는 Codec</a></li>
</ul>
</li>
<li><a href="#use-existing-bolt-connection">기존 Bolt 연결 사용하기</a></li>
<li><a href="#batch-mode">Batch 모드</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#nodes-and-nested-buckets">노드와 중첩 버킷</a>
<ul>
<li><a href="#node-options">노드 옵션</a></li>
</ul>
</li>
<li><a href="#simple-keyvalue-store">간단한 Key/Value 저장소</a></li>
<li><a href="#boltdb">BoltDB</a></li>
<li><a href="#license">라이선스</a></li>
<li><a href="#credits">크레딧</a></li>
</ul>
<h2>시작하기</h2>
<pre><code class="language-bash">GO111MODULE=on go get -u github.com/asdine/storm/v3
</code></pre>
<h2>Storm 임포트하기</h2>
<pre><code class="language-go">import &quot;github.com/asdine/storm/v3&quot;
</code></pre>
<h2>데이터베이스 열기</h2>
<p>데이터베이스를 빠르게 여는 방법</p>
<pre><code class="language-go">db, err := storm.Open(&quot;my.db&quot;)

defer db.Close()
</code></pre>
<p><code>Open</code>은 동작 방식을 사용자화할 수 있는 여러 옵션을 받을 수 있습니다. 아래 <a href="#options">옵션</a> 항목을 참고하세요.</p>
<h2>간단한 CRUD 시스템</h2>
<h3>구조체 선언하기</h3>
<pre><code class="language-go">type User struct {
  ID int // 기본 키
  Group string `storm:&quot;index&quot;` // 이 필드는 인덱싱됩니다
  Email string `storm:&quot;unique&quot;` // 이 필드는 유일성 제약과 함께 인덱싱됩니다
  Name string // 이 필드는 인덱싱되지 않습니다
  Age int `storm:&quot;index&quot;`
}
</code></pre>
<p>기본 키는 0값이 아닌 한 어떤 타입도 사용할 수 있습니다. Storm은 <code>id</code> 태그를 우선적으로 검색하며, 없을 경우 <code>ID</code>라는 이름의 필드를 찾습니다.</p>
<pre><code class="language-go">type User struct {
  ThePrimaryKey string `storm:&quot;id&quot;`// 기본 키
  Group string `storm:&quot;index&quot;` // 이 필드는 인덱싱됩니다
  Email string `storm:&quot;unique&quot;` // 이 필드는 유일성 제약과 함께 인덱싱됩니다
  Name string // 이 필드는 인덱싱되지 않습니다
}
</code></pre>
<p>Storm은 중첩 구조체에서 <code>inline</code> 태그로 태그를 처리합니다.</p>
<pre><code class="language-go">type Base struct {
  Ident bson.ObjectId `storm:&quot;id&quot;`
}

type User struct {
  Base      `storm:&quot;inline&quot;`
  Group     string `storm:&quot;index&quot;`
  Email     string `storm:&quot;unique&quot;`
  Name      string
  CreatedAt time.Time `storm:&quot;index&quot;`
}
</code></pre>
<h3>객체 저장하기</h3>
<pre><code class="language-go">user := User{
  ID: 10,
  Group: &quot;staff&quot;,
  Email: &quot;john@provider.com&quot;,
  Name: &quot;John&quot;,
  Age: 21,
  CreatedAt: time.Now(),
}

err := db.Save(&amp;user)
// err == nil

user.ID++
err = db.Save(&amp;user)
// err == storm.ErrAlreadyExists
</code></pre>
<p>이것으로 끝입니다.</p>
<p><code>Save</code>는 필요한 모든 인덱스와 버킷을 생성 또는 업데이트하고, 유일성 제약을 검사하며 객체를 저장소에 저장합니다.</p>
<h4>자동 증가</h4>
<p>Storm은 정수 값을 자동으로 증가시킬 수 있으므로 객체 저장 시 해당 부분을 신경 쓸 필요가 없습니다. 또한 새로운 값이 자동으로 필드에 삽입됩니다.</p>
<pre><code class="language-go">
type Product struct {
  Pk                  int `storm:&quot;id,increment&quot;` // 자동 증가가 있는 기본 키
  Name                string
  IntegerField        uint64 `storm:&quot;increment&quot;`
  IndexedIntegerField uint32 `storm:&quot;index,increment&quot;`
  UniqueIntegerField  int16  `storm:&quot;unique,increment=100&quot;` // 시작값을 지정할 수 있습니다
}

p := Product{Name: &quot;Vaccum Cleaner&quot;}

fmt.Println(p.Pk)
fmt.Println(p.IntegerField)
fmt.Println(p.IndexedIntegerField)
fmt.Println(p.UniqueIntegerField)
// 0
// 0
// 0
// 0

_ = db.Save(&amp;p)

fmt.Println(p.Pk)
fmt.Println(p.IntegerField)
fmt.Println(p.IndexedIntegerField)
fmt.Println(p.UniqueIntegerField)
// 1
// 1
// 1
// 100

</code></pre>
<h3>간단한 쿼리</h3>
<p>어떤 객체든(인덱싱 여부와 상관없이) 가져올 수 있습니다. Storm은 인덱스가 있을 경우 인덱스를 사용하고, 없으면 <a href="#advanced-queries">쿼리 시스템</a>을 사용합니다.</p>
<h4>단일 객체 가져오기</h4>
<pre><code class="language-go">var user User
err := db.One(&quot;Email&quot;, &quot;john@provider.com&quot;, &amp;user)
// err == nil

err = db.One(&quot;Name&quot;, &quot;John&quot;, &amp;user)
// err == nil

err = db.One(&quot;Name&quot;, &quot;Jack&quot;, &amp;user)
// err == storm.ErrNotFound
</code></pre>
<h4>여러 객체 가져오기</h4>
<pre><code class="language-go">var users []User
err := db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users)
</code></pre>
<h4>모든 객체 가져오기</h4>
<pre><code class="language-go">var users []User
err := db.All(&amp;users)
</code></pre>
<h4>인덱스로 정렬하여 모든 객체 가져오기</h4>
<pre><code class="language-go">var users []User
err := db.AllByIndex(&quot;CreatedAt&quot;, &amp;users)
</code></pre>
<h4>객체의 범위 조회</h4>
<pre><code class="language-go">var users []User
err := db.Range(&quot;Age&quot;, 10, 21, &amp;users)
</code></pre>
<h4>접두어로 객체 조회</h4>
<pre><code class="language-go">var users []User
err := db.Prefix(&quot;Name&quot;, &quot;Jo&quot;, &amp;users)
</code></pre>
<h4>Skip, Limit 및 Reverse</h4>
<pre><code class="language-go">var users []User
err := db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Skip(10))
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Limit(10))
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Reverse())
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())

err = db.All(&amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
err = db.AllByIndex(&quot;CreatedAt&quot;, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
err = db.Range(&quot;Age&quot;, 10, 21, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
</code></pre>
<h4>객체 삭제</h4>
<pre><code class="language-go">err := db.DeleteStruct(&amp;user)
</code></pre>
<h4>객체 업데이트</h4>
<pre><code class="language-go">// 여러 필드 업데이트
// 0 값이 아닌 필드에만 동작합니다 (예: Name은 &quot;&quot;이 될 수 없고, Age는 0이 될 수 없음)
err := db.Update(&amp;User{ID: 10, Name: &quot;Jack&quot;, Age: 45})

// 단일 필드 업데이트
// 0 값 필드(0, false, &quot;&quot;, ...)도 동작합니다
err := db.UpdateField(&amp;User{ID: 10}, &quot;Age&quot;, 0)
</code></pre>
<h4>객체를 저장하기 전에 버킷 및 인덱스 초기화</h4>
<pre><code class="language-go">err := db.Init(&amp;User{})
</code></pre>
<p>애플리케이션 시작 시 유용합니다</p>
<h4>버킷 삭제</h4>
<p>구조체를 사용하여</p>
<pre><code class="language-go">err := db.Drop(&amp;User)
</code></pre>
<p>버킷 이름을 사용하여</p>
<pre><code class="language-go">err := db.Drop(&quot;User&quot;)
</code></pre>
<h4>버킷의 인덱스 재설정</h4>
<pre><code class="language-go">err := db.ReIndex(&amp;User{})
</code></pre>
<p>구조가 변경된 경우 유용합니다</p>
<h3>고급 쿼리</h3>
<p>더 복잡한 쿼리가 필요할 경우, <code>Select</code> 메서드를 사용할 수 있습니다.<br />
<code>Select</code>는 <a href="https://godoc.org/github.com/asdine/storm/q"><code>q</code></a> 패키지의 <a href="https://godoc.org/github.com/asdine/storm/q#Matcher"><code>Matcher</code></a>를 여러 개 받을 수 있습니다.</p>
<p>아래는 자주 사용하는 Matcher 예시입니다:</p>
<pre><code class="language-go">// 동등 비교
q.Eq(&quot;Name&quot;, John)

// 엄격한 초과
q.Gt(&quot;Age&quot;, 7)

// 이하 또는 같은 값
q.Lte(&quot;Age&quot;, 77)

// D로 시작하는 이름의 정규식
q.Re(&quot;Name&quot;, &quot;^D&quot;)

// 주어진 값 집합에 포함
q.In(&quot;Group&quot;, []string{&quot;Staff&quot;, &quot;Admin&quot;})

// 필드 비교
q.EqF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.LtF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.GtF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.LteF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.GteF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
</code></pre>
<p>Matcher는 <code>And</code>, <code>Or</code>, <code>Not</code>과 조합할 수 있습니다:</p>
<pre><code class="language-go">
// 모두 일치하는 경우
q.And(
  q.Gt(&quot;Age&quot;, 7),
  q.Re(&quot;Name&quot;, &quot;^D&quot;)
)

// 하나라도 일치하는 경우
q.Or(
  q.Re(&quot;Name&quot;, &quot;^A&quot;),
  q.Not(
    q.Re(&quot;Name&quot;, &quot;^B&quot;)
  ),
  q.Re(&quot;Name&quot;, &quot;^C&quot;),
  q.In(&quot;Group&quot;, []string{&quot;Staff&quot;, &quot;Admin&quot;}),
  q.And(
    q.StrictEq(&quot;Password&quot;, []byte(password)),
    q.Eq(&quot;Registered&quot;, true)
  )
)
</code></pre>
<p>전체 목록은 <a href="https://godoc.org/github.com/asdine/storm/q#Matcher">문서</a>에서 확인할 수 있습니다.</p>
<p><code>Select</code>는 여러 matcher를 받아 내부적으로 <code>q.And()</code>로 감싸므로 명시적으로 지정할 필요가 없습니다. 반환값은 <a href="https://godoc.org/github.com/asdine/storm#Query"><code>Query</code></a> 타입입니다.</p>
<pre><code class="language-go">query := db.Select(q.Gte(&quot;Age&quot;, 7), q.Lte(&quot;Age&quot;, 77))
</code></pre>
<p><code>Query</code> 타입은 레코드를 필터링하고 정렬하는 메서드를 제공합니다.</p>
<pre><code class="language-go">// Limit
query = query.Limit(10)

// Skip
query = query.Skip(20)

// 메서드 체이닝도 가능합니다
query = query.Limit(10).Skip(20).OrderBy(&quot;Age&quot;).Reverse()
</code></pre>
<p>또한 데이터 조회 방식을 지정할 수 있습니다.</p>
<pre><code class="language-go">var users []User
err = query.Find(&amp;users)

var user User
err = query.First(&amp;user)
</code></pre>
<p><code>Select</code> 사용 예시:</p>
<pre><code class="language-go">// ID가 10에서 100 사이인 모든 사용자 조회
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Find(&amp;users)

// 중첩 matcher
err = db.Select(q.Or(
  q.Gt(&quot;ID&quot;, 50),
  q.Lt(&quot;Age&quot;, 21),
  q.And(
    q.Eq(&quot;Group&quot;, &quot;admin&quot;),
    q.Gte(&quot;Age&quot;, 21),
  ),
)).Find(&amp;users)

query := db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;)

// 여러 레코드 조회
err = query.Find(&amp;users)
// 또는
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;).Find(&amp;users)
</code></pre>
<pre><code class="language-go">// 첫 번째 레코드 찾기
err = query.First(&amp;user)
// 또는
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;).First(&amp;user)

// 모든 일치하는 레코드 삭제
err = query.Delete(new(User))

// 레코드를 하나씩 가져오기 (버킷에 많은 레코드가 있을 때 유용)
query = db.Select(q.Gte(&quot;ID&quot;, 10),q.Lte(&quot;ID&quot;, 100)).OrderBy(&quot;Age&quot;, &quot;Name&quot;)

err = query.Each(new(User), func(record interface{}) error) {
  u := record.(*User)
  ...
  return nil
}
</code></pre>
<p>전체 메소드 목록은 <a href="https://godoc.org/github.com/asdine/storm#Query">문서</a>를 참고하세요.</p>
<h3>트랜잭션</h3>
<pre><code class="language-go">tx, err := db.Begin(true)
if err != nil {
  return err
}
defer tx.Rollback()

accountA.Amount -= 100
accountB.Amount += 100

err = tx.Save(accountA)
if err != nil {
  return err
}

err = tx.Save(accountB)
if err != nil {
  return err
}

return tx.Commit()
</code></pre>
<h3>옵션</h3>
<p>Storm 옵션은 Storm 인스턴스를 생성할 때 전달할 수 있는 함수들입니다. 원하는 만큼 옵션을 전달할 수 있습니다.</p>
<h4>BoltOptions</h4>
<p>기본적으로 Storm은 모드 <code>0600</code>과 1초의 타임아웃으로 데이터베이스를 엽니다.
이 동작을 변경하려면 <code>BoltOptions</code>를 사용하세요.</p>
<pre><code class="language-go">db, err := storm.Open(&quot;my.db&quot;, storm.BoltOptions(0600, &amp;bolt.Options{Timeout: 1 * time.Second}))
</code></pre>
<h4>MarshalUnmarshaler</h4>
<p>BoltDB에 데이터를 저장할 때, Storm은 기본적으로 JSON으로 마샬링합니다. 이 동작을 변경하고 싶다면 <a href="https://godoc.org/github.com/asdine/storm/codec#MarshalUnmarshaler"><code>codec.MarshalUnmarshaler</code></a>를 구현한 코덱을 <a href="https://godoc.org/github.com/asdine/storm#Codec"><code>storm.Codec</code></a> 옵션을 통해 전달할 수 있습니다:</p>
<pre><code class="language-go">db := storm.Open(&quot;my.db&quot;, storm.Codec(myCodec))
</code></pre>
<h5>기본 제공 코덱</h5>
<p>직접 <code>MarshalUnmarshaler</code>를 구현할 수도 있지만, Storm은 <a href="https://godoc.org/github.com/asdine/storm/codec/json">JSON</a> (기본값), <a href="https://godoc.org/github.com/asdine/storm/codec/gob">GOB</a>, <a href="https://godoc.org/github.com/asdine/storm/codec/sereal">Sereal</a>, <a href="https://godoc.org/github.com/asdine/storm/codec/protobuf">Protocol Buffers</a>, <a href="https://godoc.org/github.com/asdine/storm/codec/msgpack">MessagePack</a>을 기본적으로 지원합니다.</p>
<p>아래 예시처럼 관련 패키지를 임포트하고 해당 코덱을 사용해 Storm을 구성할 수 있습니다. (오류 처리는 생략)</p>
<pre><code class="language-go">import (
  &quot;github.com/asdine/storm/v3&quot;
  &quot;github.com/asdine/storm/v3/codec/gob&quot;
  &quot;github.com/asdine/storm/v3/codec/json&quot;
  &quot;github.com/asdine/storm/v3/codec/sereal&quot;
  &quot;github.com/asdine/storm/v3/codec/protobuf&quot;
  &quot;github.com/asdine/storm/v3/codec/msgpack&quot;
)

var gobDb, _ = storm.Open(&quot;gob.db&quot;, storm.Codec(gob.Codec))
var jsonDb, _ = storm.Open(&quot;json.db&quot;, storm.Codec(json.Codec))
var serealDb, _ = storm.Open(&quot;sereal.db&quot;, storm.Codec(sereal.Codec))
var protobufDb, _ = storm.Open(&quot;protobuf.db&quot;, storm.Codec(protobuf.Codec))
var msgpackDb, _ = storm.Open(&quot;msgpack.db&quot;, storm.Codec(msgpack.Codec))
</code></pre>
<p><strong>팁</strong>: 생성된 Protobuf 파일에 Storm 태그를 추가하는 것은 까다로울 수 있습니다. <a href="https://github.com/favadi/protoc-go-inject-tag">이 도구</a>를 사용해 컴파일 시 태그를 주입하는 것이 좋은 해결책입니다.</p>
<h4>기존 Bolt 연결 사용</h4>
<p>기존 연결을 Storm에 전달해 사용할 수 있습니다.</p>
<pre><code class="language-go">bDB, _ := bolt.Open(filepath.Join(dir, &quot;bolt.db&quot;), 0600, &amp;bolt.Options{Timeout: 10 * time.Second})
db := storm.Open(&quot;my.db&quot;, storm.UseDB(bDB))
</code></pre>
<h4>배치 모드</h4>
<p>배치 모드를 활성화하면 동시 쓰기 속도를 높일 수 있습니다 (<a href="https://github.com/coreos/bbolt#batch-read-write-transactions">배치 읽기-쓰기 트랜잭션</a> 참고)</p>
<pre><code class="language-go">db := storm.Open(&quot;my.db&quot;, storm.Batch())
</code></pre>
<h2>노드와 중첩 버킷</h2>
<p>Storm은 <code>storm.Node</code>를 사용하여 BoltDB의 중첩 버킷 기능을 활용합니다.<br />
<code>storm.Node</code>는 <code>storm.DB</code>가 버킷을 조작할 때 사용하는 기본 객체입니다.<br />
중첩 버킷을 만들고 <code>storm.DB</code>와 동일한 API를 사용하려면 <code>DB.From</code> 메서드를 사용할 수 있습니다.</p>
<pre><code class="language-go">repo := db.From(&quot;repo&quot;)

err := repo.Save(&amp;Issue{
  Title: &quot;I want more features&quot;,
  Author: user.ID,
})

err = repo.Save(newRelease(&quot;0.10&quot;))

var issues []Issue
err = repo.Find(&quot;Author&quot;, user.ID, &amp;issues)

var release Release
err = repo.One(&quot;Tag&quot;, &quot;0.10&quot;, &amp;release)
</code></pre>
<p>노드를 체인으로 연결해 계층 구조를 만들 수도 있습니다.</p>
<pre><code class="language-go">chars := db.From(&quot;characters&quot;)
heroes := chars.From(&quot;heroes&quot;)
enemies := chars.From(&quot;enemies&quot;)

items := db.From(&quot;items&quot;)
potions := items.From(&quot;consumables&quot;).From(&quot;medicine&quot;).From(&quot;potions&quot;)
</code></pre>
<p>전체 계층을 <code>From</code>의 인자로 전달하는 것도 가능합니다:</p>
<pre><code class="language-go">privateNotes := db.From(&quot;notes&quot;, &quot;private&quot;)
workNotes :=  db.From(&quot;notes&quot;, &quot;work&quot;)
</code></pre>
<h3>노드 옵션</h3>
<p>노드도 설정할 수 있습니다. 노드에서 옵션을 활성화하면 복사본이 생성되므로 노드는 항상 스레드 세이프(thread-safe)입니다.</p>
<pre><code class="language-go">n := db.From(&quot;my-node&quot;)
</code></pre>
<p>노드에 bolt.Tx 트랜잭션을 전달하기</p>
<pre><code class="language-go">n = n.WithTransaction(tx)
</code></pre>
<p>배치 모드 활성화</p>
<pre><code class="language-go">n = n.WithBatch(true)
</code></pre>
<p>코덱 사용</p>
<pre><code class="language-go">n = n.WithCodec(gob.Codec)
</code></pre>
<h2>간단한 Key/Value 저장소</h2>
<p>Storm은 간단하고 견고한 key/value 저장소로도 사용할 수 있습니다.
키와 값은 키가 0값(zero value)이 아니기만 하면 어떤 타입이든 가능합니다.</p>
<p>데이터 저장:</p>
<pre><code class="language-go">db.Set(&quot;logs&quot;, time.Now(), &quot;I'm eating my breakfast man&quot;)
db.Set(&quot;sessions&quot;, bson.NewObjectId(), &amp;someUser)
db.Set(&quot;weird storage&quot;, &quot;754-3010&quot;, map[string]interface{}{
  &quot;hair&quot;: &quot;blonde&quot;,
  &quot;likes&quot;: []string{&quot;cheese&quot;, &quot;star wars&quot;},
})
</code></pre>
<p>데이터 조회:</p>
<pre><code class="language-go">user := User{}
db.Get(&quot;sessions&quot;, someObjectId, &amp;user)

var details map[string]interface{}
db.Get(&quot;weird storage&quot;, &quot;754-3010&quot;, &amp;details)
</code></pre>
<p>db.Get(&quot;sessions&quot;, someObjectId, &amp;details)</p>
<pre><code>
데이터 삭제 :

```go
db.Delete(&quot;sessions&quot;, someObjectId)
db.Delete(&quot;weird storage&quot;, &quot;754-3010&quot;)
</code></pre>
<p>다른 유용한 메서드들은 <a href="https://godoc.org/github.com/asdine/storm#KeyValueStore">문서</a>에서 확인할 수 있습니다.</p>
<h2>BoltDB</h2>
<p>BoltDB는 여전히 쉽게 접근할 수 있으며, 기존과 동일하게 사용할 수 있습니다.</p>
<pre><code class="language-go">db.Bolt.View(func(tx *bolt.Tx) error {
  bucket := tx.Bucket([]byte(&quot;my bucket&quot;))
  val := bucket.Get([]byte(&quot;any id&quot;))
  fmt.Println(string(val))
  return nil
})
</code></pre>
<p>트랜잭션도 Storm에 전달할 수 있습니다.</p>
<pre><code class="language-go">db.Bolt.Update(func(tx *bolt.Tx) error {
  ...
  dbx := db.WithTransaction(tx)
  err = dbx.Save(&amp;user)
  ...
  return nil
})
</code></pre>
<h2>라이선스</h2>
<p>MIT</p>
<h2>크레딧</h2>
<ul>
<li><a href="https://github.com/asdine">Asdine El Hrychy</a></li>
<li><a href="https://github.com/bep">Bjørn Erik Pedersen</a></li>
</ul>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-11</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>