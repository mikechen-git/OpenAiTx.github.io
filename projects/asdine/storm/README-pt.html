<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>storm - asdine/storm</title>
    <meta name="title" content="storm - asdine/storm">
    <meta name="description" content="asdine/storm - GitHub repository pt documentation and informationStorm Storm é um kit de ferramentas simples e poderoso para BoltDB. Basicamente, Storm fornece índices, uma ampla variedade de métodos para armazenar e buscar dados, um sistema de consultas avançado e muito mais. Além dos exemplos abaixo, veja também os exemplos na GoDoc. Para consultas estendidas e suporte ao Badger, veja também o Genji Índice Primeiros Passos Importar Storm Abrir um banco de dados Sistema CRUD simples Declarar suas estruturas Salvar seu objeto Auto Incremento Consultas simples Buscar um objeto Buscar múltiplos objetos Buscar todos os objetos Buscar todos os objetos ordenados por índice Buscar um intervalo de objetos Buscar objetos por prefixo Pular, Limitar e Reverter Excluir um objeto Atualizar um objeto Inicializar buckets e índices antes de salvar um objeto Excluir um bucket Reindexar um bucket Consultas avançadas Transações Opções BoltOptions MarshalUnmarshaler Codecs fornecidos Usar conexão Bolt existente Modo batch Nodes e buckets aninhados Opções de Node...">
    <meta name="keywords" content="asdine, storm, GitHub, repository, pt documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/asdine/storm/README-pt.html">
    <meta property="og:title" content="storm - asdine/storm">
    <meta property="og:description" content="asdine/storm - GitHub repository pt documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/asdine/storm" id="githubRepoLink" target="_blank">asdine/storm</a>
<br>
<h1 style="display: none;">Storm Storm é um kit de ferramentas simples e poderoso para BoltDB. Basicamente, Storm fornece índices, uma ampla variedade de métodos para armazenar e buscar dados, um sistema de consultas avançado e muito mais. Além dos exemplos abaixo, veja também os exemplos na GoDoc. Para consultas estendidas e suporte ao Badger, veja também o Genji Índice Primeiros Passos Importar Storm Abrir um banco de dados Sistema CRUD simples Declarar suas estruturas Salvar seu objeto Auto Incremento Consultas simples Buscar um objeto Buscar múltiplos objetos Buscar todos os objetos Buscar todos os objetos ordenados por índice Buscar um intervalo de objetos Buscar objetos por prefixo Pular, Limitar e Reverter Excluir um objeto Atualizar um objeto Inicializar buckets e índices antes de salvar um objeto Excluir um bucket Reindexar um bucket Consultas avançadas Transações Opções BoltOptions MarshalUnmarshaler Codecs fornecidos Usar conexão Bolt existente Modo batch Nodes e buckets aninhados Opções de Node...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>Storm</h1>
<p><a href="https://travis-ci.org/asdine/storm"><img src="https://travis-ci.org/asdine/storm.svg" alt="Build Status" /></a>
<a href="https://godoc.org/github.com/asdine/storm"><img src="https://godoc.org/github.com/asdine/storm?status.svg" alt="GoDoc" /></a></p>
<p>Storm é um kit de ferramentas simples e poderoso para <a href="https://github.com/coreos/bbolt">BoltDB</a>. Basicamente, Storm fornece índices, uma ampla variedade de métodos para armazenar e buscar dados, um sistema de consultas avançado e muito mais.</p>
<p>Além dos exemplos abaixo, veja também os <a href="https://godoc.org/github.com/asdine/storm#pkg-examples">exemplos na GoDoc</a>.</p>
<p><em>Para consultas estendidas e suporte ao <a href="https://github.com/dgraph-io/badger">Badger</a>, veja também o <a href="https://github.com/asdine/genji">Genji</a></em></p>
<h2>Índice</h2>
<ul>
<li><a href="#getting-started">Primeiros Passos</a></li>
<li><a href="#import-storm">Importar Storm</a></li>
<li><a href="#open-a-database">Abrir um banco de dados</a></li>
<li><a href="#simple-crud-system">Sistema CRUD simples</a>
<ul>
<li><a href="#declare-your-structures">Declarar suas estruturas</a></li>
<li><a href="#save-your-object">Salvar seu objeto</a>
<ul>
<li><a href="#auto-increment">Auto Incremento</a></li>
</ul>
</li>
<li><a href="#simple-queries">Consultas simples</a>
<ul>
<li><a href="#fetch-one-object">Buscar um objeto</a></li>
<li><a href="#fetch-multiple-objects">Buscar múltiplos objetos</a></li>
<li><a href="#fetch-all-objects">Buscar todos os objetos</a></li>
<li><a href="#fetch-all-objects-sorted-by-index">Buscar todos os objetos ordenados por índice</a></li>
<li><a href="#fetch-a-range-of-objects">Buscar um intervalo de objetos</a></li>
<li><a href="#fetch-objects-by-prefix">Buscar objetos por prefixo</a></li>
<li><a href="#skip-limit-and-reverse">Pular, Limitar e Reverter</a></li>
<li><a href="#delete-an-object">Excluir um objeto</a></li>
<li><a href="#update-an-object">Atualizar um objeto</a></li>
<li><a href="#initialize-buckets-and-indexes-before-saving-an-object">Inicializar buckets e índices antes de salvar um objeto</a></li>
<li><a href="#drop-a-bucket">Excluir um bucket</a></li>
<li><a href="#re-index-a-bucket">Reindexar um bucket</a></li>
</ul>
</li>
<li><a href="#advanced-queries">Consultas avançadas</a></li>
<li><a href="#transactions">Transações</a></li>
<li><a href="#options">Opções</a>
<ul>
<li><a href="#boltoptions">BoltOptions</a></li>
<li><a href="#marshalunmarshaler">MarshalUnmarshaler</a>
<ul>
<li><a href="#provided-codecs">Codecs fornecidos</a></li>
</ul>
</li>
<li><a href="#use-existing-bolt-connection">Usar conexão Bolt existente</a></li>
<li><a href="#batch-mode">Modo batch</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#nodes-and-nested-buckets">Nodes e buckets aninhados</a>
<ul>
<li><a href="#node-options">Opções de Node</a></li>
</ul>
</li>
<li><a href="#simple-keyvalue-store">Armazenamento Simples Chave/Valor</a></li>
<li><a href="#boltdb">BoltDB</a></li>
<li><a href="#license">Licença</a></li>
<li><a href="#credits">Créditos</a></li>
</ul>
<h2>Primeiros Passos</h2>
<pre><code class="language-bash">GO111MODULE=on go get -u github.com/asdine/storm/v3
</code></pre>
<h2>Importar Storm</h2>
<pre><code class="language-go">import &quot;github.com/asdine/storm/v3&quot;
</code></pre>
<h2>Abrir um banco de dados</h2>
<p>Forma rápida de abrir um banco de dados</p>
<pre><code class="language-go">db, err := storm.Open(&quot;my.db&quot;)

defer db.Close()
</code></pre>
<p><code>Open</code> pode receber múltiplas opções para customizar seu comportamento. Veja <a href="#options">Opções</a> abaixo</p>
<h2>Sistema CRUD simples</h2>
<h3>Declarar suas estruturas</h3>
<pre><code class="language-go">type User struct {
  ID int // chave primária
  Group string `storm:&quot;index&quot;` // este campo será indexado
  Email string `storm:&quot;unique&quot;` // este campo será indexado com restrição de unicidade
  Name string // este campo não será indexado
  Age int `storm:&quot;index&quot;`
}
</code></pre>
<p>A chave primária pode ser de qualquer tipo, desde que não seja um valor zero. O Storm procurará pela tag <code>id</code>; se não estiver presente, procurará por um campo chamado <code>ID</code>.</p>
<pre><code class="language-go">type User struct {
  ThePrimaryKey string `storm:&quot;id&quot;`// chave primária
  Group string `storm:&quot;index&quot;` // este campo será indexado
  Email string `storm:&quot;unique&quot;` // este campo será indexado com restrição de unicidade
  Name string // este campo não será indexado
}
</code></pre>
<p>O Storm lida com tags em estruturas aninhadas usando a tag <code>inline</code></p>
<pre><code class="language-go">type Base struct {
  Ident bson.ObjectId `storm:&quot;id&quot;`
}

type User struct {
  Base      `storm:&quot;inline&quot;`
  Group     string `storm:&quot;index&quot;`
  Email     string `storm:&quot;unique&quot;`
  Name      string
  CreatedAt time.Time `storm:&quot;index&quot;`
}
</code></pre>
<h3>Salvar seu objeto</h3>
<pre><code class="language-go">user := User{
  ID: 10,
  Group: &quot;staff&quot;,
  Email: &quot;john@provider.com&quot;,
  Name: &quot;John&quot;,
  Age: 21,
  CreatedAt: time.Now(),
}

err := db.Save(&amp;user)
// err == nil

user.ID++
err = db.Save(&amp;user)
// err == storm.ErrAlreadyExists
</code></pre>
<p>É isso.</p>
<p><code>Save</code> cria ou atualiza todos os índices e buckets necessários, verifica as restrições de unicidade e salva o objeto no armazenamento.</p>
<h4>Auto Incremento</h4>
<p>O Storm pode incrementar valores inteiros automaticamente para que você não precise se preocupar com isso ao salvar seus objetos. Além disso, o novo valor é inserido automaticamente em seu campo.</p>
<pre><code class="language-go">
type Product struct {
  Pk                  int `storm:&quot;id,increment&quot;` // chave primária com auto incremento
  Name                string
  IntegerField        uint64 `storm:&quot;increment&quot;`
  IndexedIntegerField uint32 `storm:&quot;index,increment&quot;`
  UniqueIntegerField  int16  `storm:&quot;unique,increment=100&quot;` // o valor inicial pode ser definido
}

p := Product{Name: &quot;Vaccum Cleaner&quot;}

fmt.Println(p.Pk)
fmt.Println(p.IntegerField)
fmt.Println(p.IndexedIntegerField)
fmt.Println(p.UniqueIntegerField)
// 0
// 0
// 0
// 0

_ = db.Save(&amp;p)

fmt.Println(p.Pk)
fmt.Println(p.IntegerField)
fmt.Println(p.IndexedIntegerField)
fmt.Println(p.UniqueIntegerField)
// 1
// 1
// 1
// 100

</code></pre>
<h3>Consultas simples</h3>
<p>Qualquer objeto pode ser buscado, indexado ou não. O Storm usa índices quando disponíveis, caso contrário, utiliza o <a href="#advanced-queries">sistema de consultas</a>.</p>
<h4>Buscar um objeto</h4>
<pre><code class="language-go">var user User
err := db.One(&quot;Email&quot;, &quot;john@provider.com&quot;, &amp;user)
// err == nil

err = db.One(&quot;Name&quot;, &quot;John&quot;, &amp;user)
// err == nil

err = db.One(&quot;Name&quot;, &quot;Jack&quot;, &amp;user)
// err == storm.ErrNotFound
</code></pre>
<h4>Buscar múltiplos objetos</h4>
<pre><code class="language-go">var users []User
err := db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users)
</code></pre>
<h4>Buscar todos os objetos</h4>
<pre><code class="language-go">var users []User
err := db.All(&amp;users)
</code></pre>
<h4>Buscar todos os objetos ordenados por índice</h4>
<pre><code class="language-go">var users []User
err := db.AllByIndex(&quot;CreatedAt&quot;, &amp;users)
</code></pre>
<h4>Buscar um intervalo de objetos</h4>
<pre><code class="language-go">var users []User
err := db.Range(&quot;Age&quot;, 10, 21, &amp;users)
</code></pre>
<h4>Buscar objetos por prefixo</h4>
<pre><code class="language-go">var users []User
err := db.Prefix(&quot;Name&quot;, &quot;Jo&quot;, &amp;users)
</code></pre>
<h4>Skip, Limit e Reverse</h4>
<pre><code class="language-go">var users []User
err := db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Skip(10))
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Limit(10))
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Reverse())
err = db.Find(&quot;Group&quot;, &quot;staff&quot;, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())

err = db.All(&amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
err = db.AllByIndex(&quot;CreatedAt&quot;, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
err = db.Range(&quot;Age&quot;, 10, 21, &amp;users, storm.Limit(10), storm.Skip(10), storm.Reverse())
</code></pre>
<h4>Excluir um objeto</h4>
<pre><code class="language-go">err := db.DeleteStruct(&amp;user)
</code></pre>
<h4>Atualizar um objeto</h4>
<pre><code class="language-go">// Atualizar vários campos
// Funciona apenas para campos com valor diferente do zero (por exemplo, Name não pode ser &quot;&quot;, Age não pode ser 0)
err := db.Update(&amp;User{ID: 10, Name: &quot;Jack&quot;, Age: 45})

// Atualizar um único campo
// Também funciona para campos com valor zero (0, false, &quot;&quot;, ...)
err := db.UpdateField(&amp;User{ID: 10}, &quot;Age&quot;, 0)
</code></pre>
<h4>Inicializar buckets e índices antes de salvar um objeto</h4>
<pre><code class="language-go">err := db.Init(&amp;User{})
</code></pre>
<p>Útil ao iniciar sua aplicação</p>
<h4>Remover um bucket</h4>
<p>Usando a struct</p>
<pre><code class="language-go">err := db.Drop(&amp;User)
</code></pre>
<p>Usando o nome do bucket</p>
<pre><code class="language-go">err := db.Drop(&quot;User&quot;)
</code></pre>
<h4>Reindexar um bucket</h4>
<pre><code class="language-go">err := db.ReIndex(&amp;User{})
</code></pre>
<p>Útil quando a estrutura foi alterada</p>
<h3>Consultas avançadas</h3>
<p>Para consultas mais complexas, você pode usar o método <code>Select</code>.
<code>Select</code> aceita qualquer número de <a href="https://godoc.org/github.com/asdine/storm/q#Matcher"><code>Matcher</code></a> do pacote <a href="https://godoc.org/github.com/asdine/storm/q"><code>q</code></a>.</p>
<p>Aqui estão alguns Matchers comuns:</p>
<pre><code class="language-go">// Igualdade
q.Eq(&quot;Name&quot;, John)

// Estritamente maior que
q.Gt(&quot;Age&quot;, 7)

// Menor ou igual a
q.Lte(&quot;Age&quot;, 77)

// Regex com nome começando com a letra D
q.Re(&quot;Name&quot;, &quot;^D&quot;)

// Dentro de um slice de valores fornecido
q.In(&quot;Group&quot;, []string{&quot;Staff&quot;, &quot;Admin&quot;})

// Comparando campos
q.EqF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.LtF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.GtF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.LteF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
q.GteF(&quot;FieldName&quot;, &quot;SecondFieldName&quot;)
</code></pre>
<p>Matchers também podem ser combinados com <code>And</code>, <code>Or</code> e <code>Not</code>:</p>
<pre><code class="language-go">
// Corresponde se todos coincidirem
q.And(
  q.Gt(&quot;Age&quot;, 7),
  q.Re(&quot;Name&quot;, &quot;^D&quot;)
)

// Corresponde se algum coincidir
q.Or(
  q.Re(&quot;Name&quot;, &quot;^A&quot;),
  q.Not(
    q.Re(&quot;Name&quot;, &quot;^B&quot;)
  ),
  q.Re(&quot;Name&quot;, &quot;^C&quot;),
  q.In(&quot;Group&quot;, []string{&quot;Staff&quot;, &quot;Admin&quot;}),
  q.And(
    q.StrictEq(&quot;Password&quot;, []byte(password)),
    q.Eq(&quot;Registered&quot;, true)
  )
)
</code></pre>
<p>Você pode encontrar a lista completa na <a href="https://godoc.org/github.com/asdine/storm/q#Matcher">documentação</a>.</p>
<p><code>Select</code> aceita qualquer número de matchers e os encapsula em um <code>q.And()</code>, então não é necessário especificá-lo. Ele retorna um tipo <a href="https://godoc.org/github.com/asdine/storm#Query"><code>Query</code></a>.</p>
<pre><code class="language-go">query := db.Select(q.Gte(&quot;Age&quot;, 7), q.Lte(&quot;Age&quot;, 77))
</code></pre>
<p>O tipo <code>Query</code> contém métodos para filtrar e ordenar os registros.</p>
<pre><code class="language-go">// Limitar
query = query.Limit(10)

// Pular
query = query.Skip(20)

// As chamadas também podem ser encadeadas
query = query.Limit(10).Skip(20).OrderBy(&quot;Age&quot;).Reverse()
</code></pre>
<p>Mas também para especificar como buscá-los.</p>
<pre><code class="language-go">var users []User
err = query.Find(&amp;users)

var user User
err = query.First(&amp;user)
</code></pre>
<p>Exemplos com <code>Select</code>:</p>
<pre><code class="language-go">// Encontrar todos os usuários com um ID entre 10 e 100
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Find(&amp;users)

// Matchers aninhados
err = db.Select(q.Or(
  q.Gt(&quot;ID&quot;, 50),
  q.Lt(&quot;Age&quot;, 21),
  q.And(
    q.Eq(&quot;Group&quot;, &quot;admin&quot;),
    q.Gte(&quot;Age&quot;, 21),
  ),
)).Find(&amp;users)

query := db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;)

// Encontrar múltiplos registros
err = query.Find(&amp;users)
// ou
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;).Find(&amp;users)
</code></pre>
<p>// Encontrar o primeiro registro
err = query.First(&amp;user)
// ou
err = db.Select(q.Gte(&quot;ID&quot;, 10), q.Lte(&quot;ID&quot;, 100)).Limit(10).Skip(5).Reverse().OrderBy(&quot;Age&quot;, &quot;Name&quot;).First(&amp;user)</p>
<p>// Deletar todos os registros correspondentes
err = query.Delete(new(User))</p>
<p>// Buscar registros um por um (útil quando o bucket contém muitos registros)
query = db.Select(q.Gte(&quot;ID&quot;, 10),q.Lte(&quot;ID&quot;, 100)).OrderBy(&quot;Age&quot;, &quot;Name&quot;)</p>
<p>err = query.Each(new(User), func(record interface{}) error) {
u := record.(*User)
...
return nil
}</p>
<pre><code>
Veja a [documentação](https://godoc.org/github.com/asdine/storm#Query) para uma lista completa de métodos.

### Transações

```go
tx, err := db.Begin(true)
if err != nil {
  return err
}
defer tx.Rollback()

accountA.Amount -= 100
accountB.Amount += 100

err = tx.Save(accountA)
if err != nil {
  return err
}

err = tx.Save(accountB)
if err != nil {
  return err
}

return tx.Commit()
</code></pre>
<h3>Opções</h3>
<p>As opções do Storm são funções que podem ser passadas ao construir sua instância Storm. Você pode passar qualquer número de opções.</p>
<h4>BoltOptions</h4>
<p>Por padrão, o Storm abre um banco de dados com o modo <code>0600</code> e um timeout de um segundo.
Você pode alterar esse comportamento usando <code>BoltOptions</code></p>
<pre><code class="language-go">db, err := storm.Open(&quot;my.db&quot;, storm.BoltOptions(0600, &amp;bolt.Options{Timeout: 1 * time.Second}))
</code></pre>
<h4>MarshalUnmarshaler</h4>
<p>Para armazenar os dados no BoltDB, o Storm faz o marshal em JSON por padrão. Se você quiser alterar esse comportamento, pode passar um codec que implemente <a href="https://godoc.org/github.com/asdine/storm/codec#MarshalUnmarshaler"><code>codec.MarshalUnmarshaler</code></a> via a opção <a href="https://godoc.org/github.com/asdine/storm#Codec"><code>storm.Codec</code></a>:</p>
<pre><code class="language-go">db := storm.Open(&quot;my.db&quot;, storm.Codec(myCodec))
</code></pre>
<h5>Codecs fornecidos</h5>
<p>Você pode facilmente implementar seu próprio <code>MarshalUnmarshaler</code>, mas o Storm vem com suporte nativo para <a href="https://godoc.org/github.com/asdine/storm/codec/json">JSON</a> (padrão), <a href="https://godoc.org/github.com/asdine/storm/codec/gob">GOB</a>, <a href="https://godoc.org/github.com/asdine/storm/codec/sereal">Sereal</a>, <a href="https://godoc.org/github.com/asdine/storm/codec/protobuf">Protocol Buffers</a> e <a href="https://godoc.org/github.com/asdine/storm/codec/msgpack">MessagePack</a>.</p>
<p>Esses codecs podem ser utilizados importando o pacote correspondente e usando-o para configurar o Storm. O exemplo abaixo mostra todas as variantes (sem tratamento de erros):</p>
<pre><code class="language-go">import (
  &quot;github.com/asdine/storm/v3&quot;
  &quot;github.com/asdine/storm/v3/codec/gob&quot;
  &quot;github.com/asdine/storm/v3/codec/json&quot;
  &quot;github.com/asdine/storm/v3/codec/sereal&quot;
  &quot;github.com/asdine/storm/v3/codec/protobuf&quot;
  &quot;github.com/asdine/storm/v3/codec/msgpack&quot;
)

var gobDb, _ = storm.Open(&quot;gob.db&quot;, storm.Codec(gob.Codec))
var jsonDb, _ = storm.Open(&quot;json.db&quot;, storm.Codec(json.Codec))
var serealDb, _ = storm.Open(&quot;sereal.db&quot;, storm.Codec(sereal.Codec))
var protobufDb, _ = storm.Open(&quot;protobuf.db&quot;, storm.Codec(protobuf.Codec))
var msgpackDb, _ = storm.Open(&quot;msgpack.db&quot;, storm.Codec(msgpack.Codec))
</code></pre>
<p><strong>Dica</strong>: Adicionar tags do Storm a arquivos Protobuf gerados pode ser complicado. Uma boa solução é usar <a href="https://github.com/favadi/protoc-go-inject-tag">esta ferramenta</a> para injetar as tags durante a compilação.</p>
<h4>Usar conexão Bolt existente</h4>
<p>Você pode usar uma conexão existente e passá-la para o Storm</p>
<pre><code class="language-go">bDB, _ := bolt.Open(filepath.Join(dir, &quot;bolt.db&quot;), 0600, &amp;bolt.Options{Timeout: 10 * time.Second})
db := storm.Open(&quot;my.db&quot;, storm.UseDB(bDB))
</code></pre>
<h4>Modo Batch</h4>
<p>O modo batch pode ser habilitado para acelerar escritas concorrentes (veja <a href="https://github.com/coreos/bbolt#batch-read-write-transactions">Batch read-write transactions</a>)</p>
<pre><code class="language-go">db := storm.Open(&quot;my.db&quot;, storm.Batch())
</code></pre>
<h2>Nodes e buckets aninhados</h2>
<p>O Storm aproveita o recurso de buckets aninhados do BoltDB usando <code>storm.Node</code>.
Um <code>storm.Node</code> é o objeto subjacente usado pelo <code>storm.DB</code> para manipular um bucket.
Para criar um bucket aninhado e usar a mesma API do <code>storm.DB</code>, você pode usar o método <code>DB.From</code>.</p>
<pre><code class="language-go">repo := db.From(&quot;repo&quot;)

err := repo.Save(&amp;Issue{
  Title: &quot;I want more features&quot;,
  Author: user.ID,
})

err = repo.Save(newRelease(&quot;0.10&quot;))

var issues []Issue
err = repo.Find(&quot;Author&quot;, user.ID, &amp;issues)

var release Release
err = repo.One(&quot;Tag&quot;, &quot;0.10&quot;, &amp;release)
</code></pre>
<p>Você também pode encadear os nodes para criar uma hierarquia</p>
<pre><code class="language-go">chars := db.From(&quot;characters&quot;)
heroes := chars.From(&quot;heroes&quot;)
enemies := chars.From(&quot;enemies&quot;)

items := db.From(&quot;items&quot;)
potions := items.From(&quot;consumables&quot;).From(&quot;medicine&quot;).From(&quot;potions&quot;)
</code></pre>
<p>Você pode até passar toda a hierarquia como argumentos para <code>From</code>:</p>
<pre><code class="language-go">privateNotes := db.From(&quot;notes&quot;, &quot;private&quot;)
workNotes :=  db.From(&quot;notes&quot;, &quot;work&quot;)
</code></pre>
<h3>Opções do Node</h3>
<p>Um Node também pode ser configurado. Ativar uma opção em um Node cria uma cópia, então um Node é sempre thread-safe.</p>
<pre><code class="language-go">n := db.From(&quot;my-node&quot;)
</code></pre>
<p>Dar uma transação bolt.Tx para o Node</p>
<pre><code class="language-go">n = n.WithTransaction(tx)
</code></pre>
<p>Habilitar modo batch</p>
<pre><code class="language-go">n = n.WithBatch(true)
</code></pre>
<p>Usar um Codec</p>
<pre><code class="language-go">n = n.WithCodec(gob.Codec)
</code></pre>
<h2>Armazenamento simples de chave/valor</h2>
<p>O Storm pode ser usado como um armazenamento de chave/valor simples e robusto, que pode armazenar qualquer coisa.
A chave e o valor podem ser de qualquer tipo, desde que a chave não seja um valor zero.</p>
<p>Salvando dados:</p>
<pre><code class="language-go">db.Set(&quot;logs&quot;, time.Now(), &quot;I'm eating my breakfast man&quot;)
db.Set(&quot;sessions&quot;, bson.NewObjectId(), &amp;someUser)
db.Set(&quot;weird storage&quot;, &quot;754-3010&quot;, map[string]interface{}{
  &quot;hair&quot;: &quot;blonde&quot;,
  &quot;likes&quot;: []string{&quot;cheese&quot;, &quot;star wars&quot;},
})
</code></pre>
<p>Buscando dados:</p>
<pre><code class="language-go">user := User{}
db.Get(&quot;sessions&quot;, someObjectId, &amp;user)

var details map[string]interface{}
db.Get(&quot;weird storage&quot;, &quot;754-3010&quot;, &amp;details)
</code></pre>
<p>db.Get(&quot;sessions&quot;, someObjectId, &amp;details)</p>
<pre><code>
Excluindo dados :

```go
db.Delete(&quot;sessions&quot;, someObjectId)
db.Delete(&quot;weird storage&quot;, &quot;754-3010&quot;)
</code></pre>
<p>Você pode encontrar outros métodos úteis na <a href="https://godoc.org/github.com/asdine/storm#KeyValueStore">documentação</a>.</p>
<h2>BoltDB</h2>
<p>BoltDB ainda é facilmente acessível e pode ser usado como de costume</p>
<pre><code class="language-go">db.Bolt.View(func(tx *bolt.Tx) error {
  bucket := tx.Bucket([]byte(&quot;my bucket&quot;))
  val := bucket.Get([]byte(&quot;any id&quot;))
  fmt.Println(string(val))
  return nil
})
</code></pre>
<p>Uma transação também pode ser passada para o Storm</p>
<pre><code class="language-go">db.Bolt.Update(func(tx *bolt.Tx) error {
  ...
  dbx := db.WithTransaction(tx)
  err = dbx.Save(&amp;user)
  ...
  return nil
})
</code></pre>
<h2>Licença</h2>
<p>MIT</p>
<h2>Créditos</h2>
<ul>
<li><a href="https://github.com/asdine">Asdine El Hrychy</a></li>
<li><a href="https://github.com/bep">Bjørn Erik Pedersen</a></li>
</ul>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-11</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Statcounter and other scripts can be added here -->
</body>
</html>