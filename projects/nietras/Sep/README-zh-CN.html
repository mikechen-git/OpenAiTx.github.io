<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sep - nietras/Sep</title>
    <meta name="title" content="Sep - nietras/Sep">
    <meta name="description" content="nietras/Sep - GitHub repository zh-CN documentation and informationSep - 世界上最快的 .NET CSV 解析器 现代、极简、极速、零分配，支持分隔值（如 csv、tsv 等）的读写。跨平台、可裁剪，兼容 AOT/NativeAOT。API 设计有主见，面向实际，特别针对机器学习场景实现。 ⭐ 如果你喜欢这个项目，请为其加星。⭐ 🌃 现代化 - 利用 Span&lt;T&gt;...">
    <meta name="keywords" content="nietras, Sep, GitHub, repository, zh-CN documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/nietras/Sep/README-zh-CN.html">
    <meta property="og:title" content="Sep - nietras/Sep">
    <meta property="og:description" content="nietras/Sep - GitHub repository zh-CN documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/nietras/Sep" id="githubRepoLink" target="_blank">nietras/Sep</a>
<h1 style="display: none;">Sep - 世界上最快的 .NET CSV 解析器 现代、极简、极速、零分配，支持分隔值（如 csv、tsv 等）的读写。跨平台、可裁剪，兼容 AOT/NativeAOT。API 设计有主见，面向实际，特别针对机器学习场景实现。 ⭐ 如果你喜欢这个项目，请为其加星。⭐ 🌃 现代化 - 利用 Span&lt;T&gt;...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <h1>Sep - 世界上最快的 .NET CSV 解析器</h1>
<p><img src="https://img.shields.io/badge/net8.0%20net9.0-5C2D91?logo=.NET&amp;labelColor=gray" alt=".NET" />
<img src="https://img.shields.io/badge/C%23-13.0-239120?labelColor=gray" alt="C#" />
<a href="https://github.com/nietras/Sep/actions/workflows/dotnet.yml"><img src="https://github.com/nietras/Sep/actions/workflows/dotnet.yml/badge.svg?branch=main" alt="Build Status" /></a>
<a href="https://github.com/marketplace/actions/super-linter"><img src="https://github.com/nietras/Sep/actions/workflows/super-linter.yml/badge.svg" alt="Super-Linter" /></a>
<a href="https://codecov.io/gh/nietras/Sep"><img src="https://codecov.io/gh/nietras/Sep/branch/main/graph/badge.svg?token=WN56CR3X0D" alt="codecov" /></a>
<a href="https://github.com/nietras/Sep/actions?query=workflow%3ACodeQL"><img src="https://github.com/nietras/Sep/workflows/CodeQL/badge.svg" alt="CodeQL" /></a>
<a href="https://www.nuget.org/packages/Sep/"><img src="https://img.shields.io/nuget/v/Sep?color=purple" alt="Nuget" /></a>
<a href="https://github.com/nietras/Sep/releases/"><img src="https://img.shields.io/github/v/release/nietras/Sep" alt="Release" /></a>
<a href="https://www.nuget.org/packages/Sep"><img src="https://img.shields.io/nuget/dt/Sep" alt="downloads" /></a>
<img src="https://img.shields.io/github/repo-size/nietras/Sep.svg" alt="Size" />
<a href="https://github.com/nietras/Sep/blob/main/LICENSE"><img src="https://img.shields.io/github/license/nietras/Sep" alt="License" /></a>
<a href="https://nietras.com"><img src="https://img.shields.io/badge/blog-nietras.com-4993DD" alt="Blog" /></a>
<img src="https://img.shields.io/github/stars/nietras/Sep?style=flat" alt="GitHub Repo stars" /></p>
<p>现代、极简、极速、零分配，支持分隔值（如 <code>csv</code>、<code>tsv</code> 等）的读写。跨平台、可裁剪，兼容 AOT/NativeAOT。API 设计有主见，面向实际，特别针对机器学习场景实现。</p>
<p>⭐ 如果你喜欢这个项目，请为其加星。⭐</p>
<p><strong>🌃  现代化</strong> - 利用 <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2018/january/csharp-all-about-span-exploring-a-new-net-mainstay"><code>Span&lt;T&gt;</code></a>、<a href="https://devblogs.microsoft.com/dotnet/dotnet-7-generic-math/">泛型数学</a>（<a href="https://learn.microsoft.com/en-us/dotnet/api/system.ispanparsable-1"><code>ISpanParsable&lt;T&gt;</code></a>/<a href="https://learn.microsoft.com/en-us/dotnet/api/system.ispanformattable"><code>ISpanFormattable</code></a>）、<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/ref-struct"><code>ref struct</code></a>、<a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1"><code>ArrayPool&lt;T&gt;</code></a> 以及 <a href="https://nietras.com/2022/11/26/dotnet-and-csharp-versions/">.NET 7+ 和 C# 11+</a> 的相关特性，带来现代且高效的实现。</p>
<p><strong>🔎 极简</strong> - 简洁且表达力强的 API，选项少，无隐藏的输入输出变化。读写即所得。例如默认情况下不会“自动”转义/反转义引号或修剪空格。可通过 <a href="#sepreaderoptions">SepReaderOptions</a>、<a href="#unescaping">Unescaping</a> 和 <a href="#trimming">Trimming</a> 开启。写入端的 <a href="#escaping">转义</a> 见 <a href="#sepwriteroptions">SepWriterOptions</a>。</p>
<p><strong>🚀 极速</strong> - 支持架构相关和跨平台的 SIMD 向量化解析，包括 64/128/256/512-bit 路径，如 AVX2、AVX-512（.NET 8.0+）、NEON。浮点解析集成 <a href="https://github.com/CarlVerret/csFastFloat">csFastFloat</a>。跨平台详细<a href="#comparison-benchmarks">性能基准</a>。</p>
<p><strong>🌪️ 多线程</strong> - 高效的并行 CSV 解析，<a href="#floats-reader-comparison-benchmarks">速度可达 CsvHelper 的 35 倍</a>，详见 <a href="#parallelenumerate-and-enumerate">ParallelEnumerate</a> 与<a href="#comparison-benchmarks">性能基准</a>。</p>
<p><strong>🌀 异步支持</strong> - 高效的基于 <code>ValueTask</code> 的 <code>async/await</code> 支持。需 C# 13.0+，.NET 9.0+ 下 <code>SepReader</code> 实现 <code>IAsyncEnumerable&lt;&gt;</code>。详见 <a href="#async-support">Async Support</a>。</p>
<p><strong>🗑️ 零分配</strong> - 智能高效的内存管理，预热后零分配，轻松支持读写值数组（如特征）而无需反复分配。</p>
<p><strong>✅ 充分测试</strong> - 覆盖率高，重点关注边界条件测试，包括随机 <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzz 测试</a>。</p>
<p><strong>🌐 跨平台</strong> - 适用于所有 .NET 支持的平台和架构。100% 纯托管，现代 C# 编写。</p>
<p><strong>✂️ 可裁剪且兼容 AOT/NativeAOT</strong> - 无反射或动态代码生成，完全<a href="https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/prepare-libraries-for-trimming">可裁剪</a>且<a href="https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/">AOT</a> 兼容。控制台测试程序可精简至数 MB。💾</p>
<p><strong>🗣️ 有主见且实用</strong> - 遵循 <a href="https://www.ietf.org/rfc/rfc4180.txt">RFC-4180</a> 基本规范，但对引号与行结束等细节采取有主见的实用做法。见 <a href="#rfc-4180">RFC-4180</a>。</p>
<p><a href="#example">示例</a> | <a href="#naming-and-terminology">命名与术语</a> | <a href="#application-programming-interface-api">API</a> | <a href="#limitations-and-constraints">限制与约束</a> | <a href="#comparison-benchmarks">性能对比</a> | <a href="#example-catalogue">示例目录</a> | <a href="#rfc-4180">RFC-4180</a> | <a href="#frequently-asked-questions-faq">FAQ</a>  | <a href="#public-api-reference">API 参考</a></p>
<h2>示例</h2>
<pre><code class="language-csharp">var text = &quot;&quot;&quot;
           A;B;C;D;E;F
           Sep;🚀;1;1.2;0.1;0.5
           CSV;✅;2;2.2;0.2;1.5
           &quot;&quot;&quot;;

using var reader = Sep.Reader().FromText(text);   // 从表头自动推断分隔符
using var writer = reader.Spec.Writer().ToText(); // Writer 由 reader 'Spec' 定义
                                                  // 读写文件请用 .FromFile(...)/ToFile(...)
var idx = reader.Header.IndexOf(&quot;B&quot;);
var nms = new[] { &quot;E&quot;, &quot;F&quot; };

foreach (var readRow in reader)           // 逐行读取
{
    var a = readRow[&quot;A&quot;].Span;            // ReadOnlySpan&lt;char&gt; 方式取列
    var b = readRow[idx].ToString();      // 列转为 string（可能被池化）
    var c = readRow[&quot;C&quot;].Parse&lt;int&gt;();    // 解析为任意 T : ISpanParsable&lt;T&gt;
    var d = readRow[&quot;D&quot;].Parse&lt;float&gt;();  // 浮点用 csFastFloat 快速解析
    var s = readRow[nms].Parse&lt;double&gt;(); // 多列解析为 Span&lt;T&gt;
                                          // - Sep 自动管理数组分配与复用
    foreach (ref var v in s) { v *= 10; }

    using var writeRow = writer.NewRow(); // 新起一行，Dispose 时写入
    writeRow[&quot;A&quot;].Set(a);                 // Set 支持 ReadOnlySpan&lt;char&gt;
    writeRow[&quot;B&quot;].Set(b);                 // Set 支持 string
    writeRow[&quot;C&quot;].Set($&quot;{c * 2}&quot;);        // 支持插值字符串，无分配
    writeRow[&quot;D&quot;].Format(d / 2);          // Format 任意 T : ISpanFormattable
    writeRow[nms].Format(s);              // 多列直接格式化
    // 列首次访问时自动添加，表头在写首行时写出
}

var expected = &quot;&quot;&quot;
               A;B;C;D;E;F
               Sep;🚀;2;0.6;1;5
               CSV;✅;4;1.1;2;15
               
               &quot;&quot;&quot;;                       // 结尾空行用于统一行结束符
Assert.AreEqual(expected, writer.ToString());

// 上述代码仅供演示。
// 命名简短、常量重复仅为展示。
</code></pre>
<h2>命名与术语</h2>
<p>Sep 的命名/术语不依赖 <a href="#rfc-4180">RFC-4180</a>，而是更贴合机器学习等领域使用场景，并在合适时采用缩写或简写以简化代码且不引起歧义。例如用 <code>Sep</code> 表示 <code>Separator</code>，用 <code>Col</code> 表示 <code>Column</code>。</p>
<p>|术语 | 说明 |
|-----|------|
|<code>Sep</code> | 分隔符（separator/delimiter）的缩写。例如逗号（<code>,</code>）为 CSV 文件的分隔符。|
|<code>Header</code> | 可选的首行，用于定义列名。|
|<code>Row</code> | 一行由若干列（col/column）组成，可能跨多行。又称 record。|
|<code>Col</code> | 列（column/field）的缩写。|
|<code>Line</code> | 一行字符，行结束于 <code>\r\n</code>、<code>\r</code>、<code>\n</code>。|
|<code>Index</code> | 0 基索引，如 <code>RowIndex</code> 为 0 表示首行（或表头）。|
|<code>Number</code> | 1 基索引，如 <code>LineNumber</code> 为 1 表示首行（如 notepad）。由于一行可能跨多行，所以行号有 <em>From</em> 和 <em>ToExcl</em> 区间，语法如 C# 的 <code>[LineNumberFrom..LineNumberToExcl]</code>。|</p>
<h2>应用编程接口（API）</h2>
<p><code>Sep</code> 不仅是库的简写名，也是使用的入口和合法分隔符的容器。其基本定义如下：</p>
<pre><code class="language-csharp">public readonly record struct Sep(char Separator);
</code></pre>
<p>构造时会校验分隔符字符，保证在限定范围内且不是如 <code>&quot;</code>（引号）等特殊字符。见 <a href="https://raw.githubusercontent.com/nietras/Sep/main/src/Sep/Sep.cs">src/Sep/Sep.cs</a>。出于内部优化，分隔符也有限制，不能任用任意字符。</p>
<p>⚠ 注意所有类型均在命名空间 <code>nietras.SeparatedValues</code> 下，而非 <code>Sep</code>，因为类型与命名空间同名会有问题。</p>
<p>入门时可用 <code>Sep</code> 作为静态入口创建 reader 或 writer。例如，reader 用法如下：</p>
<pre><code class="language-csharp">using var reader = Sep.Reader().FromFile(&quot;titanic.csv&quot;);
</code></pre>
<p>其中 <code>.Reader()</code> 相当于：</p>
<pre><code class="language-csharp">using var reader = Sep.Auto.Reader().FromFile(&quot;titanic.csv&quot;);
</code></pre>
<p><code>Sep? Auto =&gt; null;</code> 为静态属性，返回 <code>null</code> 表示分隔符需从首行（可能是表头）自动推断。若首行没有支持的分隔符或无行，则采用默认分隔符。</p>
<p>⚠ Sep 默认分隔符为 <code>;</code>，因为内部专有库原本如此设计，也可避免 <code>,</code> 在部分本地化场景被用作小数点而必须加引号。</p>
<p>如需指定分隔符，可写：</p>
<pre><code class="language-csharp">using var reader = Sep.New(',').Reader().FromFile(&quot;titanic.csv&quot;);
</code></pre>
<p>或</p>
<pre><code class="language-csharp">var sep = new Sep(',');
using var reader = sep.Reader().FromFile(&quot;titanic.csv&quot;);
</code></pre>
<p>writer 类似：</p>
<pre><code class="language-csharp">using var writer = Sep.Writer().ToFile(&quot;titanic.csv&quot;);
</code></pre>
<p>或</p>
<pre><code class="language-csharp">using var writer = Sep.New(',').Writer().ToFile(&quot;titanic.csv&quot;);
</code></pre>
<p>writer 必须指定有效分隔符，无法自动推断。为便于分隔符与 <code>CultureInfo</code> 流转，<code>SepReader</code> 和 <code>SepWriter</code> 均有 <code>Spec</code> 属性，类型为 <a href="https://raw.githubusercontent.com/nietras/Sep/main/src/Sep/SepSpec.cs"><code>SepSpec</code></a>，只定义这两项。示例：</p>
<pre><code class="language-csharp">using var reader = Sep.Reader().FromFile(&quot;titanic.csv&quot;);
using var writer = reader.Spec.Writer().ToFile(&quot;titanic-survivors.csv&quot;);
</code></pre>
<p>此时 writer 会采用 reader 推断的分隔符。</p>
<h3>API 模式</h3>
<p>整体读写流程类似如下：</p>
<pre><code class="language-text">Sep/Spec =&gt; SepReaderOptions =&gt; SepReader =&gt; Row =&gt; Col(s) =&gt; Span/ToString/Parse
Sep/Spec =&gt; SepWriterOptions =&gt; SepWriter =&gt; Row =&gt; Col(s) =&gt; Set/Format
</code></pre>
<p>每一步都流畅衔接。例如 <code>Reader()</code> 是 <code>Sep</code> 或 <code>SepSpec</code> 的扩展方法，返回 <code>SepReaderOptions</code>。<code>Writer()</code> 同理返回 <code>SepWriterOptions</code>。</p>
<p><a href="https://raw.githubusercontent.com/nietras/Sep/main/src/Sep/SepReaderOptions.cs"><code>SepReaderOptions</code></a> 与 <a href="https://raw.githubusercontent.com/nietras/Sep/main/src/Sep/SepWriterOptions.cs"><code>SepWriterOptions</code></a> 可选配置。后续各节有详细 API 说明。</p>
<p>完整示例见上方 <a href="#example">示例</a> 或 <a href="https://raw.githubusercontent.com/nietras/Sep/main/src/Sep.XyzTest/ReadMeTest.cs">ReadMeTest.cs</a>。</p>
<p>⚠ Sep 的 <code>Row</code>/<code>Col</code>/<code>Cols</code> 是 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/ref-struct"><code>ref struct</code></a>（请点击链接了解其限制）。这些类型仅作为底层 reader/writer 的门面/间接层，不能用 LINQ，也不能 <code>reader.ToArray()</code>。从 .NET9+ 起 reader 实现了 <code>IEnumerable&lt;&gt;</code>，但 ref struct 依然不兼容 LINQ。需要 per row 状态时请自行解析或复制。<code>Col</code>/<code>Cols</code> 也指向可复用的内部状态，避免为每行分配，确保最佳性能，同时保证结构良好且易用的 API。更多说明见<a href="#why-sepreader-was-not-ienumerable-until-net-9-and-is-not-linq-compatible">相关章节</a>。</p>
<p>⚠ 公共类型和方法见 <a href="#public-api-reference">API 参考</a>。</p>
<h3>SepReader API</h3>
<p><code>SepReader</code> API 结构（伪 C#）如下：</p>
<pre><code class="language-csharp">using var reader = Sep.Reader(o =&gt; o).FromFile/FromText/From...;
var header = reader.Header;
var _ = header.IndexOf/IndicesOf/NamesStartingWith...;
foreach (var row in reader)
{
    var _ = row[colName/colNames].Span/ToString/Parse&lt;T&gt;...;
    var _ = row[colIndex/colIndices].Span/ToString/Parse&lt;T&gt;...;
}
</code></pre>
<p>使用要点如下：</p>
<ol>
<li>可选指定 <code>Sep</code> 或自动推断分隔符。</li>
<li>创建 reader，可选配置 <code>SepReaderOptions</code>。如无表头可用：
<pre><code class="language-csharp">Sep.Reader(o =&gt; o with { HasHeader = false })
</code></pre>
所有选项见 <a href="#sepreaderoptions">SepReaderOptions</a>。</li>
<li>通过 <code>From</code> 方法指定数据源，如文件、字符串（<code>string</code>）、<code>TextWriter</code> 等。</li>
<li>可选访问表头。例如取所有以 <code>GT_</code> 开头的列名：
<pre><code class="language-csharp">var colNames = header.NamesStarting(&quot;GT_&quot;);
var colIndices = header.IndicesOf(colNames);
</code></pre>
</li>
<li>逐行遍历，每次只处理一行。</li>
<li>通过列名或索引访问列，亦可批量操作。Sep 内部池化/复用多列操作所需的数组。</li>
<li>用 <code>Span</code> 直接访问列（<code>ReadOnlySpan&lt;char&gt;</code>），或用 <code>ToString</code> 转为字符串，或用 <code>Parse&lt;T&gt;</code>（T : ISpanParsable<T>）解析为类型。</li>
</ol>
<h4>SepReaderOptions</h4>
<p>可用选项如下：</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 指定分隔符，若为 `null` 则自动检测（首行）。
/// &lt;/summary&gt;
public Sep? Sep { get; init; } = null;
/// &lt;summary&gt;
/// 内部 char 缓冲区初始长度。
/// &lt;/summary&gt;
public int InitialBufferLength { get; init; } = SepDefaults.InitialBufferLength;
/// &lt;summary&gt;
/// 解析用区域文化（culture），可为 null 表示默认。
/// &lt;/summary&gt;
public CultureInfo? CultureInfo { get; init; } = SepDefaults.CultureInfo;
/// &lt;summary&gt;
/// 首行是否为表头。
/// &lt;/summary&gt;
public bool HasHeader { get; init; } = true;
/// &lt;summary&gt;
/// 比较表头列名和索引时用的 IEqualityComparer。
/// &lt;/summary&gt;
public IEqualityComparer&lt;string&gt; ColNameComparer { get; init; } = SepDefaults.ColNameComparer;
/// &lt;summary&gt;
/// 列 span 转 string 的方法工厂。
/// &lt;/summary&gt;
public SepCreateToString CreateToString { get; init; } = SepToString.Direct;
/// &lt;summary&gt;
/// 禁用 csFastFloat 解析 float/double。
/// &lt;/summary&gt;
public bool DisableFastFloat { get; init; } = false;
/// &lt;summary&gt;
/// 禁用列数一致性检查。
/// &lt;/summary&gt;
public bool DisableColCountCheck { get; init; } = false;
/// &lt;summary&gt;
/// 禁用引号解析。
/// &lt;/summary&gt;
public bool DisableQuotesParsing { get; init; } = false;
/// &lt;summary&gt;
/// 列访问时反转义引号。
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// 若为 true，若列以引号开头，则去除最外两引号，内部每对引号去一个。反转义原地操作，故 &lt;see cref=&quot;SepReader.Row.Span&quot; /&gt; 在下次列访问前可能“污染”。效率优先，无需二次分配。表头也会反转义。需 &lt;see cref=&quot;DisableQuotesParsing&quot;/&gt; 为 false。
/// &lt;/remarks&gt;
public bool Unescape { get; init; } = false;
/// &lt;summary&gt;
/// 列访问时修剪空格（仅 ASCII 32）。
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// 默认不修剪。见 &lt;see cref=&quot;SepTrim&quot;/&gt;。修剪也可能原地发生。表头也会修剪。仅修剪空格 ` `（ASCII 32），非所有空白字符。
/// &lt;/remarks&gt;
public SepTrim Trim { get; init; } = SepTrim.None;
/// &lt;summary&gt;
/// async 方法调用时传递的 ConfigureAwait。
/// &lt;/summary&gt;
public bool AsyncContinueOnCapturedContext { get; init; } = false;
</code></pre>
<h4>反转义（Unescaping）</h4>
<p>Sep 反转义引号经过仔细设计以保证正确且高效，但对无效输入时的处理与 CsvHelper/Sylvan 等有差异。Sep 设计原则为不抛异常，兼顾速度与简单。</p>
<p>表格对比见原文（略）。</p>
<h4>修剪（Trimming）</h4>
<p>Sep 用 <a href="https://raw.githubusercontent.com/nietras/Sep/main/src/Sep/SepTrim.cs"><code>SepTrim</code></a> 枚举支持修剪，具体效果见原文表格（略）。Sep 支持先修剪再反转义。</p>
<h4>SepReader 可调试性</h4>
<p>SepReader 在调试器中的显示友好，详情见原文。</p>
<h5>SepReader.Row 可调试性</h5>
<p>调试器悬停 <code>row</code> 时会显示如：</p>
<pre><code class="language-text">  2:[5..9] = &quot;B;\&quot;Apple\r\nBanana\r\nOrange\r\nPear\&quot;&quot;
</code></pre>
<p>格式为：</p>
<pre><code class="language-text">&lt;ROWINDEX&gt;:[&lt;LINENUMBERRANGE&gt;] = &quot;&lt;ROW&gt;&quot;
</code></pre>
<p>可定位行号。展开 <code>row</code> 可见各列内容。</p>
<h5>SepReader.Col 可调试性</h5>
<p>悬停 <code>col</code> 显示内容字符串。</p>
<h4>为什么 SepReader 直到 .NET 9 才实现 IEnumerable，且不兼容 LINQ</h4>
<p>详见原文。Sep 的 Row/Col/Cols 均为 ref struct，底层为 reader 的门面，不能 ToArray/LINQ。如需 LINQ，建议先用自定义方法/迭代器解析为其它类型。Sep 提供了 <code>Enumerate</code>/<code>ParallelEnumerate</code> 等辅助方法。</p>
<h4>ParallelEnumerate 与 Enumerate</h4>
<p>Sep 的 <code>ParallelEnumerate</code> 基于 LINQ 的 <code>AsParallel().AsOrdered()</code>，用于高效并行解析（解析阶段，不建议用于每行耗时很久的操作）。如每行操作耗时超过 1 毫秒，建议将耗时操作放到 <code>ParallelEnumerate</code>/<code>Enumerate</code> 之后。</p>
<h3>SepWriter API</h3>
<p><code>SepWriter</code> API 结构（伪 C#）如下：</p>
<pre><code class="language-csharp">using var writer = Sep.Writer(o =&gt; o).ToFile/ToText/To...;
foreach (var data in EnumerateData())
{
    using var row = writer.NewRow();
    var _ = row[colName/colNames].Set/Format&lt;T&gt;...;
    var _ = row[colIndex/colIndices].Set/Format&lt;T&gt;...;
}
</code></pre>
<p>使用要点如下：</p>
<ol>
<li>可选指定 <code>Sep</code> 或默认分隔符。</li>
<li>创建 writer，可选配置 <code>SepWriterOptions</code>。详见 <a href="#sepwriteroptions">SepWriterOptions</a>。</li>
<li>通过 <code>To</code> 方法指定目标（如文件、字符串、<code>TextWriter</code>）。</li>
<li>⚠ 当前不支持预先定义表头，表头根据首行写入时的列顺序自动生成。</li>
<li>用 <code>NewRow</code> 新建行。⚠ 每次新行前请先 Dispose 上一行！Sep 提供重载，可直接用 <code>SepReader.Row</code> 复制一行。
<pre><code class="language-csharp">using var reader = Sep.Reader().FromText(text);
using var writer = reader.Spec.Writer().ToText();
foreach (var readRow in reader)
{   using var writeRow = writer.NewRow(readRow); }
</code></pre>
</li>
<li>按名/索引创建列，或批量列操作。内部自动池化/复用多列数组。</li>
<li>用 <code>Set</code> 设值（支持 ReadOnlySpan<char>、string、插值字符串），或用 <code>Format&lt;T&gt;</code>。</li>
<li>行在 Dispose 时写入。
<blockquote>
<p>这样做便于将来支持列删除、移动、重命名等灵活操作（暂未支持）。</p>
</blockquote>
</li>
</ol>
<h4>SepWriterOptions</h4>
<p>可用选项如下：</p>
<pre><code class="language-csharp">/// &lt;summary&gt;
/// 指定分隔符。
/// &lt;/summary&gt;
public Sep Sep { get; init; }
/// &lt;summary&gt;
/// 解析用区域文化（culture），可为 null 表示默认。
/// &lt;/summary&gt;
public CultureInfo? CultureInfo { get; init; }
/// &lt;summary&gt;
/// 是否先写表头（需全部列有名，否则可仅索引写列）。
/// &lt;/summary&gt;
public bool WriteHeader { get; init; } = true;
/// &lt;summary&gt;
/// 禁用列数一致性检查。
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// 若为 true，则 &lt;see cref=&quot;ColNotSetOption&quot;/&gt; 控制未设值列如何处理（跳过或写空）。若跳过，则数据行的列顺序可能与表头不一致。
/// 只要按顺序写入，列数可任意。
/// &lt;/remarks&gt;
public bool DisableColCountCheck { get; init; } = false;
/// &lt;summary&gt;
/// 未设值列的处理方式。
/// &lt;/summary&gt;
public SepColNotSetOption ColNotSetOption { get; init; } = SepColNotSetOption.Throw;
/// &lt;summary&gt;
/// 写入时是否转义列名和值。
/// &lt;/summary&gt;
/// &lt;remarks&gt;
/// 若为 true，列含分隔符、回车（`\r`）、换行（`\n`）、引号（`&quot;`）时，加双引号包裹，内部引号变双引号。表头也适用。
/// &lt;/remarks&gt;
public bool Escape { get; init; } = false;
/// &lt;summary&gt;
/// async 方法调用时传递的 ConfigureAwait。
/// &lt;/summary&gt;
public bool AsyncContinueOnCapturedContext { get; init; } = false;
</code></pre>
<h4>转义（Escaping）</h4>
<p>Sep 默认不转义，开启后与主流库一致（CsvHelper 还会转义空格，但不是必须的）。</p>
<p>原文表格略。</p>
<h2>异步支持</h2>
<p>Sep 支持高效的基于 <code>ValueTask</code> 的异步读写。</p>
<p>由于 <code>SepReader.Row</code> 和 <code>SepWriter.Row</code> 都是 <code>ref struct</code>（只可同时用一个，指向内部状态），<code>async/await</code> 仅支持 C# 13.0+（支持 ref/unsafe in async/iterator，详见 <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-13">C# 13 新特性</a>）。详细约束见官方文档。</p>
<p>.NET 9.0+/C# 13.0+ 下 <code>SepReader</code> 实现 <code>IAsyncEnumerable&lt;SepReader.Row&gt;</code> 和 <code>IEnumerable&lt;SepReader.Row&gt;</code>。</p>
<p>异步支持直接集成于 <code>SepReader</code> 和 <code>SepWriter</code>，类似 <code>TextReader</code>/<code>TextWriter</code>。开发者需自行调用异步方法并用 <code>await</code>。示例：</p>
<pre><code class="language-csharp">var text = &quot;&quot;&quot;
           A;B;C;D;E;F
           Sep;🚀;1;1.2;0.1;0.5
           CSV;✅;2;2.2;0.2;1.5
           
           &quot;&quot;&quot;; // 末尾空行为统一行结束

using var reader = await Sep.Reader().FromTextAsync(text);
await using var writer = reader.Spec.Writer().ToText();
await foreach (var readRow in reader)
{
    await using var writeRow = writer.NewRow(readRow);
}
Assert.AreEqual(text, writer.ToString());
</code></pre>
<p>注意：<code>SepReader</code> 的 <code>FromTextAsync</code> 需 await（因要确定分隔符和表头），后续行可用 <code>await foreach</code> 异步遍历。漏写 await 则为同步遍历。</p>
<p><code>SepWriter</code> 的 <code>To*</code> 方法无 Async 变体，创建同步，行写入和 Dispose/DisposeAsync 时才会写内容。读端无需异步释放，但 <code>SepWriter</code> 建议用 <code>await using</code>。</p>
<p>支持取消的 API 也提供 <code>CancellationToken</code>。详细见 <a href="#public-api-reference">API 参考</a>。</p>
<p>此外，<a href="#sepreaderoptions">SepReaderOptions</a> 与 <a href="#sepwriteroptions">SepWriterOptions</a> 均有 <code>AsyncContinueOnCapturedContext</code>，内部转发到 <code>ConfigureAwait</code>。</p>
<h2>限制与约束</h2>
<p>Sep 以极简高效为目标，具有限定：</p>
<ul>
<li>不原生支持 <code>#</code> 注释。可手动跳过行：
<pre><code class="language-csharp">foreach (var row in reader)
{
      // 如果行以 # 开头则跳过
      if (!row.Span.StartsWith(&quot;#&quot;))
      {
           // ...
      }
}
</code></pre>
该方式无法跳过表头前以 <code>#</code> 开头的行，完整例子见 <a href="#example-catalogue">示例目录</a>。</li>
</ul>
<h2>性能对比</h2>
<p>为评估 Sep 性能，选取如下对比对象：</p>
<ul>
<li><a href="https://github.com/JoshClose/csvhelper">CsvHelper</a> - 最流行的 CSV 库，NuGet 超高下载量。功能丰富，成熟稳定。</li>
<li><a href="https://github.com/MarkPflug/Sylvan">Sylvan</a> - 以速度著称，曾被评为<a href="https://www.joelverhagen.com/blog/2020/12/fastest-net-csv-parsers">.NET 最快 CSV 库</a>（Sep 改变了这一点 😉）。</li>
<li><code>ReadLine</code>/<code>WriteLine</code> - 基础实现，逐行读取并按分隔符切分。写入时直接拼接。无引号等处理。</li>
</ul>
<p>所有基准测试均在内存中（<code>StringReader</code>/<code>StreamReader+MemoryStream</code>，<code>StringWriter</code>/<code>StreamWriter+MemoryStream</code>），避免磁盘影响。</p>
<p><code>StringReader</code>/<code>StringWriter</code> 下每个 <code>char</code> 视为 2 字节，<code>StreamReader</code>/<code>StreamWriter</code> 下为 UTF-8，通常 1 字节。默认只展示 <code>StringReader</code>/<code>StringWriter</code> 结果，其他场景与其一致，性能约减半。</p>
<p>所有测试中，Sep 作为 <a href="https://benchmarkdotnet.org/">BenchmarkDotNet</a> 的基线（<code>Ratio</code> 为 1.00），其他库的 <code>Ratio</code> 表示 Sep 的几倍速度或内存分配。</p>
<blockquote>
<p>声明：本对比在特定前提/假设下进行。Sep 为全新库，充分利用 .NET 最新特性；CsvHelper/Sylvan 因兼容旧环境或历史负担，可能无法轻松用上新特性。Sep、Sylvan、CsvHelper 功能侧重点不同，性能只是其中之一。评估时请结合实际需求。</p>
</blockquote>
<h3>运行时与平台</h3>
<p>基准测试运行环境及平台配置详见原文。</p>
<h3>Reader 对比基准</h3>
<ul>
<li>NCsvPerf 场景</li>
<li><a href="#floats-reader-comparison-benchmarks"><strong>Floats</strong></a>（如机器学习中的浮点特征）</li>
</ul>
<p>详细场景及结果表格见原文。</p>
<h4>NCsvPerf PackageAssets 基准</h4>
<p>简述：以 <a href="https://github.com/joelverhagen/NCsvPerf">NCsvPerf</a> 真实数据集，涉及 25 列，测试各库性能。Sylvan、CsvHelper、Sep 均采用字符串池化优化（Sep 支持按列池化更高效）。Sep 在所有指标下均为最快，并发（MT）下领先更多。</p>
<p>详细数据表略。</p>
<h4>含引号等特殊情况</h4>
<p>在有引号、空格等特殊情况时，Sep 解析性能依然领先，详细见原文各表格。</p>
<h4>浮点型特征场景（Floats Reader Benchmarks）</h4>
<p>模拟机器学习特征数据，批量高效解析浮点数组，Sep 内置 csFastFloat，解析浮点数比 Sylvan 快 2 倍以上，并发下可达 23 倍。对比 CsvHelper，单线程快 4 倍，并发快 35 倍。</p>
<p>详细数据表略。</p>
<h3>Writer 对比基准</h3>
<p>Writer 部分基准待补充，Sep 以便捷与灵活为主，性能仍然高效但未必绝对最快。</p>
<h2>示例目录</h2>
<p>以下示例可见于 <a href="https://raw.githubusercontent.com/nietras/Sep/main/src/Sep.XyzTest/ReadMeTest.cs">ReadMeTest.cs</a>。</p>
<ul>
<li><strong>复制行</strong></li>
<li><strong>异步复制行</strong></li>
<li><strong>跳过空行</strong></li>
<li><strong>在 async/await 场景下用 Enumerate 扩展方法（C# 13.0 前）</strong></li>
<li><strong>在 async/await 场景下用本地函数</strong></li>
<li><strong>跳过以 # 开头的注释行/行</strong></li>
</ul>
<p>每个示例代码见原文。</p>
<h2>RFC-4180</h2>
<p><a href="https://www.ietf.org/rfc/rfc4180.txt">RFC-4180</a> 标准要求用 <code>\r\n</code> 行结束，Sep 支持常见的 <code>\r\n</code>、<code>\n</code>、<code>\r</code>。写入时用 <code>Environment.NewLine</code>。引号配对即视为转义。</p>
<p>许多库号称兼容 RFC，但 RFC 非常严格（仅允许逗号分隔符等），Sep 写入默认用 <code>;</code>，读取时自动检测分隔符。这是显著不兼容的设计。</p>
<p>ABNF 语法见原文。</p>
<p>总之，Sep 以实际机器学习等场景为主，采取更实用的做法。</p>
<h2>常见问题（FAQ）</h2>
<p>如有疑问请在 GitHub 提问。</p>
<ul>
<li><em>Sep 是否支持类似 <a href="https://joshclose.github.io/CsvHelper/examples/reading/get-class-records/">CsvHelper 对象映射</a>?</em><br />
不支持，Sep 以极简为目标，无对象映射。对象映射常依赖反射，Sep 避免此类实现。对象映射通常需手写每个属性的映射逻辑，这与自己写解析代码差别不大。如确需此功能，可考虑自定义 <a href="https://devblogs.microsoft.com/dotnet/new-c-source-generator-samples/">source generator</a>。未来可能会内置，但近期暂无计划。</li>
</ul>
<h3>SepReader 常见问题</h3>
<h3>SepWriter 常见问题</h3>
<h2>相关链接</h2>
<ul>
<li><a href="https://www.meziantou.net/publishing-a-nuget-package-following-best-practices-using-github.htm">用 GitHub 和 GitHub Actions 发布 NuGet 包最佳实践</a></li>
</ul>
<h2>API 参考</h2>
<pre><code class="language-csharp">// 省略，内容同原文，未翻译 API 代码注释
</code></pre>
<hr />
<p>Tranlated By <a href="https://github.com/OpenAiTx/OpenAiTx">Open Ai Tx</a> | Last indexed: 2025-06-07</p>
<hr />

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Default Statcounter code for openaitx
https://openaitx.github.io/ -->
    <script type="text/javascript">
        var sc_project = 13142514;
        var sc_invisible = 1;
        var sc_security = "d03a31d8"; 
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript>
        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                    class="statcounter" src="https://c.statcounter.com/13142514/0/d03a31d8/1/" alt="Web Analytics"
                    referrerPolicy="no-referrer-when-downgrade"></a></div>
    </noscript>
    <!-- End of Statcounter Code -->
</body>
</html>