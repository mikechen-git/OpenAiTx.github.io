<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jwt - jwt-dotnet/jwt</title>
    <meta name="title" content="jwt - jwt-dotnet/jwt">
    <meta name="description" content="jwt-dotnet/jwt - GitHub repository it documentation and informationJwt.Net, una implementazione JWT (JSON Web Token) per .NET Sponsor Pacchetti NuGet disponibili Versioni .NET supportate: Jwt.NET Creazione (codifica) di un token Oppure usando la Fluent Builder API Parsing (decodifica) e verifica del token Oppure usando la Fluent Builder API Oppure usando la Fluent Builder API Validare la scadenza del token Parsing (decodifica) dell’header del token Oppure usando la Fluent Builder API Disattivare parti della validazione del token Oppure usando la Fluent Builder API Serializzatore JSON personalizzato Impostazioni di serializzazione JSON personalizzate con il JsonNetSerializer predefinito Jwt.Net ASP.NET Core Registrare l’handler di autenticazione per validare i JWT Factory personalizzate per produrre Identity o AuthenticationTicket Licenza Jwt.Net, una implementazione JWT (JSON Web Token) per .NET Questa libreria supporta la generazione e la decodifica di JSON Web Token. Sponsor | | | |-|-| | | Se vuoi implementare rapidamente un’autenticazione sicura nel tuo progetto JWT, crea un account Auth0; è gratuito! |...">
    <meta name="keywords" content="jwt-dotnet, jwt, GitHub, repository, it documentation">
    <meta name="author" content="Open AI Tx">
    <meta name="robots" content="index, follow">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://openaitx.github.io/projects/jwt-dotnet/jwt/README-it.html">
    <meta property="og:title" content="jwt - jwt-dotnet/jwt">
    <meta property="og:description" content="jwt-dotnet/jwt - GitHub repository it documentation and information">
    <meta property="og:image" content="https://openaitx.github.io/logo_crop.png">
    <link rel="icon" type="image/jpeg" href="/icon.jpg">
    <link rel="apple-touch-icon" href="/icon.jpg">
    <script src="/js/marked.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/css/github.min.css?v=20250613">
    <script src="/js/highlight.min.js?v=20250613"></script>
    <link rel="stylesheet" href="/view.css?v=20250613">
    <style>
        body { display: flex; flex-direction: column; min-height: 100vh; }
        .main-container { margin: 0 auto; width: 100%; max-width: 980px; padding: 0 20px; }
        @media (max-width: 768px) { .main-container { padding: 0 15px; } }
        .markdown-body img { max-width: 100%; height: auto; }
        .header { text-align: center; margin-bottom: 30px; padding: 20px; background-color: #f6f8fa; border-bottom: 1px solid #e1e4e8; position: relative; }
        .header .links { margin-top: 10px; font-size: 16px; }
        .header .links a { color: #0366d6; text-decoration: none; margin-left: 5px; }
        .header .links a:hover { text-decoration: underline; }
        .language-badges { margin-top: 15px; text-align: center; }
        .language-badges a { display: inline-block; margin: 2px; text-decoration: none; }
        .language-badges img { height: 20px; border-radius: 3px; }
        .language-badges a:hover img { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="header">
        <div class="links">
            GitHub Repository: <a href="https://github.com/jwt-dotnet/jwt" id="githubRepoLink" target="_blank">jwt-dotnet/jwt</a>
<br>
<h1 style="display: none;">Jwt.Net, una implementazione JWT (JSON Web Token) per .NET Sponsor Pacchetti NuGet disponibili Versioni .NET supportate: Jwt.NET Creazione (codifica) di un token Oppure usando la Fluent Builder API Parsing (decodifica) e verifica del token Oppure usando la Fluent Builder API Oppure usando la Fluent Builder API Validare la scadenza del token Parsing (decodifica) dell’header del token Oppure usando la Fluent Builder API Disattivare parti della validazione del token Oppure usando la Fluent Builder API Serializzatore JSON personalizzato Impostazioni di serializzazione JSON personalizzate con il JsonNetSerializer predefinito Jwt.Net ASP.NET Core Registrare l’handler di autenticazione per validare i JWT Factory personalizzate per produrre Identity o AuthenticationTicket Licenza Jwt.Net, una implementazione JWT (JSON Web Token) per .NET Questa libreria supporta la generazione e la decodifica di JSON Web Token. Sponsor | | | |-|-| | | Se vuoi implementare rapidamente un’autenticazione sicura nel tuo progetto JWT, crea un account Auth0; è gratuito! |...</h1>
        </div>
        <div class="language-badges" id="languageBadges">
            <!-- You can generate language badges here if needed -->
        </div>
    </div>
    <div class="main-container">
        <div class="markdown-body" id="content">
            <!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DO NOT EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="#jwtnet-una-implementazione-jwt-json-web-token-per-net">Jwt.Net, una implementazione JWT (JSON Web Token) per .NET</a></li>
<li><a href="#sponsor">Sponsor</a></li>
<li><a href="#pacchetti-nuget-disponibili">Pacchetti NuGet disponibili</a></li>
<li><a href="#versioni-net-supportate">Versioni .NET supportate:</a></li>
<li><a href="#jwtnet">Jwt.NET</a>
<ul>
<li><a href="#creazione-codifica-di-un-token">Creazione (codifica) di un token</a>
<ul>
<li><a href="#oppure-usando-la-fluent-builder-api">Oppure usando la Fluent Builder API</a></li>
</ul>
</li>
<li><a href="#parsing-decodifica-e-verifica-del-token">Parsing (decodifica) e verifica del token</a>
<ul>
<li><a href="#oppure-usando-la-fluent-builder-api-1">Oppure usando la Fluent Builder API</a></li>
<li><a href="#oppure-usando-la-fluent-builder-api-2">Oppure usando la Fluent Builder API</a></li>
</ul>
</li>
<li><a href="#validare-la-scadenza-del-token">Validare la scadenza del token</a></li>
<li><a href="#parsing-decodifica-dellheader-del-token">Parsing (decodifica) dell’header del token</a>
<ul>
<li><a href="#oppure-usando-la-fluent-builder-api-3">Oppure usando la Fluent Builder API</a></li>
</ul>
</li>
<li><a href="#disattivare-parti-della-validazione-del-token">Disattivare parti della validazione del token</a>
<ul>
<li><a href="#oppure-usando-la-fluent-builder-api-4">Oppure usando la Fluent Builder API</a></li>
</ul>
</li>
<li><a href="#serializzatore-json-personalizzato">Serializzatore JSON personalizzato</a></li>
<li><a href="#impostazioni-di-serializzazione-json-personalizzate-con-il-jsonnetserializer-predefinito">Impostazioni di serializzazione JSON personalizzate con il JsonNetSerializer predefinito</a></li>
</ul>
</li>
<li><a href="#jwtnet-aspnet-core">Jwt.Net ASP.NET Core</a>
<ul>
<li><a href="#registrare-lhandler-di-autenticazione-per-validare-i-jwt">Registrare l’handler di autenticazione per validare i JWT</a></li>
<li><a href="#factory-personalizzate-per-produrre-identity-o-authenticationticket">Factory personalizzate per produrre Identity o AuthenticationTicket</a></li>
</ul>
</li>
<li><a href="#licenza">Licenza</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<p><a href="https://abatishchev.visualstudio.com/OpenSource/_build/latest?definitionId=9"><img src="https://abatishchev.visualstudio.com/OpenSource/_apis/build/status/Jwt.Net-CI" alt="Build status" /></a>
<a href="https://abatishchev.visualstudio.com/OpenSource/_release?_a=releases&amp;view=mine&amp;definitionId=2"><img src="https://abatishchev.vsrm.visualstudio.com/_apis/public/Release/badge/b7fc2610-91d5-4968-814c-97a9d76b03c4/2/2" alt="Release status" /></a></p>
<h2>Jwt.Net, una implementazione JWT (JSON Web Token) per .NET</h2>
<p>Questa libreria supporta la generazione e la decodifica di <a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a>.</p>
<h2>Sponsor</h2>
<p>| | |
|-|-|
| <a href="https://a0.to/try-auth0"><img alt="Auth0 logo" src="https://cdn.auth0.com/blog/github-sponsorships/brand-evolution-logo-Auth0-horizontal-Indigo.png" height="91"></a> | Se vuoi implementare rapidamente un’autenticazione sicura nel tuo progetto JWT, <a href="https://a0.to/try-auth0">crea un account Auth0</a>; è gratuito! |</p>
<h2>Pacchetti NuGet disponibili</h2>
<ol>
<li>Jwt.Net</li>
</ol>
<p><a href="https://www.nuget.org/packages/JWT"><img src="https://img.shields.io/nuget/v/JWT.svg" alt="NuGet" /></a>
<a href="https://www.nuget.org/packages/JWT"><img src="https://img.shields.io/nuget/vpre/JWT.svg" alt="NuGet Pre" /></a></p>
<ol start="2">
<li>Jwt.Net per il contenitore di Iniezione delle Dipendenze di Microsoft</li>
</ol>
<p><a href="https://www.nuget.org/packages/JWT.Extensions.DependencyInjection"><img src="https://img.shields.io/nuget/v/JWT.Extensions.DependencyInjection.svg" alt="NuGet" /></a>
<a href="https://www.nuget.org/packages/JWT.Extensions.DependencyInjection"><img src="https://img.shields.io/nuget/vpre/JWT.Extensions.DependencyInjection.svg" alt="NuGet Pre" /></a></p>
<ol start="3">
<li>Jwt.Net per ASP.NET Core</li>
</ol>
<p><a href="https://www.nuget.org/packages/JWT.Extensions.AspNetCore"><img src="https://img.shields.io/nuget/v/JWT.Extensions.AspNetCore.svg" alt="NuGet" /></a>
<a href="https://www.nuget.org/packages/JWT.Extensions.AspNetCore"><img src="https://img.shields.io/nuget/vpre/JWT.Extensions.AspNetCore.svg" alt="NuGet Pre" /></a></p>
<h2>Versioni .NET supportate:</h2>
<ul>
<li>.NET Framework 3.5</li>
<li>.NET Framework 4.0 - 4.8</li>
<li>.NET Standard 1.3, 2.0</li>
<li>.NET 6.0</li>
</ul>
<h2>Jwt.NET</h2>
<h3>Creazione (codifica) di un token</h3>
<pre><code class="language-c#">var payload = new Dictionary&lt;string, object&gt;
{
    { &quot;claim1&quot;, 0 },
    { &quot;claim2&quot;, &quot;claim2-value&quot; }
};

IJwtAlgorithm algorithm = new RS256Algorithm(certificate);
IJsonSerializer serializer = new JsonNetSerializer();
IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();
IJwtEncoder encoder = new JwtEncoder(algorithm, serializer, urlEncoder);
const string key = null; // non necessario se l’algoritmo è asimmetrico

var token = encoder.Encode(payload, key);
Console.WriteLine(token);
</code></pre>
<h4>Oppure usando la Fluent Builder API</h4>
<pre><code class="language-c#">var token = JwtBuilder.Create()
                      .WithAlgorithm(new RS256Algorithm(certificate))
                      .AddClaim(&quot;exp&quot;, DateTimeOffset.UtcNow.AddHours(1).ToUnixTimeSeconds())
                      .AddClaim(&quot;claim1&quot;, 0)
                      .AddClaim(&quot;claim2&quot;, &quot;claim2-value&quot;)
                      .Encode();
Console.WriteLine(token);
</code></pre>
<h3>Parsing (decodifica) e verifica del token</h3>
<pre><code class="language-c#">try
{
    IJsonSerializer serializer = new JsonNetSerializer();
    IDateTimeProvider provider = new UtcDateTimeProvider();
    IJwtValidator validator = new JwtValidator(serializer, provider);
    IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();
    IJwtAlgorithm algorithm = new RS256Algorithm(certificate);
    IJwtDecoder decoder = new JwtDecoder(serializer, validator, urlEncoder, algorithm);
    
    var json = decoder.Decode(token);
    Console.WriteLine(json);
}
catch (TokenNotYetValidException)
{
    Console.WriteLine(&quot;Il token non è ancora valido&quot;);
}
catch (TokenExpiredException)
{
    Console.WriteLine(&quot;Il token è scaduto&quot;);
}
catch (SignatureVerificationException)
{
    Console.WriteLine(&quot;Il token ha una firma non valida&quot;);
}
</code></pre>
<h4>Oppure usando la Fluent Builder API</h4>
<pre><code class="language-c#">var json = JwtBuilder.Create()
                     .WithAlgorithm(new RS256Algorithm(certificate))
                     .MustVerifySignature()
                     .Decode(token);                    
Console.WriteLine(json);
</code></pre>
<p>L’output sarà:</p>
<blockquote>
<p>{ &quot;claim1&quot;: 0, &quot;claim2&quot;: &quot;claim2-value&quot; }</p>
</blockquote>
<p>Puoi anche deserializzare direttamente il payload JSON in un tipo .NET:</p>
<pre><code class="language-c#">var payload = decoder.DecodeToObject&lt;IDictionary&lt;string, object&gt;&gt;(token, secret);
</code></pre>
<h4>Oppure usando la Fluent Builder API</h4>
<pre><code class="language-c#">var payload = JwtBuilder.Create()
                        .WithAlgorithm(new RS256Algorithm(certificate))
                        .WithSecret(secret)
                        .MustVerifySignature()
                        .Decode&lt;IDictionary&lt;string, object&gt;&gt;(token);     
</code></pre>
<h3>Validare la scadenza del token</h3>
<p>Come descritto nella <a href="https://tools.ietf.org/html/rfc7519#section-4.1.4">RFC 7519 sezione 4.1.4</a>:</p>
<blockquote>
<p>La claim <code>exp</code> identifica il tempo di scadenza oltre il quale il JWT NON DEVE essere accettato per l’elaborazione.</p>
</blockquote>
<p>Se è presente nel payload e supera l’ora corrente, il token non verrà verificato. Il valore deve essere specificato come numero di secondi trascorsi dall’<a href="https://en.wikipedia.org/wiki/Unix_time">epoca Unix</a>, 1/1/1970 00:00:00 UTC.</p>
<pre><code class="language-c#">IDateTimeProvider provider = new UtcDateTimeProvider();
var now = provider.GetNow().AddMinutes(-5); // il token è scaduto 5 minuti fa

double secondsSinceEpoch = UnixEpoch.GetSecondsSince(now);

var payload = new Dictionary&lt;string, object&gt;
{
    { &quot;exp&quot;, secondsSinceEpoch }
};
var token = encoder.Encode(payload);

decoder.Decode(token); // genera TokenExpiredException
</code></pre>
<p>Poi, come descritto nella <a href="https://tools.ietf.org/html/rfc7519#section-4.1.5">RFC 7519 sezione 4.1.5</a>:</p>
<blockquote>
<p>La claim &quot;nbf&quot; (not before) identifica il momento prima del quale il JWT NON DEVE essere accettato per l’elaborazione</p>
</blockquote>
<p>Se è presente nel payload ed è successiva all’ora corrente, il token non verrà verificato.</p>
<h3>Parsing (decodifica) dell’header del token</h3>
<pre><code class="language-c#">IJsonSerializer serializer = new JsonNetSerializer();
IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();
IJwtDecoder decoder = new JwtDecoder(serializer, urlEncoder);

JwtHeader header = decoder.DecodeHeader&lt;JwtHeader&gt;(token);

var typ = header.Type; // JWT
var alg = header.Algorithm; // RS256
var kid = header.KeyId; // CFAEAE2D650A6CA9862575DE54371EA980643849
</code></pre>
<h4>Oppure usando la Fluent Builder API</h4>
<pre><code class="language-c#">JwtHeader header = JwtBuilder.Create()
                             .DecodeHeader&lt;JwtHeader&gt;(token);

var typ = header.Type; // JWT
var alg = header.Algorithm; // RS256
var kid = header.KeyId; // CFAEAE2D650A6CA9862575DE54371EA980643849
</code></pre>
<h3>Disattivare parti della validazione del token</h3>
<p>Se desideri validare un token ma ignorare determinate parti della validazione (ad esempio se il token è scaduto o non ancora valido), puoi passare un oggetto <code>ValidateParameters</code> al costruttore della classe <code>JwtValidator</code>.</p>
<pre><code class="language-c#">var validationParameters = new ValidationParameters
{
    ValidateSignature = true,
    ValidateExpirationTime = false,
    ValidateIssuedTime = false,
    TimeMargin = 100
};
IJwtValidator validator = new JwtValidator(serializer, provider, validationParameters);
IJwtDecoder decoder = new JwtDecoder(serializer, validator, urlEncoder, algorithm);
var json = decoder.Decode(expiredToken); // non lancerà eccezione a causa del token scaduto
</code></pre>
<h4>Oppure utilizzando la Fluent Builder API</h4>
<pre><code class="language-c#">var json = JwtBuilder.Create()
                     .WithAlgorithm(new RS256Algorirhm(certificate))
                     .WithSecret(secret)
                     .WithValidationParameters(
                         new ValidationParameters
                         {
                             ValidateSignature = true,
                             ValidateExpirationTime = false,
                             ValidateIssuedTime = false,
                             TimeMargin = 100
                         })
                     .Decode(expiredToken);
</code></pre>
<h3>Serializer JSON personalizzato</h3>
<p>Di default la serializzazione JSON è eseguita da JsonNetSerializer implementato utilizzando <a href="https://www.json.net">Json.Net</a>. Per usarne uno diverso, implementa l’interfaccia <code>IJsonSerializer</code>:</p>
<pre><code class="language-c#">public sealed class CustomJsonSerializer : IJsonSerializer
{
    public string Serialize(object obj)
    {
        // Implementa utilizzando il tuo serializer JSON preferito
    }

    public T Deserialize&lt;T&gt;(string json)
    {
        // Implementa utilizzando il tuo serializer JSON preferito
    }
}
</code></pre>
<p>E poi passa questo serializer al costruttore di JwtEncoder:</p>
<pre><code class="language-c#">IJwtAlgorithm algorithm = new RS256Algorirhm(certificate);
IJsonSerializer serializer = new CustomJsonSerializer();
IBase64UrlEncoder urlEncoder = new JwtBase64UrlEncoder();
IJwtEncoder encoder = new JwtEncoder(algorithm, serializer, urlEncoder);
</code></pre>
<h3>Impostazioni di serializzazione JSON personalizzate con il JsonNetSerializer predefinito</h3>
<p>Come menzionato sopra, la serializzazione JSON predefinita è eseguita da <code>JsonNetSerializer</code>. Puoi definire le tue impostazioni di serializzazione personalizzate come segue:</p>
<pre><code class="language-c#">JsonSerializer customJsonSerializer = new JsonSerializer
{
    // Tutte le chiavi iniziano con caratteri minuscoli invece che con la stessa capitalizzazione del modello/proprietà, es. fullName
    ContractResolver = new CamelCasePropertyNamesContractResolver(), 
    
    // Facile da leggere, ma puoi anche usare Formatting.None per ridurre la dimensione del payload
    Formatting = Formatting.Indented,
    
    // Il formato datetime più appropriato.
    DateFormatHandling = DateFormatHandling.IsoDateFormat,
    
    // Non aggiungere chiavi/valori quando il valore è null.
    NullValueHandling = NullValueHandling.Ignore,
    
    // Usa il valore stringa dell'enum, non il valore int implicito, es. &quot;red&quot; per enum Color { Red }
    Converters.Add(new StringEnumConverter())
};
IJsonSerializer serializer = new JsonNetSerializer(customJsonSerializer);
</code></pre>
<h2>Jwt.Net ASP.NET Core</h2>
<h3>Registrare l’handler di autenticazione per validare JWT</h3>
<pre><code class="language-c#">public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(options =&gt;
                 {
                     options.DefaultAuthenticateScheme = JwtAuthenticationDefaults.AuthenticationScheme;
                     options.DefaultChallengeScheme = JwtAuthenticationDefaults.AuthenticationScheme;
                 })
            .AddJwt(options =&gt;
                 {
                     // secrets, richiesto solo per algoritmi simmetrici, come HMACSHA256Algorithm
                     // options.Keys = new[] { &quot;mySecret&quot; };
                     
                     // opzionale; disabilita il lancio di un'eccezione se la firma JWT non è valida
                     // options.VerifySignature = false;
                 });
  // la versione non generica AddJwt() richiede la registrazione manuale di un’istanza di IAlgorithmFactory
  services.AddSingleton&lt;IAlgorithmFactory&gt;(new RSAlgorithmFactory(certificate));
  // oppure
  services.AddSingleton&lt;IAlgorithmFactory&gt;(new DelegateAlgorithmFactory(algorithm));

  // oppure usa la versione generica AddJwt&lt;TFactory() per usare un’implementazione personalizzata di IAlgorithmFactory
  .AddJwt&lt;MyCustomAlgorithmFactory&gt;(options =&gt; ...);
}

public void Configure(IApplicationBuilder app)
{
    app.UseAuthentication();
}
</code></pre>
<h3>Factory personalizzate per produrre Identity o AuthenticationTicket</h3>
<pre><code class="language-c#">services.AddSingleton&lt;IIdentityFactory, CustomIdentityFctory&gt;();
services.AddSingleton&lt;ITicketFactory, CustomTicketFactory&gt;();
</code></pre>
<h2>Licenza</h2>
<p>I seguenti progetti e i relativi package risultanti sono concessi sotto Public Domain, vedi il file <a href="LICENSE.md#Public-Domain">LICENSE#Public-Domain</a>.</p>
<ul>
<li>JWT</li>
</ul>
<p>I seguenti progetti e i relativi package risultanti sono concessi sotto licenza MIT, vedi il file <a href="LICENSE.md#MIT">LICENSE#MIT</a>.</p>
<ul>
<li>JWT.Extensions.AspNetCore</li>
<li>JWT.Extensions.DependencyInjection</li>
</ul>
<pre><code>

---


Tranlated By [Open Ai Tx](https://github.com/OpenAiTx/OpenAiTx) | Last indexed: 2025-06-09


---
</code></pre>

        </div>
    </div>
    <footer class="footer">
        Powered by <a href="https://github.com/OpenAiTx/OpenAiTx" target="_blank">Open AI Tx</a>
    </footer>
    <!-- Statcounter and other scripts can be added here -->
</body>
</html>